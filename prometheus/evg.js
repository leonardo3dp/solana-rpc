var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(W) {
    return W && W.__esModule && Object.prototype.hasOwnProperty.call(W, "default") ? W.default : W
}
function getAugmentedNamespace(W) {
    if (W.__esModule)
        return W;
    var z = W.default;
    if (typeof z == "function") {
        var Y = function ne() {
            return this instanceof ne ? Reflect.construct(z, arguments, this.constructor) : z.apply(this, arguments)
        };
        Y.prototype = z.prototype
    } else
        Y = {};
    return Object.defineProperty(Y, "__esModule", {
        value: !0
    }),
    Object.keys(W).forEach(function(ne) {
        var le = Object.getOwnPropertyDescriptor(W, ne);
        Object.defineProperty(Y, ne, le.get ? le : {
            enumerable: !0,
            get: function() {
                return W[ne]
            }
        })
    }),
    Y
}
var jquery = {
    exports: {}
}, module;
module = jquery,
function(W, z) {
    module.exports = W.document ? z(W, !0) : function(Y) {
        if (!Y.document)
            throw new Error("jQuery requires a window with a document");
        return z(Y)
    }
}(typeof window < "u" ? window : commonjsGlobal, function(W, z) {
    var Y = []
      , ne = Object.getPrototypeOf
      , le = Y.slice
      , ue = Y.flat ? function(pe) {
        return Y.flat.call(pe)
    }
    : function(pe) {
        return Y.concat.apply([], pe)
    }
      , de = Y.push
      , he = Y.indexOf
      , fe = {}
      , ge = fe.toString
      , xe = fe.hasOwnProperty
      , $e = xe.toString
      , Ee = $e.call(Object)
      , Se = {}
      , Ne = function(pe) {
        return typeof pe == "function" && typeof pe.nodeType != "number" && typeof pe.item != "function"
    }
      , tt = function(pe) {
        return pe != null && pe === pe.window
    }
      , rr = W.document
      , tr = {
        type: !0,
        src: !0,
        nonce: !0,
        noModule: !0
    };
    function we(pe, me, Le) {
        var rt, nr, sr = (Le = Le || rr).createElement("script");
        if (sr.text = pe,
        me)
            for (rt in tr)
                (nr = me[rt] || me.getAttribute && me.getAttribute(rt)) && sr.setAttribute(rt, nr);
        Le.head.appendChild(sr).parentNode.removeChild(sr)
    }
    function Ut(pe) {
        return pe == null ? pe + "" : typeof pe == "object" || typeof pe == "function" ? fe[ge.call(pe)] || "object" : typeof pe
    }
    var lr = "3.7.1"
      , cr = /HTML$/i
      , be = function(pe, me) {
        return new be.fn.init(pe,me)
    };
    function mr(pe) {
        var me = !!pe && "length"in pe && pe.length
          , Le = Ut(pe);
        return !Ne(pe) && !tt(pe) && (Le === "array" || me === 0 || typeof me == "number" && me > 0 && me - 1 in pe)
    }
    function fr(pe, me) {
        return pe.nodeName && pe.nodeName.toLowerCase() === me.toLowerCase()
    }
    be.fn = be.prototype = {
        jquery: lr,
        constructor: be,
        length: 0,
        toArray: function() {
            return le.call(this)
        },
        get: function(pe) {
            return pe == null ? le.call(this) : pe < 0 ? this[pe + this.length] : this[pe]
        },
        pushStack: function(pe) {
            var me = be.merge(this.constructor(), pe);
            return me.prevObject = this,
            me
        },
        each: function(pe) {
            return be.each(this, pe)
        },
        map: function(pe) {
            return this.pushStack(be.map(this, function(me, Le) {
                return pe.call(me, Le, me)
            }))
        },
        slice: function() {
            return this.pushStack(le.apply(this, arguments))
        },
        first: function() {
            return this.eq(0)
        },
        last: function() {
            return this.eq(-1)
        },
        even: function() {
            return this.pushStack(be.grep(this, function(pe, me) {
                return (me + 1) % 2
            }))
        },
        odd: function() {
            return this.pushStack(be.grep(this, function(pe, me) {
                return me % 2
            }))
        },
        eq: function(pe) {
            var me = this.length
              , Le = +pe + (pe < 0 ? me : 0);
            return this.pushStack(Le >= 0 && Le < me ? [this[Le]] : [])
        },
        end: function() {
            return this.prevObject || this.constructor()
        },
        push: de,
        sort: Y.sort,
        splice: Y.splice
    },
    be.extend = be.fn.extend = function() {
        var pe, me, Le, rt, nr, sr, ur = arguments[0] || {}, $r = 1, yr = arguments.length, Or = !1;
        for (typeof ur == "boolean" && (Or = ur,
        ur = arguments[$r] || {},
        $r++),
        typeof ur == "object" || Ne(ur) || (ur = {}),
        $r === yr && (ur = this,
        $r--); $r < yr; $r++)
            if ((pe = arguments[$r]) != null)
                for (me in pe)
                    rt = pe[me],
                    me !== "__proto__" && ur !== rt && (Or && rt && (be.isPlainObject(rt) || (nr = Array.isArray(rt))) ? (Le = ur[me],
                    sr = nr && !Array.isArray(Le) ? [] : nr || be.isPlainObject(Le) ? Le : {},
                    nr = !1,
                    ur[me] = be.extend(Or, sr, rt)) : rt !== void 0 && (ur[me] = rt));
        return ur
    }
    ,
    be.extend({
        expando: "jQuery" + (lr + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(pe) {
            throw new Error(pe)
        },
        noop: function() {},
        isPlainObject: function(pe) {
            var me, Le;
            return !(!pe || ge.call(pe) !== "[object Object]" || (me = ne(pe)) && (typeof (Le = xe.call(me, "constructor") && me.constructor) != "function" || $e.call(Le) !== Ee))
        },
        isEmptyObject: function(pe) {
            var me;
            for (me in pe)
                return !1;
            return !0
        },
        globalEval: function(pe, me, Le) {
            we(pe, {
                nonce: me && me.nonce
            }, Le)
        },
        each: function(pe, me) {
            var Le, rt = 0;
            if (mr(pe))
                for (Le = pe.length; rt < Le && me.call(pe[rt], rt, pe[rt]) !== !1; rt++)
                    ;
            else
                for (rt in pe)
                    if (me.call(pe[rt], rt, pe[rt]) === !1)
                        break;
            return pe
        },
        text: function(pe) {
            var me, Le = "", rt = 0, nr = pe.nodeType;
            if (!nr)
                for (; me = pe[rt++]; )
                    Le += be.text(me);
            return nr === 1 || nr === 11 ? pe.textContent : nr === 9 ? pe.documentElement.textContent : nr === 3 || nr === 4 ? pe.nodeValue : Le
        },
        makeArray: function(pe, me) {
            var Le = me || [];
            return pe != null && (mr(Object(pe)) ? be.merge(Le, typeof pe == "string" ? [pe] : pe) : de.call(Le, pe)),
            Le
        },
        inArray: function(pe, me, Le) {
            return me == null ? -1 : he.call(me, pe, Le)
        },
        isXMLDoc: function(pe) {
            var me = pe && pe.namespaceURI
              , Le = pe && (pe.ownerDocument || pe).documentElement;
            return !cr.test(me || Le && Le.nodeName || "HTML")
        },
        merge: function(pe, me) {
            for (var Le = +me.length, rt = 0, nr = pe.length; rt < Le; rt++)
                pe[nr++] = me[rt];
            return pe.length = nr,
            pe
        },
        grep: function(pe, me, Le) {
            for (var rt = [], nr = 0, sr = pe.length, ur = !Le; nr < sr; nr++)
                !me(pe[nr], nr) !== ur && rt.push(pe[nr]);
            return rt
        },
        map: function(pe, me, Le) {
            var rt, nr, sr = 0, ur = [];
            if (mr(pe))
                for (rt = pe.length; sr < rt; sr++)
                    (nr = me(pe[sr], sr, Le)) != null && ur.push(nr);
            else
                for (sr in pe)
                    (nr = me(pe[sr], sr, Le)) != null && ur.push(nr);
            return ue(ur)
        },
        guid: 1,
        support: Se
    }),
    typeof Symbol == "function" && (be.fn[Symbol.iterator] = Y[Symbol.iterator]),
    be.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(pe, me) {
        fe["[object " + me + "]"] = me.toLowerCase()
    });
    var Rr = Y.pop
      , Pr = Y.sort
      , Fr = Y.splice
      , br = "[\\x20\\t\\r\\n\\f]"
      , xr = new RegExp("^" + br + "+|((?:^|[^\\\\])(?:\\\\.)*)" + br + "+$","g");
    be.contains = function(pe, me) {
        var Le = me && me.parentNode;
        return pe === Le || !(!Le || Le.nodeType !== 1 || !(pe.contains ? pe.contains(Le) : pe.compareDocumentPosition && 16 & pe.compareDocumentPosition(Le)))
    }
    ;
    var _r = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
    function Ir(pe, me) {
        return me ? pe === "\0" ? "ï¿½" : pe.slice(0, -1) + "\\" + pe.charCodeAt(pe.length - 1).toString(16) + " " : "\\" + pe
    }
    be.escapeSelector = function(pe) {
        return (pe + "").replace(_r, Ir)
    }
    ;
    var Nr = rr
      , gn = de;
    (function() {
        var pe, me, Le, rt, nr, sr, ur, $r, yr, Or, Ur = gn, Hr = be.expando, Br = 0, Kr = 0, ti = eo(), wi = eo(), li = eo(), Qi = eo(), lo = function(gr, Tr) {
            return gr === Tr && (nr = !0),
            0
        }, Ro = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", Qo = "(?:\\\\[\\da-fA-F]{1,6}" + br + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", Ei = "\\[" + br + "*(" + Qo + ")(?:" + br + "*([*^$|!~]?=)" + br + `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + Qo + "))|)" + br + "*\\]", ka = ":(" + Qo + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + Ei + ")*)|.*)\\)|)", Ai = new RegExp(br + "+","g"), Li = new RegExp("^" + br + "*," + br + "*"), ns = new RegExp("^" + br + "*([>+~]|" + br + ")" + br + "*"), Gs = new RegExp(br + "|>"), aa = new RegExp(ka), Ss = new RegExp("^" + Qo + "$"), va = {
            ID: new RegExp("^#(" + Qo + ")"),
            CLASS: new RegExp("^\\.(" + Qo + ")"),
            TAG: new RegExp("^(" + Qo + "|[*])"),
            ATTR: new RegExp("^" + Ei),
            PSEUDO: new RegExp("^" + ka),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + br + "*(even|odd|(([+-]|)(\\d*)n|)" + br + "*(?:([+-]|)" + br + "*(\\d+)|))" + br + "*\\)|)","i"),
            bool: new RegExp("^(?:" + Ro + ")$","i"),
            needsContext: new RegExp("^" + br + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + br + "*((?:-\\d)?\\d*)" + br + "*\\)|)(?=[^-]|$)","i")
        }, Aa = /^(?:input|select|textarea|button)$/i, is = /^h\d$/i, uo = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, co = /[+~]/, no = new RegExp("\\\\[\\da-fA-F]{1,6}" + br + "?|\\\\([^\\r\\n\\f])","g"), vo = function(gr, Tr) {
            var Mr = "0x" + gr.slice(1) - 65536;
            return Tr || (Mr < 0 ? String.fromCharCode(Mr + 65536) : String.fromCharCode(Mr >> 10 | 55296, 1023 & Mr | 56320))
        }, Ia = function() {
            Pa()
        }, fo = Ys(function(gr) {
            return gr.disabled === !0 && fr(gr, "fieldset")
        }, {
            dir: "parentNode",
            next: "legend"
        });
        try {
            Ur.apply(Y = le.call(Nr.childNodes), Nr.childNodes),
            Y[Nr.childNodes.length].nodeType
        } catch {
            Ur = {
                apply: function(Tr, Mr) {
                    gn.apply(Tr, le.call(Mr))
                },
                call: function(Tr) {
                    gn.apply(Tr, le.call(arguments, 1))
                }
            }
        }
        function ri(gr, Tr, Mr, Dr) {
            var Yr, Sn, On, Un, An, Ii, mi, bi = Tr && Tr.ownerDocument, Si = Tr ? Tr.nodeType : 9;
            if (Mr = Mr || [],
            typeof gr != "string" || !gr || Si !== 1 && Si !== 9 && Si !== 11)
                return Mr;
            if (!Dr && (Pa(Tr),
            Tr = Tr || sr,
            $r)) {
                if (Si !== 11 && (An = uo.exec(gr)))
                    if (Yr = An[1]) {
                        if (Si === 9) {
                            if (!(On = Tr.getElementById(Yr)))
                                return Mr;
                            if (On.id === Yr)
                                return Ur.call(Mr, On),
                                Mr
                        } else if (bi && (On = bi.getElementById(Yr)) && ri.contains(Tr, On) && On.id === Yr)
                            return Ur.call(Mr, On),
                            Mr
                    } else {
                        if (An[2])
                            return Ur.apply(Mr, Tr.getElementsByTagName(gr)),
                            Mr;
                        if ((Yr = An[3]) && Tr.getElementsByClassName)
                            return Ur.apply(Mr, Tr.getElementsByClassName(Yr)),
                            Mr
                    }
                if (!(Qi[gr + " "] || yr && yr.test(gr))) {
                    if (mi = gr,
                    bi = Tr,
                    Si === 1 && (Gs.test(gr) || ns.test(gr))) {
                        for ((bi = co.test(gr) && yl(Tr.parentNode) || Tr) == Tr && Se.scope || ((Un = Tr.getAttribute("id")) ? Un = be.escapeSelector(Un) : Tr.setAttribute("id", Un = Hr)),
                        Sn = (Ii = ks(gr)).length; Sn--; )
                            Ii[Sn] = (Un ? "#" + Un : ":scope") + " " + Vs(Ii[Sn]);
                        mi = Ii.join(",")
                    }
                    try {
                        return Ur.apply(Mr, bi.querySelectorAll(mi)),
                        Mr
                    } catch {
                        Qi(gr, !0)
                    } finally {
                        Un === Hr && Tr.removeAttribute("id")
                    }
                }
            }
            return _l(gr.replace(xr, "$1"), Tr, Mr, Dr)
        }
        function eo() {
            var gr = [];
            return function Tr(Mr, Dr) {
                return gr.push(Mr + " ") > me.cacheLength && delete Tr[gr.shift()],
                Tr[Mr + " "] = Dr
            }
        }
        function Gi(gr) {
            return gr[Hr] = !0,
            gr
        }
        function Bi(gr) {
            var Tr = sr.createElement("fieldset");
            try {
                return !!gr(Tr)
            } catch {
                return !1
            } finally {
                Tr.parentNode && Tr.parentNode.removeChild(Tr),
                Tr = null
            }
        }
        function sa(gr) {
            return function(Tr) {
                return fr(Tr, "input") && Tr.type === gr
            }
        }
        function os(gr) {
            return function(Tr) {
                return (fr(Tr, "input") || fr(Tr, "button")) && Tr.type === gr
            }
        }
        function as(gr) {
            return function(Tr) {
                return "form"in Tr ? Tr.parentNode && Tr.disabled === !1 ? "label"in Tr ? "label"in Tr.parentNode ? Tr.parentNode.disabled === gr : Tr.disabled === gr : Tr.isDisabled === gr || Tr.isDisabled !== !gr && fo(Tr) === gr : Tr.disabled === gr : "label"in Tr && Tr.disabled === gr
            }
        }
        function Da(gr) {
            return Gi(function(Tr) {
                return Tr = +Tr,
                Gi(function(Mr, Dr) {
                    for (var Yr, Sn = gr([], Mr.length, Tr), On = Sn.length; On--; )
                        Mr[Yr = Sn[On]] && (Mr[Yr] = !(Dr[Yr] = Mr[Yr]))
                })
            })
        }
        function yl(gr) {
            return gr && gr.getElementsByTagName !== void 0 && gr
        }
        function Pa(gr) {
            var Tr, Mr = gr ? gr.ownerDocument || gr : Nr;
            return Mr != sr && Mr.nodeType === 9 && Mr.documentElement && (ur = (sr = Mr).documentElement,
            $r = !be.isXMLDoc(sr),
            Or = ur.matches || ur.webkitMatchesSelector || ur.msMatchesSelector,
            ur.msMatchesSelector && Nr != sr && (Tr = sr.defaultView) && Tr.top !== Tr && Tr.addEventListener("unload", Ia),
            Se.getById = Bi(function(Dr) {
                return ur.appendChild(Dr).id = be.expando,
                !sr.getElementsByName || !sr.getElementsByName(be.expando).length
            }),
            Se.disconnectedMatch = Bi(function(Dr) {
                return Or.call(Dr, "*")
            }),
            Se.scope = Bi(function() {
                return sr.querySelectorAll(":scope")
            }),
            Se.cssHas = Bi(function() {
                try {
                    return sr.querySelector(":has(*,:jqfake)"),
                    !1
                } catch {
                    return !0
                }
            }),
            Se.getById ? (me.filter.ID = function(Dr) {
                var Yr = Dr.replace(no, vo);
                return function(Sn) {
                    return Sn.getAttribute("id") === Yr
                }
            }
            ,
            me.find.ID = function(Dr, Yr) {
                if (Yr.getElementById !== void 0 && $r) {
                    var Sn = Yr.getElementById(Dr);
                    return Sn ? [Sn] : []
                }
            }
            ) : (me.filter.ID = function(Dr) {
                var Yr = Dr.replace(no, vo);
                return function(Sn) {
                    var On = Sn.getAttributeNode !== void 0 && Sn.getAttributeNode("id");
                    return On && On.value === Yr
                }
            }
            ,
            me.find.ID = function(Dr, Yr) {
                if (Yr.getElementById !== void 0 && $r) {
                    var Sn, On, Un, An = Yr.getElementById(Dr);
                    if (An) {
                        if ((Sn = An.getAttributeNode("id")) && Sn.value === Dr)
                            return [An];
                        for (Un = Yr.getElementsByName(Dr),
                        On = 0; An = Un[On++]; )
                            if ((Sn = An.getAttributeNode("id")) && Sn.value === Dr)
                                return [An]
                    }
                    return []
                }
            }
            ),
            me.find.TAG = function(Dr, Yr) {
                return Yr.getElementsByTagName !== void 0 ? Yr.getElementsByTagName(Dr) : Yr.querySelectorAll(Dr)
            }
            ,
            me.find.CLASS = function(Dr, Yr) {
                if (Yr.getElementsByClassName !== void 0 && $r)
                    return Yr.getElementsByClassName(Dr)
            }
            ,
            yr = [],
            Bi(function(Dr) {
                var Yr;
                ur.appendChild(Dr).innerHTML = "<a id='" + Hr + "' href='' disabled='disabled'></a><select id='" + Hr + "-\r\\' disabled='disabled'><option selected=''></option></select>",
                Dr.querySelectorAll("[selected]").length || yr.push("\\[" + br + "*(?:value|" + Ro + ")"),
                Dr.querySelectorAll("[id~=" + Hr + "-]").length || yr.push("~="),
                Dr.querySelectorAll("a#" + Hr + "+*").length || yr.push(".#.+[+~]"),
                Dr.querySelectorAll(":checked").length || yr.push(":checked"),
                (Yr = sr.createElement("input")).setAttribute("type", "hidden"),
                Dr.appendChild(Yr).setAttribute("name", "D"),
                ur.appendChild(Dr).disabled = !0,
                Dr.querySelectorAll(":disabled").length !== 2 && yr.push(":enabled", ":disabled"),
                (Yr = sr.createElement("input")).setAttribute("name", ""),
                Dr.appendChild(Yr),
                Dr.querySelectorAll("[name='']").length || yr.push("\\[" + br + "*name" + br + "*=" + br + `*(?:''|"")`)
            }),
            Se.cssHas || yr.push(":has"),
            yr = yr.length && new RegExp(yr.join("|")),
            lo = function(Dr, Yr) {
                if (Dr === Yr)
                    return nr = !0,
                    0;
                var Sn = !Dr.compareDocumentPosition - !Yr.compareDocumentPosition;
                return Sn || (1 & (Sn = (Dr.ownerDocument || Dr) == (Yr.ownerDocument || Yr) ? Dr.compareDocumentPosition(Yr) : 1) || !Se.sortDetached && Yr.compareDocumentPosition(Dr) === Sn ? Dr === sr || Dr.ownerDocument == Nr && ri.contains(Nr, Dr) ? -1 : Yr === sr || Yr.ownerDocument == Nr && ri.contains(Nr, Yr) ? 1 : rt ? he.call(rt, Dr) - he.call(rt, Yr) : 0 : 4 & Sn ? -1 : 1)
            }
            ),
            sr
        }
        for (pe in ri.matches = function(gr, Tr) {
            return ri(gr, null, null, Tr)
        }
        ,
        ri.matchesSelector = function(gr, Tr) {
            if (Pa(gr),
            $r && !Qi[Tr + " "] && (!yr || !yr.test(Tr)))
                try {
                    var Mr = Or.call(gr, Tr);
                    if (Mr || Se.disconnectedMatch || gr.document && gr.document.nodeType !== 11)
                        return Mr
                } catch {
                    Qi(Tr, !0)
                }
            return ri(Tr, sr, null, [gr]).length > 0
        }
        ,
        ri.contains = function(gr, Tr) {
            return (gr.ownerDocument || gr) != sr && Pa(gr),
            be.contains(gr, Tr)
        }
        ,
        ri.attr = function(gr, Tr) {
            (gr.ownerDocument || gr) != sr && Pa(gr);
            var Mr = me.attrHandle[Tr.toLowerCase()]
              , Dr = Mr && xe.call(me.attrHandle, Tr.toLowerCase()) ? Mr(gr, Tr, !$r) : void 0;
            return Dr !== void 0 ? Dr : gr.getAttribute(Tr)
        }
        ,
        ri.error = function(gr) {
            throw new Error("Syntax error, unrecognized expression: " + gr)
        }
        ,
        be.uniqueSort = function(gr) {
            var Tr, Mr = [], Dr = 0, Yr = 0;
            if (nr = !Se.sortStable,
            rt = !Se.sortStable && le.call(gr, 0),
            Pr.call(gr, lo),
            nr) {
                for (; Tr = gr[Yr++]; )
                    Tr === gr[Yr] && (Dr = Mr.push(Yr));
                for (; Dr--; )
                    Fr.call(gr, Mr[Dr], 1)
            }
            return rt = null,
            gr
        }
        ,
        be.fn.uniqueSort = function() {
            return this.pushStack(be.uniqueSort(le.apply(this)))
        }
        ,
        me = be.expr = {
            cacheLength: 50,
            createPseudo: Gi,
            match: va,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(gr) {
                    return gr[1] = gr[1].replace(no, vo),
                    gr[3] = (gr[3] || gr[4] || gr[5] || "").replace(no, vo),
                    gr[2] === "~=" && (gr[3] = " " + gr[3] + " "),
                    gr.slice(0, 4)
                },
                CHILD: function(gr) {
                    return gr[1] = gr[1].toLowerCase(),
                    gr[1].slice(0, 3) === "nth" ? (gr[3] || ri.error(gr[0]),
                    gr[4] = +(gr[4] ? gr[5] + (gr[6] || 1) : 2 * (gr[3] === "even" || gr[3] === "odd")),
                    gr[5] = +(gr[7] + gr[8] || gr[3] === "odd")) : gr[3] && ri.error(gr[0]),
                    gr
                },
                PSEUDO: function(gr) {
                    var Tr, Mr = !gr[6] && gr[2];
                    return va.CHILD.test(gr[0]) ? null : (gr[3] ? gr[2] = gr[4] || gr[5] || "" : Mr && aa.test(Mr) && (Tr = ks(Mr, !0)) && (Tr = Mr.indexOf(")", Mr.length - Tr) - Mr.length) && (gr[0] = gr[0].slice(0, Tr),
                    gr[2] = Mr.slice(0, Tr)),
                    gr.slice(0, 3))
                }
            },
            filter: {
                TAG: function(gr) {
                    var Tr = gr.replace(no, vo).toLowerCase();
                    return gr === "*" ? function() {
                        return !0
                    }
                    : function(Mr) {
                        return fr(Mr, Tr)
                    }
                },
                CLASS: function(gr) {
                    var Tr = ti[gr + " "];
                    return Tr || (Tr = new RegExp("(^|" + br + ")" + gr + "(" + br + "|$)")) && ti(gr, function(Mr) {
                        return Tr.test(typeof Mr.className == "string" && Mr.className || Mr.getAttribute !== void 0 && Mr.getAttribute("class") || "")
                    })
                },
                ATTR: function(gr, Tr, Mr) {
                    return function(Dr) {
                        var Yr = ri.attr(Dr, gr);
                        return Yr == null ? Tr === "!=" : !Tr || (Yr += "",
                        Tr === "=" ? Yr === Mr : Tr === "!=" ? Yr !== Mr : Tr === "^=" ? Mr && Yr.indexOf(Mr) === 0 : Tr === "*=" ? Mr && Yr.indexOf(Mr) > -1 : Tr === "$=" ? Mr && Yr.slice(-Mr.length) === Mr : Tr === "~=" ? (" " + Yr.replace(Ai, " ") + " ").indexOf(Mr) > -1 : Tr === "|=" && (Yr === Mr || Yr.slice(0, Mr.length + 1) === Mr + "-"))
                    }
                },
                CHILD: function(gr, Tr, Mr, Dr, Yr) {
                    var Sn = gr.slice(0, 3) !== "nth"
                      , On = gr.slice(-4) !== "last"
                      , Un = Tr === "of-type";
                    return Dr === 1 && Yr === 0 ? function(An) {
                        return !!An.parentNode
                    }
                    : function(An, Ii, mi) {
                        var bi, Si, ii, io, go, Ji = Sn !== On ? "nextSibling" : "previousSibling", Vi = An.parentNode, wo = Un && An.nodeName.toLowerCase(), Fo = !mi && !Un, zi = !1;
                        if (Vi) {
                            if (Sn) {
                                for (; Ji; ) {
                                    for (ii = An; ii = ii[Ji]; )
                                        if (Un ? fr(ii, wo) : ii.nodeType === 1)
                                            return !1;
                                    go = Ji = gr === "only" && !go && "nextSibling"
                                }
                                return !0
                            }
                            if (go = [On ? Vi.firstChild : Vi.lastChild],
                            On && Fo) {
                                for (zi = (io = (bi = (Si = Vi[Hr] || (Vi[Hr] = {}))[gr] || [])[0] === Br && bi[1]) && bi[2],
                                ii = io && Vi.childNodes[io]; ii = ++io && ii && ii[Ji] || (zi = io = 0) || go.pop(); )
                                    if (ii.nodeType === 1 && ++zi && ii === An) {
                                        Si[gr] = [Br, io, zi];
                                        break
                                    }
                            } else if (Fo && (zi = io = (bi = (Si = An[Hr] || (An[Hr] = {}))[gr] || [])[0] === Br && bi[1]),
                            zi === !1)
                                for (; (ii = ++io && ii && ii[Ji] || (zi = io = 0) || go.pop()) && (!(Un ? fr(ii, wo) : ii.nodeType === 1) || !++zi || (Fo && ((Si = ii[Hr] || (ii[Hr] = {}))[gr] = [Br, zi]),
                                ii !== An)); )
                                    ;
                            return (zi -= Yr) === Dr || zi % Dr == 0 && zi / Dr >= 0
                        }
                    }
                },
                PSEUDO: function(gr, Tr) {
                    var Mr, Dr = me.pseudos[gr] || me.setFilters[gr.toLowerCase()] || ri.error("unsupported pseudo: " + gr);
                    return Dr[Hr] ? Dr(Tr) : Dr.length > 1 ? (Mr = [gr, gr, "", Tr],
                    me.setFilters.hasOwnProperty(gr.toLowerCase()) ? Gi(function(Yr, Sn) {
                        for (var On, Un = Dr(Yr, Tr), An = Un.length; An--; )
                            Yr[On = he.call(Yr, Un[An])] = !(Sn[On] = Un[An])
                    }) : function(Yr) {
                        return Dr(Yr, 0, Mr)
                    }
                    ) : Dr
                }
            },
            pseudos: {
                not: Gi(function(gr) {
                    var Tr = []
                      , Mr = []
                      , Dr = Cl(gr.replace(xr, "$1"));
                    return Dr[Hr] ? Gi(function(Yr, Sn, On, Un) {
                        for (var An, Ii = Dr(Yr, null, Un, []), mi = Yr.length; mi--; )
                            (An = Ii[mi]) && (Yr[mi] = !(Sn[mi] = An))
                    }) : function(Yr, Sn, On) {
                        return Tr[0] = Yr,
                        Dr(Tr, null, On, Mr),
                        Tr[0] = null,
                        !Mr.pop()
                    }
                }),
                has: Gi(function(gr) {
                    return function(Tr) {
                        return ri(gr, Tr).length > 0
                    }
                }),
                contains: Gi(function(gr) {
                    return gr = gr.replace(no, vo),
                    function(Tr) {
                        return (Tr.textContent || be.text(Tr)).indexOf(gr) > -1
                    }
                }),
                lang: Gi(function(gr) {
                    return Ss.test(gr || "") || ri.error("unsupported lang: " + gr),
                    gr = gr.replace(no, vo).toLowerCase(),
                    function(Tr) {
                        var Mr;
                        do
                            if (Mr = $r ? Tr.lang : Tr.getAttribute("xml:lang") || Tr.getAttribute("lang"))
                                return (Mr = Mr.toLowerCase()) === gr || Mr.indexOf(gr + "-") === 0;
                        while ((Tr = Tr.parentNode) && Tr.nodeType === 1);
                        return !1
                    }
                }),
                target: function(gr) {
                    var Tr = W.location && W.location.hash;
                    return Tr && Tr.slice(1) === gr.id
                },
                root: function(gr) {
                    return gr === ur
                },
                focus: function(gr) {
                    return gr === function() {
                        try {
                            return sr.activeElement
                        } catch {}
                    }() && sr.hasFocus() && !!(gr.type || gr.href || ~gr.tabIndex)
                },
                enabled: as(!1),
                disabled: as(!0),
                checked: function(gr) {
                    return fr(gr, "input") && !!gr.checked || fr(gr, "option") && !!gr.selected
                },
                selected: function(gr) {
                    return gr.parentNode && gr.parentNode.selectedIndex,
                    gr.selected === !0
                },
                empty: function(gr) {
                    for (gr = gr.firstChild; gr; gr = gr.nextSibling)
                        if (gr.nodeType < 6)
                            return !1;
                    return !0
                },
                parent: function(gr) {
                    return !me.pseudos.empty(gr)
                },
                header: function(gr) {
                    return is.test(gr.nodeName)
                },
                input: function(gr) {
                    return Aa.test(gr.nodeName)
                },
                button: function(gr) {
                    return fr(gr, "input") && gr.type === "button" || fr(gr, "button")
                },
                text: function(gr) {
                    var Tr;
                    return fr(gr, "input") && gr.type === "text" && ((Tr = gr.getAttribute("type")) == null || Tr.toLowerCase() === "text")
                },
                first: Da(function() {
                    return [0]
                }),
                last: Da(function(gr, Tr) {
                    return [Tr - 1]
                }),
                eq: Da(function(gr, Tr, Mr) {
                    return [Mr < 0 ? Mr + Tr : Mr]
                }),
                even: Da(function(gr, Tr) {
                    for (var Mr = 0; Mr < Tr; Mr += 2)
                        gr.push(Mr);
                    return gr
                }),
                odd: Da(function(gr, Tr) {
                    for (var Mr = 1; Mr < Tr; Mr += 2)
                        gr.push(Mr);
                    return gr
                }),
                lt: Da(function(gr, Tr, Mr) {
                    var Dr;
                    for (Dr = Mr < 0 ? Mr + Tr : Mr > Tr ? Tr : Mr; --Dr >= 0; )
                        gr.push(Dr);
                    return gr
                }),
                gt: Da(function(gr, Tr, Mr) {
                    for (var Dr = Mr < 0 ? Mr + Tr : Mr; ++Dr < Tr; )
                        gr.push(Dr);
                    return gr
                })
            }
        },
        me.pseudos.nth = me.pseudos.eq,
        {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        })
            me.pseudos[pe] = sa(pe);
        for (pe in {
            submit: !0,
            reset: !0
        })
            me.pseudos[pe] = os(pe);
        function ql() {}
        function ks(gr, Tr) {
            var Mr, Dr, Yr, Sn, On, Un, An, Ii = wi[gr + " "];
            if (Ii)
                return Tr ? 0 : Ii.slice(0);
            for (On = gr,
            Un = [],
            An = me.preFilter; On; ) {
                for (Sn in Mr && !(Dr = Li.exec(On)) || (Dr && (On = On.slice(Dr[0].length) || On),
                Un.push(Yr = [])),
                Mr = !1,
                (Dr = ns.exec(On)) && (Mr = Dr.shift(),
                Yr.push({
                    value: Mr,
                    type: Dr[0].replace(xr, " ")
                }),
                On = On.slice(Mr.length)),
                me.filter)
                    !(Dr = va[Sn].exec(On)) || An[Sn] && !(Dr = An[Sn](Dr)) || (Mr = Dr.shift(),
                    Yr.push({
                        value: Mr,
                        type: Sn,
                        matches: Dr
                    }),
                    On = On.slice(Mr.length));
                if (!Mr)
                    break
            }
            return Tr ? On.length : On ? ri.error(gr) : wi(gr, Un).slice(0)
        }
        function Vs(gr) {
            for (var Tr = 0, Mr = gr.length, Dr = ""; Tr < Mr; Tr++)
                Dr += gr[Tr].value;
            return Dr
        }
        function Ys(gr, Tr, Mr) {
            var Dr = Tr.dir
              , Yr = Tr.next
              , Sn = Yr || Dr
              , On = Mr && Sn === "parentNode"
              , Un = Kr++;
            return Tr.first ? function(An, Ii, mi) {
                for (; An = An[Dr]; )
                    if (An.nodeType === 1 || On)
                        return gr(An, Ii, mi);
                return !1
            }
            : function(An, Ii, mi) {
                var bi, Si, ii = [Br, Un];
                if (mi) {
                    for (; An = An[Dr]; )
                        if ((An.nodeType === 1 || On) && gr(An, Ii, mi))
                            return !0
                } else
                    for (; An = An[Dr]; )
                        if (An.nodeType === 1 || On)
                            if (Si = An[Hr] || (An[Hr] = {}),
                            Yr && fr(An, Yr))
                                An = An[Dr] || An;
                            else {
                                if ((bi = Si[Sn]) && bi[0] === Br && bi[1] === Un)
                                    return ii[2] = bi[2];
                                if (Si[Sn] = ii,
                                ii[2] = gr(An, Ii, mi))
                                    return !0
                            }
                return !1
            }
        }
        function As(gr) {
            return gr.length > 1 ? function(Tr, Mr, Dr) {
                for (var Yr = gr.length; Yr--; )
                    if (!gr[Yr](Tr, Mr, Dr))
                        return !1;
                return !0
            }
            : gr[0]
        }
        function Is(gr, Tr, Mr, Dr, Yr) {
            for (var Sn, On = [], Un = 0, An = gr.length, Ii = Tr != null; Un < An; Un++)
                (Sn = gr[Un]) && (Mr && !Mr(Sn, Dr, Yr) || (On.push(Sn),
                Ii && Tr.push(Un)));
            return On
        }
        function xl(gr, Tr, Mr, Dr, Yr, Sn) {
            return Dr && !Dr[Hr] && (Dr = xl(Dr)),
            Yr && !Yr[Hr] && (Yr = xl(Yr, Sn)),
            Gi(function(On, Un, An, Ii) {
                var mi, bi, Si, ii, io = [], go = [], Ji = Un.length, Vi = On || function(Fo, zi, wa) {
                    for (var oo = 0, ss = zi.length; oo < ss; oo++)
                        ri(Fo, zi[oo], wa);
                    return wa
                }(Tr || "*", An.nodeType ? [An] : An, []), wo = !gr || !On && Tr ? Vi : Is(Vi, io, gr, An, Ii);
                if (Mr ? Mr(wo, ii = Yr || (On ? gr : Ji || Dr) ? [] : Un, An, Ii) : ii = wo,
                Dr)
                    for (mi = Is(ii, go),
                    Dr(mi, [], An, Ii),
                    bi = mi.length; bi--; )
                        (Si = mi[bi]) && (ii[go[bi]] = !(wo[go[bi]] = Si));
                if (On) {
                    if (Yr || gr) {
                        if (Yr) {
                            for (mi = [],
                            bi = ii.length; bi--; )
                                (Si = ii[bi]) && mi.push(wo[bi] = Si);
                            Yr(null, ii = [], mi, Ii)
                        }
                        for (bi = ii.length; bi--; )
                            (Si = ii[bi]) && (mi = Yr ? he.call(On, Si) : io[bi]) > -1 && (On[mi] = !(Un[mi] = Si))
                    }
                } else
                    ii = Is(ii === Un ? ii.splice(Ji, ii.length) : ii),
                    Yr ? Yr(null, Un, ii, Ii) : Ur.apply(Un, ii)
            })
        }
        function $l(gr) {
            for (var Tr, Mr, Dr, Yr = gr.length, Sn = me.relative[gr[0].type], On = Sn || me.relative[" "], Un = Sn ? 1 : 0, An = Ys(function(bi) {
                return bi === Tr
            }, On, !0), Ii = Ys(function(bi) {
                return he.call(Tr, bi) > -1
            }, On, !0), mi = [function(bi, Si, ii) {
                var io = !Sn && (ii || Si != Le) || ((Tr = Si).nodeType ? An(bi, Si, ii) : Ii(bi, Si, ii));
                return Tr = null,
                io
            }
            ]; Un < Yr; Un++)
                if (Mr = me.relative[gr[Un].type])
                    mi = [Ys(As(mi), Mr)];
                else {
                    if ((Mr = me.filter[gr[Un].type].apply(null, gr[Un].matches))[Hr]) {
                        for (Dr = ++Un; Dr < Yr && !me.relative[gr[Dr].type]; Dr++)
                            ;
                        return xl(Un > 1 && As(mi), Un > 1 && Vs(gr.slice(0, Un - 1).concat({
                            value: gr[Un - 2].type === " " ? "*" : ""
                        })).replace(xr, "$1"), Mr, Un < Dr && $l(gr.slice(Un, Dr)), Dr < Yr && $l(gr = gr.slice(Dr)), Dr < Yr && Vs(gr))
                    }
                    mi.push(Mr)
                }
            return As(mi)
        }
        function Cl(gr, Tr) {
            var Mr, Dr = [], Yr = [], Sn = li[gr + " "];
            if (!Sn) {
                for (Tr || (Tr = ks(gr)),
                Mr = Tr.length; Mr--; )
                    (Sn = $l(Tr[Mr]))[Hr] ? Dr.push(Sn) : Yr.push(Sn);
                Sn = li(gr, function(On, Un) {
                    var An = Un.length > 0
                      , Ii = On.length > 0
                      , mi = function(bi, Si, ii, io, go) {
                        var Ji, Vi, wo, Fo = 0, zi = "0", wa = bi && [], oo = [], ss = Le, Gl = bi || Ii && me.find.TAG("*", go), Vl = Br += ss == null ? 1 : Math.random() || .1, El = Gl.length;
                        for (go && (Le = Si == sr || Si || go); zi !== El && (Ji = Gl[zi]) != null; zi++) {
                            if (Ii && Ji) {
                                for (Vi = 0,
                                Si || Ji.ownerDocument == sr || (Pa(Ji),
                                ii = !$r); wo = On[Vi++]; )
                                    if (wo(Ji, Si || sr, ii)) {
                                        Ur.call(io, Ji);
                                        break
                                    }
                                go && (Br = Vl)
                            }
                            An && ((Ji = !wo && Ji) && Fo--,
                            bi && wa.push(Ji))
                        }
                        if (Fo += zi,
                        An && zi !== Fo) {
                            for (Vi = 0; wo = Un[Vi++]; )
                                wo(wa, oo, Si, ii);
                            if (bi) {
                                if (Fo > 0)
                                    for (; zi--; )
                                        wa[zi] || oo[zi] || (oo[zi] = Rr.call(io));
                                oo = Is(oo)
                            }
                            Ur.apply(io, oo),
                            go && !bi && oo.length > 0 && Fo + Un.length > 1 && be.uniqueSort(io)
                        }
                        return go && (Br = Vl,
                        Le = ss),
                        wa
                    };
                    return An ? Gi(mi) : mi
                }(Yr, Dr)),
                Sn.selector = gr
            }
            return Sn
        }
        function _l(gr, Tr, Mr, Dr) {
            var Yr, Sn, On, Un, An, Ii = typeof gr == "function" && gr, mi = !Dr && ks(gr = Ii.selector || gr);
            if (Mr = Mr || [],
            mi.length === 1) {
                if ((Sn = mi[0] = mi[0].slice(0)).length > 2 && (On = Sn[0]).type === "ID" && Tr.nodeType === 9 && $r && me.relative[Sn[1].type]) {
                    if (!(Tr = (me.find.ID(On.matches[0].replace(no, vo), Tr) || [])[0]))
                        return Mr;
                    Ii && (Tr = Tr.parentNode),
                    gr = gr.slice(Sn.shift().value.length)
                }
                for (Yr = va.needsContext.test(gr) ? 0 : Sn.length; Yr-- && (On = Sn[Yr],
                !me.relative[Un = On.type]); )
                    if ((An = me.find[Un]) && (Dr = An(On.matches[0].replace(no, vo), co.test(Sn[0].type) && yl(Tr.parentNode) || Tr))) {
                        if (Sn.splice(Yr, 1),
                        !(gr = Dr.length && Vs(Sn)))
                            return Ur.apply(Mr, Dr),
                            Mr;
                        break
                    }
            }
            return (Ii || Cl(gr, mi))(Dr, Tr, !$r, Mr, !Tr || co.test(gr) && yl(Tr.parentNode) || Tr),
            Mr
        }
        ql.prototype = me.filters = me.pseudos,
        me.setFilters = new ql,
        Se.sortStable = Hr.split("").sort(lo).join("") === Hr,
        Pa(),
        Se.sortDetached = Bi(function(gr) {
            return 1 & gr.compareDocumentPosition(sr.createElement("fieldset"))
        }),
        be.find = ri,
        be.expr[":"] = be.expr.pseudos,
        be.unique = be.uniqueSort,
        ri.compile = Cl,
        ri.select = _l,
        ri.setDocument = Pa,
        ri.tokenize = ks,
        ri.escape = be.escapeSelector,
        ri.getText = be.text,
        ri.isXML = be.isXMLDoc,
        ri.selectors = be.expr,
        ri.support = be.support,
        ri.uniqueSort = be.uniqueSort
    }
    )();
    var Zr = function(pe, me, Le) {
        for (var rt = [], nr = Le !== void 0; (pe = pe[me]) && pe.nodeType !== 9; )
            if (pe.nodeType === 1) {
                if (nr && be(pe).is(Le))
                    break;
                rt.push(pe)
            }
        return rt
    }
      , Tn = function(pe, me) {
        for (var Le = []; pe; pe = pe.nextSibling)
            pe.nodeType === 1 && pe !== me && Le.push(pe);
        return Le
    }
      , Zn = be.expr.match.needsContext
      , Cn = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    function Gn(pe, me, Le) {
        return Ne(me) ? be.grep(pe, function(rt, nr) {
            return !!me.call(rt, nr, rt) !== Le
        }) : me.nodeType ? be.grep(pe, function(rt) {
            return rt === me !== Le
        }) : typeof me != "string" ? be.grep(pe, function(rt) {
            return he.call(me, rt) > -1 !== Le
        }) : be.filter(me, pe, Le)
    }
    be.filter = function(pe, me, Le) {
        var rt = me[0];
        return Le && (pe = ":not(" + pe + ")"),
        me.length === 1 && rt.nodeType === 1 ? be.find.matchesSelector(rt, pe) ? [rt] : [] : be.find.matches(pe, be.grep(me, function(nr) {
            return nr.nodeType === 1
        }))
    }
    ,
    be.fn.extend({
        find: function(pe) {
            var me, Le, rt = this.length, nr = this;
            if (typeof pe != "string")
                return this.pushStack(be(pe).filter(function() {
                    for (me = 0; me < rt; me++)
                        if (be.contains(nr[me], this))
                            return !0
                }));
            for (Le = this.pushStack([]),
            me = 0; me < rt; me++)
                be.find(pe, nr[me], Le);
            return rt > 1 ? be.uniqueSort(Le) : Le
        },
        filter: function(pe) {
            return this.pushStack(Gn(this, pe || [], !1))
        },
        not: function(pe) {
            return this.pushStack(Gn(this, pe || [], !0))
        },
        is: function(pe) {
            return !!Gn(this, typeof pe == "string" && Zn.test(pe) ? be(pe) : pe || [], !1).length
        }
    });
    var ni, xi = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
    (be.fn.init = function(pe, me, Le) {
        var rt, nr;
        if (!pe)
            return this;
        if (Le = Le || ni,
        typeof pe == "string") {
            if (!(rt = pe[0] === "<" && pe[pe.length - 1] === ">" && pe.length >= 3 ? [null, pe, null] : xi.exec(pe)) || !rt[1] && me)
                return !me || me.jquery ? (me || Le).find(pe) : this.constructor(me).find(pe);
            if (rt[1]) {
                if (me = me instanceof be ? me[0] : me,
                be.merge(this, be.parseHTML(rt[1], me && me.nodeType ? me.ownerDocument || me : rr, !0)),
                Cn.test(rt[1]) && be.isPlainObject(me))
                    for (rt in me)
                        Ne(this[rt]) ? this[rt](me[rt]) : this.attr(rt, me[rt]);
                return this
            }
            return (nr = rr.getElementById(rt[2])) && (this[0] = nr,
            this.length = 1),
            this
        }
        return pe.nodeType ? (this[0] = pe,
        this.length = 1,
        this) : Ne(pe) ? Le.ready !== void 0 ? Le.ready(pe) : pe(be) : be.makeArray(pe, this)
    }
    ).prototype = be.fn,
    ni = be(rr);
    var oi = /^(?:parents|prev(?:Until|All))/
      , $i = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    function Ci(pe, me) {
        for (; (pe = pe[me]) && pe.nodeType !== 1; )
            ;
        return pe
    }
    be.fn.extend({
        has: function(pe) {
            var me = be(pe, this)
              , Le = me.length;
            return this.filter(function() {
                for (var rt = 0; rt < Le; rt++)
                    if (be.contains(this, me[rt]))
                        return !0
            })
        },
        closest: function(pe, me) {
            var Le, rt = 0, nr = this.length, sr = [], ur = typeof pe != "string" && be(pe);
            if (!Zn.test(pe)) {
                for (; rt < nr; rt++)
                    for (Le = this[rt]; Le && Le !== me; Le = Le.parentNode)
                        if (Le.nodeType < 11 && (ur ? ur.index(Le) > -1 : Le.nodeType === 1 && be.find.matchesSelector(Le, pe))) {
                            sr.push(Le);
                            break
                        }
            }
            return this.pushStack(sr.length > 1 ? be.uniqueSort(sr) : sr)
        },
        index: function(pe) {
            return pe ? typeof pe == "string" ? he.call(be(pe), this[0]) : he.call(this, pe.jquery ? pe[0] : pe) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
        },
        add: function(pe, me) {
            return this.pushStack(be.uniqueSort(be.merge(this.get(), be(pe, me))))
        },
        addBack: function(pe) {
            return this.add(pe == null ? this.prevObject : this.prevObject.filter(pe))
        }
    }),
    be.each({
        parent: function(pe) {
            var me = pe.parentNode;
            return me && me.nodeType !== 11 ? me : null
        },
        parents: function(pe) {
            return Zr(pe, "parentNode")
        },
        parentsUntil: function(pe, me, Le) {
            return Zr(pe, "parentNode", Le)
        },
        next: function(pe) {
            return Ci(pe, "nextSibling")
        },
        prev: function(pe) {
            return Ci(pe, "previousSibling")
        },
        nextAll: function(pe) {
            return Zr(pe, "nextSibling")
        },
        prevAll: function(pe) {
            return Zr(pe, "previousSibling")
        },
        nextUntil: function(pe, me, Le) {
            return Zr(pe, "nextSibling", Le)
        },
        prevUntil: function(pe, me, Le) {
            return Zr(pe, "previousSibling", Le)
        },
        siblings: function(pe) {
            return Tn((pe.parentNode || {}).firstChild, pe)
        },
        children: function(pe) {
            return Tn(pe.firstChild)
        },
        contents: function(pe) {
            return pe.contentDocument != null && ne(pe.contentDocument) ? pe.contentDocument : (fr(pe, "template") && (pe = pe.content || pe),
            be.merge([], pe.childNodes))
        }
    }, function(pe, me) {
        be.fn[pe] = function(Le, rt) {
            var nr = be.map(this, me, Le);
            return pe.slice(-5) !== "Until" && (rt = Le),
            rt && typeof rt == "string" && (nr = be.filter(rt, nr)),
            this.length > 1 && ($i[pe] || be.uniqueSort(nr),
            oi.test(pe) && nr.reverse()),
            this.pushStack(nr)
        }
    });
    var Yn = /[^\x20\t\r\n\f]+/g;
    function pi(pe) {
        return pe
    }
    function yi(pe) {
        throw pe
    }
    function dr(pe, me, Le, rt) {
        var nr;
        try {
            pe && Ne(nr = pe.promise) ? nr.call(pe).done(me).fail(Le) : pe && Ne(nr = pe.then) ? nr.call(pe, me, Le) : me.apply(void 0, [pe].slice(rt))
        } catch (sr) {
            Le.apply(void 0, [sr])
        }
    }
    be.Callbacks = function(pe) {
        pe = typeof pe == "string" ? function(Ur) {
            var Hr = {};
            return be.each(Ur.match(Yn) || [], function(Br, Kr) {
                Hr[Kr] = !0
            }),
            Hr
        }(pe) : be.extend({}, pe);
        var me, Le, rt, nr, sr = [], ur = [], $r = -1, yr = function() {
            for (nr = nr || pe.once,
            rt = me = !0; ur.length; $r = -1)
                for (Le = ur.shift(); ++$r < sr.length; )
                    sr[$r].apply(Le[0], Le[1]) === !1 && pe.stopOnFalse && ($r = sr.length,
                    Le = !1);
            pe.memory || (Le = !1),
            me = !1,
            nr && (sr = Le ? [] : "")
        }, Or = {
            add: function() {
                return sr && (Le && !me && ($r = sr.length - 1,
                ur.push(Le)),
                function Ur(Hr) {
                    be.each(Hr, function(Br, Kr) {
                        Ne(Kr) ? pe.unique && Or.has(Kr) || sr.push(Kr) : Kr && Kr.length && Ut(Kr) !== "string" && Ur(Kr)
                    })
                }(arguments),
                Le && !me && yr()),
                this
            },
            remove: function() {
                return be.each(arguments, function(Ur, Hr) {
                    for (var Br; (Br = be.inArray(Hr, sr, Br)) > -1; )
                        sr.splice(Br, 1),
                        Br <= $r && $r--
                }),
                this
            },
            has: function(Ur) {
                return Ur ? be.inArray(Ur, sr) > -1 : sr.length > 0
            },
            empty: function() {
                return sr && (sr = []),
                this
            },
            disable: function() {
                return nr = ur = [],
                sr = Le = "",
                this
            },
            disabled: function() {
                return !sr
            },
            lock: function() {
                return nr = ur = [],
                Le || me || (sr = Le = ""),
                this
            },
            locked: function() {
                return !!nr
            },
            fireWith: function(Ur, Hr) {
                return nr || (Hr = [Ur, (Hr = Hr || []).slice ? Hr.slice() : Hr],
                ur.push(Hr),
                me || yr()),
                this
            },
            fire: function() {
                return Or.fireWith(this, arguments),
                this
            },
            fired: function() {
                return !!rt
            }
        };
        return Or
    }
    ,
    be.extend({
        Deferred: function(pe) {
            var me = [["notify", "progress", be.Callbacks("memory"), be.Callbacks("memory"), 2], ["resolve", "done", be.Callbacks("once memory"), be.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", be.Callbacks("once memory"), be.Callbacks("once memory"), 1, "rejected"]]
              , Le = "pending"
              , rt = {
                state: function() {
                    return Le
                },
                always: function() {
                    return nr.done(arguments).fail(arguments),
                    this
                },
                catch: function(sr) {
                    return rt.then(null, sr)
                },
                pipe: function() {
                    var sr = arguments;
                    return be.Deferred(function(ur) {
                        be.each(me, function($r, yr) {
                            var Or = Ne(sr[yr[4]]) && sr[yr[4]];
                            nr[yr[1]](function() {
                                var Ur = Or && Or.apply(this, arguments);
                                Ur && Ne(Ur.promise) ? Ur.promise().progress(ur.notify).done(ur.resolve).fail(ur.reject) : ur[yr[0] + "With"](this, Or ? [Ur] : arguments)
                            })
                        }),
                        sr = null
                    }).promise()
                },
                then: function(sr, ur, $r) {
                    var yr = 0;
                    function Or(Ur, Hr, Br, Kr) {
                        return function() {
                            var ti = this
                              , wi = arguments
                              , li = function() {
                                var lo, Ro;
                                if (!(Ur < yr)) {
                                    if ((lo = Br.apply(ti, wi)) === Hr.promise())
                                        throw new TypeError("Thenable self-resolution");
                                    Ro = lo && (typeof lo == "object" || typeof lo == "function") && lo.then,
                                    Ne(Ro) ? Kr ? Ro.call(lo, Or(yr, Hr, pi, Kr), Or(yr, Hr, yi, Kr)) : (yr++,
                                    Ro.call(lo, Or(yr, Hr, pi, Kr), Or(yr, Hr, yi, Kr), Or(yr, Hr, pi, Hr.notifyWith))) : (Br !== pi && (ti = void 0,
                                    wi = [lo]),
                                    (Kr || Hr.resolveWith)(ti, wi))
                                }
                            }
                              , Qi = Kr ? li : function() {
                                try {
                                    li()
                                } catch (lo) {
                                    be.Deferred.exceptionHook && be.Deferred.exceptionHook(lo, Qi.error),
                                    Ur + 1 >= yr && (Br !== yi && (ti = void 0,
                                    wi = [lo]),
                                    Hr.rejectWith(ti, wi))
                                }
                            }
                            ;
                            Ur ? Qi() : (be.Deferred.getErrorHook ? Qi.error = be.Deferred.getErrorHook() : be.Deferred.getStackHook && (Qi.error = be.Deferred.getStackHook()),
                            W.setTimeout(Qi))
                        }
                    }
                    return be.Deferred(function(Ur) {
                        me[0][3].add(Or(0, Ur, Ne($r) ? $r : pi, Ur.notifyWith)),
                        me[1][3].add(Or(0, Ur, Ne(sr) ? sr : pi)),
                        me[2][3].add(Or(0, Ur, Ne(ur) ? ur : yi))
                    }).promise()
                },
                promise: function(sr) {
                    return sr != null ? be.extend(sr, rt) : rt
                }
            }
              , nr = {};
            return be.each(me, function(sr, ur) {
                var $r = ur[2]
                  , yr = ur[5];
                rt[ur[1]] = $r.add,
                yr && $r.add(function() {
                    Le = yr
                }, me[3 - sr][2].disable, me[3 - sr][3].disable, me[0][2].lock, me[0][3].lock),
                $r.add(ur[3].fire),
                nr[ur[0]] = function() {
                    return nr[ur[0] + "With"](this === nr ? void 0 : this, arguments),
                    this
                }
                ,
                nr[ur[0] + "With"] = $r.fireWith
            }),
            rt.promise(nr),
            pe && pe.call(nr, nr),
            nr
        },
        when: function(pe) {
            var me = arguments.length
              , Le = me
              , rt = Array(Le)
              , nr = le.call(arguments)
              , sr = be.Deferred()
              , ur = function($r) {
                return function(yr) {
                    rt[$r] = this,
                    nr[$r] = arguments.length > 1 ? le.call(arguments) : yr,
                    --me || sr.resolveWith(rt, nr)
                }
            };
            if (me <= 1 && (dr(pe, sr.done(ur(Le)).resolve, sr.reject, !me),
            sr.state() === "pending" || Ne(nr[Le] && nr[Le].then)))
                return sr.then();
            for (; Le--; )
                dr(nr[Le], ur(Le), sr.reject);
            return sr.promise()
        }
    });
    var Sr = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    be.Deferred.exceptionHook = function(pe, me) {
        W.console && W.console.warn && pe && Sr.test(pe.name) && W.console.warn("jQuery.Deferred exception: " + pe.message, pe.stack, me)
    }
    ,
    be.readyException = function(pe) {
        W.setTimeout(function() {
            throw pe
        })
    }
    ;
    var Gr = be.Deferred();
    function Qr() {
        rr.removeEventListener("DOMContentLoaded", Qr),
        W.removeEventListener("load", Qr),
        be.ready()
    }
    be.fn.ready = function(pe) {
        return Gr.then(pe).catch(function(me) {
            be.readyException(me)
        }),
        this
    }
    ,
    be.extend({
        isReady: !1,
        readyWait: 1,
        ready: function(pe) {
            (pe === !0 ? --be.readyWait : be.isReady) || (be.isReady = !0,
            pe !== !0 && --be.readyWait > 0 || Gr.resolveWith(rr, [be]))
        }
    }),
    be.ready.then = Gr.then,
    rr.readyState === "complete" || rr.readyState !== "loading" && !rr.documentElement.doScroll ? W.setTimeout(be.ready) : (rr.addEventListener("DOMContentLoaded", Qr),
    W.addEventListener("load", Qr));
    var vn = function(pe, me, Le, rt, nr, sr, ur) {
        var $r = 0
          , yr = pe.length
          , Or = Le == null;
        if (Ut(Le) === "object")
            for ($r in nr = !0,
            Le)
                vn(pe, me, $r, Le[$r], !0, sr, ur);
        else if (rt !== void 0 && (nr = !0,
        Ne(rt) || (ur = !0),
        Or && (ur ? (me.call(pe, rt),
        me = null) : (Or = me,
        me = function(Ur, Hr, Br) {
            return Or.call(be(Ur), Br)
        }
        )),
        me))
            for (; $r < yr; $r++)
                me(pe[$r], Le, ur ? rt : rt.call(pe[$r], $r, me(pe[$r], Le)));
        return nr ? pe : Or ? me.call(pe) : yr ? me(pe[0], Le) : sr
    }
      , Oe = /^-ms-/
      , ot = /-([a-z])/g;
    function ir(pe, me) {
        return me.toUpperCase()
    }
    function vr(pe) {
        return pe.replace(Oe, "ms-").replace(ot, ir)
    }
    var Er = function(pe) {
        return pe.nodeType === 1 || pe.nodeType === 9 || !+pe.nodeType
    };
    function Ar() {
        this.expando = be.expando + Ar.uid++
    }
    Ar.uid = 1,
    Ar.prototype = {
        cache: function(pe) {
            var me = pe[this.expando];
            return me || (me = {},
            Er(pe) && (pe.nodeType ? pe[this.expando] = me : Object.defineProperty(pe, this.expando, {
                value: me,
                configurable: !0
            }))),
            me
        },
        set: function(pe, me, Le) {
            var rt, nr = this.cache(pe);
            if (typeof me == "string")
                nr[vr(me)] = Le;
            else
                for (rt in me)
                    nr[vr(rt)] = me[rt];
            return nr
        },
        get: function(pe, me) {
            return me === void 0 ? this.cache(pe) : pe[this.expando] && pe[this.expando][vr(me)]
        },
        access: function(pe, me, Le) {
            return me === void 0 || me && typeof me == "string" && Le === void 0 ? this.get(pe, me) : (this.set(pe, me, Le),
            Le !== void 0 ? Le : me)
        },
        remove: function(pe, me) {
            var Le, rt = pe[this.expando];
            if (rt !== void 0) {
                if (me !== void 0)
                    for (Le = (me = Array.isArray(me) ? me.map(vr) : (me = vr(me))in rt ? [me] : me.match(Yn) || []).length; Le--; )
                        delete rt[me[Le]];
                (me === void 0 || be.isEmptyObject(rt)) && (pe.nodeType ? pe[this.expando] = void 0 : delete pe[this.expando])
            }
        },
        hasData: function(pe) {
            var me = pe[this.expando];
            return me !== void 0 && !be.isEmptyObject(me)
        }
    };
    var kr = new Ar
      , _n = new Ar
      , Qn = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/
      , gi = /[A-Z]/g;
    function ei(pe, me, Le) {
        var rt;
        if (Le === void 0 && pe.nodeType === 1)
            if (rt = "data-" + me.replace(gi, "-$&").toLowerCase(),
            typeof (Le = pe.getAttribute(rt)) == "string") {
                try {
                    Le = function(nr) {
                        return nr === "true" || nr !== "false" && (nr === "null" ? null : nr === +nr + "" ? +nr : Qn.test(nr) ? JSON.parse(nr) : nr)
                    }(Le)
                } catch {}
                _n.set(pe, me, Le)
            } else
                Le = void 0;
        return Le
    }
    be.extend({
        hasData: function(pe) {
            return _n.hasData(pe) || kr.hasData(pe)
        },
        data: function(pe, me, Le) {
            return _n.access(pe, me, Le)
        },
        removeData: function(pe, me) {
            _n.remove(pe, me)
        },
        _data: function(pe, me, Le) {
            return kr.access(pe, me, Le)
        },
        _removeData: function(pe, me) {
            kr.remove(pe, me)
        }
    }),
    be.fn.extend({
        data: function(pe, me) {
            var Le, rt, nr, sr = this[0], ur = sr && sr.attributes;
            if (pe === void 0) {
                if (this.length && (nr = _n.get(sr),
                sr.nodeType === 1 && !kr.get(sr, "hasDataAttrs"))) {
                    for (Le = ur.length; Le--; )
                        ur[Le] && (rt = ur[Le].name).indexOf("data-") === 0 && (rt = vr(rt.slice(5)),
                        ei(sr, rt, nr[rt]));
                    kr.set(sr, "hasDataAttrs", !0)
                }
                return nr
            }
            return typeof pe == "object" ? this.each(function() {
                _n.set(this, pe)
            }) : vn(this, function($r) {
                var yr;
                if (sr && $r === void 0)
                    return (yr = _n.get(sr, pe)) !== void 0 || (yr = ei(sr, pe)) !== void 0 ? yr : void 0;
                this.each(function() {
                    _n.set(this, pe, $r)
                })
            }, null, me, arguments.length > 1, null, !0)
        },
        removeData: function(pe) {
            return this.each(function() {
                _n.remove(this, pe)
            })
        }
    }),
    be.extend({
        queue: function(pe, me, Le) {
            var rt;
            if (pe)
                return me = (me || "fx") + "queue",
                rt = kr.get(pe, me),
                Le && (!rt || Array.isArray(Le) ? rt = kr.access(pe, me, be.makeArray(Le)) : rt.push(Le)),
                rt || []
        },
        dequeue: function(pe, me) {
            me = me || "fx";
            var Le = be.queue(pe, me)
              , rt = Le.length
              , nr = Le.shift()
              , sr = be._queueHooks(pe, me);
            nr === "inprogress" && (nr = Le.shift(),
            rt--),
            nr && (me === "fx" && Le.unshift("inprogress"),
            delete sr.stop,
            nr.call(pe, function() {
                be.dequeue(pe, me)
            }, sr)),
            !rt && sr && sr.empty.fire()
        },
        _queueHooks: function(pe, me) {
            var Le = me + "queueHooks";
            return kr.get(pe, Le) || kr.access(pe, Le, {
                empty: be.Callbacks("once memory").add(function() {
                    kr.remove(pe, [me + "queue", Le])
                })
            })
        }
    }),
    be.fn.extend({
        queue: function(pe, me) {
            var Le = 2;
            return typeof pe != "string" && (me = pe,
            pe = "fx",
            Le--),
            arguments.length < Le ? be.queue(this[0], pe) : me === void 0 ? this : this.each(function() {
                var rt = be.queue(this, pe, me);
                be._queueHooks(this, pe),
                pe === "fx" && rt[0] !== "inprogress" && be.dequeue(this, pe)
            })
        },
        dequeue: function(pe) {
            return this.each(function() {
                be.dequeue(this, pe)
            })
        },
        clearQueue: function(pe) {
            return this.queue(pe || "fx", [])
        },
        promise: function(pe, me) {
            var Le, rt = 1, nr = be.Deferred(), sr = this, ur = this.length, $r = function() {
                --rt || nr.resolveWith(sr, [sr])
            };
            for (typeof pe != "string" && (me = pe,
            pe = void 0),
            pe = pe || "fx"; ur--; )
                (Le = kr.get(sr[ur], pe + "queueHooks")) && Le.empty && (rt++,
                Le.empty.add($r));
            return $r(),
            nr.promise(me)
        }
    });
    var si = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source
      , Ki = new RegExp("^(?:([+-])=|)(" + si + ")([a-z%]*)$","i")
      , Ni = ["Top", "Right", "Bottom", "Left"]
      , Hi = rr.documentElement
      , Wo = function(pe) {
        return be.contains(pe.ownerDocument, pe)
    }
      , na = {
        composed: !0
    };
    Hi.getRootNode && (Wo = function(pe) {
        return be.contains(pe.ownerDocument, pe) || pe.getRootNode(na) === pe.ownerDocument
    }
    );
    var Xo = function(pe, me) {
        return (pe = me || pe).style.display === "none" || pe.style.display === "" && Wo(pe) && be.css(pe, "display") === "none"
    };
    function Ls(pe, me, Le, rt) {
        var nr, sr, ur = 20, $r = rt ? function() {
            return rt.cur()
        }
        : function() {
            return be.css(pe, me, "")
        }
        , yr = $r(), Or = Le && Le[3] || (be.cssNumber[me] ? "" : "px"), Ur = pe.nodeType && (be.cssNumber[me] || Or !== "px" && +yr) && Ki.exec(be.css(pe, me));
        if (Ur && Ur[3] !== Or) {
            for (yr /= 2,
            Or = Or || Ur[3],
            Ur = +yr || 1; ur--; )
                be.style(pe, me, Ur + Or),
                (1 - sr) * (1 - (sr = $r() / yr || .5)) <= 0 && (ur = 0),
                Ur /= sr;
            Ur *= 2,
            be.style(pe, me, Ur + Or),
            Le = Le || []
        }
        return Le && (Ur = +Ur || +yr || 0,
        nr = Le[1] ? Ur + (Le[1] + 1) * Le[2] : +Le[2],
        rt && (rt.unit = Or,
        rt.start = Ur,
        rt.end = nr)),
        nr
    }
    var Ws = {};
    function ua(pe) {
        var me, Le = pe.ownerDocument, rt = pe.nodeName, nr = Ws[rt];
        return nr || (me = Le.body.appendChild(Le.createElement(rt)),
        nr = be.css(me, "display"),
        me.parentNode.removeChild(me),
        nr === "none" && (nr = "block"),
        Ws[rt] = nr,
        nr)
    }
    function Xa(pe, me) {
        for (var Le, rt, nr = [], sr = 0, ur = pe.length; sr < ur; sr++)
            (rt = pe[sr]).style && (Le = rt.style.display,
            me ? (Le === "none" && (nr[sr] = kr.get(rt, "display") || null,
            nr[sr] || (rt.style.display = "")),
            rt.style.display === "" && Xo(rt) && (nr[sr] = ua(rt))) : Le !== "none" && (nr[sr] = "none",
            kr.set(rt, "display", Le)));
        for (sr = 0; sr < ur; sr++)
            nr[sr] != null && (pe[sr].style.display = nr[sr]);
        return pe
    }
    be.fn.extend({
        show: function() {
            return Xa(this, !0)
        },
        hide: function() {
            return Xa(this)
        },
        toggle: function(pe) {
            return typeof pe == "boolean" ? pe ? this.show() : this.hide() : this.each(function() {
                Xo(this) ? be(this).show() : be(this).hide()
            })
        }
    });
    var da, fs, Ba = /^(?:checkbox|radio)$/i, No = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, ha = /^$|^module$|\/(?:java|ecma)script/i;
    da = rr.createDocumentFragment().appendChild(rr.createElement("div")),
    (fs = rr.createElement("input")).setAttribute("type", "radio"),
    fs.setAttribute("checked", "checked"),
    fs.setAttribute("name", "t"),
    da.appendChild(fs),
    Se.checkClone = da.cloneNode(!0).cloneNode(!0).lastChild.checked,
    da.innerHTML = "<textarea>x</textarea>",
    Se.noCloneChecked = !!da.cloneNode(!0).lastChild.defaultValue,
    da.innerHTML = "<option></option>",
    Se.option = !!da.lastChild;
    var Do = {
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
    };
    function _o(pe, me) {
        var Le;
        return Le = pe.getElementsByTagName !== void 0 ? pe.getElementsByTagName(me || "*") : pe.querySelectorAll !== void 0 ? pe.querySelectorAll(me || "*") : [],
        me === void 0 || me && fr(pe, me) ? be.merge([pe], Le) : Le
    }
    function gs(pe, me) {
        for (var Le = 0, rt = pe.length; Le < rt; Le++)
            kr.set(pe[Le], "globalEval", !me || kr.get(me[Le], "globalEval"))
    }
    Do.tbody = Do.tfoot = Do.colgroup = Do.caption = Do.thead,
    Do.th = Do.td,
    Se.option || (Do.optgroup = Do.option = [1, "<select multiple='multiple'>", "</select>"]);
    var ul = /<|&#?\w+;/;
    function dl(pe, me, Le, rt, nr) {
        for (var sr, ur, $r, yr, Or, Ur, Hr = me.createDocumentFragment(), Br = [], Kr = 0, ti = pe.length; Kr < ti; Kr++)
            if ((sr = pe[Kr]) || sr === 0)
                if (Ut(sr) === "object")
                    be.merge(Br, sr.nodeType ? [sr] : sr);
                else if (ul.test(sr)) {
                    for (ur = ur || Hr.appendChild(me.createElement("div")),
                    $r = (No.exec(sr) || ["", ""])[1].toLowerCase(),
                    yr = Do[$r] || Do._default,
                    ur.innerHTML = yr[1] + be.htmlPrefilter(sr) + yr[2],
                    Ur = yr[0]; Ur--; )
                        ur = ur.lastChild;
                    be.merge(Br, ur.childNodes),
                    (ur = Hr.firstChild).textContent = ""
                } else
                    Br.push(me.createTextNode(sr));
        for (Hr.textContent = "",
        Kr = 0; sr = Br[Kr++]; )
            if (rt && be.inArray(sr, rt) > -1)
                nr && nr.push(sr);
            else if (Or = Wo(sr),
            ur = _o(Hr.appendChild(sr), "script"),
            Or && gs(ur),
            Le)
                for (Ur = 0; sr = ur[Ur++]; )
                    ha.test(sr.type || "") && Le.push(sr);
        return Hr
    }
    var Za = /^([^.]*)(?:\.(.+)|)/;
    function ja() {
        return !0
    }
    function Ma() {
        return !1
    }
    function ci(pe, me, Le, rt, nr, sr) {
        var ur, $r;
        if (typeof me == "object") {
            for ($r in typeof Le != "string" && (rt = rt || Le,
            Le = void 0),
            me)
                ci(pe, $r, Le, rt, me[$r], sr);
            return pe
        }
        if (rt == null && nr == null ? (nr = Le,
        rt = Le = void 0) : nr == null && (typeof Le == "string" ? (nr = rt,
        rt = void 0) : (nr = rt,
        rt = Le,
        Le = void 0)),
        nr === !1)
            nr = Ma;
        else if (!nr)
            return pe;
        return sr === 1 && (ur = nr,
        nr = function(yr) {
            return be().off(yr),
            ur.apply(this, arguments)
        }
        ,
        nr.guid = ur.guid || (ur.guid = be.guid++)),
        pe.each(function() {
            be.event.add(this, me, nr, rt, Le)
        })
    }
    function _i(pe, me, Le) {
        Le ? (kr.set(pe, me, !1),
        be.event.add(pe, me, {
            namespace: !1,
            handler: function(rt) {
                var nr, sr = kr.get(this, me);
                if (1 & rt.isTrigger && this[me]) {
                    if (sr)
                        (be.event.special[me] || {}).delegateType && rt.stopPropagation();
                    else if (sr = le.call(arguments),
                    kr.set(this, me, sr),
                    this[me](),
                    nr = kr.get(this, me),
                    kr.set(this, me, !1),
                    sr !== nr)
                        return rt.stopImmediatePropagation(),
                        rt.preventDefault(),
                        nr
                } else
                    sr && (kr.set(this, me, be.event.trigger(sr[0], sr.slice(1), this)),
                    rt.stopPropagation(),
                    rt.isImmediatePropagationStopped = ja)
            }
        })) : kr.get(pe, me) === void 0 && be.event.add(pe, me, ja)
    }
    be.event = {
        global: {},
        add: function(pe, me, Le, rt, nr) {
            var sr, ur, $r, yr, Or, Ur, Hr, Br, Kr, ti, wi, li = kr.get(pe);
            if (Er(pe))
                for (Le.handler && (Le = (sr = Le).handler,
                nr = sr.selector),
                nr && be.find.matchesSelector(Hi, nr),
                Le.guid || (Le.guid = be.guid++),
                (yr = li.events) || (yr = li.events = Object.create(null)),
                (ur = li.handle) || (ur = li.handle = function(Qi) {
                    return be !== void 0 && be.event.triggered !== Qi.type ? be.event.dispatch.apply(pe, arguments) : void 0
                }
                ),
                Or = (me = (me || "").match(Yn) || [""]).length; Or--; )
                    Kr = wi = ($r = Za.exec(me[Or]) || [])[1],
                    ti = ($r[2] || "").split(".").sort(),
                    Kr && (Hr = be.event.special[Kr] || {},
                    Kr = (nr ? Hr.delegateType : Hr.bindType) || Kr,
                    Hr = be.event.special[Kr] || {},
                    Ur = be.extend({
                        type: Kr,
                        origType: wi,
                        data: rt,
                        handler: Le,
                        guid: Le.guid,
                        selector: nr,
                        needsContext: nr && be.expr.match.needsContext.test(nr),
                        namespace: ti.join(".")
                    }, sr),
                    (Br = yr[Kr]) || ((Br = yr[Kr] = []).delegateCount = 0,
                    Hr.setup && Hr.setup.call(pe, rt, ti, ur) !== !1 || pe.addEventListener && pe.addEventListener(Kr, ur)),
                    Hr.add && (Hr.add.call(pe, Ur),
                    Ur.handler.guid || (Ur.handler.guid = Le.guid)),
                    nr ? Br.splice(Br.delegateCount++, 0, Ur) : Br.push(Ur),
                    be.event.global[Kr] = !0)
        },
        remove: function(pe, me, Le, rt, nr) {
            var sr, ur, $r, yr, Or, Ur, Hr, Br, Kr, ti, wi, li = kr.hasData(pe) && kr.get(pe);
            if (li && (yr = li.events)) {
                for (Or = (me = (me || "").match(Yn) || [""]).length; Or--; )
                    if (Kr = wi = ($r = Za.exec(me[Or]) || [])[1],
                    ti = ($r[2] || "").split(".").sort(),
                    Kr) {
                        for (Hr = be.event.special[Kr] || {},
                        Br = yr[Kr = (rt ? Hr.delegateType : Hr.bindType) || Kr] || [],
                        $r = $r[2] && new RegExp("(^|\\.)" + ti.join("\\.(?:.*\\.|)") + "(\\.|$)"),
                        ur = sr = Br.length; sr--; )
                            Ur = Br[sr],
                            !nr && wi !== Ur.origType || Le && Le.guid !== Ur.guid || $r && !$r.test(Ur.namespace) || rt && rt !== Ur.selector && (rt !== "**" || !Ur.selector) || (Br.splice(sr, 1),
                            Ur.selector && Br.delegateCount--,
                            Hr.remove && Hr.remove.call(pe, Ur));
                        ur && !Br.length && (Hr.teardown && Hr.teardown.call(pe, ti, li.handle) !== !1 || be.removeEvent(pe, Kr, li.handle),
                        delete yr[Kr])
                    } else
                        for (Kr in yr)
                            be.event.remove(pe, Kr + me[Or], Le, rt, !0);
                be.isEmptyObject(yr) && kr.remove(pe, "handle events")
            }
        },
        dispatch: function(pe) {
            var me, Le, rt, nr, sr, ur, $r = new Array(arguments.length), yr = be.event.fix(pe), Or = (kr.get(this, "events") || Object.create(null))[yr.type] || [], Ur = be.event.special[yr.type] || {};
            for ($r[0] = yr,
            me = 1; me < arguments.length; me++)
                $r[me] = arguments[me];
            if (yr.delegateTarget = this,
            !Ur.preDispatch || Ur.preDispatch.call(this, yr) !== !1) {
                for (ur = be.event.handlers.call(this, yr, Or),
                me = 0; (nr = ur[me++]) && !yr.isPropagationStopped(); )
                    for (yr.currentTarget = nr.elem,
                    Le = 0; (sr = nr.handlers[Le++]) && !yr.isImmediatePropagationStopped(); )
                        yr.rnamespace && sr.namespace !== !1 && !yr.rnamespace.test(sr.namespace) || (yr.handleObj = sr,
                        yr.data = sr.data,
                        (rt = ((be.event.special[sr.origType] || {}).handle || sr.handler).apply(nr.elem, $r)) !== void 0 && (yr.result = rt) === !1 && (yr.preventDefault(),
                        yr.stopPropagation()));
                return Ur.postDispatch && Ur.postDispatch.call(this, yr),
                yr.result
            }
        },
        handlers: function(pe, me) {
            var Le, rt, nr, sr, ur, $r = [], yr = me.delegateCount, Or = pe.target;
            if (yr && Or.nodeType && !(pe.type === "click" && pe.button >= 1)) {
                for (; Or !== this; Or = Or.parentNode || this)
                    if (Or.nodeType === 1 && (pe.type !== "click" || Or.disabled !== !0)) {
                        for (sr = [],
                        ur = {},
                        Le = 0; Le < yr; Le++)
                            ur[nr = (rt = me[Le]).selector + " "] === void 0 && (ur[nr] = rt.needsContext ? be(nr, this).index(Or) > -1 : be.find(nr, this, null, [Or]).length),
                            ur[nr] && sr.push(rt);
                        sr.length && $r.push({
                            elem: Or,
                            handlers: sr
                        })
                    }
            }
            return Or = this,
            yr < me.length && $r.push({
                elem: Or,
                handlers: me.slice(yr)
            }),
            $r
        },
        addProp: function(pe, me) {
            Object.defineProperty(be.Event.prototype, pe, {
                enumerable: !0,
                configurable: !0,
                get: Ne(me) ? function() {
                    if (this.originalEvent)
                        return me(this.originalEvent)
                }
                : function() {
                    if (this.originalEvent)
                        return this.originalEvent[pe]
                }
                ,
                set: function(Le) {
                    Object.defineProperty(this, pe, {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: Le
                    })
                }
            })
        },
        fix: function(pe) {
            return pe[be.expando] ? pe : new be.Event(pe)
        },
        special: {
            load: {
                noBubble: !0
            },
            click: {
                setup: function(pe) {
                    var me = this || pe;
                    return Ba.test(me.type) && me.click && fr(me, "input") && _i(me, "click", !0),
                    !1
                },
                trigger: function(pe) {
                    var me = this || pe;
                    return Ba.test(me.type) && me.click && fr(me, "input") && _i(me, "click"),
                    !0
                },
                _default: function(pe) {
                    var me = pe.target;
                    return Ba.test(me.type) && me.click && fr(me, "input") && kr.get(me, "click") || fr(me, "a")
                }
            },
            beforeunload: {
                postDispatch: function(pe) {
                    pe.result !== void 0 && pe.originalEvent && (pe.originalEvent.returnValue = pe.result)
                }
            }
        }
    },
    be.removeEvent = function(pe, me, Le) {
        pe.removeEventListener && pe.removeEventListener(me, Le)
    }
    ,
    be.Event = function(pe, me) {
        if (!(this instanceof be.Event))
            return new be.Event(pe,me);
        pe && pe.type ? (this.originalEvent = pe,
        this.type = pe.type,
        this.isDefaultPrevented = pe.defaultPrevented || pe.defaultPrevented === void 0 && pe.returnValue === !1 ? ja : Ma,
        this.target = pe.target && pe.target.nodeType === 3 ? pe.target.parentNode : pe.target,
        this.currentTarget = pe.currentTarget,
        this.relatedTarget = pe.relatedTarget) : this.type = pe,
        me && be.extend(this, me),
        this.timeStamp = pe && pe.timeStamp || Date.now(),
        this[be.expando] = !0
    }
    ,
    be.Event.prototype = {
        constructor: be.Event,
        isDefaultPrevented: Ma,
        isPropagationStopped: Ma,
        isImmediatePropagationStopped: Ma,
        isSimulated: !1,
        preventDefault: function() {
            var pe = this.originalEvent;
            this.isDefaultPrevented = ja,
            pe && !this.isSimulated && pe.preventDefault()
        },
        stopPropagation: function() {
            var pe = this.originalEvent;
            this.isPropagationStopped = ja,
            pe && !this.isSimulated && pe.stopPropagation()
        },
        stopImmediatePropagation: function() {
            var pe = this.originalEvent;
            this.isImmediatePropagationStopped = ja,
            pe && !this.isSimulated && pe.stopImmediatePropagation(),
            this.stopPropagation()
        }
    },
    be.each({
        altKey: !0,
        bubbles: !0,
        cancelable: !0,
        changedTouches: !0,
        ctrlKey: !0,
        detail: !0,
        eventPhase: !0,
        metaKey: !0,
        pageX: !0,
        pageY: !0,
        shiftKey: !0,
        view: !0,
        char: !0,
        code: !0,
        charCode: !0,
        key: !0,
        keyCode: !0,
        button: !0,
        buttons: !0,
        clientX: !0,
        clientY: !0,
        offsetX: !0,
        offsetY: !0,
        pointerId: !0,
        pointerType: !0,
        screenX: !0,
        screenY: !0,
        targetTouches: !0,
        toElement: !0,
        touches: !0,
        which: !0
    }, be.event.addProp),
    be.each({
        focus: "focusin",
        blur: "focusout"
    }, function(pe, me) {
        function Le(rt) {
            if (rr.documentMode) {
                var nr = kr.get(this, "handle")
                  , sr = be.event.fix(rt);
                sr.type = rt.type === "focusin" ? "focus" : "blur",
                sr.isSimulated = !0,
                nr(rt),
                sr.target === sr.currentTarget && nr(sr)
            } else
                be.event.simulate(me, rt.target, be.event.fix(rt))
        }
        be.event.special[pe] = {
            setup: function() {
                var rt;
                if (_i(this, pe, !0),
                !rr.documentMode)
                    return !1;
                (rt = kr.get(this, me)) || this.addEventListener(me, Le),
                kr.set(this, me, (rt || 0) + 1)
            },
            trigger: function() {
                return _i(this, pe),
                !0
            },
            teardown: function() {
                var rt;
                if (!rr.documentMode)
                    return !1;
                (rt = kr.get(this, me) - 1) ? kr.set(this, me, rt) : (this.removeEventListener(me, Le),
                kr.remove(this, me))
            },
            _default: function(rt) {
                return kr.get(rt.target, pe)
            },
            delegateType: me
        },
        be.event.special[me] = {
            setup: function() {
                var rt = this.ownerDocument || this.document || this
                  , nr = rr.documentMode ? this : rt
                  , sr = kr.get(nr, me);
                sr || (rr.documentMode ? this.addEventListener(me, Le) : rt.addEventListener(pe, Le, !0)),
                kr.set(nr, me, (sr || 0) + 1)
            },
            teardown: function() {
                var rt = this.ownerDocument || this.document || this
                  , nr = rr.documentMode ? this : rt
                  , sr = kr.get(nr, me) - 1;
                sr ? kr.set(nr, me, sr) : (rr.documentMode ? this.removeEventListener(me, Le) : rt.removeEventListener(pe, Le, !0),
                kr.remove(nr, me))
            }
        }
    }),
    be.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(pe, me) {
        be.event.special[pe] = {
            delegateType: me,
            bindType: me,
            handle: function(Le) {
                var rt, nr = Le.relatedTarget, sr = Le.handleObj;
                return nr && (nr === this || be.contains(this, nr)) || (Le.type = sr.origType,
                rt = sr.handler.apply(this, arguments),
                Le.type = me),
                rt
            }
        }
    }),
    be.fn.extend({
        on: function(pe, me, Le, rt) {
            return ci(this, pe, me, Le, rt)
        },
        one: function(pe, me, Le, rt) {
            return ci(this, pe, me, Le, rt, 1)
        },
        off: function(pe, me, Le) {
            var rt, nr;
            if (pe && pe.preventDefault && pe.handleObj)
                return rt = pe.handleObj,
                be(pe.delegateTarget).off(rt.namespace ? rt.origType + "." + rt.namespace : rt.origType, rt.selector, rt.handler),
                this;
            if (typeof pe == "object") {
                for (nr in pe)
                    this.off(nr, me, pe[nr]);
                return this
            }
            return me !== !1 && typeof me != "function" || (Le = me,
            me = void 0),
            Le === !1 && (Le = Ma),
            this.each(function() {
                be.event.remove(this, pe, Le, me)
            })
        }
    });
    var hn = /<script|<style|<link/i
      , Pi = /checked\s*(?:[^=]|=\s*.checked.)/i
      , La = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
    function Ds(pe, me) {
        return fr(pe, "table") && fr(me.nodeType !== 11 ? me : me.firstChild, "tr") && be(pe).children("tbody")[0] || pe
    }
    function hl(pe) {
        return pe.type = (pe.getAttribute("type") !== null) + "/" + pe.type,
        pe
    }
    function xc(pe) {
        return (pe.type || "").slice(0, 5) === "true/" ? pe.type = pe.type.slice(5) : pe.removeAttribute("type"),
        pe
    }
    function ms(pe, me) {
        var Le, rt, nr, sr, ur, $r;
        if (me.nodeType === 1) {
            if (kr.hasData(pe) && ($r = kr.get(pe).events))
                for (nr in kr.remove(me, "handle events"),
                $r)
                    for (Le = 0,
                    rt = $r[nr].length; Le < rt; Le++)
                        be.event.add(me, nr, $r[nr][Le]);
            _n.hasData(pe) && (sr = _n.access(pe),
            ur = be.extend({}, sr),
            _n.set(me, ur))
        }
    }
    function Us(pe, me) {
        var Le = me.nodeName.toLowerCase();
        Le === "input" && Ba.test(pe.type) ? me.checked = pe.checked : Le !== "input" && Le !== "textarea" || (me.defaultValue = pe.defaultValue)
    }
    function Ka(pe, me, Le, rt) {
        me = ue(me);
        var nr, sr, ur, $r, yr, Or, Ur = 0, Hr = pe.length, Br = Hr - 1, Kr = me[0], ti = Ne(Kr);
        if (ti || Hr > 1 && typeof Kr == "string" && !Se.checkClone && Pi.test(Kr))
            return pe.each(function(wi) {
                var li = pe.eq(wi);
                ti && (me[0] = Kr.call(this, wi, li.html())),
                Ka(li, me, Le, rt)
            });
        if (Hr && (sr = (nr = dl(me, pe[0].ownerDocument, !1, pe, rt)).firstChild,
        nr.childNodes.length === 1 && (nr = sr),
        sr || rt)) {
            for ($r = (ur = be.map(_o(nr, "script"), hl)).length; Ur < Hr; Ur++)
                yr = nr,
                Ur !== Br && (yr = be.clone(yr, !0, !0),
                $r && be.merge(ur, _o(yr, "script"))),
                Le.call(pe[Ur], yr, Ur);
            if ($r)
                for (Or = ur[ur.length - 1].ownerDocument,
                be.map(ur, xc),
                Ur = 0; Ur < $r; Ur++)
                    yr = ur[Ur],
                    ha.test(yr.type || "") && !kr.access(yr, "globalEval") && be.contains(Or, yr) && (yr.src && (yr.type || "").toLowerCase() !== "module" ? be._evalUrl && !yr.noModule && be._evalUrl(yr.src, {
                        nonce: yr.nonce || yr.getAttribute("nonce")
                    }, Or) : we(yr.textContent.replace(La, ""), yr, Or))
        }
        return pe
    }
    function pl(pe, me, Le) {
        for (var rt, nr = me ? be.filter(me, pe) : pe, sr = 0; (rt = nr[sr]) != null; sr++)
            Le || rt.nodeType !== 1 || be.cleanData(_o(rt)),
            rt.parentNode && (Le && Wo(rt) && gs(_o(rt, "script")),
            rt.parentNode.removeChild(rt));
        return pe
    }
    be.extend({
        htmlPrefilter: function(pe) {
            return pe
        },
        clone: function(pe, me, Le) {
            var rt, nr, sr, ur, $r = pe.cloneNode(!0), yr = Wo(pe);
            if (!(Se.noCloneChecked || pe.nodeType !== 1 && pe.nodeType !== 11 || be.isXMLDoc(pe)))
                for (ur = _o($r),
                rt = 0,
                nr = (sr = _o(pe)).length; rt < nr; rt++)
                    Us(sr[rt], ur[rt]);
            if (me)
                if (Le)
                    for (sr = sr || _o(pe),
                    ur = ur || _o($r),
                    rt = 0,
                    nr = sr.length; rt < nr; rt++)
                        ms(sr[rt], ur[rt]);
                else
                    ms(pe, $r);
            return (ur = _o($r, "script")).length > 0 && gs(ur, !yr && _o(pe, "script")),
            $r
        },
        cleanData: function(pe) {
            for (var me, Le, rt, nr = be.event.special, sr = 0; (Le = pe[sr]) !== void 0; sr++)
                if (Er(Le)) {
                    if (me = Le[kr.expando]) {
                        if (me.events)
                            for (rt in me.events)
                                nr[rt] ? be.event.remove(Le, rt) : be.removeEvent(Le, rt, me.handle);
                        Le[kr.expando] = void 0
                    }
                    Le[_n.expando] && (Le[_n.expando] = void 0)
                }
        }
    }),
    be.fn.extend({
        detach: function(pe) {
            return pl(this, pe, !0)
        },
        remove: function(pe) {
            return pl(this, pe)
        },
        text: function(pe) {
            return vn(this, function(me) {
                return me === void 0 ? be.text(this) : this.empty().each(function() {
                    this.nodeType !== 1 && this.nodeType !== 11 && this.nodeType !== 9 || (this.textContent = me)
                })
            }, null, pe, arguments.length)
        },
        append: function() {
            return Ka(this, arguments, function(pe) {
                this.nodeType !== 1 && this.nodeType !== 11 && this.nodeType !== 9 || Ds(this, pe).appendChild(pe)
            })
        },
        prepend: function() {
            return Ka(this, arguments, function(pe) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var me = Ds(this, pe);
                    me.insertBefore(pe, me.firstChild)
                }
            })
        },
        before: function() {
            return Ka(this, arguments, function(pe) {
                this.parentNode && this.parentNode.insertBefore(pe, this)
            })
        },
        after: function() {
            return Ka(this, arguments, function(pe) {
                this.parentNode && this.parentNode.insertBefore(pe, this.nextSibling)
            })
        },
        empty: function() {
            for (var pe, me = 0; (pe = this[me]) != null; me++)
                pe.nodeType === 1 && (be.cleanData(_o(pe, !1)),
                pe.textContent = "");
            return this
        },
        clone: function(pe, me) {
            return pe = pe != null && pe,
            me = me ?? pe,
            this.map(function() {
                return be.clone(this, pe, me)
            })
        },
        html: function(pe) {
            return vn(this, function(me) {
                var Le = this[0] || {}
                  , rt = 0
                  , nr = this.length;
                if (me === void 0 && Le.nodeType === 1)
                    return Le.innerHTML;
                if (typeof me == "string" && !hn.test(me) && !Do[(No.exec(me) || ["", ""])[1].toLowerCase()]) {
                    me = be.htmlPrefilter(me);
                    try {
                        for (; rt < nr; rt++)
                            (Le = this[rt] || {}).nodeType === 1 && (be.cleanData(_o(Le, !1)),
                            Le.innerHTML = me);
                        Le = 0
                    } catch {}
                }
                Le && this.empty().append(me)
            }, null, pe, arguments.length)
        },
        replaceWith: function() {
            var pe = [];
            return Ka(this, arguments, function(me) {
                var Le = this.parentNode;
                be.inArray(this, pe) < 0 && (be.cleanData(_o(this)),
                Le && Le.replaceChild(me, this))
            }, pe)
        }
    }),
    be.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(pe, me) {
        be.fn[pe] = function(Le) {
            for (var rt, nr = [], sr = be(Le), ur = sr.length - 1, $r = 0; $r <= ur; $r++)
                rt = $r === ur ? this : this.clone(!0),
                be(sr[$r])[me](rt),
                de.apply(nr, rt.get());
            return this.pushStack(nr)
        }
    });
    var bs = new RegExp("^(" + si + ")(?!px)[a-z%]+$","i")
      , vs = /^--/
      , fi = function(pe) {
        var me = pe.ownerDocument.defaultView;
        return me && me.opener || (me = W),
        me.getComputedStyle(pe)
    }
      , ia = function(pe, me, Le) {
        var rt, nr, sr = {};
        for (nr in me)
            sr[nr] = pe.style[nr],
            pe.style[nr] = me[nr];
        for (nr in rt = Le.call(pe),
        me)
            pe.style[nr] = sr[nr];
        return rt
    }
      , fl = new RegExp(Ni.join("|"),"i");
    function Uo(pe, me, Le) {
        var rt, nr, sr, ur, $r = vs.test(me), yr = pe.style;
        return (Le = Le || fi(pe)) && (ur = Le.getPropertyValue(me) || Le[me],
        $r && ur && (ur = ur.replace(xr, "$1") || void 0),
        ur !== "" || Wo(pe) || (ur = be.style(pe, me)),
        !Se.pixelBoxStyles() && bs.test(ur) && fl.test(me) && (rt = yr.width,
        nr = yr.minWidth,
        sr = yr.maxWidth,
        yr.minWidth = yr.maxWidth = yr.width = ur,
        ur = Le.width,
        yr.width = rt,
        yr.minWidth = nr,
        yr.maxWidth = sr)),
        ur !== void 0 ? ur + "" : ur
    }
    function Ri(pe, me) {
        return {
            get: function() {
                if (!pe())
                    return (this.get = me).apply(this, arguments);
                delete this.get
            }
        }
    }
    (function() {
        function pe() {
            if (Or) {
                yr.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",
                Or.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",
                Hi.appendChild(yr).appendChild(Or);
                var Ur = W.getComputedStyle(Or);
                Le = Ur.top !== "1%",
                $r = me(Ur.marginLeft) === 12,
                Or.style.right = "60%",
                sr = me(Ur.right) === 36,
                rt = me(Ur.width) === 36,
                Or.style.position = "absolute",
                nr = me(Or.offsetWidth / 3) === 12,
                Hi.removeChild(yr),
                Or = null
            }
        }
        function me(Ur) {
            return Math.round(parseFloat(Ur))
        }
        var Le, rt, nr, sr, ur, $r, yr = rr.createElement("div"), Or = rr.createElement("div");
        Or.style && (Or.style.backgroundClip = "content-box",
        Or.cloneNode(!0).style.backgroundClip = "",
        Se.clearCloneStyle = Or.style.backgroundClip === "content-box",
        be.extend(Se, {
            boxSizingReliable: function() {
                return pe(),
                rt
            },
            pixelBoxStyles: function() {
                return pe(),
                sr
            },
            pixelPosition: function() {
                return pe(),
                Le
            },
            reliableMarginLeft: function() {
                return pe(),
                $r
            },
            scrollboxSize: function() {
                return pe(),
                nr
            },
            reliableTrDimensions: function() {
                var Ur, Hr, Br, Kr;
                return ur == null && (Ur = rr.createElement("table"),
                Hr = rr.createElement("tr"),
                Br = rr.createElement("div"),
                Ur.style.cssText = "position:absolute;left:-11111px;border-collapse:separate",
                Hr.style.cssText = "box-sizing:content-box;border:1px solid",
                Hr.style.height = "1px",
                Br.style.height = "9px",
                Br.style.display = "block",
                Hi.appendChild(Ur).appendChild(Hr).appendChild(Br),
                Kr = W.getComputedStyle(Hr),
                ur = parseInt(Kr.height, 10) + parseInt(Kr.borderTopWidth, 10) + parseInt(Kr.borderBottomWidth, 10) === Hr.offsetHeight,
                Hi.removeChild(Ur)),
                ur
            }
        }))
    }
    )();
    var Ja = ["Webkit", "Moz", "ms"]
      , Qa = rr.createElement("div").style
      , ws = {};
    function pa(pe) {
        var me = be.cssProps[pe] || ws[pe];
        return me || (pe in Qa ? pe : ws[pe] = function(Le) {
            for (var rt = Le[0].toUpperCase() + Le.slice(1), nr = Ja.length; nr--; )
                if ((Le = Ja[nr] + rt)in Qa)
                    return Le
        }(pe) || pe)
    }
    var gl = /^(none|table(?!-c[ea]).+)/
      , jl = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }
      , ki = {
        letterSpacing: "0",
        fontWeight: "400"
    };
    function mo(pe, me, Le) {
        var rt = Ki.exec(me);
        return rt ? Math.max(0, rt[2] - (Le || 0)) + (rt[3] || "px") : me
    }
    function oa(pe, me, Le, rt, nr, sr) {
        var ur = me === "width" ? 1 : 0
          , $r = 0
          , yr = 0
          , Or = 0;
        if (Le === (rt ? "border" : "content"))
            return 0;
        for (; ur < 4; ur += 2)
            Le === "margin" && (Or += be.css(pe, Le + Ni[ur], !0, nr)),
            rt ? (Le === "content" && (yr -= be.css(pe, "padding" + Ni[ur], !0, nr)),
            Le !== "margin" && (yr -= be.css(pe, "border" + Ni[ur] + "Width", !0, nr))) : (yr += be.css(pe, "padding" + Ni[ur], !0, nr),
            Le !== "padding" ? yr += be.css(pe, "border" + Ni[ur] + "Width", !0, nr) : $r += be.css(pe, "border" + Ni[ur] + "Width", !0, nr));
        return !rt && sr >= 0 && (yr += Math.max(0, Math.ceil(pe["offset" + me[0].toUpperCase() + me.slice(1)] - sr - yr - $r - .5)) || 0),
        yr + Or
    }
    function Hs(pe, me, Le) {
        var rt = fi(pe)
          , nr = (!Se.boxSizingReliable() || Le) && be.css(pe, "boxSizing", !1, rt) === "border-box"
          , sr = nr
          , ur = Uo(pe, me, rt)
          , $r = "offset" + me[0].toUpperCase() + me.slice(1);
        if (bs.test(ur)) {
            if (!Le)
                return ur;
            ur = "auto"
        }
        return (!Se.boxSizingReliable() && nr || !Se.reliableTrDimensions() && fr(pe, "tr") || ur === "auto" || !parseFloat(ur) && be.css(pe, "display", !1, rt) === "inline") && pe.getClientRects().length && (nr = be.css(pe, "boxSizing", !1, rt) === "border-box",
        (sr = $r in pe) && (ur = pe[$r])),
        (ur = parseFloat(ur) || 0) + oa(pe, me, Le || (nr ? "border" : "content"), sr, rt, ur) + "px"
    }
    function Eo(pe, me, Le, rt, nr) {
        return new Eo.prototype.init(pe,me,Le,rt,nr)
    }
    be.extend({
        cssHooks: {
            opacity: {
                get: function(pe, me) {
                    if (me) {
                        var Le = Uo(pe, "opacity");
                        return Le === "" ? "1" : Le
                    }
                }
            }
        },
        cssNumber: {
            animationIterationCount: !0,
            aspectRatio: !0,
            borderImageSlice: !0,
            columnCount: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            gridArea: !0,
            gridColumn: !0,
            gridColumnEnd: !0,
            gridColumnStart: !0,
            gridRow: !0,
            gridRowEnd: !0,
            gridRowStart: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            scale: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0,
            fillOpacity: !0,
            floodOpacity: !0,
            stopOpacity: !0,
            strokeMiterlimit: !0,
            strokeOpacity: !0
        },
        cssProps: {},
        style: function(pe, me, Le, rt) {
            if (pe && pe.nodeType !== 3 && pe.nodeType !== 8 && pe.style) {
                var nr, sr, ur, $r = vr(me), yr = vs.test(me), Or = pe.style;
                if (yr || (me = pa($r)),
                ur = be.cssHooks[me] || be.cssHooks[$r],
                Le === void 0)
                    return ur && "get"in ur && (nr = ur.get(pe, !1, rt)) !== void 0 ? nr : Or[me];
                (sr = typeof Le) == "string" && (nr = Ki.exec(Le)) && nr[1] && (Le = Ls(pe, me, nr),
                sr = "number"),
                Le != null && Le == Le && (sr !== "number" || yr || (Le += nr && nr[3] || (be.cssNumber[$r] ? "" : "px")),
                Se.clearCloneStyle || Le !== "" || me.indexOf("background") !== 0 || (Or[me] = "inherit"),
                ur && "set"in ur && (Le = ur.set(pe, Le, rt)) === void 0 || (yr ? Or.setProperty(me, Le) : Or[me] = Le))
            }
        },
        css: function(pe, me, Le, rt) {
            var nr, sr, ur, $r = vr(me);
            return vs.test(me) || (me = pa($r)),
            (ur = be.cssHooks[me] || be.cssHooks[$r]) && "get"in ur && (nr = ur.get(pe, !0, Le)),
            nr === void 0 && (nr = Uo(pe, me, rt)),
            nr === "normal" && me in ki && (nr = ki[me]),
            Le === "" || Le ? (sr = parseFloat(nr),
            Le === !0 || isFinite(sr) ? sr || 0 : nr) : nr
        }
    }),
    be.each(["height", "width"], function(pe, me) {
        be.cssHooks[me] = {
            get: function(Le, rt, nr) {
                if (rt)
                    return !gl.test(be.css(Le, "display")) || Le.getClientRects().length && Le.getBoundingClientRect().width ? Hs(Le, me, nr) : ia(Le, jl, function() {
                        return Hs(Le, me, nr)
                    })
            },
            set: function(Le, rt, nr) {
                var sr, ur = fi(Le), $r = !Se.scrollboxSize() && ur.position === "absolute", yr = ($r || nr) && be.css(Le, "boxSizing", !1, ur) === "border-box", Or = nr ? oa(Le, me, nr, yr, ur) : 0;
                return yr && $r && (Or -= Math.ceil(Le["offset" + me[0].toUpperCase() + me.slice(1)] - parseFloat(ur[me]) - oa(Le, me, "border", !1, ur) - .5)),
                Or && (sr = Ki.exec(rt)) && (sr[3] || "px") !== "px" && (Le.style[me] = rt,
                rt = be.css(Le, me)),
                mo(0, rt, Or)
            }
        }
    }),
    be.cssHooks.marginLeft = Ri(Se.reliableMarginLeft, function(pe, me) {
        if (me)
            return (parseFloat(Uo(pe, "marginLeft")) || pe.getBoundingClientRect().left - ia(pe, {
                marginLeft: 0
            }, function() {
                return pe.getBoundingClientRect().left
            })) + "px"
    }),
    be.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(pe, me) {
        be.cssHooks[pe + me] = {
            expand: function(Le) {
                for (var rt = 0, nr = {}, sr = typeof Le == "string" ? Le.split(" ") : [Le]; rt < 4; rt++)
                    nr[pe + Ni[rt] + me] = sr[rt] || sr[rt - 2] || sr[0];
                return nr
            }
        },
        pe !== "margin" && (be.cssHooks[pe + me].set = mo)
    }),
    be.fn.extend({
        css: function(pe, me) {
            return vn(this, function(Le, rt, nr) {
                var sr, ur, $r = {}, yr = 0;
                if (Array.isArray(rt)) {
                    for (sr = fi(Le),
                    ur = rt.length; yr < ur; yr++)
                        $r[rt[yr]] = be.css(Le, rt[yr], !1, sr);
                    return $r
                }
                return nr !== void 0 ? be.style(Le, rt, nr) : be.css(Le, rt)
            }, pe, me, arguments.length > 1)
        }
    }),
    be.Tween = Eo,
    Eo.prototype = {
        constructor: Eo,
        init: function(pe, me, Le, rt, nr, sr) {
            this.elem = pe,
            this.prop = Le,
            this.easing = nr || be.easing._default,
            this.options = me,
            this.start = this.now = this.cur(),
            this.end = rt,
            this.unit = sr || (be.cssNumber[Le] ? "" : "px")
        },
        cur: function() {
            var pe = Eo.propHooks[this.prop];
            return pe && pe.get ? pe.get(this) : Eo.propHooks._default.get(this)
        },
        run: function(pe) {
            var me, Le = Eo.propHooks[this.prop];
            return this.options.duration ? this.pos = me = be.easing[this.easing](pe, this.options.duration * pe, 0, 1, this.options.duration) : this.pos = me = pe,
            this.now = (this.end - this.start) * me + this.start,
            this.options.step && this.options.step.call(this.elem, this.now, this),
            Le && Le.set ? Le.set(this) : Eo.propHooks._default.set(this),
            this
        }
    },
    Eo.prototype.init.prototype = Eo.prototype,
    Eo.propHooks = {
        _default: {
            get: function(pe) {
                var me;
                return pe.elem.nodeType !== 1 || pe.elem[pe.prop] != null && pe.elem.style[pe.prop] == null ? pe.elem[pe.prop] : (me = be.css(pe.elem, pe.prop, "")) && me !== "auto" ? me : 0
            },
            set: function(pe) {
                be.fx.step[pe.prop] ? be.fx.step[pe.prop](pe) : pe.elem.nodeType !== 1 || !be.cssHooks[pe.prop] && pe.elem.style[pa(pe.prop)] == null ? pe.elem[pe.prop] = pe.now : be.style(pe.elem, pe.prop, pe.now + pe.unit)
            }
        }
    },
    Eo.propHooks.scrollTop = Eo.propHooks.scrollLeft = {
        set: function(pe) {
            pe.elem.nodeType && pe.elem.parentNode && (pe.elem[pe.prop] = pe.now)
        }
    },
    be.easing = {
        linear: function(pe) {
            return pe
        },
        swing: function(pe) {
            return .5 - Math.cos(pe * Math.PI) / 2
        },
        _default: "swing"
    },
    be.fx = Eo.prototype.init,
    be.fx.step = {};
    var Zo, Ko, Fs = /^(?:toggle|show|hide)$/, fa = /queueHooks$/;
    function bo() {
        Ko && (rr.hidden === !1 && W.requestAnimationFrame ? W.requestAnimationFrame(bo) : W.setTimeout(bo, be.fx.interval),
        be.fx.tick())
    }
    function ml() {
        return W.setTimeout(function() {
            Zo = void 0
        }),
        Zo = Date.now()
    }
    function ys(pe, me) {
        var Le, rt = 0, nr = {
            height: pe
        };
        for (me = me ? 1 : 0; rt < 4; rt += 2 - me)
            nr["margin" + (Le = Ni[rt])] = nr["padding" + Le] = pe;
        return me && (nr.opacity = nr.width = pe),
        nr
    }
    function bl(pe, me, Le) {
        for (var rt, nr = (To.tweeners[me] || []).concat(To.tweeners["*"]), sr = 0, ur = nr.length; sr < ur; sr++)
            if (rt = nr[sr].call(Le, me, pe))
                return rt
    }
    function To(pe, me, Le) {
        var rt, nr, sr = 0, ur = To.prefilters.length, $r = be.Deferred().always(function() {
            delete yr.elem
        }), yr = function() {
            if (nr)
                return !1;
            for (var Hr = Zo || ml(), Br = Math.max(0, Or.startTime + Or.duration - Hr), Kr = 1 - (Br / Or.duration || 0), ti = 0, wi = Or.tweens.length; ti < wi; ti++)
                Or.tweens[ti].run(Kr);
            return $r.notifyWith(pe, [Or, Kr, Br]),
            Kr < 1 && wi ? Br : (wi || $r.notifyWith(pe, [Or, 1, 0]),
            $r.resolveWith(pe, [Or]),
            !1)
        }, Or = $r.promise({
            elem: pe,
            props: be.extend({}, me),
            opts: be.extend(!0, {
                specialEasing: {},
                easing: be.easing._default
            }, Le),
            originalProperties: me,
            originalOptions: Le,
            startTime: Zo || ml(),
            duration: Le.duration,
            tweens: [],
            createTween: function(Hr, Br) {
                var Kr = be.Tween(pe, Or.opts, Hr, Br, Or.opts.specialEasing[Hr] || Or.opts.easing);
                return Or.tweens.push(Kr),
                Kr
            },
            stop: function(Hr) {
                var Br = 0
                  , Kr = Hr ? Or.tweens.length : 0;
                if (nr)
                    return this;
                for (nr = !0; Br < Kr; Br++)
                    Or.tweens[Br].run(1);
                return Hr ? ($r.notifyWith(pe, [Or, 1, 0]),
                $r.resolveWith(pe, [Or, Hr])) : $r.rejectWith(pe, [Or, Hr]),
                this
            }
        }), Ur = Or.props;
        for (function(Hr, Br) {
            var Kr, ti, wi, li, Qi;
            for (Kr in Hr)
                if (wi = Br[ti = vr(Kr)],
                li = Hr[Kr],
                Array.isArray(li) && (wi = li[1],
                li = Hr[Kr] = li[0]),
                Kr !== ti && (Hr[ti] = li,
                delete Hr[Kr]),
                (Qi = be.cssHooks[ti]) && "expand"in Qi)
                    for (Kr in li = Qi.expand(li),
                    delete Hr[ti],
                    li)
                        Kr in Hr || (Hr[Kr] = li[Kr],
                        Br[Kr] = wi);
                else
                    Br[ti] = wi
        }(Ur, Or.opts.specialEasing); sr < ur; sr++)
            if (rt = To.prefilters[sr].call(Or, pe, Ur, Or.opts))
                return Ne(rt.stop) && (be._queueHooks(Or.elem, Or.opts.queue).stop = rt.stop.bind(rt)),
                rt;
        return be.map(Ur, bl, Or),
        Ne(Or.opts.start) && Or.opts.start.call(pe, Or),
        Or.progress(Or.opts.progress).done(Or.opts.done, Or.opts.complete).fail(Or.opts.fail).always(Or.opts.always),
        be.fx.timer(be.extend(yr, {
            elem: pe,
            anim: Or,
            queue: Or.opts.queue
        })),
        Or
    }
    be.Animation = be.extend(To, {
        tweeners: {
            "*": [function(pe, me) {
                var Le = this.createTween(pe, me);
                return Ls(Le.elem, pe, Ki.exec(me), Le),
                Le
            }
            ]
        },
        tweener: function(pe, me) {
            Ne(pe) ? (me = pe,
            pe = ["*"]) : pe = pe.match(Yn);
            for (var Le, rt = 0, nr = pe.length; rt < nr; rt++)
                Le = pe[rt],
                To.tweeners[Le] = To.tweeners[Le] || [],
                To.tweeners[Le].unshift(me)
        },
        prefilters: [function(pe, me, Le) {
            var rt, nr, sr, ur, $r, yr, Or, Ur, Hr = "width"in me || "height"in me, Br = this, Kr = {}, ti = pe.style, wi = pe.nodeType && Xo(pe), li = kr.get(pe, "fxshow");
            for (rt in Le.queue || ((ur = be._queueHooks(pe, "fx")).unqueued == null && (ur.unqueued = 0,
            $r = ur.empty.fire,
            ur.empty.fire = function() {
                ur.unqueued || $r()
            }
            ),
            ur.unqueued++,
            Br.always(function() {
                Br.always(function() {
                    ur.unqueued--,
                    be.queue(pe, "fx").length || ur.empty.fire()
                })
            })),
            me)
                if (nr = me[rt],
                Fs.test(nr)) {
                    if (delete me[rt],
                    sr = sr || nr === "toggle",
                    nr === (wi ? "hide" : "show")) {
                        if (nr !== "show" || !li || li[rt] === void 0)
                            continue;
                        wi = !0
                    }
                    Kr[rt] = li && li[rt] || be.style(pe, rt)
                }
            if ((yr = !be.isEmptyObject(me)) || !be.isEmptyObject(Kr))
                for (rt in Hr && pe.nodeType === 1 && (Le.overflow = [ti.overflow, ti.overflowX, ti.overflowY],
                (Or = li && li.display) == null && (Or = kr.get(pe, "display")),
                (Ur = be.css(pe, "display")) === "none" && (Or ? Ur = Or : (Xa([pe], !0),
                Or = pe.style.display || Or,
                Ur = be.css(pe, "display"),
                Xa([pe]))),
                (Ur === "inline" || Ur === "inline-block" && Or != null) && be.css(pe, "float") === "none" && (yr || (Br.done(function() {
                    ti.display = Or
                }),
                Or == null && (Ur = ti.display,
                Or = Ur === "none" ? "" : Ur)),
                ti.display = "inline-block")),
                Le.overflow && (ti.overflow = "hidden",
                Br.always(function() {
                    ti.overflow = Le.overflow[0],
                    ti.overflowX = Le.overflow[1],
                    ti.overflowY = Le.overflow[2]
                })),
                yr = !1,
                Kr)
                    yr || (li ? "hidden"in li && (wi = li.hidden) : li = kr.access(pe, "fxshow", {
                        display: Or
                    }),
                    sr && (li.hidden = !wi),
                    wi && Xa([pe], !0),
                    Br.done(function() {
                        for (rt in wi || Xa([pe]),
                        kr.remove(pe, "fxshow"),
                        Kr)
                            be.style(pe, rt, Kr[rt])
                    })),
                    yr = bl(wi ? li[rt] : 0, rt, Br),
                    rt in li || (li[rt] = yr.start,
                    wi && (yr.end = yr.start,
                    yr.start = 0))
        }
        ],
        prefilter: function(pe, me) {
            me ? To.prefilters.unshift(pe) : To.prefilters.push(pe)
        }
    }),
    be.speed = function(pe, me, Le) {
        var rt = pe && typeof pe == "object" ? be.extend({}, pe) : {
            complete: Le || !Le && me || Ne(pe) && pe,
            duration: pe,
            easing: Le && me || me && !Ne(me) && me
        };
        return be.fx.off ? rt.duration = 0 : typeof rt.duration != "number" && (rt.duration in be.fx.speeds ? rt.duration = be.fx.speeds[rt.duration] : rt.duration = be.fx.speeds._default),
        rt.queue != null && rt.queue !== !0 || (rt.queue = "fx"),
        rt.old = rt.complete,
        rt.complete = function() {
            Ne(rt.old) && rt.old.call(this),
            rt.queue && be.dequeue(this, rt.queue)
        }
        ,
        rt
    }
    ,
    be.fn.extend({
        fadeTo: function(pe, me, Le, rt) {
            return this.filter(Xo).css("opacity", 0).show().end().animate({
                opacity: me
            }, pe, Le, rt)
        },
        animate: function(pe, me, Le, rt) {
            var nr = be.isEmptyObject(pe)
              , sr = be.speed(me, Le, rt)
              , ur = function() {
                var $r = To(this, be.extend({}, pe), sr);
                (nr || kr.get(this, "finish")) && $r.stop(!0)
            };
            return ur.finish = ur,
            nr || sr.queue === !1 ? this.each(ur) : this.queue(sr.queue, ur)
        },
        stop: function(pe, me, Le) {
            var rt = function(nr) {
                var sr = nr.stop;
                delete nr.stop,
                sr(Le)
            };
            return typeof pe != "string" && (Le = me,
            me = pe,
            pe = void 0),
            me && this.queue(pe || "fx", []),
            this.each(function() {
                var nr = !0
                  , sr = pe != null && pe + "queueHooks"
                  , ur = be.timers
                  , $r = kr.get(this);
                if (sr)
                    $r[sr] && $r[sr].stop && rt($r[sr]);
                else
                    for (sr in $r)
                        $r[sr] && $r[sr].stop && fa.test(sr) && rt($r[sr]);
                for (sr = ur.length; sr--; )
                    ur[sr].elem !== this || pe != null && ur[sr].queue !== pe || (ur[sr].anim.stop(Le),
                    nr = !1,
                    ur.splice(sr, 1));
                !nr && Le || be.dequeue(this, pe)
            })
        },
        finish: function(pe) {
            return pe !== !1 && (pe = pe || "fx"),
            this.each(function() {
                var me, Le = kr.get(this), rt = Le[pe + "queue"], nr = Le[pe + "queueHooks"], sr = be.timers, ur = rt ? rt.length : 0;
                for (Le.finish = !0,
                be.queue(this, pe, []),
                nr && nr.stop && nr.stop.call(this, !0),
                me = sr.length; me--; )
                    sr[me].elem === this && sr[me].queue === pe && (sr[me].anim.stop(!0),
                    sr.splice(me, 1));
                for (me = 0; me < ur; me++)
                    rt[me] && rt[me].finish && rt[me].finish.call(this);
                delete Le.finish
            })
        }
    }),
    be.each(["toggle", "show", "hide"], function(pe, me) {
        var Le = be.fn[me];
        be.fn[me] = function(rt, nr, sr) {
            return rt == null || typeof rt == "boolean" ? Le.apply(this, arguments) : this.animate(ys(me, !0), rt, nr, sr)
        }
    }),
    be.each({
        slideDown: ys("show"),
        slideUp: ys("hide"),
        slideToggle: ys("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(pe, me) {
        be.fn[pe] = function(Le, rt, nr) {
            return this.animate(me, Le, rt, nr)
        }
    }),
    be.timers = [],
    be.fx.tick = function() {
        var pe, me = 0, Le = be.timers;
        for (Zo = Date.now(); me < Le.length; me++)
            (pe = Le[me])() || Le[me] !== pe || Le.splice(me--, 1);
        Le.length || be.fx.stop(),
        Zo = void 0
    }
    ,
    be.fx.timer = function(pe) {
        be.timers.push(pe),
        be.fx.start()
    }
    ,
    be.fx.interval = 13,
    be.fx.start = function() {
        Ko || (Ko = !0,
        bo())
    }
    ,
    be.fx.stop = function() {
        Ko = null
    }
    ,
    be.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    },
    be.fn.delay = function(pe, me) {
        return pe = be.fx && be.fx.speeds[pe] || pe,
        me = me || "fx",
        this.queue(me, function(Le, rt) {
            var nr = W.setTimeout(Le, pe);
            rt.stop = function() {
                W.clearTimeout(nr)
            }
        })
    }
    ,
    function() {
        var pe = rr.createElement("input")
          , me = rr.createElement("select").appendChild(rr.createElement("option"));
        pe.type = "checkbox",
        Se.checkOn = pe.value !== "",
        Se.optSelected = me.selected,
        (pe = rr.createElement("input")).value = "t",
        pe.type = "radio",
        Se.radioValue = pe.value === "t"
    }();
    var vl, po = be.expr.attrHandle;
    be.fn.extend({
        attr: function(pe, me) {
            return vn(this, be.attr, pe, me, arguments.length > 1)
        },
        removeAttr: function(pe) {
            return this.each(function() {
                be.removeAttr(this, pe)
            })
        }
    }),
    be.extend({
        attr: function(pe, me, Le) {
            var rt, nr, sr = pe.nodeType;
            if (sr !== 3 && sr !== 8 && sr !== 2)
                return pe.getAttribute === void 0 ? be.prop(pe, me, Le) : (sr === 1 && be.isXMLDoc(pe) || (nr = be.attrHooks[me.toLowerCase()] || (be.expr.match.bool.test(me) ? vl : void 0)),
                Le !== void 0 ? Le === null ? void be.removeAttr(pe, me) : nr && "set"in nr && (rt = nr.set(pe, Le, me)) !== void 0 ? rt : (pe.setAttribute(me, Le + ""),
                Le) : nr && "get"in nr && (rt = nr.get(pe, me)) !== null ? rt : (rt = be.find.attr(pe, me)) == null ? void 0 : rt)
        },
        attrHooks: {
            type: {
                set: function(pe, me) {
                    if (!Se.radioValue && me === "radio" && fr(pe, "input")) {
                        var Le = pe.value;
                        return pe.setAttribute("type", me),
                        Le && (pe.value = Le),
                        me
                    }
                }
            }
        },
        removeAttr: function(pe, me) {
            var Le, rt = 0, nr = me && me.match(Yn);
            if (nr && pe.nodeType === 1)
                for (; Le = nr[rt++]; )
                    pe.removeAttribute(Le)
        }
    }),
    vl = {
        set: function(pe, me, Le) {
            return me === !1 ? be.removeAttr(pe, Le) : pe.setAttribute(Le, Le),
            Le
        }
    },
    be.each(be.expr.match.bool.source.match(/\w+/g), function(pe, me) {
        var Le = po[me] || be.find.attr;
        po[me] = function(rt, nr, sr) {
            var ur, $r, yr = nr.toLowerCase();
            return sr || ($r = po[yr],
            po[yr] = ur,
            ur = Le(rt, nr, sr) != null ? yr : null,
            po[yr] = $r),
            ur
        }
    });
    var Ml = /^(?:input|select|textarea|button)$/i
      , wl = /^(?:a|area)$/i;
    function Jo(pe) {
        return (pe.match(Yn) || []).join(" ")
    }
    function ga(pe) {
        return pe.getAttribute && pe.getAttribute("class") || ""
    }
    function Io(pe) {
        return Array.isArray(pe) ? pe : typeof pe == "string" && pe.match(Yn) || []
    }
    be.fn.extend({
        prop: function(pe, me) {
            return vn(this, be.prop, pe, me, arguments.length > 1)
        },
        removeProp: function(pe) {
            return this.each(function() {
                delete this[be.propFix[pe] || pe]
            })
        }
    }),
    be.extend({
        prop: function(pe, me, Le) {
            var rt, nr, sr = pe.nodeType;
            if (sr !== 3 && sr !== 8 && sr !== 2)
                return sr === 1 && be.isXMLDoc(pe) || (me = be.propFix[me] || me,
                nr = be.propHooks[me]),
                Le !== void 0 ? nr && "set"in nr && (rt = nr.set(pe, Le, me)) !== void 0 ? rt : pe[me] = Le : nr && "get"in nr && (rt = nr.get(pe, me)) !== null ? rt : pe[me]
        },
        propHooks: {
            tabIndex: {
                get: function(pe) {
                    var me = be.find.attr(pe, "tabindex");
                    return me ? parseInt(me, 10) : Ml.test(pe.nodeName) || wl.test(pe.nodeName) && pe.href ? 0 : -1
                }
            }
        },
        propFix: {
            for: "htmlFor",
            class: "className"
        }
    }),
    Se.optSelected || (be.propHooks.selected = {
        get: function(pe) {
            var me = pe.parentNode;
            return me && me.parentNode && me.parentNode.selectedIndex,
            null
        },
        set: function(pe) {
            var me = pe.parentNode;
            me && (me.selectedIndex,
            me.parentNode && me.parentNode.selectedIndex)
        }
    }),
    be.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
        be.propFix[this.toLowerCase()] = this
    }),
    be.fn.extend({
        addClass: function(pe) {
            var me, Le, rt, nr, sr, ur;
            return Ne(pe) ? this.each(function($r) {
                be(this).addClass(pe.call(this, $r, ga(this)))
            }) : (me = Io(pe)).length ? this.each(function() {
                if (rt = ga(this),
                Le = this.nodeType === 1 && " " + Jo(rt) + " ") {
                    for (sr = 0; sr < me.length; sr++)
                        nr = me[sr],
                        Le.indexOf(" " + nr + " ") < 0 && (Le += nr + " ");
                    ur = Jo(Le),
                    rt !== ur && this.setAttribute("class", ur)
                }
            }) : this
        },
        removeClass: function(pe) {
            var me, Le, rt, nr, sr, ur;
            return Ne(pe) ? this.each(function($r) {
                be(this).removeClass(pe.call(this, $r, ga(this)))
            }) : arguments.length ? (me = Io(pe)).length ? this.each(function() {
                if (rt = ga(this),
                Le = this.nodeType === 1 && " " + Jo(rt) + " ") {
                    for (sr = 0; sr < me.length; sr++)
                        for (nr = me[sr]; Le.indexOf(" " + nr + " ") > -1; )
                            Le = Le.replace(" " + nr + " ", " ");
                    ur = Jo(Le),
                    rt !== ur && this.setAttribute("class", ur)
                }
            }) : this : this.attr("class", "")
        },
        toggleClass: function(pe, me) {
            var Le, rt, nr, sr, ur = typeof pe, $r = ur === "string" || Array.isArray(pe);
            return Ne(pe) ? this.each(function(yr) {
                be(this).toggleClass(pe.call(this, yr, ga(this), me), me)
            }) : typeof me == "boolean" && $r ? me ? this.addClass(pe) : this.removeClass(pe) : (Le = Io(pe),
            this.each(function() {
                if ($r)
                    for (sr = be(this),
                    nr = 0; nr < Le.length; nr++)
                        rt = Le[nr],
                        sr.hasClass(rt) ? sr.removeClass(rt) : sr.addClass(rt);
                else
                    pe !== void 0 && ur !== "boolean" || ((rt = ga(this)) && kr.set(this, "__className__", rt),
                    this.setAttribute && this.setAttribute("class", rt || pe === !1 ? "" : kr.get(this, "__className__") || ""))
            }))
        },
        hasClass: function(pe) {
            var me, Le, rt = 0;
            for (me = " " + pe + " "; Le = this[rt++]; )
                if (Le.nodeType === 1 && (" " + Jo(ga(Le)) + " ").indexOf(me) > -1)
                    return !0;
            return !1
        }
    });
    var xs = /\r/g;
    be.fn.extend({
        val: function(pe) {
            var me, Le, rt, nr = this[0];
            return arguments.length ? (rt = Ne(pe),
            this.each(function(sr) {
                var ur;
                this.nodeType === 1 && ((ur = rt ? pe.call(this, sr, be(this).val()) : pe) == null ? ur = "" : typeof ur == "number" ? ur += "" : Array.isArray(ur) && (ur = be.map(ur, function($r) {
                    return $r == null ? "" : $r + ""
                })),
                (me = be.valHooks[this.type] || be.valHooks[this.nodeName.toLowerCase()]) && "set"in me && me.set(this, ur, "value") !== void 0 || (this.value = ur))
            })) : nr ? (me = be.valHooks[nr.type] || be.valHooks[nr.nodeName.toLowerCase()]) && "get"in me && (Le = me.get(nr, "value")) !== void 0 ? Le : typeof (Le = nr.value) == "string" ? Le.replace(xs, "") : Le ?? "" : void 0
        }
    }),
    be.extend({
        valHooks: {
            option: {
                get: function(pe) {
                    var me = be.find.attr(pe, "value");
                    return me ?? Jo(be.text(pe))
                }
            },
            select: {
                get: function(pe) {
                    var me, Le, rt, nr = pe.options, sr = pe.selectedIndex, ur = pe.type === "select-one", $r = ur ? null : [], yr = ur ? sr + 1 : nr.length;
                    for (rt = sr < 0 ? yr : ur ? sr : 0; rt < yr; rt++)
                        if (((Le = nr[rt]).selected || rt === sr) && !Le.disabled && (!Le.parentNode.disabled || !fr(Le.parentNode, "optgroup"))) {
                            if (me = be(Le).val(),
                            ur)
                                return me;
                            $r.push(me)
                        }
                    return $r
                },
                set: function(pe, me) {
                    for (var Le, rt, nr = pe.options, sr = be.makeArray(me), ur = nr.length; ur--; )
                        ((rt = nr[ur]).selected = be.inArray(be.valHooks.option.get(rt), sr) > -1) && (Le = !0);
                    return Le || (pe.selectedIndex = -1),
                    sr
                }
            }
        }
    }),
    be.each(["radio", "checkbox"], function() {
        be.valHooks[this] = {
            set: function(pe, me) {
                if (Array.isArray(me))
                    return pe.checked = be.inArray(be(pe).val(), me) > -1
            }
        },
        Se.checkOn || (be.valHooks[this].get = function(pe) {
            return pe.getAttribute("value") === null ? "on" : pe.value
        }
        )
    });
    var Xi = W.location
      , Ta = {
        guid: Date.now()
    }
      , Sa = /\?/;
    be.parseXML = function(pe) {
        var me, Le;
        if (!pe || typeof pe != "string")
            return null;
        try {
            me = new W.DOMParser().parseFromString(pe, "text/xml")
        } catch {}
        return Le = me && me.getElementsByTagName("parsererror")[0],
        me && !Le || be.error("Invalid XML: " + (Le ? be.map(Le.childNodes, function(rt) {
            return rt.textContent
        }).join(`
`) : pe)),
        me
    }
    ;
    var ma = /^(?:focusinfocus|focusoutblur)$/
      , $s = function(pe) {
        pe.stopPropagation()
    };
    be.extend(be.event, {
        trigger: function(pe, me, Le, rt) {
            var nr, sr, ur, $r, yr, Or, Ur, Hr, Br = [Le || rr], Kr = xe.call(pe, "type") ? pe.type : pe, ti = xe.call(pe, "namespace") ? pe.namespace.split(".") : [];
            if (sr = Hr = ur = Le = Le || rr,
            Le.nodeType !== 3 && Le.nodeType !== 8 && !ma.test(Kr + be.event.triggered) && (Kr.indexOf(".") > -1 && (ti = Kr.split("."),
            Kr = ti.shift(),
            ti.sort()),
            yr = Kr.indexOf(":") < 0 && "on" + Kr,
            (pe = pe[be.expando] ? pe : new be.Event(Kr,typeof pe == "object" && pe)).isTrigger = rt ? 2 : 3,
            pe.namespace = ti.join("."),
            pe.rnamespace = pe.namespace ? new RegExp("(^|\\.)" + ti.join("\\.(?:.*\\.|)") + "(\\.|$)") : null,
            pe.result = void 0,
            pe.target || (pe.target = Le),
            me = me == null ? [pe] : be.makeArray(me, [pe]),
            Ur = be.event.special[Kr] || {},
            rt || !Ur.trigger || Ur.trigger.apply(Le, me) !== !1)) {
                if (!rt && !Ur.noBubble && !tt(Le)) {
                    for ($r = Ur.delegateType || Kr,
                    ma.test($r + Kr) || (sr = sr.parentNode); sr; sr = sr.parentNode)
                        Br.push(sr),
                        ur = sr;
                    ur === (Le.ownerDocument || rr) && Br.push(ur.defaultView || ur.parentWindow || W)
                }
                for (nr = 0; (sr = Br[nr++]) && !pe.isPropagationStopped(); )
                    Hr = sr,
                    pe.type = nr > 1 ? $r : Ur.bindType || Kr,
                    (Or = (kr.get(sr, "events") || Object.create(null))[pe.type] && kr.get(sr, "handle")) && Or.apply(sr, me),
                    (Or = yr && sr[yr]) && Or.apply && Er(sr) && (pe.result = Or.apply(sr, me),
                    pe.result === !1 && pe.preventDefault());
                return pe.type = Kr,
                rt || pe.isDefaultPrevented() || Ur._default && Ur._default.apply(Br.pop(), me) !== !1 || !Er(Le) || yr && Ne(Le[Kr]) && !tt(Le) && ((ur = Le[yr]) && (Le[yr] = null),
                be.event.triggered = Kr,
                pe.isPropagationStopped() && Hr.addEventListener(Kr, $s),
                Le[Kr](),
                pe.isPropagationStopped() && Hr.removeEventListener(Kr, $s),
                be.event.triggered = void 0,
                ur && (Le[yr] = ur)),
                pe.result
            }
        },
        simulate: function(pe, me, Le) {
            var rt = be.extend(new be.Event, Le, {
                type: pe,
                isSimulated: !0
            });
            be.event.trigger(rt, null, me)
        }
    }),
    be.fn.extend({
        trigger: function(pe, me) {
            return this.each(function() {
                be.event.trigger(pe, me, this)
            })
        },
        triggerHandler: function(pe, me) {
            var Le = this[0];
            if (Le)
                return be.event.trigger(pe, me, Le, !0)
        }
    });
    var Ll = /\[\]$/
      , Cs = /\r?\n/g
      , $c = /^(?:submit|button|image|reset|file)$/i
      , _s = /^(?:input|select|textarea|keygen)/i;
    function En(pe, me, Le, rt) {
        var nr;
        if (Array.isArray(me))
            be.each(me, function(sr, ur) {
                Le || Ll.test(pe) ? rt(pe, ur) : En(pe + "[" + (typeof ur == "object" && ur != null ? sr : "") + "]", ur, Le, rt)
            });
        else if (Le || Ut(me) !== "object")
            rt(pe, me);
        else
            for (nr in me)
                En(pe + "[" + nr + "]", me[nr], Le, rt)
    }
    be.param = function(pe, me) {
        var Le, rt = [], nr = function(sr, ur) {
            var $r = Ne(ur) ? ur() : ur;
            rt[rt.length] = encodeURIComponent(sr) + "=" + encodeURIComponent($r ?? "")
        };
        if (pe == null)
            return "";
        if (Array.isArray(pe) || pe.jquery && !be.isPlainObject(pe))
            be.each(pe, function() {
                nr(this.name, this.value)
            });
        else
            for (Le in pe)
                En(Le, pe[Le], me, nr);
        return rt.join("&")
    }
    ,
    be.fn.extend({
        serialize: function() {
            return be.param(this.serializeArray())
        },
        serializeArray: function() {
            return this.map(function() {
                var pe = be.prop(this, "elements");
                return pe ? be.makeArray(pe) : this
            }).filter(function() {
                var pe = this.type;
                return this.name && !be(this).is(":disabled") && _s.test(this.nodeName) && !$c.test(pe) && (this.checked || !Ba.test(pe))
            }).map(function(pe, me) {
                var Le = be(this).val();
                return Le == null ? null : Array.isArray(Le) ? be.map(Le, function(rt) {
                    return {
                        name: me.name,
                        value: rt.replace(Cs, `\r
`)
                    }
                }) : {
                    name: me.name,
                    value: Le.replace(Cs, `\r
`)
                }
            }).get()
        }
    });
    var Wl = /%20/g
      , Dl = /#.*$/
      , Cc = /([?&])_=[^&]*/
      , _c = /^(.*?):[ \t]*([^\r\n]*)$/gm
      , Ul = /^(?:GET|HEAD)$/
      , es = /^\/\//
      , Es = {}
      , ts = {}
      , zs = "*/".concat("*")
      , Ho = rr.createElement("a");
    function qs(pe) {
        return function(me, Le) {
            typeof me != "string" && (Le = me,
            me = "*");
            var rt, nr = 0, sr = me.toLowerCase().match(Yn) || [];
            if (Ne(Le))
                for (; rt = sr[nr++]; )
                    rt[0] === "+" ? (rt = rt.slice(1) || "*",
                    (pe[rt] = pe[rt] || []).unshift(Le)) : (pe[rt] = pe[rt] || []).push(Le)
        }
    }
    function Wa(pe, me, Le, rt) {
        var nr = {}
          , sr = pe === ts;
        function ur($r) {
            var yr;
            return nr[$r] = !0,
            be.each(pe[$r] || [], function(Or, Ur) {
                var Hr = Ur(me, Le, rt);
                return typeof Hr != "string" || sr || nr[Hr] ? sr ? !(yr = Hr) : void 0 : (me.dataTypes.unshift(Hr),
                ur(Hr),
                !1)
            }),
            yr
        }
        return ur(me.dataTypes[0]) || !nr["*"] && ur("*")
    }
    function Po(pe, me) {
        var Le, rt, nr = be.ajaxSettings.flatOptions || {};
        for (Le in me)
            me[Le] !== void 0 && ((nr[Le] ? pe : rt || (rt = {}))[Le] = me[Le]);
        return rt && be.extend(!0, pe, rt),
        pe
    }
    Ho.href = Xi.href,
    be.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: Xi.href,
            type: "GET",
            isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Xi.protocol),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": zs,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": JSON.parse,
                "text xml": be.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(pe, me) {
            return me ? Po(Po(pe, be.ajaxSettings), me) : Po(be.ajaxSettings, pe)
        },
        ajaxPrefilter: qs(Es),
        ajaxTransport: qs(ts),
        ajax: function(pe, me) {
            typeof pe == "object" && (me = pe,
            pe = void 0),
            me = me || {};
            var Le, rt, nr, sr, ur, $r, yr, Or, Ur, Hr, Br = be.ajaxSetup({}, me), Kr = Br.context || Br, ti = Br.context && (Kr.nodeType || Kr.jquery) ? be(Kr) : be.event, wi = be.Deferred(), li = be.Callbacks("once memory"), Qi = Br.statusCode || {}, lo = {}, Ro = {}, Qo = "canceled", Ei = {
                readyState: 0,
                getResponseHeader: function(Ai) {
                    var Li;
                    if (yr) {
                        if (!sr)
                            for (sr = {}; Li = _c.exec(nr); )
                                sr[Li[1].toLowerCase() + " "] = (sr[Li[1].toLowerCase() + " "] || []).concat(Li[2]);
                        Li = sr[Ai.toLowerCase() + " "]
                    }
                    return Li == null ? null : Li.join(", ")
                },
                getAllResponseHeaders: function() {
                    return yr ? nr : null
                },
                setRequestHeader: function(Ai, Li) {
                    return yr == null && (Ai = Ro[Ai.toLowerCase()] = Ro[Ai.toLowerCase()] || Ai,
                    lo[Ai] = Li),
                    this
                },
                overrideMimeType: function(Ai) {
                    return yr == null && (Br.mimeType = Ai),
                    this
                },
                statusCode: function(Ai) {
                    var Li;
                    if (Ai)
                        if (yr)
                            Ei.always(Ai[Ei.status]);
                        else
                            for (Li in Ai)
                                Qi[Li] = [Qi[Li], Ai[Li]];
                    return this
                },
                abort: function(Ai) {
                    var Li = Ai || Qo;
                    return Le && Le.abort(Li),
                    ka(0, Li),
                    this
                }
            };
            if (wi.promise(Ei),
            Br.url = ((pe || Br.url || Xi.href) + "").replace(es, Xi.protocol + "//"),
            Br.type = me.method || me.type || Br.method || Br.type,
            Br.dataTypes = (Br.dataType || "*").toLowerCase().match(Yn) || [""],
            Br.crossDomain == null) {
                $r = rr.createElement("a");
                try {
                    $r.href = Br.url,
                    $r.href = $r.href,
                    Br.crossDomain = Ho.protocol + "//" + Ho.host != $r.protocol + "//" + $r.host
                } catch {
                    Br.crossDomain = !0
                }
            }
            if (Br.data && Br.processData && typeof Br.data != "string" && (Br.data = be.param(Br.data, Br.traditional)),
            Wa(Es, Br, me, Ei),
            yr)
                return Ei;
            for (Ur in (Or = be.event && Br.global) && be.active++ == 0 && be.event.trigger("ajaxStart"),
            Br.type = Br.type.toUpperCase(),
            Br.hasContent = !Ul.test(Br.type),
            rt = Br.url.replace(Dl, ""),
            Br.hasContent ? Br.data && Br.processData && (Br.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && (Br.data = Br.data.replace(Wl, "+")) : (Hr = Br.url.slice(rt.length),
            Br.data && (Br.processData || typeof Br.data == "string") && (rt += (Sa.test(rt) ? "&" : "?") + Br.data,
            delete Br.data),
            Br.cache === !1 && (rt = rt.replace(Cc, "$1"),
            Hr = (Sa.test(rt) ? "&" : "?") + "_=" + Ta.guid++ + Hr),
            Br.url = rt + Hr),
            Br.ifModified && (be.lastModified[rt] && Ei.setRequestHeader("If-Modified-Since", be.lastModified[rt]),
            be.etag[rt] && Ei.setRequestHeader("If-None-Match", be.etag[rt])),
            (Br.data && Br.hasContent && Br.contentType !== !1 || me.contentType) && Ei.setRequestHeader("Content-Type", Br.contentType),
            Ei.setRequestHeader("Accept", Br.dataTypes[0] && Br.accepts[Br.dataTypes[0]] ? Br.accepts[Br.dataTypes[0]] + (Br.dataTypes[0] !== "*" ? ", " + zs + "; q=0.01" : "") : Br.accepts["*"]),
            Br.headers)
                Ei.setRequestHeader(Ur, Br.headers[Ur]);
            if (Br.beforeSend && (Br.beforeSend.call(Kr, Ei, Br) === !1 || yr))
                return Ei.abort();
            if (Qo = "abort",
            li.add(Br.complete),
            Ei.done(Br.success),
            Ei.fail(Br.error),
            Le = Wa(ts, Br, me, Ei)) {
                if (Ei.readyState = 1,
                Or && ti.trigger("ajaxSend", [Ei, Br]),
                yr)
                    return Ei;
                Br.async && Br.timeout > 0 && (ur = W.setTimeout(function() {
                    Ei.abort("timeout")
                }, Br.timeout));
                try {
                    yr = !1,
                    Le.send(lo, ka)
                } catch (Ai) {
                    if (yr)
                        throw Ai;
                    ka(-1, Ai)
                }
            } else
                ka(-1, "No Transport");
            function ka(Ai, Li, ns, Gs) {
                var aa, Ss, va, Aa, is, uo = Li;
                yr || (yr = !0,
                ur && W.clearTimeout(ur),
                Le = void 0,
                nr = Gs || "",
                Ei.readyState = Ai > 0 ? 4 : 0,
                aa = Ai >= 200 && Ai < 300 || Ai === 304,
                ns && (Aa = function(co, no, vo) {
                    for (var Ia, fo, ri, eo, Gi = co.contents, Bi = co.dataTypes; Bi[0] === "*"; )
                        Bi.shift(),
                        Ia === void 0 && (Ia = co.mimeType || no.getResponseHeader("Content-Type"));
                    if (Ia) {
                        for (fo in Gi)
                            if (Gi[fo] && Gi[fo].test(Ia)) {
                                Bi.unshift(fo);
                                break
                            }
                    }
                    if (Bi[0]in vo)
                        ri = Bi[0];
                    else {
                        for (fo in vo) {
                            if (!Bi[0] || co.converters[fo + " " + Bi[0]]) {
                                ri = fo;
                                break
                            }
                            eo || (eo = fo)
                        }
                        ri = ri || eo
                    }
                    if (ri)
                        return ri !== Bi[0] && Bi.unshift(ri),
                        vo[ri]
                }(Br, Ei, ns)),
                !aa && be.inArray("script", Br.dataTypes) > -1 && be.inArray("json", Br.dataTypes) < 0 && (Br.converters["text script"] = function() {}
                ),
                Aa = function(co, no, vo, Ia) {
                    var fo, ri, eo, Gi, Bi, sa = {}, os = co.dataTypes.slice();
                    if (os[1])
                        for (eo in co.converters)
                            sa[eo.toLowerCase()] = co.converters[eo];
                    for (ri = os.shift(); ri; )
                        if (co.responseFields[ri] && (vo[co.responseFields[ri]] = no),
                        !Bi && Ia && co.dataFilter && (no = co.dataFilter(no, co.dataType)),
                        Bi = ri,
                        ri = os.shift()) {
                            if (ri === "*")
                                ri = Bi;
                            else if (Bi !== "*" && Bi !== ri) {
                                if (!(eo = sa[Bi + " " + ri] || sa["* " + ri])) {
                                    for (fo in sa)
                                        if ((Gi = fo.split(" "))[1] === ri && (eo = sa[Bi + " " + Gi[0]] || sa["* " + Gi[0]])) {
                                            eo === !0 ? eo = sa[fo] : sa[fo] !== !0 && (ri = Gi[0],
                                            os.unshift(Gi[1]));
                                            break
                                        }
                                }
                                if (eo !== !0)
                                    if (eo && co.throws)
                                        no = eo(no);
                                    else
                                        try {
                                            no = eo(no)
                                        } catch (as) {
                                            return {
                                                state: "parsererror",
                                                error: eo ? as : "No conversion from " + Bi + " to " + ri
                                            }
                                        }
                            }
                        }
                    return {
                        state: "success",
                        data: no
                    }
                }(Br, Aa, Ei, aa),
                aa ? (Br.ifModified && ((is = Ei.getResponseHeader("Last-Modified")) && (be.lastModified[rt] = is),
                (is = Ei.getResponseHeader("etag")) && (be.etag[rt] = is)),
                Ai === 204 || Br.type === "HEAD" ? uo = "nocontent" : Ai === 304 ? uo = "notmodified" : (uo = Aa.state,
                Ss = Aa.data,
                aa = !(va = Aa.error))) : (va = uo,
                !Ai && uo || (uo = "error",
                Ai < 0 && (Ai = 0))),
                Ei.status = Ai,
                Ei.statusText = (Li || uo) + "",
                aa ? wi.resolveWith(Kr, [Ss, uo, Ei]) : wi.rejectWith(Kr, [Ei, uo, va]),
                Ei.statusCode(Qi),
                Qi = void 0,
                Or && ti.trigger(aa ? "ajaxSuccess" : "ajaxError", [Ei, Br, aa ? Ss : va]),
                li.fireWith(Kr, [Ei, uo]),
                Or && (ti.trigger("ajaxComplete", [Ei, Br]),
                --be.active || be.event.trigger("ajaxStop")))
            }
            return Ei
        },
        getJSON: function(pe, me, Le) {
            return be.get(pe, me, Le, "json")
        },
        getScript: function(pe, me) {
            return be.get(pe, void 0, me, "script")
        }
    }),
    be.each(["get", "post"], function(pe, me) {
        be[me] = function(Le, rt, nr, sr) {
            return Ne(rt) && (sr = sr || nr,
            nr = rt,
            rt = void 0),
            be.ajax(be.extend({
                url: Le,
                type: me,
                dataType: sr,
                data: rt,
                success: nr
            }, be.isPlainObject(Le) && Le))
        }
    }),
    be.ajaxPrefilter(function(pe) {
        var me;
        for (me in pe.headers)
            me.toLowerCase() === "content-type" && (pe.contentType = pe.headers[me] || "")
    }),
    be._evalUrl = function(pe, me, Le) {
        return be.ajax({
            url: pe,
            type: "GET",
            dataType: "script",
            cache: !0,
            async: !1,
            global: !1,
            converters: {
                "text script": function() {}
            },
            dataFilter: function(rt) {
                be.globalEval(rt, me, Le)
            }
        })
    }
    ,
    be.fn.extend({
        wrapAll: function(pe) {
            var me;
            return this[0] && (Ne(pe) && (pe = pe.call(this[0])),
            me = be(pe, this[0].ownerDocument).eq(0).clone(!0),
            this[0].parentNode && me.insertBefore(this[0]),
            me.map(function() {
                for (var Le = this; Le.firstElementChild; )
                    Le = Le.firstElementChild;
                return Le
            }).append(this)),
            this
        },
        wrapInner: function(pe) {
            return Ne(pe) ? this.each(function(me) {
                be(this).wrapInner(pe.call(this, me))
            }) : this.each(function() {
                var me = be(this)
                  , Le = me.contents();
                Le.length ? Le.wrapAll(pe) : me.append(pe)
            })
        },
        wrap: function(pe) {
            var me = Ne(pe);
            return this.each(function(Le) {
                be(this).wrapAll(me ? pe.call(this, Le) : pe)
            })
        },
        unwrap: function(pe) {
            return this.parent(pe).not("body").each(function() {
                be(this).replaceWith(this.childNodes)
            }),
            this
        }
    }),
    be.expr.pseudos.hidden = function(pe) {
        return !be.expr.pseudos.visible(pe)
    }
    ,
    be.expr.pseudos.visible = function(pe) {
        return !!(pe.offsetWidth || pe.offsetHeight || pe.getClientRects().length)
    }
    ,
    be.ajaxSettings.xhr = function() {
        try {
            return new W.XMLHttpRequest
        } catch {}
    }
    ;
    var Hl = {
        0: 200,
        1223: 204
    }
      , Wn = be.ajaxSettings.xhr();
    Se.cors = !!Wn && "withCredentials"in Wn,
    Se.ajax = Wn = !!Wn,
    be.ajaxTransport(function(pe) {
        var me, Le;
        if (Se.cors || Wn && !pe.crossDomain)
            return {
                send: function(rt, nr) {
                    var sr, ur = pe.xhr();
                    if (ur.open(pe.type, pe.url, pe.async, pe.username, pe.password),
                    pe.xhrFields)
                        for (sr in pe.xhrFields)
                            ur[sr] = pe.xhrFields[sr];
                    for (sr in pe.mimeType && ur.overrideMimeType && ur.overrideMimeType(pe.mimeType),
                    pe.crossDomain || rt["X-Requested-With"] || (rt["X-Requested-With"] = "XMLHttpRequest"),
                    rt)
                        ur.setRequestHeader(sr, rt[sr]);
                    me = function($r) {
                        return function() {
                            me && (me = Le = ur.onload = ur.onerror = ur.onabort = ur.ontimeout = ur.onreadystatechange = null,
                            $r === "abort" ? ur.abort() : $r === "error" ? typeof ur.status != "number" ? nr(0, "error") : nr(ur.status, ur.statusText) : nr(Hl[ur.status] || ur.status, ur.statusText, (ur.responseType || "text") !== "text" || typeof ur.responseText != "string" ? {
                                binary: ur.response
                            } : {
                                text: ur.responseText
                            }, ur.getAllResponseHeaders()))
                        }
                    }
                    ,
                    ur.onload = me(),
                    Le = ur.onerror = ur.ontimeout = me("error"),
                    ur.onabort !== void 0 ? ur.onabort = Le : ur.onreadystatechange = function() {
                        ur.readyState === 4 && W.setTimeout(function() {
                            me && Le()
                        })
                    }
                    ,
                    me = me("abort");
                    try {
                        ur.send(pe.hasContent && pe.data || null)
                    } catch ($r) {
                        if (me)
                            throw $r
                    }
                },
                abort: function() {
                    me && me()
                }
            }
    }),
    be.ajaxPrefilter(function(pe) {
        pe.crossDomain && (pe.contents.script = !1)
    }),
    be.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function(pe) {
                return be.globalEval(pe),
                pe
            }
        }
    }),
    be.ajaxPrefilter("script", function(pe) {
        pe.cache === void 0 && (pe.cache = !1),
        pe.crossDomain && (pe.type = "GET")
    }),
    be.ajaxTransport("script", function(pe) {
        var me, Le;
        if (pe.crossDomain || pe.scriptAttrs)
            return {
                send: function(rt, nr) {
                    me = be("<script>").attr(pe.scriptAttrs || {}).prop({
                        charset: pe.scriptCharset,
                        src: pe.url
                    }).on("load error", Le = function(sr) {
                        me.remove(),
                        Le = null,
                        sr && nr(sr.type === "error" ? 404 : 200, sr.type)
                    }
                    ),
                    rr.head.appendChild(me[0])
                },
                abort: function() {
                    Le && Le()
                }
            }
    });
    var Ts, ba = [], rs = /(=)\?(?=&|$)|\?\?/;
    be.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var pe = ba.pop() || be.expando + "_" + Ta.guid++;
            return this[pe] = !0,
            pe
        }
    }),
    be.ajaxPrefilter("json jsonp", function(pe, me, Le) {
        var rt, nr, sr, ur = pe.jsonp !== !1 && (rs.test(pe.url) ? "url" : typeof pe.data == "string" && (pe.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rs.test(pe.data) && "data");
        if (ur || pe.dataTypes[0] === "jsonp")
            return rt = pe.jsonpCallback = Ne(pe.jsonpCallback) ? pe.jsonpCallback() : pe.jsonpCallback,
            ur ? pe[ur] = pe[ur].replace(rs, "$1" + rt) : pe.jsonp !== !1 && (pe.url += (Sa.test(pe.url) ? "&" : "?") + pe.jsonp + "=" + rt),
            pe.converters["script json"] = function() {
                return sr || be.error(rt + " was not called"),
                sr[0]
            }
            ,
            pe.dataTypes[0] = "json",
            nr = W[rt],
            W[rt] = function() {
                sr = arguments
            }
            ,
            Le.always(function() {
                nr === void 0 ? be(W).removeProp(rt) : W[rt] = nr,
                pe[rt] && (pe.jsonpCallback = me.jsonpCallback,
                ba.push(rt)),
                sr && Ne(nr) && nr(sr[0]),
                sr = nr = void 0
            }),
            "script"
    }),
    Se.createHTMLDocument = ((Ts = rr.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>",
    Ts.childNodes.length === 2),
    be.parseHTML = function(pe, me, Le) {
        return typeof pe != "string" ? [] : (typeof me == "boolean" && (Le = me,
        me = !1),
        me || (Se.createHTMLDocument ? ((rt = (me = rr.implementation.createHTMLDocument("")).createElement("base")).href = rr.location.href,
        me.head.appendChild(rt)) : me = rr),
        sr = !Le && [],
        (nr = Cn.exec(pe)) ? [me.createElement(nr[1])] : (nr = dl([pe], me, sr),
        sr && sr.length && be(sr).remove(),
        be.merge([], nr.childNodes)));
        var rt, nr, sr
    }
    ,
    be.fn.load = function(pe, me, Le) {
        var rt, nr, sr, ur = this, $r = pe.indexOf(" ");
        return $r > -1 && (rt = Jo(pe.slice($r)),
        pe = pe.slice(0, $r)),
        Ne(me) ? (Le = me,
        me = void 0) : me && typeof me == "object" && (nr = "POST"),
        ur.length > 0 && be.ajax({
            url: pe,
            type: nr || "GET",
            dataType: "html",
            data: me
        }).done(function(yr) {
            sr = arguments,
            ur.html(rt ? be("<div>").append(be.parseHTML(yr)).find(rt) : yr)
        }).always(Le && function(yr, Or) {
            ur.each(function() {
                Le.apply(this, sr || [yr.responseText, Or, yr])
            })
        }
        ),
        this
    }
    ,
    be.expr.pseudos.animated = function(pe) {
        return be.grep(be.timers, function(me) {
            return pe === me.elem
        }).length
    }
    ,
    be.offset = {
        setOffset: function(pe, me, Le) {
            var rt, nr, sr, ur, $r, yr, Or = be.css(pe, "position"), Ur = be(pe), Hr = {};
            Or === "static" && (pe.style.position = "relative"),
            $r = Ur.offset(),
            sr = be.css(pe, "top"),
            yr = be.css(pe, "left"),
            (Or === "absolute" || Or === "fixed") && (sr + yr).indexOf("auto") > -1 ? (ur = (rt = Ur.position()).top,
            nr = rt.left) : (ur = parseFloat(sr) || 0,
            nr = parseFloat(yr) || 0),
            Ne(me) && (me = me.call(pe, Le, be.extend({}, $r))),
            me.top != null && (Hr.top = me.top - $r.top + ur),
            me.left != null && (Hr.left = me.left - $r.left + nr),
            "using"in me ? me.using.call(pe, Hr) : Ur.css(Hr)
        }
    },
    be.fn.extend({
        offset: function(pe) {
            if (arguments.length)
                return pe === void 0 ? this : this.each(function(nr) {
                    be.offset.setOffset(this, pe, nr)
                });
            var me, Le, rt = this[0];
            return rt ? rt.getClientRects().length ? (me = rt.getBoundingClientRect(),
            Le = rt.ownerDocument.defaultView,
            {
                top: me.top + Le.pageYOffset,
                left: me.left + Le.pageXOffset
            }) : {
                top: 0,
                left: 0
            } : void 0
        },
        position: function() {
            if (this[0]) {
                var pe, me, Le, rt = this[0], nr = {
                    top: 0,
                    left: 0
                };
                if (be.css(rt, "position") === "fixed")
                    me = rt.getBoundingClientRect();
                else {
                    for (me = this.offset(),
                    Le = rt.ownerDocument,
                    pe = rt.offsetParent || Le.documentElement; pe && (pe === Le.body || pe === Le.documentElement) && be.css(pe, "position") === "static"; )
                        pe = pe.parentNode;
                    pe && pe !== rt && pe.nodeType === 1 && ((nr = be(pe).offset()).top += be.css(pe, "borderTopWidth", !0),
                    nr.left += be.css(pe, "borderLeftWidth", !0))
                }
                return {
                    top: me.top - nr.top - be.css(rt, "marginTop", !0),
                    left: me.left - nr.left - be.css(rt, "marginLeft", !0)
                }
            }
        },
        offsetParent: function() {
            return this.map(function() {
                for (var pe = this.offsetParent; pe && be.css(pe, "position") === "static"; )
                    pe = pe.offsetParent;
                return pe || Hi
            })
        }
    }),
    be.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(pe, me) {
        var Le = me === "pageYOffset";
        be.fn[pe] = function(rt) {
            return vn(this, function(nr, sr, ur) {
                var $r;
                if (tt(nr) ? $r = nr : nr.nodeType === 9 && ($r = nr.defaultView),
                ur === void 0)
                    return $r ? $r[me] : nr[sr];
                $r ? $r.scrollTo(Le ? $r.pageXOffset : ur, Le ? ur : $r.pageYOffset) : nr[sr] = ur
            }, pe, rt, arguments.length)
        }
    }),
    be.each(["top", "left"], function(pe, me) {
        be.cssHooks[me] = Ri(Se.pixelPosition, function(Le, rt) {
            if (rt)
                return rt = Uo(Le, me),
                bs.test(rt) ? be(Le).position()[me] + "px" : rt
        })
    }),
    be.each({
        Height: "height",
        Width: "width"
    }, function(pe, me) {
        be.each({
            padding: "inner" + pe,
            content: me,
            "": "outer" + pe
        }, function(Le, rt) {
            be.fn[rt] = function(nr, sr) {
                var ur = arguments.length && (Le || typeof nr != "boolean")
                  , $r = Le || (nr === !0 || sr === !0 ? "margin" : "border");
                return vn(this, function(yr, Or, Ur) {
                    var Hr;
                    return tt(yr) ? rt.indexOf("outer") === 0 ? yr["inner" + pe] : yr.document.documentElement["client" + pe] : yr.nodeType === 9 ? (Hr = yr.documentElement,
                    Math.max(yr.body["scroll" + pe], Hr["scroll" + pe], yr.body["offset" + pe], Hr["offset" + pe], Hr["client" + pe])) : Ur === void 0 ? be.css(yr, Or, $r) : be.style(yr, Or, Ur, $r)
                }, me, ur ? nr : void 0, ur)
            }
        })
    }),
    be.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(pe, me) {
        be.fn[me] = function(Le) {
            return this.on(me, Le)
        }
    }),
    be.fn.extend({
        bind: function(pe, me, Le) {
            return this.on(pe, null, me, Le)
        },
        unbind: function(pe, me) {
            return this.off(pe, null, me)
        },
        delegate: function(pe, me, Le, rt) {
            return this.on(me, pe, Le, rt)
        },
        undelegate: function(pe, me, Le) {
            return arguments.length === 1 ? this.off(pe, "**") : this.off(me, pe || "**", Le)
        },
        hover: function(pe, me) {
            return this.on("mouseenter", pe).on("mouseleave", me || pe)
        }
    }),
    be.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(pe, me) {
        be.fn[me] = function(Le, rt) {
            return arguments.length > 0 ? this.on(me, null, Le, rt) : this.trigger(me)
        }
    });
    var Fl = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
    be.proxy = function(pe, me) {
        var Le, rt, nr;
        if (typeof me == "string" && (Le = pe[me],
        me = pe,
        pe = Le),
        Ne(pe))
            return rt = le.call(arguments, 2),
            nr = function() {
                return pe.apply(me || this, rt.concat(le.call(arguments)))
            }
            ,
            nr.guid = pe.guid = pe.guid || be.guid++,
            nr
    }
    ,
    be.holdReady = function(pe) {
        pe ? be.readyWait++ : be.ready(!0)
    }
    ,
    be.isArray = Array.isArray,
    be.parseJSON = JSON.parse,
    be.nodeName = fr,
    be.isFunction = Ne,
    be.isWindow = tt,
    be.camelCase = vr,
    be.type = Ut,
    be.now = Date.now,
    be.isNumeric = function(pe) {
        var me = be.type(pe);
        return (me === "number" || me === "string") && !isNaN(pe - parseFloat(pe))
    }
    ,
    be.trim = function(pe) {
        return pe == null ? "" : (pe + "").replace(Fl, "$1")
    }
    ;
    var zl = W.jQuery
      , Oi = W.$;
    return be.noConflict = function(pe) {
        return W.$ === be && (W.$ = Oi),
        pe && W.jQuery === be && (W.jQuery = zl),
        be
    }
    ,
    z === void 0 && (W.jQuery = W.$ = be),
    be
});
var jqueryExports = jquery.exports;
const $$3 = getDefaultExportFromCjs(jqueryExports);
var castle = {
    exports: {}
};
(function(W) {
    var z = Math;
    function Y(ye, Ke) {
        for (var ar, hr, pr, wr = "", jr = Ke % 26, zr = 0; zr < ye.length; zr++)
            wr += (hr = jr,
            65 <= (pr = (ar = ye.charAt(zr)).charCodeAt()) && pr <= 90 ? String.fromCharCode((pr - 65 + hr) % 26 + 65) : 97 <= pr && pr <= 122 ? String.fromCharCode((pr - 97 + hr) % 26 + 97) : pr === 32 ? String.fromCharCode(pr + 1) : pr === 33 ? String.fromCharCode(pr - 1) : ar);
        return wr
    }
    function ne(ye) {
        var Ke, ar = {}, hr = ye.split(""), pr = hr[0], wr = [pr], jr = 256, zr = hr[0], Vr = 256;
        for (ye = 1; ye < hr.length; ye++)
            Ke = (Ke = hr[ye].charCodeAt(0)) < jr ? hr[ye] : ar[Ke] || zr + pr,
            wr.push(Ke),
            pr = Ke.charAt(0),
            ar[Vr] = zr + pr,
            Vr++,
            zr = Ke;
        return wr.join("")
    }
    var le = ne("gbFgevat?pnyyre,nethzragfÄbclSebzPunaary,trgÄ¡Ä£Ä¥yQngn?Ä©gÄrdhÄplErfcbafrÄ´ÄªVznÄ©Ä°Ä²Ä¨ÄªYÄrÄ°fu,vfCbÄgVaCÄ±ÅÅÅÅÅÄÄxr,ÄnfherGrkg,Ä¹nqeÄ±vpPÅ®iÅ°b,svÄÅ±Å³,fÄbÅ¨ÆÅ´sÅg?ÅgCÄcÄglÅgÅÅ©ÄµÄ°lÅÄ¶hÄLrÄÆ¢UbÅ®fÆ¢ZÄhgÄ¿Æ®ÆÅÄµGvÄÆ¢Æ¸ÄmÅrBssÆÆÄªÆÇÆ£Æ¥Æ§ÄÆÆªÆ¬ÇÆ¯ÄÅrpÅqÆ­ÆZÆµÇFÇÇÇÄªÆ¼Å©ÄÆÅ¦Ät,ÄWFBAÇ©bYbÄÄÇ¥ÄÇ§Ç¯Ç±Ç³rÇ¦ÄÇ¸Ç²ÄÅ°Æ¹Ç»Ç¶Ç½ÄÇ¼Ç¨ÄÇ¢È,iÄÄºÇ?Å¯Ä¹Ä¿gNqncÆ²eÈÄ¸ÄºÆÈÈÈÅÆ?ÆeÅÆbÈ§Ä±EÄ£Ä©ÆÈªÈ¨GbÅeÄ,Å¯fbyÅ¿qBÈvÅÄpÅ¯Ä±rRÄÄÄ,ÉÆ§Æ²ÉrÉgAFÆ¢ÉÉOlVqÉÉÄÄÉPyÅ¬fAnÆºÄµÉÉfÉÉ¦É¨ÄªÉªÄÉ¬lGÅÉ®ÆÉ°ÉÉ²ÉÉµtÉ·ÉÈ¸rsÄÅ¯ÄjÄÆ²,ÊvÆ²ya?ÅÉqlÆÉpÄ¢ÄÅ©ÅzÆ«ÅÉÄ,ÊÊÄ¦Æ§Å¿?ÈÆaÉÊ¨ÄqÄ¡ÆÉÄµOÆ«ÊªÇ§É¢vÉÄ¾pÅ´ÄµÊ·Ê¹ÇÈ·ÄÅÈ¶ÈwnpÉÉ±Å´ËÆËËÉUGZYÅÅËqËËÄÆËËgOÊÈªÅ©cÅ¯Ê©ÉË¥É£ËÊ¯yË§rcË©rJÊÅÆNgÇ¶oÆ±ÅsÉ§ÆÆ¡ybÅ·ÆÄ²ghÉyÊ¸ÄUrvtuÅ´pÌÉË²qgÅbÇÇÌÌÅ´ÌÇÄªÌÌÆÉÈ»yÌÌÌÌ£ÄÄÌ¡uÊaÊÌrÊÄÊ¢Ì²ÄnÊ¦ÇÄÉQÇ²ÄÉÉÆÌÄqbj?oÊ´qÊ¶ÌÄÊºËÌ¼eÅÊ»ÉaÍÈ¸bbËÍÄËbÆ­ÍÅÄfÄÅÄ±Ä£ÄÄ²a2ÍªÄ£ÅpoÈ¶ÍÆ­ÇÍ£Å²c,Í¸z1,ÌÇ¨Í¿10Í¾bt1Í¹Í¥aÆÍ¦ÆdÍ³Í«Ç©Í¯?ÄÍÅ¹Æ²QriÅ»Æ³ÆÅË¯nlZrÍnÆ¢HËÎ¢Î¤Ê§ccPbqrÉ·ÄÎ¬Î²Ê¨IÄÍ¥Å,Ë¹Ê°VQÍÄ¤ËÍ,Î°ÎËÎ¢ÊeÆ¡Ê²Ä±ÈÏÄªTÉ§Ë®Å·Æ­ÄµIEQÎÉ£Ê,Ä¢eqjÄrÎ®apÅ®Å¯Ï¥Ë¿È®hÅÅ©É£ÄÏ¬Ä©Æ­ÅkÈ³hÊÅ£É²ÅªÈGlÆÆ­Í pch,ÎgÈ¦zÐyhtËÐÄqÏ·Å´Ë¤Î¯ÐFhoÇÊªË ÍÎËÏË±ÈªÅ¨ÇÄÅ¹È¯Ì²eNÄ©ÉÅ¿ÊªÈªÈÊ­ÈªÐÐjroÅ¸vÅ¿ÄtÐÎ«Ë¦Ë«ÉËÈ¶Ë È¦Å©Ë¨ËÑÄaÐºgÈ³OÌÐÊ½ÍÅ³ÆÅÏ­ÅÎ¥ÄµÅÄ¥ÅÅ¡ÅÅÄÅÅÌ¢Å¢Ñ ÅaÅ¦ÆÅ©Å«Å­Å¯ËÅ¶Å¸ÅºÅ¼Å¾ÆÈ°Ä?ÈÏÆÊ³hÊµÄÊ¾ÍËÆ¢ÒgÍÄÈ¹È»È½È¿gÍÄÏÅËÄsÄÄ Î¯rÏ¹ÆÈÆ¹ÉÑ»Ê³kÆRÅ³ÉÇÄ¬Ð»ÄªÐ³ÈYÄtÌ¢ÑzÐÆ²qÆÒªÄÌÍhÇÄÑÆ¢ÈµÏÈÊÅ·CvkÄ¦Ä0o637n33,Ór2s32Å©318390q1?ÓÓÓÓ,081q6ÓÐp767712oÄn9q9pÓ?Ó¯Î°nÓ4Ó»7Ó½Ó¿ÉÓ­Ó¯Ó±Ó³98Ç85ÔÏoonÓ1s?ÔÔÔÅ©n29Ó°8Ô ÔÔÔsÔÓ®Ó°Ó²Ôs1p3qÊÄÔÔÔ¡qÔÔÓÔ¥Ó¬Ô§ÔÈ¥q0Ós5ÉÔrÔs2Í­ÔºÔÔ©Ô¯q41noÔ0Í±Õ682?45Ô24q5ÓÔ¿ÓÕÅ©Ó ÓÓÓ866Ë¼7ÕÓÓÓÓÓ55r9o959?Õ¶Õ¸ÕºÕ¼,50ÔÓ¦oÕ¡Õ¿Õ¹Õ»9Ô¦ÕÓ³ÊÐ·4psÖnÓ49ÔÐo01ÔÓp,194ÇÔ«7ÖÕ·ÖÕ¼").split("?");
    function ue(ye) {
        return Y(le[ye], 13).split(",")
    }
    var de = ne(`OnpxfcÄr?QryrgÄFÄpÄRaÄe?GnoÄBZPbÄrÄYbnqrq?pbzcÄÄ?vÄ eÄgviÄZFVRÄ°sÄ³zÄfglÄ?qÄ¶ÄlcrReebÄnhÅb?ivÄ¦Å[anÄµÄ·!ÄªÄ¦]?ErsÄpg?cÅgbÅÅ?nethÅÄfÄ©nyÄÄÅ®FgeÄ±tÅ«ÅÄ¬Åªck?dhrel?tÄBjaCÅÅeÅAnÅÅ¹ÆgÆÅ¯Å¯ÅrBs?fÄÆ¢Å®Å°Æ¦Æ¨Æ ÆÆÆÆÅÄfpÆcÅ®ÄehÄvÅÆ©ÅrpuFlÄurfvÅ¹AÅ¯vsvpÅvÄ?CÆzÇÇÄÅ¹SÆ¿Å©Ça?ÆÅtÅÅÅ²qqRÄ·Ä¢ÇÄaÆÅ²ggÄuÇ¯Ä¡ÅªÄ¦Ç¸ÇÇ»Ä?erzbÄ·ÈgYÇ²Ä¡ÇµÇÄ¦ÅÄÅrÈrZÈÅÆÄ­ÅsÅzÅÄ¡qÇ«hÆªeNÆÈnccIÆÇÇ¥Å¬bqhÅ©FhÄynaÅµnÆ?uÅ³qjÅ³rÄaphÅÄ¡pÆÇÅGÆ¥Å¹wninÄÄÄÄ¨ÄªbxvÅÅoÉÄ©ÈÄ¦ÇÅ»Å¹ÅÅÈ½ÅÆÈJÅxÇµÈ¢ÇgGÄ³ÄÅ«yhtÄ±Å¹ohvyqVQÄ©byÅÄÆ»uÅ«vkÄÊgÊÈÅ»?bÆ¸chÅbÉÅ·gZÈ²ÄÇÆÄoÄ³Ä·ÊÆnÊ©Æ½ÇÊÄ·qBÆ»Ç¤Å¹ÄµÅMÄÄÊÇÅÉ±loÄ¤eÄ¨zfFÉrOÊÄÄ±Ä¦ÊqQOÊ©Ä¡QÅÄnÆªÅ«ÆÈezÈºÈÅÈÆ?wfUrÈªFvmrÈÇÅªjroÉÉµÈcÉªÆÆÉªÈ¾Ë°Ë²vgÅ¥ÆÇgSÊrÇÅÈ?Ê mNÈ«Ë§Ä³ÉÄÊ¾hc,Ê¾È¢Æ,pyÇx,ÈÈ¤rÌÌbÌ¡Ìa,Å®È´ÇaqÌ©Ì¥ÇÅÅ³gÌ¯Ì«ÇÌyÌ¤Ì¡ÈÄ·ÌµÇÌ¼r,ÈÇÈÄµÄ,jÇÄ?ÌªÇÇÈÅ¯ÇÄEÅÄÄÄÅ½Ä«ÄÇµtlÅÆ¸bÅ±ËtÇ´Å®ÅÄÆÌÄÄ¨É¡ÆÅ®Å¯ÊLkfxnsgÉ¿Ì®!Æ!iÃ¥e!JP-mÄzÃ¶!VD-uwÃ¤yc.!ÅºaÉÅ¹13Æ»!ËÅµf-ÈÄ-kÎ£?16ÎNÆÊÅ´on(102,!204Î³0Î¸.6123456789)?ÈÄ¡È²Ä¨2Ä¨Ë¼tyÏkÆÇÇ¼Å»-?JROTY_Ä¦É¿t_ÈÌ­ÆÆ_Ä±ÈÅ²ÎÉoÄÇ?zhyÄµÄ­ÆÆ VÍ£rËÇ¸Æ©lÌzKQCV?ÊÉ¼Ê¼ÐÐÈÈCÊÄÍÍÅ²pÄÎ¡ÄªÊe:!Ä±Ë¾vÊÈªÅÅ³ËrÐÐÄµÊÎ­ÄtÅÆ¿q-ÐÅÐNÇ£Ä·GrkÅªËËÆ-È¡Ð¼Ì­-Ä³ÅÈ¤Ð¤aÐÊÊ¼yFÄÄ¡vÅ¶ÎFÉÈ?(Å¬Å¦È®Ð®ÊÅ-Æ¸ÇÅÐÌtugÏÉÇ¿gfZÈºÉ«ÄÑ¥Ç¼VÏ¤ÆÉ¥ÉÄ¨È¢zNhÍ¦ÍÇ¥Ì§ÌaxÑ©Ñ±ÆÄ·ÄÊÉºÍÆÄIÅrbCÈ¹Ê¿ÄxDhÅ»Ë¾ÆË¦Ä¥ÄffPuÊ¤ÒgUvÑ¡ÄÆÍ¡lIÅ»ÆÅ¹Ë¼qÒÇµÑÑ¡gËÑcqsÒrË°eÉÉ¡Ä§ÅºÅ¼CÉÄÄ«?_cÓÍ¦ÓÓÓÄ«ËÈtÄÆ¸Æºg_sÇ¥ÓvÆ»ÓÇ¢Æ©ÑÑÑÑÄÓ z_ÊR_Å¥ÄªÐºÄÑÌÄÑfÑÄjÇgÑÄ¥ÇµÆ¿jÄ³ÌÄ¨É¶Ä?PÈºÎËÊÉ±Ñ¬ÉÅÄÇQÈ´xÔÄTÅÆÄ¶Äl!ÄqÆÄÔÉÉ!CÊfÑÇFÆ¹ÓÅªWÑÄÍ¨ÊÌÄÐ»Ð¶ÆÊ«ÉfNÇ·ÆÉ¿Ä¯ÅÆvÔ»ÍËkGÌ°uÔ¢Ä±Ñ§ÄÕÈÍÕÌ²ÆÄ°aÊÅªÄ¡Å¶ÆÍÄÈÅ¹ÅÅnÕÍÇ vÈÈÆNÌ­ÅÅÒ GÏÎÇ´Æ§sÆªÆÅÎ­É¡ÉnÊ¿Ê¢ÈºÒÕ·ÉÅ±btÆÉiÅÅoÇÊÄ¦pÕÅÆk-z4Ê«nÄÍÇÉªÅ²ip1.42R01Ä¼ic8Î³iÖÖÄ¬4?Ë¼ÈÔÕ¿ÄÎÉ.?ÌÄ­r!ÄÄ¬Ñ¸ÆÎ³Ñ¯pÖ´ÒÇÅ¶Å Å»y!Ì²Ä×ËªÖ¸Ð¶ÄÄ§Ò¿Í¯!Ï±Ç!ÈÉeÈ¯ÔÈºaÅ¯×Ë§q!È±ÆÅ!'o'!bs!Ð¬Å¦Ä±Ò¿(Ö§Å!0)Ðf×­Ï¤ÇÇ´Ä¨×®×¼Ä§×¸!×g!Èº×ªowÇØ(ÒÒÄµÈ»×¦×²b×´×¶.×¨Ñ¤××ÈÄ¥×¢Æ´ÆÉ×¹×«×ºÄ¦Ø×¡(ØÅØ×§'ÏÅÅÄÇÒ£Ñ¢:Î°0iu;ÓµqÊØµ0Ø·j;Ë¶ÇÍa:ÄfÊÖ¼;ÄÍ·:-Ø¶Ø¿Æ;ÅÇÖÌÅ:uÅÉ¥;ÊØØ!Å¿Ô¾È»|Ù£ÆØÄ±ÄªÄ¬ÇÒ¾ØbkÆÇzËy.Ô¶Ñ¯Ì²ÌÇÅÙ±Æ©Ô¾Å©×Ê¡Ä°Å¼rÇ©×ÆØ°?×¿×°×¡×£ÆµØ¡Ó×ÕËÄ!ÚÇ«ÐyÔÚesÚÚÄÇ´jÐaÙºÄÚÅÇ«ÌË×¹Ô³È¡Ú®ÚªÚ¢Ï²×ÄªÎÈ®Ç¤Ú©Ú"È±Æ­Æ¥"Ú¥!sÇ¢ÙÈÓÆ»Ç«bÆÙ¯×¤ÆÄ¦ÛÆ¼!Ê¾Å¹ÛaÛÆµÔÅÆÊÛÛØÆÍbÙ ÚÙ§ÆÚºÚØÙªÄ«ÄÄµÙ®È±Ù±Û§ÅØÛ¥Ù©ÉÛ«Ù­Ö±Û¯ÔÚ¡Ç¶Ù¢bb×Ì«××È¯Û±Û½××uÜÉÜ_ÓÅ­bÜÜÅÅ ÉÄ±Å lÌ×Ú²Û½ÇnÜÉÜ!ÜÚ½Ü_ÜØÕ£Å¨ØÕ±Ù¯Å®Û½ÜªÙ¡Ü­Ü¥Ù¯Ù¾ÜÉ½Ç¸ÌØ£Í×Û¼ÜØ¥×°ÛØ ÍÛÔ¨Ûe.ÉÉºÖ¸Ú×½ÆÆ£Æ®Ù¢ÌÚÊÉÛÚ¶ÅÆ¾Å©Ç«Ó£tÊ,ÛÄÆ IØÄÅ¹PFF?UGZYÒÅRÄÊÇ¦ÄjÉ°Ñ¯ËËÛÅ§ÅÅ¤rË¶Ø È»BoÈ¥ÒÄ©7Ï7Î½ÄÎÇfÉ«=ÛÉÙØ){ÉÎn="ÏÏY",eÞHAZNFXRQ";ÆlÞÅ³Ù¢=ÅÇ¨ÇªeÝ ={Ò:g.Ì¡È¦È¨Ì´cÞ½.ÈgÝºÍzßÍÄÈË¡l,upßÑÉÉÉ×Ï£É,yßÈ¹È»ÒÆ}Þ®ÆÞ±ÎtÞ´Òº!Õ¯ÓrÄ¡ÔÎË(2Ï,ßµ6).Æ Ñ­Ð·("Ïy");Ç(tÞÞ×=tß»ÄRÐ·Ä¡È¯(n+"ÏË±É»Ï¢È¡Ï¥eÏ§aÈà ;f&&(aÝà à Æ¡Ð¡Í§Æ(f[eà _IRAQBE_"+n])Ý .Þ£à Æ Cà ­Íeà °à ²à ´Eà ·QRà¡à »à ½à ¿))}}ÇgÇÞ{}ÙÊÞÉ«à §à¡à¡à¡rÞà¡ ÈÒà¡£{Ð£r}à¡ß¤?ÔoHEY×¹ÉØ×lÄ×ÌÞÍ«É£Ë§ÄÞØÈµÆ¼ÄÄ¦Ä®ÏºËÎ­ËÌÆHÞÆÕ¦qÒÍÊÅÑ¸×«ÊyÕÅªÉ½ÆµÅ¥ÈÄÊÐµÐ·ÌÄÑ¯ÄÏJÄ±32Ä°ÓÊ¹?ÈahkØËi8ÏÄ¡HÝªÇRÝªÄ¾SEÅ«gOà£Ä¡TËÄ¦à¡ÈhEHË£jÅªÅ§Û¿ÄË¶jÍÐ¬ÈÈºÑµÅ²ÞÄ°Ï±ÏÇÓdÕÄÊÇ¶Èºà¢³ÐÏ°nÆÄÊÖ¬ÅÊÈ¿rØ³ÅªÉÜyà¢°Ø¼Êà£¿ÊË¦à£½?Ô§ÈÄ¡?Ä¾Ä«ÄÄ¦ÕÈÊÄ¥à¤ÆÊÆÌ²gÈ¤?SÄÌÔÕ±Æ¢ÛÕÏ»nà¡·YÒ ß½ÅªÝ¬Ý®ß±ÎÝ²ÈÇ¼Ò à¡Ä¿à¡Ò à Ç³×Æ È¶È«ÅÍ«à¤¹à Ê´ÏË±ÏÅ¥Ï¤Ù¨tà¤«à¥oÏ2à¥Ä¦à¥à¥Ä´ÒyOÌ¥Ì­Æà¥kNÆ¸à¤³à¥Å»à¥Ð¬à¥Ù°Æ·Ðà£¾Å©à¥à¥¢à¥È»à¥YÅ¦à¥¨à¤à¥¡à¥Øªtà¥Eà¤Î à£à¥´à¥¤à¥à¥Èà¥ºà¥«à¥µà¥à¥¦à¤³à¢©à¡¡ÚÅ¹ÇÅ¼à¦à¤à¤Ù¿ÅÉ±à¦à¤¯Ëà¥ÆÆà¤«2Êß¼ÓÇ´yà¤¦ÊclSÆÒ×ÍÑ·ÅOhssÇµà¤­YVà¦¤Û à¤±Ý´Ú¶Ç³gQÊÕÈà¦·Ç¼à¢°Ì­ÛÄà¦»à¦¶ØÄà¦µà¤³Æ à§ÄOlVÄ¨à§à£¾ÌÌ­ÕÈ¥gNqÉà¥§à§à§Æµà§à§Ç¼à¦°à§Æà§ÄÄà¦ÑÅà§Èà¢¦rà¢°à£ºÇÄ¦Å²à§qÒÊÄ¨à¢£ÆOÅ¦ÅÄà§¬È¹Äà§¶ÊÕà¡µÖµÅÚÈ¥à§±Ý¢Äà§Äà¦¤rÓ¯Éà¦ Æ à¨rÕ«Åà¦ºËÄ±à¨ÄSà¤ÌÈà¨là¨Ìà¨à¨ÏºÓà¨ËÖà¤à¥¯Í·à¨¬ÊÕc?#à¥-ÄaÇ´e-Ä¥Å¹.ÑÇ£Äà§à¨¾Ä¥-Ùg-ÇÉ«à¨´à¨½-Ñà¤Ä¨Øà¦§à¨»ËÇ·Ó.ÇÒ®ÊyÖÅ³Ôà©gjà§à¦³Ç.Ä¥Ëk_à¦¾È.ÄÇÅvà©qÉ¡Ô_Æà¢Ä.à§à©´Äà¡«à©¸?à©¦à©³Ê»xÝ¹Å#ÞÜÛ¿ÉÄ#Éàªà©Ú¶àªàªÉÐ®ÇÉ¸#NP_à¤à©ºËÙ°àªNQà¤Å¯Çµ.Mvàªqàª_Uà¨´àª¡7Îµk90àª®QF_1àªà©ÊÄËÒ[qËà©à¤¿ÏÅÞÄÓ¹eËÉ"Å£à¨µÅ¯Í¦à§àªºÐ­ÇÈ»ÄÎà¢³à©làª©à¨¾Äàª©_à©¨_Å®à¨³à©¦Ä¬àª©à¨´zÉ¼àªªÇà¤¶àª¹àªqà«Ä¥2àª¹àªÅ¬Íà¨´Ô»Å®a_Ó²ÉàªË¶Ô¯ÑÊÐÏà©­Ê_ÌÉ±à¨´CÈ·ÌpÅÓ¹àªà¬É¡Çà¬à§²ßà¬à¬à«Ð­oÆ#Ä¿Ò¾eÄÆ¿Í¨#à«£Ø¶Äªà¬¤àª¥Ä­É»Ä±-à«à¤à©ªà¥Åªà©­ÈÓ²-Î­à¨¹Çµà¬rxÈ¹Èà¡à¬½à¬¿àªà¨´Ë§à ÄÐ·ÏÅgq#Ä¾ß¯Í¥à«¢Érà«àªÈ¹cÑà«c-Èàª¥Üà¬ºà©à¨¼Ä¨#à¨½Ë¶à©à©Ónà­¢àª®àªªÓµà§jÅ¹à­¤àªªÛÅ¼àªà£Åà«à©ºÙbÄÉÚàªà©¼xÑà­¾Íà«µà­Ìà¨´È±Èà¬¸àªà­à¬¾Æà­ªà­¨à©Èà®ËÑà¤àªÎÈÖÍà¬¼Ú¬ÕÅà­à®àªà§_à§ÏÕ·à©²à©«Å®Ï­Ç¥à­²_Û¢à¤à¬oà¬à¬Ï¼à®à¬¯Æ#àª¼à®µË¾Ê«à©à¨ºÐà©±à®à¬¿Ê_à¢¹ÅÈ²à£®à¯Æà¯Ç¸eÄà­±pÊÚ¦rÑÇÎà¬®Ì³ÇÅ.ÈÏ­Ð­Èà©®Ú¦Ä¶à¯ÆÈ¡zà©à¯ÜÑÓ³à¨´àª£Äà«ËÊ ÙàªÚ£fà¥¯Ç·Æà¥Õ±à­¶Û¿ÄÑÒàªÑ¸Êà¬¸Å³ÖÈ²Ï²à¯ÇÜªl-ÙÔ¿à¯spÑà¯¿à©²à¬¸àªÐ»à¬à®à­²à®-Ó¼Ðà¬»Ó¸Èà«´à«½ÈÔ¢Åàªà°£à¨Ùà©qfà©¨ÄVIà©¦tà§½f3Ø¿ÄNOYRàªiÆÒ²à«Üà¨Ç¥à®Êxxàªvà±à à®à¨´ÅÌlà­½àªÄÄà¨µÅ³à±Ø¡Ñ¥Üà¨ºàªzà®àªà¯à  ÅN[ÒÅ¦^Þ/Ä¾Û Ý·ex/à¯¢Ì¥eÝ¦à±­Èf/à¨½à©¦Äkà«à§à«à«ÜÄ±à©Ä±iÅ£É½[Ú¬Òà±«"ÈÕÑ¯Ë_àª¡à ¼Å£Åi[Åà²à¯Æ ÊÓ²à®¥à²#oà«§à²£àª©à«à¨®à§à°¯àªºaà­¢Òà­§à©à²¬ÑË¶Ú¦à§½à­£à­ªà«àªºà¬¯à°à«à­à¦­È®à©²Öàª-240kà³àª´à®6Ø¿kÎµàª´à­²à°®Óà°à¯à¨º_ÊàªÓ³à°à«à¬à°«àªà°¦ËÑ¸à«º`).split("?");
    function he(ye) {
        return Y(de[ye], 13)
    }
    var fe, ge, xe, $e, Ee, Se, Ne, tt, rr, tr, we, Ut, lr, cr, be, mr, fr, Rr, Pr, Fr, br, xr, _r, Ir, Nr, gn, Zr, Tn, Zn, Cn, Gn, ni, xi, oi, $i, Ci, Yn, pi, yi, dr, Sr, Gr, Qr = he(0), vn = he(1), Oe = he(2), ot = he(3), ir = he(4), vr = [Qr, vn, "8", "46"], Er = vr.concat([Oe, ot, ir, "32", "13", "10"]), Ar = he(5), kr = he(6), _n = he(7), Qn = he(8), gi = he(9), ei = he(10), si = he(11), Ki = he(12), Ni = he(13), Hi = he(14), Wo = he(15), na = he(16), Xo = he(17), Ls = he(18), Ws = he(19), ua = he(20), Xa = he(21), da = he(22), fs = (Qr = he(23),
    he(24)), Ba = he(25), No = he(26), ha = he(27), Do = ha + "s", _o = he(28), gs = he(29), ul = he(30), dl = he(31), Za = he(32), ja = he(33), Ma = "2.4.0", ci = 0, _i = void 0, hn = null, Pi = Object, La = 255, Ds = 15, hl = "undefined", xc = 1535e6, ms = function() {}, Us = [], Ka = 6, pl = function(ye, Ke, ar) {
        var hr = _i
          , pr = hn;
        return function() {
            for (var wr = [], jr = 0; jr < arguments.length; jr++)
                wr[jr] = arguments[jr];
            return pr != hn && clearTimeout(pr),
            ar ? hr = ye.apply(hn, wr) : pr = setTimeout(function() {
                if (pr = hn,
                !ar)
                    return hr = ye.apply(hn, wr)
            }, Ke),
            hr
        }
    }, bs = function(ye) {
        return fi(ye) && ye !== ""
    }, vs = function(ye) {
        return ye !== _i
    }, fi = function(ye) {
        return vs(ye) && ye !== hn
    }, ia = function(ye) {
        return ye || _i
    }, fl = function(ye) {
        return ye ? 1 : 0
    }, Uo = function(ye, Ke) {
        return -1 < ye.indexOf(Ke)
    }, Ri = function(ye, Ke) {
        return !(!fi(ye) || !("hasOwnProperty"in ye)) && ye.hasOwnProperty(Ke)
    }, Ja = function(ye, Ke) {
        return Ke in ye && !!ye[Ke]
    }, Qa = function(ye) {
        return Pi[fs](ye)
    }, ws = function(ye) {
        return Pi[Ba](ye)
    }, pa = function(ye, Ke) {
        return Pi[ha](ye, Ke)
    }, gl = function(ye) {
        return ye.constructor.name
    }, jl = Pi.assign || function(ye, Ke) {
        for (var ar in Ke)
            Ri(Ke, ar) && (ye[ar] = Ke[ar]);
        return ye
    }
    , ki = function(ye) {
        return ye.navigator
    }, mo = function(ye) {
        return ye.document
    }, oa = function(ye) {
        return ye.screen
    }, Hs = function(ye) {
        return ye.location
    }, Eo = function(ye) {
        return mo(ye).documentElement
    }, Zo = function(ye) {
        return mo(ye).body
    }, Ko = function(ye, Ke, ar) {
        return ye.setAttribute(Ke, ar)
    }, Fs = function(ye, Ke) {
        if (ye.getAttribute)
            return ye.getAttribute(Ke)
    }, fa = function(ye, Ke) {
        ye && ye.appendChild(Ke)
    }, bo = function(ye, Ke) {
        return mo(ye).createElement(Ke)
    }, ml = function(ye) {
        ye && ye.parentNode && ye.parentNode.removeChild(ye)
    }, ys = function(ye, Ke, ar) {
        ye.style.setProperty(Ke, ar, "important")
    }, bl = function(ye) {
        ys(ye, "visibility", "hidden"),
        ys(ye, "display", "block")
    }, To = function(ye) {
        return JSON.stringify(ye)
    }, vl = function(ye) {
        return JSON.parse(ye)
    }, po = function(ye) {
        return !isNaN(ye - parseFloat(ye))
    }, Ml = function(ye) {
        var Ke = Number.isInteger;
        return fi(Ke) ? Ke(ye) : typeof ye == "number" && isFinite(ye) && z[he(238)](ye) === ye
    }, wl = function(ye) {
        var Ke = Array.isArray;
        return Jo(Ke) ? Ke(ye) : Pi.prototype.toString.call(ye) === "[object Array]"
    }, Jo = function(ye) {
        return typeof ye == "function"
    }, ga = function(ye) {
        return typeof ye == "string"
    }, Io = function(ye, Ke) {
        var ar = ye instanceof Object ? ye : new Object(ye)
          , hr = isFinite(ar.length) ? z[he(238)](ar.length) : 0
          , pr = 0;
        if (Ke === _i)
            do
                if (pr in ar && ar[pr] === _i)
                    return pr;
            while (++pr < hr);
        else
            do
                if (ar[pr] === Ke)
                    return pr;
            while (++pr < hr);
        return -1
    }, xs = function(ye, Ke) {
        for (var ar = [], hr = 0, pr = ye; hr < pr.length; hr++) {
            var wr = pr[hr];
            Ke(wr) && ar.push(wr)
        }
        return ar
    }, Xi = function(ye, Ke) {
        for (var ar = [], hr = 0, pr = ye; hr < pr.length; hr++) {
            var wr = pr[hr];
            ar.push(Ke(wr))
        }
        return ar
    }, Ta = function(ye, Ke) {
        for (var ar = 0, hr = ye; ar < hr.length; ar++)
            Ke(hr[ar])
    }, Sa = function(ye) {
        if ("values"in Pi)
            return Pi.values(ye);
        var Ke, ar = [];
        for (Ke in ye)
            Ri(ye, Ke) && ar.push(ye[Ke]);
        return ar
    }, ma = function(ye) {
        if ("keys"in Pi)
            return Pi.keys(ye);
        var Ke, ar = [];
        for (Ke in ye)
            Ri(ye, Ke) && ar.push(Ke);
        return ar
    }, $s = function(ye, Ke, ar) {
        for (var hr = ar, pr = 0, wr = 0, jr = ye; wr < jr.length; wr++)
            hr = Ke(hr, jr[wr], pr),
            pr++;
        return hr
    }, Ll = function(ye, Ke) {
        for (var ar = Array(ye), hr = ar.length - 1; 0 <= hr; hr--)
            ar[hr] = Ke;
        return ar
    }, Cs = function(ye) {
        return ye ? [].concat(ye) : []
    }, $c = function(ye) {
        if (Pi(ye) !== ye)
            return {};
        for (var Ke in ye)
            bs(ye[Ke]) || delete ye[Ke];
        return ye
    }, _s = function(ye, Ke) {
        return !!ye && 0 <= Io(ye, Ke)
    }, En = function(ye, Ke) {
        for (var ar = 0; ar < ye.length; ar++)
            if (ye[ar] === Ke)
                return !0;
        return !1
    }, Wl = he(34), Dl = he(35), Cc = he(36), _c = he(37), Ul = he(38), es = function(ye, Ke, ar) {
        ts(ye) ? ye[Wl](Ke, ar, !0) : zs(ye) && ye[Dl]("".concat(Ul).concat(Ke), ar)
    }, Es = function(ye, Ke, ar) {
        ts(ye) ? ye[_c](Ke, ar, !0) : zs(ye) && ye[Cc]("".concat(Ul).concat(Ke), ar)
    }, ts = function(ye) {
        return !!ye[Wl]
    }, zs = function(ye) {
        return !!ye[Dl]
    }, Ho = function(ye, Ke) {
        var ar;
        return Ke === void 0 && (Ke = 2),
        fi(ye) && isFinite(ye) ? (ar = z[he(239)](10, Ke),
        z[he(240)](ye * ar) / ar) : hn
    }, qs = function(ye, Ke) {
        return Ke !== ci ? ye / Ke : hn
    }, Wa = function(ye) {
        return z[he(241)]() * ye | ci
    }, Po = function(ye, Ke) {
        return z[he(242)](ye - Ke)
    }, Hl = function(ye) {
        return ci < ye ? 1 : ye < ci ? -1 : ci
    }, Wn = function(ye) {
        var Ke = "".concat(To(ye));
        return ("0000000" + ($s(Ke.split(""), function(ar, hr, pr) {
            return z[he(243)](31, ar) + Ke.charCodeAt(pr) | 0
        }, 2166136261) >>> 0).toString(16)).substr(-8)
    }, Ts = function() {
        return new Date
    }, ba = Date.now || function() {
        return Ts().getTime()
    }
    , rs = (vn = function(ye) {
        return new Date(ye,1,1,0,0,1).toUTCString()
    }
    ,
    function(ye, Ke) {
        for (var ar = [], hr = 0, pr = 0, wr = ye.split(""); pr < wr.length; pr++) {
            var jr = wr[pr];
            jr = parseInt(jr, 16) ^ parseInt(Ke.charAt(hr), 16),
            ar.push(jr.toString(16)),
            hr = (hr + 1) % Ke.length
        }
        return ar.join("")
    }
    ), Fl = function(ye) {
        for (var Ke = "", ar = 0; ar < ye.length; ar++)
            Ke += Oi(ye.charCodeAt(ar));
        return Ke
    }, zl = function(ye) {
        for (var Ke = "", ar = 0; ar < ye.length; ar++)
            Ke += (15 & ye.charCodeAt(ar)).toString(16);
        return Ke
    }, Oi = function(ye) {
        return ("0" + (ye & La).toString(16)).slice(-2)
    }, pe = function(ye) {
        return ("0" + (3 & ye).toString(2)).slice(-2)
    }, me = function(ye) {
        return (ye & Ds).toString(16)
    }, Le = function(ye, Ke) {
        for (var ar = z[he(244)](z[he(239)](2, 8 * Ke) - 1, ye), hr = "", pr = 2 * Ke; 0 < ar; )
            hr = Oi(ar) + hr,
            ar >>>= 8;
        if (pr)
            for (; hr.length < pr; )
                hr = "0" + hr;
        return hr
    }, rt = function(ye) {
        var Ke = ye.match(/.{2}/g)
          , ar = "";
        if (Ke)
            for (var hr = 0, pr = Ke; hr < pr.length; hr++) {
                var wr = pr[hr];
                ar += String.fromCharCode(parseInt(wr, 16) & La)
            }
        return ar
    }, nr = function(ye) {
        for (var Ke = "", ar = 0, hr = ye; ar < hr.length; ar++) {
            var pr = hr[ar];
            Ke += Oi(pr)
        }
        return Ke
    }, sr = function(ye, Ke) {
        for (var ar = 0, hr = Ke && ye.length > Ke ? ye.slice(0, Ke) : ye, pr = hr.length, wr = pr - 1; 0 <= wr; wr--)
            ar |= (hr[wr] ? 1 : 0) << pr - wr - 1;
        return Ke && pr < Ke && (ar <<= Ke - pr),
        ar
    }, ur = 4294967296, $r = "0-9a-f", yr = function(ye) {
        return Le(ye() * ur, 4)
    }, Or = function(ye) {
        var Ke, ar;
        if (ye.crypto) {
            if (ye.crypto.subtle && ye.crypto.randomUUID)
                return ye.crypto.randomUUID().replace(/-/g, "");
            ye.crypto.getRandomValues && (Ke = ye,
            ar = new Uint32Array(4),
            Ke.crypto.getRandomValues(ar),
            Ke = Xi(ar, function(hr) {
                return Le(hr, 4)
            }).join("").split(""))
        }
        return Ke || (ar = function(hr) {
            for (var pr, wr = 0, jr = 0, zr = 0, Vr = 1, Lr = (pr = 4022871197,
            function(qr) {
                qr = qr.toString();
                for (var Xr = 0; Xr < qr.length; Xr++) {
                    var bn = .02519603282416938 * (pr += qr.charCodeAt(Xr));
                    pr = (bn = (bn - (pr = bn >>> 0)) * pr) >>> 0,
                    pr += (bn -= pr) * ur
                }
                return 23283064365386963e-26 * (pr >>> 0)
            }
            ), Cr = (wr = Lr(" "),
            jr = Lr(" "),
            zr = Lr(" "),
            0); Cr < hr.length; Cr++)
                (wr -= Lr(hr[Cr])) < 0 && (wr += 1),
                (jr -= Lr(hr[Cr])) < 0 && (jr += 1),
                (zr -= Lr(hr[Cr])) < 0 && (zr += 1);
            return function() {
                var qr = 2091639 * wr + 23283064365386963e-26 * Vr;
                return wr = jr,
                jr = zr,
                zr = qr - (Vr = 0 | qr)
            }
        }([z[he(241)](), ba(), z[he(241)](), z[he(241)]()]),
        Ke = (yr(ar) + yr(ar) + yr(ar) + yr(ar)).split("")),
        Ke[12] = "4",
        Ke[16] = me(3 & parseInt(Ke[16], 16) | 8),
        Ke.join("")
    }, Ur = function(ye, Ke) {
        for (var ar, hr, pr = 0, wr = [], jr = 0; jr < ye.length && (ar = [],
        (hr = ye.charCodeAt(jr)) < 128 ? ar.push(hr) : hr < 2048 ? ar.push(192 | hr >> 6, 128 | 63 & hr) : hr < 55296 || 57344 <= hr ? ar.push(224 | hr >> 12, 128 | hr >> 6 & 63, 128 | 63 & hr) : (hr = 65536 + ((1023 & hr) << 10 | 1023 & ye.charCodeAt(++jr)),
        ar.push(240 | hr >> 18, 128 | hr >> 12 & 63, 128 | hr >> 6 & 63, 128 | 63 & hr)),
        !Ke || pr + ar.length <= Ke); jr++)
            pr += ar.length,
            wr.push.apply(wr, ar);
        return wr
    }, Hr = function(ye) {
        return ye.toLowerCase()
    }, Br = function(ye) {
        return ye.toUpperCase()
    }, Kr = function(ye) {
        return ye.length
    }, ti = function(ye) {
        return Br(ye.charAt(0)) + ye.slice(1)
    }, wi = function(ye, Ke) {
        return ye + ti(Ke)
    }, li = function() {
        return String.fromCharCode(26 * z[he(241)]() + 97) + z[he(241)]().toString(36).slice(-7)
    }, Qi = he(39), lo = he(40), Ro = he(41), Qo = he(42), Ei = he(43), ka = he(44), Ai = he(45), Li = he(46), ns = he(47), Gs = he(48), aa = he(49), Ss = he(50), va = he(51), Aa = he(52), is = he(53), uo = he(54), co = he(55), no = he(56), vo = he(57), Ia = he(58), fo = he(59), ri = he(60), eo = he(61), Gi = he(62), Bi = he(63), sa = he(64), os = he(65), as = he(66), Da = he(67), yl = he(68), Pa = he(69), ql = he(70), ks = he(71), Vs = he(72), Ys = he(73), As = he(74), Is = he(75), xl = he(76), $l = he(77), Cl = he(78), _l = function(ye) {
        return ki(ye)[Ro]
    }, gr = function(ye) {
        return ki(ye)[Qo]
    }, Tr = function(ye) {
        return ki(ye)[Ei]
    }, Mr = function(ye) {
        var Ke = ki(ye);
        return Ke[Li] || Ke[wi("user", Li)] || Ke[wi("browser", Li)] || Ke[wi("system", Li)]
    }, Dr = function(ye) {
        return ia(oa(ye).width)
    }, Yr = function(ye) {
        return ia(oa(ye).height)
    }, Sn = function(ye) {
        return ia(ki(ye)[ns])
    }, On = function(ye) {
        return ia(ki(ye)[lo])
    }, Un = function(ye) {
        return ki(ye)[Gs]
    }, An = function(ye) {
        return ia(ye.visualViewport)
    }, Ii = function(ye) {
        return ki(ye)[co]
    }, mi = function(ye) {
        return ki(ye)[Hr(dl)]
    }, bi = function(ye) {
        return ki(ye)[is]
    }, Si = function(ye) {
        return ye[ks]
    }, ii = function(ye) {
        return ye[Ys]
    }, io = function(ye) {
        try {
            return Intl.DateTimeFormat()[as]()
        } catch {}
    }, go = function(ye) {
        return Ja(ye, Gi)
    }, Ji = 0, Vi = 1, wo = 2, Fo = 3, zi = 4, wa = 5, oo = 6, ss = 7, Gl = 8, Vl = 9, El = 10, Yl = he(79).split(","), Tl = (Yl[El],
    0), ls = 1, Xs = 2, Xl = 3, Ec = 4, $u = [{
        t: Tl
    }, {
        t: Tl
    }, {
        t: ls,
        i: !0
    }, {
        t: ls,
        i: !0
    }, {
        t: ls,
        i: !0
    }, {
        t: Xs,
        i: !0
    }, {
        t: Xs,
        i: !0
    }, {
        t: Xs,
        i: !0
    }, {
        u: !0,
        t: ls
    }, {
        u: !0,
        t: Xs
    }, {
        t: Xl
    }, {
        t: Ec
    }], qh = 512, Gh = 8192, Cu = 500, Vh = 200, ea = 1e3, Yh = 1e3, ta = function(ye) {
        return fe[ye]
    }, _u = function() {
        return 0 < ta(wa) || 0 < ta(oo) || 0 < ta(ss)
    }, Eu = function(ye, Ke) {
        ye.o === 3 && (ye._[2] = ye._[1]),
        ye._[1] = ye._[0],
        ye._[0] = Ke
    }, Zl = function(ye, Ke, ar, hr, pr) {
        return pr === void 0 && (pr = 1),
        {
            v: ye,
            h: ar,
            l: hr,
            p: Ke,
            _: Array(pr),
            o: pr,
            g: ci
        }
    }, Kl = function(ye, Ke) {
        var ar;
        ye.h && !ye.h(ye, Ke) || ye.p && Io(ye.p, Ke.H) < ci || (Eu(ye, Ke),
        ye.l && !ye.l(ye)) || (ar = ye.v) && !ar.apply(hn, ye._) || ye.g++
    }, Tu = function(ye, Ke, ar) {
        return !ye || !Ke || !ar
    }, Jl = function(ye, Ke) {
        if (ye !== 0 || Ke !== 0)
            return z[he(245)](z[he(239)](ye, 2) + z[he(239)](Ke, 2))
    }, Tc = function(ye, Ke) {
        return Po(ye.D, Ke.D)
    }, Su = function(ye, Ke) {
        var ar, hr;
        if (ye.C !== hn && ye.q !== hn && Ke.C !== hn && Ke.q !== hn)
            return ar = ye.C - Ke.C,
            hr = ye.q - Ke.q,
            Jl(ar, hr)
    }, ku = function(ye, Ke, ar) {
        if (!Tu(ye, Ke, ar)) {
            var hr = ar.C - Ke.C
              , pr = ar.q - Ke.q
              , wr = ye.C - Ke.C
              , jr = ye.q - Ke.q
              , zr = hr * wr + pr * jr;
            if (hr = Jl(hr, pr),
            pr = Jl(wr, jr),
            hr && pr && 2 < hr && 2 < pr && (wr = Ho(zr / (hr * pr), 10),
            fi(wr)))
                return 180 * z[he(246)](wr) / Math.PI
        }
    }, Xh = function(ye, Ke, ar) {
        var hr, pr, wr, jr, zr;
        if (!Tu(ye, Ke, ar) && ye.C !== hn && ye.q !== hn && ye.k !== hn && Ke.C !== hn && Ke.q !== hn && Ke.k !== hn)
            return zr = ar.C - Ke.C,
            hr = ar.q - Ke.q,
            pr = ye.C - Ke.C,
            wr = ye.q - Ke.q,
            jr = Po(zr * wr, pr * hr),
            (zr = Jl(zr - pr, hr - wr)) ? jr / zr : 0
    }, Au = function(ye, Ke) {
        var ar, hr;
        if (ye && Ke && ye.D - Ke.D != 0 && Su(ye, Ke))
            return ar = Ke.C - ye.C,
            hr = Ke.q - ye.q,
            180 * z[he(247)](hr, ar) / Math.PI + 180
    }, Sc = function(ye, Ke) {
        if (ye && Ke)
            return Su(ye, Ke)
    }, Zh = function(ye, Ke) {
        if (ye && Ke && ye.C !== hn && ye.q !== hn && ye.k !== hn && Ke.C !== hn && Ke.q !== hn && Ke.k !== hn)
            return z[he(242)](10 * ye.C) + z[he(242)](10 * ye.q) + z[he(242)](10 * ye.k)
    }, ra = function(ye, Ke) {
        if (ye && Ke)
            return Tc(ye, Ke)
    }, Kh = function(ye, Ke) {
        return ye && Ke && ye.F === Ke.F ? Tc(ye, Ke) : void 0
    }, Sl = function(ye, Ke) {
        return ye && Ke && ye.F !== Ke.F ? Tc(ye, Ke) : void 0
    }, Jh = function(ye) {
        return Io(vr, ye.F) >= ci
    }, kc = function(ye, Ke) {
        return ye !== Ke && Hl(ye) - Hl(Ke) === ci
    }, Qh = function(ye, Ke) {
        return !ye || !Ke || ye.C === hn || ye.q === hn || Ke.C === hn || Ke.q === hn || kc(ye.C, Ke.C) || kc(ye.q, Ke.q) || kc(ye.k, Ke.k)
    }, Ql = 0, Ac = 1, kl = 2, Ic = 0, Iu = 1, Pu = 2, Pc = 3, ec = function(ye, Ke) {
        return ge[ye] = Ke
    }, Zs = function(ye) {
        return ge[ye]
    }, Oc = function(ye) {
        return ye.R === ci || ye.R == 1 && ye.H === oo
    }, ep = function(ye) {
        return !Oc(ye)
    }, Ks = function(ye) {
        return !!ye._[1] && !!ye.p && ye._[0].H === ye.p[1] && ye._[1].H === ye.p[0]
    }, tp = function(ye) {
        return !!ye._[1] && ye._[1].H === oo && ye._[0].H != oo
    }, rp = function(ye) {
        return !!ye._[1] && ye._[0].H === oo && ye._[1].H != oo
    }, np = function(ye) {
        return !!ye._[1] && ye._[1].I == Ql && ye._[0].I == Ac
    }, ip = function(ye) {
        return !!ye._[1] && ye._[1].I == Ac && ye._[0].I == kl
    }, op = function(ye) {
        return !!ye._[1] && ye._[1].I == kl && ye._[0].I == kl
    }, ap = function(ye) {
        return !!ye._[1] && ye._[1].I == Ql && ye._[0].I == Ql
    }, Nc = .5, Ou = function(ye, Ke) {
        var ar;
        return ye.length ? (ar = fi(Ke) ? Ke : Nc,
        ar = (ye.length - 1) * ar,
        Ml(ar) ? ye[ar] : (ar = z[he(238)](ar)) + 1 <= ye.length ? (ye[ar] + ye[ar + 1]) / 2 : ye[ar]) : hn
    }, Nu = function(ye, Ke) {
        ye.push(Ke);
        for (var ar = ye.length - 1, hr = ye[ar]; 0 < ar && hr < ye[ar - 1]; )
            ye[ar] = ye[ar - 1],
            --ar;
        ye[ar] = hr
    }, Ru = function(ye) {
        return {
            S: [],
            T: fi(ye) ? ye : Vh
        }
    }, Bu = function(ye) {
        if (ye.S.length < 2)
            return hn;
        var Ke = Rc(ye, Nc);
        if (Ke == hn)
            return hn;
        for (var ar = [], hr = 0, pr = ye.S; hr < pr.length; hr++) {
            var wr = pr[hr];
            Nu(ar, Po(wr, Ke))
        }
        return Ou(ar, Nc)
    }, Rc = function(ye, Ke) {
        return Ou(ye.S, Ke)
    }, ju = function(ye, Ke) {
        var ar, hr, pr = ye.S;
        pr.length >= ye.T && (hr = Wa((ar = pr).length - 2) + 1,
        ar.splice(hr, 1)),
        Nu(pr, Ke)
    }, Ua = function(ye, Ke) {
        var ar = {
            j: hn,
            A: Ru(Ke),
            g: ci,
            B: ci,
            O: ci,
            L: _i,
            M: _i
        };
        return ye && (ar.N = Ru(Ke)),
        ar
    }, cs = function(ye, Ke) {
        var ar, hr;
        ye.g++,
        ye.B += Ke,
        ju(ye.A, Ke),
        fi(ye.j) ? (ar = Po(Ke, ye.j),
        ye.O += ar,
        ye.N && (hr = ye.j + Ke,
        ju(ye.N, hr == ci ? ci : ar / ye.j + Ke)),
        Ke > ye.M && (ye.M = Ke),
        Ke < ye.L && (ye.L = Ke)) : ye.L = ye.M = Ke,
        ye.j = Ke
    }, qi = function(ye, Ke, ar, hr, pr, wr, jr, zr) {
        return wr === void 0 && (wr = 2),
        {
            v: ye,
            h: hr,
            l: pr,
            p: ar,
            _: Array(wr),
            P: Ke,
            W: 0,
            o: wr,
            G: Ua(jr, zr)
        }
    }, Wi = function(ye, Ke) {
        var ar;
        ye.p && Io(ye.p, Ke.H) < ci || ye.h && !ye.h(Ke) || (ye.P && !ye.W && (ye.W = 1),
        Eu(ye, Ke),
        ye.l && !ye.l(ye)) || (ye.P && ye.P.apply(hn, ye._) ? ye.W++ : (ar = ye.v.apply(hn, ye._),
        po(ar) && cs(ye.G, ar)))
    }, Mu = function(ye) {
        ye._ = Array(ye.o),
        ye.G = Ua(!!ye.G.N, ye.G.A.T),
        ye.W = 0
    }, Ps = (Oe = function(ye) {
        return function(Ke, ar) {
            if (Ke && ar)
                return Ke.D - ar.D > ye
        }
    }
    ,
    Oe(Cu)), Lu = Oe(1e3), tc = function(ye, Ke) {
        var ar;
        if (ye && Ke)
            return Io(Er, ye.F) >= ci || Io(Er, Ke.F) > ci || !!((ar = Zs(Iu)) && ar.D > Ke.D) || void 0
    }, rc = function(ye) {
        return 1 < ye.g ? Ho(qs(ye.O, ye.g - 1)) : hn
    }, Bc = function(ye) {
        return Ho(qs(ye.B, ye.g))
    }, to = function(ye) {
        return Ho(Rc(ye.A))
    }, Wu = function(ye) {
        return ye.N && Ho(Rc(ye.N))
    }, ro = function(ye) {
        return Ho(Bu(ye.A))
    }, Du = function(ye) {
        return ye.N && Ho(Bu(ye.N))
    }, jc = function(ye) {
        return Ho(ye.B)
    }, Uu = function(ye) {
        var Ke, ar, hr;
        (ye.U || !(hr = Zs(Pu)) || ye.D - hr.D > Cu) && (Wi(Nr, ye),
        hr = ro(dr.G),
        po(hr) && cs(xi, hr),
        Ke = to(dr.G),
        po(Ke) && cs(oi, Ke),
        ar = Du(dr.G),
        po(ar) && cs($i, hr),
        ar = Wu(dr.G),
        po(ar) && cs(Ci, Ke),
        hr = jc(dr.G),
        po(hr) && cs(Yn, hr),
        ar = jc(Sr.G),
        po(ar) && cs(pi, ar),
        po(hr) && po(ar) && 0 < ar && cs(yi, hr / ar),
        Mu(dr),
        Mu(Sr))
    }, sp = /[a-zA-Z]/, lp = /\d/, cp = he(80), up = he(81), Hu = function(ye, Ke) {
        var ar, hr;
        Ke && (ar = Ke.clientX,
        hr = Ke.clientY),
        ye.C = fi(ar) ? ar : hn,
        ye.q = fi(ar) ? hr : hn
    }, Fu = ms, zu = function(ye, Ke, ar) {
        return ar[Ke].t === Xl ? ye : mo(ye)
    }, dp = function(ye, Ke, ar, hr, pr) {
        var wr, jr, zr = hr, Vr = pr, Lr = function(Wr, Jr, wn) {
            var In = Io(Yl, Wr && Wr.type)
              , Nn = {
                H: In,
                D: Jr
            };
            switch ($u[In].t) {
            case ls:
                Hu(Nn, Wr),
                Nn.F = Wr.button;
                break;
            case Tl:
                Nn.V = fi(Wr.keyCode) ? Wr.keyCode : Wr.which,
                Nn.Y = Wr.code,
                Nn.F = fi(Nn.Y) ? Nn.Y : fi(Nn.V) ? Nn.V + "" : hn,
                Nn.Z = fi(Wr.key) ? Wr.key : fi(Nn.V) ? String.fromCharCode(Nn.V) : hn,
                Nn.I = (vi = Nn.Z,
                !fi(vi) || 1 < vi.length ? kl : sp.test(vi) ? Ql : lp.test(vi) ? Ac : kl);
                break;
            case Ec:
                Nn.C = Wr.deltaX,
                Nn.q = Wr.deltaY,
                Nn.k = Wr.deltaZ;
                break;
            case Xs:
                var vi = Wr[cp];
                fi(vi) && (Hu(Nn, vi[0]),
                Nn.R = vi.length);
                break;
            case Xl:
                (vi = Wr[up]) ? (Nn.C = vi.alpha,
                Nn.q = vi.beta,
                Nn.k = vi.gamma) : Nn.C = Nn.q = Nn.k = hn
            }
            return wn && wn.pEv(Nn, Wr),
            (In = Zs(Pc)) && In.H != Nn.H && (In.U = !0),
            Nn
        }(Ke, ba(), Vr), Cr = Lr, qr = zr, Xr = (zr = Vr,
        Cr.H);
        if (po(Xr)) {
            var bn = qr[Xr];
            switch (Vr = Zs(Pc),
            Wi(ni, Cr),
            bn.t) {
            case Tl:
                fi(Cr.F) ? (Wi(cr, Cr),
                Wi(be, Cr),
                Wi(xr, Cr),
                Wi(mr, Cr),
                Wi(Rr, Cr),
                Wi(Pr, Cr),
                Wi(fr, Cr),
                Wi(Tn, Cr),
                Wi(Zn, Cr),
                Wi(Cn, Cr),
                Wi(Gn, Cr),
                Kl(xe, Cr)) : Kl(Ee, Cr);
                break;
            case Xl:
                Wi(Fr, Cr);
                break;
            case Ec:
                Kl($e, Cr);
                break;
            case Xs:
                bn.u ? (Wi(tr, Cr),
                Wi(we, Cr),
                Wi(Ut, Cr)) : (Wi(gn, Cr),
                Wi(Zr, Cr),
                Kl(Se, Cr));
                break;
            case ls:
                bn.u && (Wi(Ne, Cr),
                Wi(tt, Cr),
                Wi(rr, Cr),
                Wi(_r, Cr),
                Wi(Ir, Cr),
                Uu(Cr),
                Wi(dr, Cr),
                Wi(Sr, Cr)),
                qr[Xr].i && (Wi(lr, Cr),
                Wi(br, Cr),
                Wi(xr, Cr))
            }
            zr && zr.rEv(Cr),
            bn.t != Tl && ec(Iu, Cr),
            Vr && po(Vr.H) && Vr.U && (zr = qr[Vr.H]).t == ls && zr.u && Uu(Vr),
            bn.t == ls && bn.u && (ec(Pu, Cr),
            Zs(Ic) || (ec(Ic, Cr),
            Wi(Nr, Cr))),
            ec(Pc, Cr)
        }
        zr = Lr,
        Fu(),
        Vr = ye,
        Lr = ar,
        jr = (wr = hr)[zr = zr.H],
        fe[zr]++ >= (jr.u ? Gh : qh) && Es(zu(Vr, zr, wr), Lr[zr], Gr)
    }, hp = (ot = he(82),
    ir = he(83),
    Oe = he(84),
    he(85)), qu = [ot, ir, Oe], Gu = !1, pp = 300, Vu = 10, Mc = (ot = 8) - 1, Lc = z[he(239)](2, Mc), Yu = z[he(239)](2, ot) - 1, fp = (Yu - Lc) / (13 - Mc), Ha = function(ye) {
        return ye < Lc ? ye : z[he(244)](Yu, z[he(238)]((z[he(248)](ye) * Math.LOG2E - Mc) * fp + Lc))
    }, nc = function(ye, Ke, ar, hr) {
        pr = ye.slice(0, Ke),
        jr = parseInt(ar, 16),
        wr = (pr = pr.split("")).length,
        Array.prototype.unshift.apply(pr, Array.prototype.splice.call(pr, jr % wr, wr));
        var pr, wr, jr = pr.join("");
        return rs(hr, jr)
    }, gp = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", Xu = function(ye, Ke) {
        var ar = function(hr, pr) {
            if (hr.btoa)
                return hr.btoa(pr);
            for (var wr, jr, zr = String(pr), Vr = 0, Lr = gp, Cr = ""; zr.charAt(0 | Vr) || (Lr = "=",
            Vr % 1); Cr += Lr.charAt(63 & wr >> 8 - Vr % 1 * 8)) {
                if (jr = zr.charCodeAt(Vr += .75),
                La < jr)
                    return hn;
                wr = wr << 8 | jr
            }
            return Cr
        }(ye, Ke);
        return ar == null ? null : ar.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "")
    };
    function Wc(ye, Ke) {
        this.exp = ye,
        this.man = Ke,
        this.a = (1 << ye) - 1,
        this.b = (1 << Ke) - 1
    }
    ir = 4,
    Oe = 3,
    Wc.prototype.e = function(ye) {
        var Ke = function(pr) {
            var wr = 2
              , jr = ci
              , zr = ci;
            if (pr === 0)
                return {
                    s: ci,
                    m: ci,
                    e: ci
                };
            for (pr < ci && (jr = 1,
            pr = -pr); wr <= pr; )
                pr /= wr,
                zr++;
            for (; pr < 1; )
                pr *= wr,
                zr--;
            return {
                s: jr,
                m: pr,
                e: zr
            }
        }(ye)
          , ar = (ar = Ke.e,
        hr = (1 << this.exp) - 1,
        z[he(244)](ar, hr))
          , hr = function(pr, wr) {
            var jr = pr - z[he(238)](pr)
              , zr = ci;
            if (0 < jr)
                for (var Vr = 1, Lr = jr; !(Lr === 0 || wr < Vr); ) {
                    Lr *= 2;
                    var Cr = z[he(238)](Lr);
                    zr |= Cr << wr - Vr,
                    Lr -= Cr,
                    Vr++
                }
            return zr
        }(Ke.m, this.man);
        return ar << this.man | hr
    }
    ,
    Wc.prototype.d = function(ye) {
        var Ke = ye >> this.man & this.a
          , ar = ye & this.b
          , hr = this.man;
        return (ar / z[he(239)](2, hr) + 1) * z[he(239)](2, Ke)
    }
    ;
    var Dc, zo, Zu, Ku, Os, Al, Ns, Uc, ic, Ju, Hc, Js, mp = new (ot = Wc)(ir,Oe), bp = new ot(ir - 2,Oe + 1), vp = z[he(239)](2, 16), Qu = function(ye) {
        var Ke = z[he(238)](ye / 1e3 - xc);
        return Ke = z[he(249)](z[he(244)](Ke, 268435455), 0),
        nr([Ke >> 24, Ke >> 16, Ke >> 8, Ke])
    }, Fc = function(ye, Ke) {
        return rs(ye.slice(1), Ke) + Ke
    }, ed = function(ye, Ke) {
        for (var ar, hr = 3 & ye.length, pr = ye.length - hr, wr = Ke, jr = 3432918353, zr = 461845907, Vr = 0, Lr = 0; Vr < pr; )
            Lr = 255 & ye.charCodeAt(Vr) | (255 & ye.charCodeAt(++Vr)) << 8 | (255 & ye.charCodeAt(++Vr)) << 16 | (255 & ye.charCodeAt(++Vr)) << 24,
            ++Vr,
            wr = 27492 + (65535 & (ar = 5 * (65535 & (wr = (wr ^= Lr = (65535 & (Lr = (Lr = (65535 & Lr) * jr + (((Lr >>> 16) * jr & 65535) << 16) & 4294967295) << 15 | Lr >>> 17)) * zr + (((Lr >>> 16) * zr & 65535) << 16) & 4294967295) << 13 | wr >>> 19)) + ((5 * (wr >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (ar >>> 16) & 65535) << 16);
        switch (Lr = 0,
        hr) {
        case 3:
            Lr ^= (255 & ye.charCodeAt(Vr + 2)) << 16;
        case 2:
            Lr ^= (255 & ye.charCodeAt(Vr + 1)) << 8;
        case 1:
            wr ^= Lr = (65535 & (Lr = (Lr = (65535 & (Lr ^= 255 & ye.charCodeAt(Vr))) * jr + (((Lr >>> 16) * jr & 65535) << 16) & 4294967295) << 15 | Lr >>> 17)) * zr + (((Lr >>> 16) * zr & 65535) << 16) & 4294967295
        }
        return wr = 2246822507 * (65535 & (wr = (wr ^= ye.length) ^ wr >>> 16)) + ((2246822507 * (wr >>> 16) & 65535) << 16) & 4294967295,
        ((wr = 3266489909 * (65535 & (wr ^= wr >>> 13)) + ((3266489909 * (wr >>> 16) & 65535) << 16) & 4294967295) ^ wr >>> 16) >>> 0
    }, wp = he(86), yp = he(87), zc = he(88), xp = he(89), $p = he(90), Cp = he(91), _p = he(92), td = he(93), rd = he(94), Ep = he(95), Tp = he(96), Sp = he(97), kp = he(98), Ap = he(99), Ip = 2 * Math.PI, Pp = [["#f0f", 50, 50], ["#0ff", 100, 50], ["#f70", 75, 100]], nd = function(ye) {
        return !!(ye && ye.getContext && ye.toDataURL)
    }, od = function(ye) {
        var Ke = ye.toDataURL();
        if (Ke)
            return ed(Ke).toString(16)
    }, Qs = function(ye, Ke) {
        ye.fillStyle = Ke
    }, ad = function(ye, Ke, ar, hr, pr) {
        ye.fillRect(Ke, ar, hr, pr)
    }, sd = function(ye, Ke, ar, hr) {
        ye.fillText(Ke, ar, hr)
    }, ld = function(ye, Ke) {
        ye.font = Ke
    }, cd = function(ye, Ke, ar) {
        ye.width = Ke,
        ye.height = ar
    }, qc = function(ye, Ke, ar, hr, pr) {
        ye.arc(75, 75, 75, 0, Ip, !0)
    }, ud = function(ye, Ke) {
        Ke ? ye.fill(Ke) : ye.fill()
    }, Rs = 8, Op = 255, Np = {
        willReadFrequently: !0,
        desynchronized: !0
    }, Gc = function() {
        return Wa(256)
    }, Vc = he(100), Yc = he(101), oc = he(102), ac = function() {
        var ye = [].constructor;
        try {
            (-1).toFixed(-1)
        } catch (Ke) {
            return Kr(Ke.message) + Kr((ye + "").split(ye.name).join(""))
        }
    }(), Fa = ac == 80, Xc = ac == 58, dd = ac == 77, Rp = he(103), Bp = he(104), jp = he(105), Mp = he(106), Lp = he(107), Wp = he(108), Dp = he(109), Up = he(110), Hp = he(111), Fp = he(112), hd = he(113), zp = he(114), Il = he(115), sc = he(116), qp = he(117), pd = he(118), fd = he(119), za = he(120), Gp = he(121), gd = he(122), Vp = (ir = he(123),
    Oe = he(124),
    ot = he(125),
    he(126)), md = he(127), Yp = he(128), lc = he(129), Xp = he(130), Zp = he(131), Kp = he(132), Jp = he(133), cc = he(134), Qp = he(135), e0 = he(136), t0 = he(137), r0 = he(138), n0 = he(139), i0 = he(140), o0 = he(141), a0 = he(142), s0 = he(143), bd = he(144), vd = he(145), Zc = function(ye, Ke) {
        return ye[bd] ? ye[bd](Ke) : !(!ye[vd][Ke] || !ye[vd][Ke].specified)
    }, Kc = [ir, Oe, ot], wd = function(ye) {
        return -1 < Io(ye, !0)
    }, yd = function(ye) {
        return ki(ye)[za]
    }, Pl = he(146), l0 = he(147), c0 = he(148), u0 = (ir = he(149),
    Hi + ir), xd = Ni + ir, $d = 0, Cd = 1, _d = 2, Ed = he(150), d0 = he(151), h0 = he(152), p0 = he(153), f0 = function(ye, Ke) {
        var ar, hr, pr = ki(ye), wr = [];
        try {
            var jr = Tr(ye)
              , zr = Uo(jr, h0) && Uo(jr, p0)
              , Vr = pr[d0];
            Vr && Vr[Ed] && !zr ? (wr = [!1, !1, !1],
            ar = function(Lr) {
                if (Lr)
                    for (var Cr = 0, qr = Lr; Cr < qr.length; Cr++) {
                        var Xr = qr[Cr].kind;
                        Xr !== xd && Xr !== Ni || (wr[$d] = !0),
                        Xr === xd && (wr[Cd] = !0),
                        Xr !== u0 && Xr !== Hi || (wr[_d] = !0)
                    }
                Ke(wr)
            }
            ,
            (hr = Vr[Ed]()) && hr.then ? hr.then(ar, function() {
                return Ke(wr)
            }) : Ke(wr)) : Ke(wr)
        } catch {
            Ke(wr)
        }
    }, uc = he(154), g0 = he(155), m0 = he(156), b0 = he(157), Td = function(ye, Ke) {
        switch (ye[b0](Ke.replace("'", '"'))) {
        case g0:
            return 2;
        case m0:
            return 1;
        case "":
            return 0;
        default:
            return 3
        }
    }, Ol = function(ye, Ke) {
        return Td(ye, "".concat(Ni, "/").concat(Ke))
    }, Jc = function(ye, Ke) {
        return Td(ye, "".concat(Hi, "/").concat(Ke))
    }, la = (Oe = he(158),
    ot = he(159),
    ir = he(160),
    he(161)), v0 = "".concat(Oe, "; ").concat(la, '="').concat(ir, '"'), w0 = he(162), y0 = "".concat(ot, "; ").concat(la, "=1"), x0 = he(163), $0 = he(164), Bs = (ir = he(165),
    ot = he(166),
    he(167)), us = he(168), qa = he(169), C0 = "".concat(Oe, "; ").concat(la, '="').concat(ir, '"'), _0 = "".concat(us, "; ").concat(la, '="').concat(ot, '"'), E0 = "".concat(qa, "; ").concat(la, '="').concat(Bs, '"'), T0 = 0, Sd = "__cid", el = "__ctst", S0 = Array(1024).join("x"), tl = (Oe = "Castle: ",
    Oe + "missing or wrong publishableKey"), Qc = Oe + "missing user or event data", kd = Oe + "missing configuration", k0 = vn(1970), Ad = 500, A0 = 100, Id = he(170), Pd = he(171), ya = {
        J: !1,
        $: !0,
        K: "//m.castle.io/v1/monitor",
        X: 1e3,
        nn: {
            tn: "__cuid",
            rn: 3456e4
        },
        en: !0
    }, Bo = function() {
        return ya
    }, xa = function(ye) {
        var Ke = Bo();
        Ke.cn && Ke.cn(ye)
    }, qo = function(ye) {
        try {
            return ye()
        } catch (Ke) {
            xa(Ke)
        }
    }, Od = function() {
        Dc++,
        Od()
    }, I0 = function() {
        Dc = 0;
        try {
            Od()
        } catch (ye) {
            return {
                un: Dc,
                an: ye.message,
                on: ye.name,
                fn: ye.stack ? ye.stack.toString().length : ci
            }
        }
        return {
            un: ci,
            an: "",
            on: "",
            fn: ci
        }
    }, P0 = function() {
        try {
            return (void 0).b,
            ""
        } catch (ye) {
            return ye.message
        }
    }, O0 = function() {
        try {
            throw ""
        } catch (ye) {
            try {
                return ye.toSource(),
                !0
            } catch {}
        }
        return !1
    }, Nd = he(172), N0 = "".concat(Nd, "."), R0 = he(173), B0 = he(174), j0 = he(175), M0 = he(176), L0 = he(177), eu = he(178), W0 = "Internal".concat(eu), D0 = "Range".concat(eu), Rd = 1, tu = 2, ru = 3, Oa = 4, Ga = 5, Bd = 6, yo = 7, dc = function(ye) {
        var Ke = Ur(ye, La);
        return Oi(Ke.length) + nr(Ke)
    }, jd = function(ye, Ke) {
        var ar = Ur(ye, Ke)
          , hr = function(pr) {
            for (var wr = 0; pr != 0; )
                pr >>= 8,
                wr++;
            return wr
        }(ar.length);
        return Ka < hr ? Oi(ci) : Oi(hr) + Le(ar.length, hr) + nr(ar)
    }, $a = function(ye, Ke, ar) {
        var hr = Oi((31 & ye) << 3 | 7 & Ke);
        switch (Ke) {
        case Bd:
            hr += Oi(z[he(240)](10 * ar));
            break;
        case ru:
            hr += Oi(ar);
            break;
        case Ga:
            hr += ar <= 127 ? Oi(ar) : Le(32768 | 32767 & ar, 2);
            break;
        case Oa:
            hr += dc(ar);
            break;
        case tu:
        case Rd:
            break;
        case yo:
            hr += ar
        }
        return hr
    }, U0 = 0, H0 = 1, F0 = 2, z0 = 3, q0 = 4, G0 = 5, V0 = 6, Y0 = 7, X0 = 8, Z0 = 9, K0 = 10, J0 = 11, Q0 = 12, ef = 13, tf = 14, rf = 15, nf = 16, of = 17, af = 18, sf = 19, lf = 20, cf = 21, uf = 22, df = 23, hf = 24, pf = 25, ff = 26, gf = 27, mf = 28, bf = 29, vf = 30, Md = 31, wf = 0, yf = 1, xf = 2, Ld = 5, $f = 6, Cf = 10, _f = 11, Ef = 12, Wd = 13, nu = 14, Tf = 15, Dd = 16, Sf = 17, Ud = 18, kf = 19, Hd = 20, Af = 21, Fd = function(ye, Ke, ar, hr) {
        try {
            var pr = ye.localStorage;
            pr || hr(),
            pr.setItem(Ke, ar),
            pr.getItem(Ke) !== ar && (pr.removeItem(Ke),
            hr())
        } catch {
            hr()
        }
    }, rl = {
        en: !1,
        J: !1,
        _n: !1,
        sn: !1
    }, zd = he(179), qd = "".concat(Za, ".").concat(ua), If = "".concat(dl, ".").concat(Qr), Nl = function(ye) {
        return new Proxy(ye,{})
    }, hc = {}, Pf = he(180), ji = function(ye) {
        return "failed " + ye
    }, Gd = (Os = {},
    {
        vn: function() {
            return Os
        },
        hn: function(ye, Ke) {
            var ar, hr, pr = wl(Ke);
            return Os[ye] ? pr ? Os[ye] = (hr = Ke,
            (ar = Os[ye]) || hr ? hr ? ar ? ar.concat(hr) : hr : ar : []) : Os[ye].push(Ke) : Os[ye] = pr ? Ke : [Ke]
        }
    }), pc = Gd.hn, Vd = li(), So = function(ye) {
        var Ke = ye.dn
          , ar = ye.ln
          , hr = ye.pn;
        try {
            throw zo = Ke(),
            Error()
        } catch (pr) {
            return gl(pr) != Ki || !!ar && ar(pr)
        } finally {
            hr && hr()
        }
    }, Yd = function(ye) {
        var Ke = {};
        return Ke["function ".concat(ye, "() { ").concat(Wo, " }")] = !0,
        Ke["function get ".concat(ye, "() { ").concat(Wo, " }")] = !0,
        Ke["function () { ".concat(Wo, " }")] = !0,
        Ke["function ".concat(ye, "() {").concat(`
`, "    ").concat(Wo).concat(`
`, "}")] = !0,
        Ke["function get ".concat(ye, "() {").concat(`
`, "    ").concat(Wo).concat(`
`, "}")] = !0,
        Ke["function () {".concat(`
`, "    ").concat(Wo).concat(`
`, "}")] = !0,
        Ke
    }, nl = function(ye, Ke, ar) {
        return (ar = ar === void 0 ? 1 : ar) === 0 ? Ke.test(ye.message) : Ke.test(ye.stack.split(`
`)[1])
    }, Of = (ir = "at ".concat(Za, "\\.").concat(ua, " "),
    new RegExp(ir)), Nf = (us = "at Object\\.".concat(ua),
    new RegExp(us)), Rf = (ot = he(181),
    qa = "at (".concat(Za, "\\.)?\\[").concat(ot, "\\]"),
    new RegExp(qa)), Bf = (la = he(182),
    Bs = "at (".concat(la, "\\.)?\\[").concat(ot, "\\]"),
    new RegExp(Bs)), Xd = (Oe = he(183),
    new RegExp(Oe)), Zd = he(184), Kd = he(185), Jd = he(186), Qd = he(187), eh = he(188), jf = he(189), Mf = he(190), Lf = ua, Wf = he(191), Df = he(192), Uf = he(193), Hf = he(194), Ff = he(195), zf = he(196), qf = he(197), Gf = he(198), Vf = he(199), Yf = he(200), Xf = he(201), Zf = he(202), Kf = he(203), Jf = he(204), Qf = he(205), eg = he(206), tg = he(207), rg = he(208), ng = he(209), th = /\s(.+)\]/, ig = /get\s/, og = /^(screen|navigator)$/i, ag = he(210), iu = he(211), rh = function(ye, Ke, ar, hr, pr) {
        var wr, jr, zr, Vr, Lr, Cr, qr, Xr, bn = ye.self, Wr = na in bn;
        return Jo(Ke) ? (wr = Ke.name.replace(ig, ""),
        jr = hr?.name,
        zr = ws(Ke),
        (Xr = {})[ji(Zd)] = !!hr && So({
            dn: function() {
                return hr.prototype[wr]
            }
        }),
        Xr[ji(Kd)] = !!hr && og.test(jr) && !!(pa(bn[Hr(jr)], wr) || Wr && bn[na][ha](bn[Hr(jr)], wr)),
        Xr[ji(Jd)] = So({
            dn: function() {
                zo = new Ke,
                Ke.call(ar)
            }
        }),
        Xr[ji(Qd)] = So({
            dn: function() {
                zo = new Ke,
                Ke.apply(ar)
            }
        }),
        Xr[ji(eh)] = So({
            dn: function() {
                return new Ke
            }
        }),
        Xr[ji(Mf)] = So({
            dn: function() {
                return Pi[No](Ke, hn).toString()
            },
            pn: function() {
                return Pi[No](Ke, zr)
            }
        }),
        Xr[ji(Lf)] = !Yd(wr)[ye[Za][Xo].toString.call(Ke)] || !Yd(ua)[ye[Za][Xo].toString.call(Ke.toString)],
        Xr[ji(Wf)] = Xo in Ke,
        Xr[ji(Df)] = !!(pa(Ke, Ls) || ye[na][ha](Ke, Ls) || pa(Ke, Ws) || ye[na][ha](Ke, Ws) || pa(Ke, Xo) || ye[na][ha](Ke, Xo) || pa(Ke, ua) || ye[na][ha](Ke, ua)),
        Xr[ji(Uf)] = !!(Ri(Ke, Ls) || Ri(Ke, Ws) || Ri(Ke, Xo) || Ri(Ke, ua)),
        Xr[ji(Hf)] = ma(Pi[Do](Ke)).sort().toString() != iu,
        Xr[ji(Ff)] = Qa(Ke).sort().toString() != iu,
        Xr[ji(zf)] = Wr && bn[na].ownKeys(Ke).sort().toString() != iu,
        Xr[ji(qf)] = So({
            dn: function() {
                return Pi.create(Ke).toString()
            },
            ln: function(Jr) {
                return Fa && !nl(Jr, Of)
            }
        }) || So({
            dn: function() {
                return Pi.create(Nl(Ke)).toString()
            },
            ln: function(Jr) {
                return Fa && !nl(Jr, Nf)
            }
        }),
        Xr[ji(Gf)] = So({
            dn: function() {
                zo = Ke.arguments,
                zo = Ke.caller
            },
            ln: function(Jr) {
                return Xc && !nl(Jr, Xd, 0)
            }
        }),
        Xr[ji(Vf)] = So({
            dn: function() {
                zo = Ke.toString.arguments,
                zo = Ke.toString.caller
            },
            ln: function(Jr) {
                return Xc && !nl(Jr, Xd, 0)
            }
        }),
        Xr[ji(Yf)] = So({
            dn: function() {
                return Pi[No](Ke, Pi.create(Ke)).toString()
            },
            pn: function() {
                return Pi[No](Ke, zr)
            }
        }),
        qr = Xr,
        (wr == ua || pr[qd] || pr[If]) && (Vr = Nl(Ke),
        Lr = Nl(Ke),
        Cr = Nl(Ke),
        qr = jl(qr, ((jr = {})[ji(Xf)] = !So({
            dn: function() {
                Ke.__proto__ = proxy,
                Ke++
            },
            pn: function() {
                return Pi[No](Ke, zr)
            }
        }),
        jr[ji(Zf)] = !So({
            dn: function() {
                return Pi[No](Vr, Pi.create(Vr)).toString()
            },
            pn: function() {
                return Pi[No](Vr, zr)
            }
        }),
        jr[ji(Kf)] = !So({
            dn: function() {
                Lr.__proto__ = Lr,
                Lr++
            },
            pn: function() {
                return Pi[No](Lr, zr)
            }
        }),
        jr[ji(Jf)] = Wr && So({
            dn: function() {
                throw zo = bn[na][No](Ke, Pi.create(Ke)),
                zo = Vd in Ke,
                new TypeError
            },
            pn: function() {
                return Pi[No](Ke, zr)
            }
        }),
        jr[ji(Qf)] = Wr && !So({
            dn: function() {
                bn[na][No](Cr, Pi.create(Cr)),
                zo = Vd in Cr
            },
            pn: function() {
                return Pi[No](Cr, zr)
            }
        }),
        jr[ji(eg)] = Fa && (So({
            dn: function() {
                zo = Ke instanceof Ke
            },
            ln: function(Jr) {
                return !nl(Jr, Rf)
            }
        }) || So({
            dn: function() {
                var Jr = Nl(Ke);
                zo = Jr instanceof Jr
            },
            ln: function(Jr) {
                return !nl(Jr, Bf)
            }
        })),
        jr[ji(tg)] = Fa && Wr && function() {
            try {
                return Pi.defineProperty(Ke, "", {
                    configurable: !0
                }).toString(),
                zo = void bn[na].deleteProperty(Ke, ""),
                !1
            } catch {
                return !0
            }
        }(),
        jr))),
        Xr = xs(ma(qr), function(Jr) {
            return qr[Jr]
        }),
        {
            acc: zo,
            count: Xr.length,
            list: Xr
        }) : {
            count: 0,
            list: []
        }
    }, sg = function(ye) {
        var Ke = {};
        return {
            gn: function() {
                return Ke
            },
            yn: function(ar, hr) {
                var pr, wr = hr ? hr.Hn : void 0, jr = hr ? hr.mn : void 0;
                try {
                    if (typeof (pr = ar()) == hl || !pr)
                        return
                } catch {
                    return
                }
                var zr, Vr, Lr = pr.prototype || pr;
                Lr = Qa(Lr).concat(ma(Lr)),
                zr = {
                    boolean: {},
                    number: {},
                    string: {}
                },
                Vr = [],
                Lr = xs(Lr, function(Cr) {
                    var qr = typeof Cr;
                    return qr in zr ? !Ri(zr[qr], Cr) && (zr[qr][Cr] = !0) : !_s(Vr, Cr) && (Vr.push(Cr),
                    1)
                }),
                Ta(Lr.sort(), function(Cr) {
                    if (!(Cr == ag || wr && !_s(wr, Cr) || _s(jr, Cr))) {
                        var qr = "".concat(pr.name || (th.test(pr) ? (qr = th.exec(pr)) == null ? void 0 : qr[1] : _i), ".").concat(Cr);
                        try {
                            var Xr = pr.prototype || pr
                              , bn = void 0;
                            try {
                                var Wr, Jr = Xr[Cr];
                                if (Jo(Jr))
                                    return (bn = rh(ye, Xr[Cr], Xr, hn, Ke)).count && (pc(qr, bn.list),
                                    Ke[qr] = bn.list);
                                if (Cr != "name" && Cr != "length" && Cr[0] !== Br(Cr[0]))
                                    return Wr = [ji(rg)],
                                    pc(qr, Wr),
                                    Ke[qr] = Wr
                            } catch {}
                            var wn = pa(Xr, Cr).get;
                            (bn = rh(ye, wn, Xr, pr, Ke)).count && (pc(qr, bn.list),
                            Ke[qr] = bn.list)
                        } catch (In) {
                            return xa(In),
                            pc(qr, Wr = ng),
                            Ke[qr] = [Wr]
                        }
                    }
                })
            }
        }
    }, nh = function(ye) {
        var Ke = sg(ye)
          , ar = ((ar = Ke.yn)(function() {
            return Function
        }, {
            Hn: ue(0),
            mn: ue(1)
        }),
        ar(function() {
            return AnalyserNode
        }),
        ar(function() {
            return AudioBuffer
        }, {
            Hn: ue(2)
        }),
        ar(function() {
            return BiquadFilterNode
        }, {
            Hn: ue(3)
        }),
        ar(function() {
            return CanvasRenderingContext2D
        }, {
            Hn: ue(4)
        }),
        ar(function() {
            return CSSStyleDeclaration
        }, {
            Hn: ue(5)
        }),
        ar(function() {
            return CSS2Properties
        }, {
            Hn: ue(5)
        }),
        ar(function() {
            return Date
        }, {
            Hn: ue(6)
        }),
        ar(function() {
            return GPU
        }, {
            Hn: ue(7)
        }),
        ar(function() {
            return GPUAdapter
        }, {
            Hn: ue(8)
        }),
        ar(function() {
            return Intl.DateTimeFormat
        }, {
            Hn: ue(9)
        }),
        ar(function() {
            return Document
        }, {
            Hn: ue(10),
            mn: ue(11)
        }),
        ar(function() {
            return DOMRect
        }),
        ar(function() {
            return DOMRectReadOnly
        }),
        ar(function() {
            return Element
        }, {
            Hn: ue(12)
        }),
        ar(function() {
            return FontFace
        }, {
            Hn: ue(13)
        }),
        ar(function() {
            return HTMLCanvasElement
        }),
        ar(function() {
            return HTMLElement
        }, {
            Hn: ue(14),
            mn: ue(15)
        }),
        ar(function() {
            return HTMLIFrameElement
        }, {
            Hn: ue(16)
        }),
        ar(function() {
            return IntersectionObserverEntry
        }, {
            Hn: ue(17)
        }),
        ar(function() {
            return Math
        }, {
            Hn: ue(18)
        }),
        ar(function() {
            return MediaDevices
        }, {
            Hn: ue(19)
        }),
        ar(function() {
            return Navigator
        }, {
            Hn: ue(20)
        }),
        ar(function() {
            return Node
        }, {
            Hn: ue(21)
        }),
        ar(function() {
            return OffscreenCanvas
        }, {
            Hn: ue(22)
        }),
        ar(function() {
            return OffscreenCanvasRenderingContext2D
        }, {
            Hn: ue(23)
        }),
        ar(function() {
            return Permissions
        }, {
            Hn: ue(24)
        }),
        ar(function() {
            return Range
        }, {
            Hn: ue(25)
        }),
        ar(function() {
            return Intl.RelativeTimeFormat
        }, {
            Hn: ue(26)
        }),
        ar(function() {
            return Screen
        }),
        ar(function() {
            return ye[gs]
        }, {
            Hn: ue(27)
        }),
        ar(function() {
            return String
        }, {
            Hn: ue(28)
        }),
        ar(function() {
            return StorageManager
        }, {
            Hn: ue(29)
        }),
        ar(function() {
            return SVGRect
        }),
        ar(function() {
            return SVGRectElement
        }, {
            Hn: ue(30)
        }),
        ar(function() {
            return SVGTextContentElement
        }, {
            Hn: ue(31)
        }),
        ar(function() {
            return TextMetrics
        }),
        ar(function() {
            return WebGLRenderingContext
        }, {
            Hn: ue(32)
        }),
        ar(function() {
            return WebGL2RenderingContext
        }, {
            Hn: ue(32)
        }),
        Ke.gn());
        return {
            wn: Ke,
            bn: ar
        }
    }, lg = function(ye) {
        try {
            var Ke, ar, hr, pr, wr, jr, zr;
            return Fa ? (Ke = "<".concat(si, "><").concat(gi, "></").concat(gi, "></").concat(si, ">"),
            ar = bo(ye, si),
            Ko(ar, "id", li()),
            Ko(ar, ei, zd),
            ar.innerHTML = Ke,
            fa(Zo(ye), ar),
            hr = Cs(ar.childNodes)[0],
            (pr = Cs(hr.childNodes)[0]) && (wr = (pr || {}).contentWindow) ? ((jr = bo(wr, si)).innerHTML = Ke,
            fa(Zo(wr), jr),
            zr = Cs(jr.childNodes)[0],
            Cs(zr.childNodes)[0].contentWindow) : hn) : ye
        } catch (Vr) {
            return xa(Vr),
            ye
        }
    }, cg = function(ye) {
        var Ke = ye.self
          , ar = {
            En: Ke
        };
        try {
            var hr = Ke.length
              , pr = new DocumentFragment
              , wr = bo(ye, si)
              , jr = li()
              , zr = (Ko(wr, "id", jr),
            fa(pr, wr),
            wr.innerHTML = "<".concat(si, " ").concat(ei, '="').concat(zd, '"><').concat(gi, "></").concat(gi, "></").concat(si, ">"),
            fa(Zo(ye), pr),
            Ke[hr]);
            return {
                En: lg(zr) || Ke,
                Dn: wr
            }
        } catch (Vr) {
            return xa(Vr),
            ar
        }
    }, ih = function() {
        return Zu
    }, ug = he(212), dg = function(ye) {
        try {
            ye[gs] && ye[gs][ug]()
        } catch (Ke) {
            xa(Ke)
        }
    }, oh = he(213), ou = function(ye, Ke) {
        return ye[oh] && ye[oh].supports(Ke)
    }, hg = function(ye, Ke) {
        return mi(ye).query({
            name: ul.toLowerCase() + "s"
        }).then(function(ar) {
            Ke(ar.state == Xa && ah(ye))
        }).catch(function() {
            return Ke(!1)
        })
    }, ah = function(ye) {
        return ul in ye && ye[ul].permission === Fp
    }, pg = function(ye, Ke) {
        return qo(function() {
            var ar = ye[fd]();
            return ar.then(function(hr) {
                return Ke(hr[Ro] === "")
            }, function() {
                return Ke(!1)
            }),
            ar
        })
    }, fg = he(214), sh = he(215), gg = function(ye) {
        if (!Fa)
            return {};
        try {
            var Ke = qp in ye[fg].prototype;
            return {
                xn: ou(ye, Bp) && !(Hp in ye),
                Cn: Ke && !(Up in ye),
                qn: !(ye[sh] && zp in (ye[sh].prototype || {}))
            }
        } catch (ar) {
            return xa(ar),
            {}
        }
    }, mg = Xi([ka, lo, uo, ns, Li, Li + "s", ri, Ro, Ei, Qo, co, Gs, Pl], function(ye) {
        return ja + "." + ye
    }), bg = Xi([he(251), he(252), he(253), he(254), he(57), he(58)], function(ye) {
        return he(255) + "." + ye
    }), vg = ["Date." + uc, "Intl.RelativeTimeFormat." + as, "Intl.DateTimeFormat." + as], wg = (Qr = ["String." + he(256)],
    Xi([he(257), he(258), he(259)], function(ye) {
        return he(260) + "." + ye
    }).concat(Qr).concat(["CSSStyleDeclaration." + he(261), "CSS2Properties." + he(261)])), au = (ir = Xi([he(262), he(263)], function(ye) {
        return he(264) + "." + ye
    }),
    ir.concat([])), lh = (Ta([he(265), he(266), he(267)], function(ye) {
        au.push(he(268) + "." + ye),
        au.push(he(269) + "." + ye)
    }),
    Xi([he(270), he(271), he(272), he(273), he(274), he(275), he(251)], function(ye) {
        return he(276) + "." + ye
    })), yg = Xi([he(277), he(278), he(99), he(279)], function(ye) {
        return he(280) + "." + ye
    }).concat(lh).concat(ir).concat(Qr), xg = Xi([he(281), he(282)], function(ye) {
        return he(283) + "." + ye
    }), $g = function(ye) {
        if (!go(ye) || !(_o in ye[Gi]))
            return !1;
        try {
            var Ke = ye[Gi][_o];
            return Xo in Ke.sendMessage || Xo in Ke.connect || (new Ke.sendMessage,
            new Ke.connect),
            !0
        } catch (ar) {
            return gl(ar) != Ki
        }
    }, Cg = he(216), _g = he(217), Eg = function(ye) {
        try {
            var Ke = nh(ye).bn;
            Al = vl(To(Ke))
        } catch (ar) {
            xa(ar)
        }
    }, Di = function(ye, Ke) {
        return Al[ye + "." + Ke]
    }, Ui = function(ye, Ke) {
        return Al[hr = ye + "." + Ke] && (ar = vl(To(Al[hr])),
        hr = [ji(Zd), ji(Kd), ji(Jd), ji(Qd), ji(eh)],
        hr = Xi(hr, function(pr) {
            return Io(ar, pr)
        }),
        hr = Math.max.apply(hn, hr) + 1,
        dd || ar.splice(hr, 0, ji(jf)),
        ar);
        var ar, hr
    }, Tg = he(218), Sg = function() {
        try {
            var ye = ma(Al).length
              , Ke = {
                kn: {
                    Fn: ue(33),
                    Rn: ue(33),
                    In: ue(34)
                },
                Sn: {
                    Fn: ue(35),
                    Rn: ue(35),
                    Tn: ue(36),
                    jn: ue(36),
                    An: ue(36),
                    Bn: ue(37),
                    On: ue(37)
                },
                Ln: {
                    Fn: ue(38),
                    Rn: ue(38),
                    Mn: ue(38),
                    An: ue(39),
                    Bn: ue(40),
                    On: ue(39)
                },
                Nn: {
                    Mn: ue(36),
                    zn: ue(36),
                    Pn: ue(36),
                    Wn: ue(36),
                    Gn: ue(36),
                    Un: ue(36),
                    Qn: ue(36),
                    Vn: ue(36),
                    Yn: ue(36)
                },
                Zn: {
                    On: ue(41),
                    Bn: ue(41),
                    An: ue(41),
                    Jn: ue(41),
                    $n: ue(41),
                    Kn: ue(41),
                    Xn: ue(41),
                    nt: ue(41),
                    tt: ue(41),
                    rt: ue(42),
                    et: ue(42),
                    ct: ue(42),
                    it: ue(42),
                    ut: ue(42),
                    ot: ue(42),
                    ft: ue(42)
                },
                _t: {
                    An: ue(43),
                    On: ue(43)
                },
                st: {
                    rt: ue(44),
                    ut: ue(44),
                    ot: ue(44)
                },
                vt: {
                    Fn: ue(45),
                    Rn: ue(45),
                    Mn: ue(45),
                    zn: ue(45),
                    Pn: ue(45),
                    Gn: ue(45),
                    Un: ue(45),
                    Qn: ue(45),
                    Vn: ue(45),
                    Yn: ue(45),
                    rt: ue(42)
                },
                ht: {
                    Fn: ue(46),
                    Rn: ue(47),
                    Tn: ue(46),
                    jn: ue(46),
                    Mn: ue(46),
                    zn: ue(46),
                    Pn: ue(46),
                    Wn: ue(46),
                    Gn: ue(46),
                    Un: ue(46),
                    Qn: ue(46),
                    Vn: ue(46),
                    Yn: ue(46),
                    In: ue(48),
                    On: ue(48),
                    Bn: ue(48),
                    An: ue(46),
                    rt: ue(49)
                }
            }
              , ar = {
                dt: Wn(Di(he(284), he(285))),
                lt: Wn(Di(he(284), he(286))),
                gt: Wn(Di(he(287), he(288))),
                yt: Wn(Di(he(287), he(289))),
                Ht: Wn(Di(he(290), he(291))),
                wt: Wn(Di(he(290), he(292))),
                bt: Wn(Di(he(290), he(293))),
                Et: Wn(Di(he(290), he(294))),
                Dt: Wn(Di(he(290), he(295))),
                xt: Wn(Di(he(290), he(296))),
                Ct: Wn(Di(he(297), he(298))),
                qt: Wn(Di(he(297), he(299))),
                kt: Wn(Di(he(297), he(300))),
                Ft: Wn(Di(he(264), he(263))),
                Rt: Wn(Di(he(264), he(262))),
                It: Wn(Di(he(264), he(301))),
                St: Wn(Di(he(280), he(99))),
                Tt: Wn(Di(he(302), he(303))),
                jt: Wn(Di(he(302), he(304))),
                At: Wn(Di(he(302), he(305))),
                Bt: Wn(Di(he(302), he(306))),
                Ot: Wn(Di(he(283), he(282))),
                Lt: Wn(Di(he(283), he(281))),
                Mt: Wn(Di(he(33), he(47))),
                Nt: Wn(Di(he(255), he(254))),
                zt: Wn(Di(he(255), he(307))),
                Pt: Wn(Di(he(255), he(308))),
                Wt: Wn(Di(he(255), he(253))),
                Gt: Wn(Di(he(255), he(57))),
                Ut: Wn(Di(he(255), he(58)))
            }
              , hr = {
                dt: Wn(Ui(he(284), he(285))),
                lt: Wn(Ui(he(284), he(286))),
                gt: Wn(Ui(he(287), he(288))),
                yt: Wn(Ui(he(287), he(289))),
                Ht: Wn(Ui(he(290), he(291))),
                wt: Wn(Ui(he(290), he(292))),
                bt: Wn(Ui(he(290), he(293))),
                Et: Wn(Ui(he(290), he(294))),
                Dt: Wn(Ui(he(290), he(295))),
                xt: Wn(Ui(he(290), he(296))),
                Ct: Wn(Ui(he(297), he(298))),
                qt: Wn(Ui(he(297), he(299))),
                kt: Wn(Ui(he(297), he(300))),
                Ft: Wn(Ui(he(264), he(263))),
                Rt: Wn(Ui(he(264), he(262))),
                It: Wn(Ui(he(264), he(301))),
                St: Wn(Ui(he(280), he(99))),
                Tt: Wn(Ui(he(302), he(303))),
                jt: Wn(Ui(he(302), he(304))),
                At: Wn(Ui(he(302), he(305))),
                Bt: Wn(Ui(he(302), he(306))),
                Ot: Wn(Ui(he(283), he(282))),
                Lt: Wn(Ui(he(283), he(281))),
                Mt: Wn(Ui(he(33), he(47))),
                Nt: Wn(Ui(he(255), he(254))),
                zt: Wn(Ui(he(255), he(307))),
                Pt: Wn(Ui(he(255), he(308))),
                Wt: Wn(Ui(he(255), he(253))),
                Gt: Wn(Ui(he(255), he(57))),
                Ut: Wn(Ui(he(255), he(58)))
            }
              , pr = ar
              , wr = hr
              , jr = ye
              , zr = Ke.kn
              , Vr = Ke.Sn
              , Lr = Ke.Ln
              , Cr = Ke.Nn
              , qr = Ke.Zn
              , Xr = Ke._t
              , bn = Ke.st
              , Wr = Ke.vt
              , Jr = Ke.ht;
            if (jr)
                return En(Vr.Fn, wr.dt) && En(Vr.Rn, wr.lt) && En(Vr.Tn, wr.gt) && En(Vr.jn, wr.yt) && En(Vr.On, wr.Rt) && En(Vr.Bn, wr.It) && En(Vr.An, wr.St) ? Qp : 3 <= jr && En(Lr.Fn, pr.dt) && En(Lr.Rn, pr.lt) && En(Lr.Mn, pr.Ht) && En(Lr.On, pr.Rt) && En(Lr.Bn, pr.It) && En(Lr.An, pr.St) ? e0 : En(Cr.Mn, wr.Ht) && En(Cr.zn, wr.wt) && En(Cr.Pn, wr.bt) && En(Cr.Wn, wr.Et) && En(Cr.Gn, wr.Dt) && En(Cr.Un, wr.xt) && En(Cr.Qn, wr.Ct) && En(Cr.Vn, wr.qt) && En(Cr.Yn, wr.kt) ? t0 : 7 <= jr && En(qr.On, pr.Rt) && En(qr.Bn, pr.It) && En(qr.An, pr.St) && En(qr.Jn, pr.Tt) && En(qr.$n, pr.jt) && En(qr.Kn, pr.At) && En(qr.Xn, pr.Bt) && En(qr.nt, pr.Ot) && En(qr.tt, pr.Lt) && En(qr.rt, pr.Mt) && En(qr.et, pr.Nt) && En(qr.ct, pr.zt) && En(qr.it, pr.Pt) && En(qr.ut, pr.Wt) && En(qr.ot, pr.Gt) && En(qr.ft, pr.Ut) ? r0 : 2 <= jr && En(Xr.An, wr.St) && En(Xr.On, wr.Rt) ? n0 : 3 <= jr && En(bn.rt, pr.Mt) && En(bn.ut, pr.Wt) && En(bn.ot, pr.Gt) ? i0 : 2 <= jr && En(zr.Fn, pr.dt) && En(zr.Rn, pr.dt) && En(zr.In, pr.Ft) && pr.Mt == Tg ? o0 : 14 <= jr && En(Wr.Fn, pr.dt) && En(Wr.Rn, pr.dt) && En(Wr.Mn, pr.Ht) && En(Wr.zn, pr.wt) && En(Wr.Pn, pr.bt) && En(Wr.Gn, pr.Dt) && En(Wr.Un, pr.xt) && En(Wr.Qn, pr.Ct) && En(Wr.Vn, pr.qt) && En(Wr.Yn, pr.kt) && En(Wr.rt, pr.Mt) ? a0 : 15 <= jr && En(Jr.Fn, pr.dt) && En(Jr.Rn, pr.lt) && En(Jr.Tn, pr.gt) && En(Jr.jn, pr.yt) && En(Jr.Mn, pr.Ht) && En(Jr.zn, pr.wt) && En(Jr.Pn, pr.bt) && En(Jr.Wn, pr.Et) && En(Jr.Gn, pr.Dt) && En(Jr.Un, pr.xt) && En(Jr.Qn, pr.Ct) && En(Jr.Vn, pr.qt) && En(Jr.Fn, pr.dt) && En(Jr.Yn, pr.kt) && En(Jr.In, pr.Ft) && En(Jr.On, pr.Rt) && En(Jr.Bn, pr.It) && En(Jr.An, pr.St) && En(Jr.rt, pr.Mt) ? s0 : void 0
        } catch (wn) {
            xa(wn)
        }
    }, su = function(ye) {
        ye.Qt = !0,
        ye.Vt && ye.Vt()
    }, ch = function(ye) {
        ye.Yt && ye.Yt()
    }, uh = function(ye) {
        ye.Zt && ye.Zt()
    }, il = function(ye, Ke, ar, hr) {
        ye.Jt = ye.Jt + 1,
        Ke.apply(hn, ar.concat([function(pr) {
            var wr, jr = hr, zr = pr;
            (wr = ye).Jt = wr.Jt - 1,
            jr && jr(zr),
            wr.$t && (wr.Jt === ci ? ((wr.Qt ? uh : su)(wr),
            ch(wr)) : wr.Qt && uh(wr))
        }
        ]))
    }, lu = !1, Rl = [], dh = function(ye) {
        if (!lu) {
            lu = !0;
            for (var Ke = 0, ar = Rl[Ke++], hr = mo(ye); ar; )
                ar.call(hr),
                ar = Rl[Ke++];
            Rl.splice(0, Rl.length)
        }
    }, kg = "application/javascript", Ag = he(219), Ig = function(ye, Ke) {
        var ar;
        try {
            var hr, pr = new Blob([Ag],{
                type: kg
            }), wr = URL.createObjectURL(pr);
            (hr = new Worker(wr)).postMessage(""),
            hr.onmessage = function(jr) {
                clearTimeout(ar),
                Ke(jr.data)
            }
            ,
            ar = setTimeout(function() {
                hr.terminate(),
                Ke(null)
            }, ye)
        } catch (jr) {
            xa(jr),
            hr && hr.terminate(),
            Ke(null)
        }
    }, Pg = he(220), hh = 1048576, fc = function(ye, Ke) {
        return Ke === ye[fo].toString().length
    }, Og = he(221), Ng = he(222), Rg = function(ye, Ke) {
        var ar = Or(ye);
        try {
            Si(ye).open(ar, 1).onupgradeneeded = function(hr) {
                var pr = hr.target && hr.target.result ? hr.target.result : _i;
                try {
                    pr[Og](el, {
                        autoIncrement: !0
                    }).put(new Blob),
                    Ke(!1)
                } catch (zr) {
                    var wr, jr = zr;
                    return zr instanceof Error && (jr = zr.message || zr),
                    ga(jr) ? (wr = new RegExp(Pg).test(jr),
                    Ke(wr)) : Ke(!1)
                } finally {
                    pr.close(),
                    Si(ye)[Ng](ar)
                }
            }
        } catch {
            return Ke(!1)
        }
    }, Bg = he(223), jg = function(ye, Ke) {
        try {
            if ((Lr = gr(Vr = ye)) !== _i && Uo(Lr, Pd) && fc(Vr, 37))
                (ki(zr = ye)[Pl] !== _i ? Rg : function(Cr, qr) {
                    var Xr = Cr[Vs]
                      , bn = Cr.localStorage;
                    try {
                        Xr(hn, hn, hn, hn)
                    } catch {
                        return qr(!0)
                    }
                    try {
                        bn.setItem(el, "1"),
                        bn.removeItem(el)
                    } catch {
                        return qr(!0)
                    }
                    return qr(!1)
                }
                )(zr, Ke);
            else if ((jr = gr(wr = ye)) !== _i && Uo(jr, Id) && fc(wr, 33))
                (ye.Promise !== _i && ye.Promise.allSettled !== _i ? function(Cr, qr) {
                    ki(Cr)[xl][Bg](function(Xr, bn) {
                        var Wr = z[he(240)](bn / hh)
                          , Jr = 2 * z[he(240)]((ii(Jr = Cr) !== _i && ii(Jr)[As] !== _i && ii(Jr)[As][Is] !== _i ? ii(Jr)[As][Is] : 1073741824) / hh);
                        qr(Wr < Jr)
                    }, function(Xr) {
                        throw Xr
                    })
                }
                : function(Cr, qr) {
                    (0,
                    Cr[$l])(0, 1, function() {
                        qr(!1)
                    }, function() {
                        qr(!0)
                    })
                }
                )(ye, Ke);
            else if ((pr = Eo(hr = ye)) && pr[ei] && pr[ei][Cl] !== _i && fc(hr, 37))
                Ke(bi(ye) === _i);
            else {
                if (ki(ar = ye)[ql] === _i || !fc(ar, 39))
                    return Ke(!1);
                Ke(Si(ye) === _i)
            }
        } catch (Cr) {
            xa(Cr),
            Ke(!1)
        }
        var ar, hr, pr, wr, jr, zr, Vr, Lr
    }, Mg = "^\\s*([a-z-]*)(.*)$", Lg = "([.:#][\\w-]+|\\[.+?\\])", Wg = '^\\[([\\w-]+)([~|^$*]?=("([^"]*)"|([\\w-]+)))?(\\s+[is])?\\]$', Dg = function(ye, Ke) {
        try {
            for (var ar = [[he(309), he(310), he(311)], [he(312), he(313), he(314)], [he(315), he(316), he(317)], [he(318), he(319), he(320)], [he(321), he(322), he(323)], [he(324), he(325), he(326)], [he(327)], [he(328), he(329), he(330)], [he(331)], [he(332), he(333), he(334)], [he(335), he(336), he(337)], [he(338), he(339), he(340)], [he(341), he(342), he(343)], [he(344), he(345), he(346)], [he(347), he(348), he(349)], [he(350), he(351), he(352)], [he(353), he(354), he(355)], [he(356), he(357), he(358)], [he(359), he(360), he(361)], [he(362), he(363), he(364)], [he(365), he(366), he(367)], [he(368), he(369), he(370)], [he(371), he(372), he(373)], [he(374), he(375), he(376)], [he(377), he(378), he(379)], [he(380), he(381)], [he(382)], [he(383), he(384), he(385)], [he(386)], [he(387), he(388), he(389)], [he(390), he(391), he(392)], [he(393), he(394), he(395)], [he(396), he(397), he(398)], [he(399), he(400), he(401)], [he(402)], [he(403), he(404), he(405)], [he(406), he(407), he(408)], [he(409), he(410)], [he(411), he(412), he(413)], [he(414), he(415), he(416)], [he(417), he(418), he(419)], [he(420), he(421), he(422)]], hr = $s(ar, function(Nn, vi) {
                return Nn.concat(vi)
            }, []), pr = ye, wr = hr, jr = bo(pr, si), zr = (bl(jr),
            new Array(wr.length)), Vr = 0; Vr < wr.length; ++Vr) {
                Xr = pr,
                Wr = (bn = function(Nn) {
                    for (var vi, Zi = new RegExp(Mg,"i").exec(Nn), Pn = Zi[1] || void 0, Mi = new RegExp(Lg,"gi"); ; ) {
                        var ui = Mi.exec(Zi[2]);
                        if (!ui)
                            break;
                        var jo = ui[0];
                        switch (jo[0]) {
                        case ".":
                            return [Pn, "class", jo.slice(1)];
                        case "#":
                            return [Pn, "id", jo.slice(1)];
                        case "[":
                            var Xn = new RegExp(Wg).exec(jo);
                            if (Xn)
                                return [Pn, Xn[1], (vi = (vi = Xn[4]) != null ? vi : Xn[5]) != null ? vi : ""]
                        }
                    }
                    return [Pn, void 0, void 0]
                }(wr[Vr]))[0],
                Jr = bn[1],
                wn = bn[2],
                In = bo(Xr, Wr ?? si),
                Jr && wn && Ko(In, Jr, wn);
                var Lr = In
                  , Cr = bo(pr, si);
                bl(Cr),
                fa(Cr, Lr),
                fa(jr, Lr),
                zr[Vr] = Lr
            }
            fa(Zo(pr), jr);
            var qr = {};
            setTimeout(function() {
                try {
                    for (var Nn = 0; Nn < wr.length; ++Nn)
                        zr[Nn].offsetParent || (qr[wr[Nn]] = !0)
                } finally {
                    ml(jr)
                }
                Ke(function(vi, Zi) {
                    for (var Pn, Mi = 0; Mi < vi.length; Mi++)
                        (function(ui) {
                            for (var jo = 0, Xn = vi[Mi]; jo < Xn.length; jo++)
                                if (ui[Xn[jo]])
                                    return !0;
                            return !1
                        }
                        )(Zi) && (Pn = Pn || []).push(Mi);
                    return Pn
                }(ar, qr))
            }, 0)
        } catch (Nn) {
            xa(Nn),
            Ke(void 0)
        }
        var Xr, bn, Wr, Jr, wn, In
    }, cu = {
        email: !1,
        hidden: !1,
        password: !1,
        tel: !1,
        text: !1
    }, Ug = he(224), Hg = he(225), ph = function(ye, Ke, ar) {
        es(mo(ye), Ke, function(hr) {
            return qo(function() {
                var pr, wr = ar;
                (pr = hr).target && pr.target.value && pr.target.type && pr.target.type in cu && (Hg !== pr.inputType && "data"in pr && Ug !== pr.animationName || (cu[pr.target.type] = !0,
                wr(cu)))
            })
        })
    }, Fg = 500, ol = {}, al = {}, Go = 0, Ca = 1, Va = {
        Jt: ci,
        $t: !1,
        Qt: !1,
        Vt: void 0,
        Zt: void 0,
        Yt: void 0,
        Kt: 300
    }, ao = function(ye, Ke, ar, hr) {
        return Uc && Uc(ye, Ke, ar, hr),
        ar
    }, js = function(ye) {
        return Xi(ye, function(Ke) {
            return !!Ke
        })
    }, ko = function(ye, Ke, ar) {
        fi(ar) && (ol[ye] = $a(ye, Ke, ar)),
        Ke != yo && ao(Go, ye, ar)
    }, fh = function(ye, Ke) {
        Ke && (ol[ye] = $a(ye, tu)),
        ao(Go, ye, Ke)
    }, sl = function(ye, Ke, ar) {
        Ke ? al[ye] = $a(ye, tu) : ar && Ke === !1 && (al[ye] = $a(ye, Rd)),
        ao(Ca, ye, Ke)
    }, gc = function(ye, Ke, ar) {
        var hr, pr;
        ar === void 0 && (ar = Go),
        Ke.length > ci && (hr = ed(Ke.sort().join("")),
        pr = Oi(Ke.length) + Le(hr, 4),
        pr = $a(ye, yo, pr),
        ar === Go ? ol[ye] = pr : ar === Ca && (al[ye] = pr)),
        ao(ar, ye, Ke, hr)
    }, gh = function(ye, Ke) {
        fi(Ke) && (ol[ye] = 25.5 < Ke ? $a(ye, Ga, z[he(240)](Ke)) : $a(ye, Bd, Ke),
        ao(Go, ye, Ke))
    }, ds = function(ye, Ke, ar) {
        var hr;
        ao(Go, ye, Ke),
        fi(Ke) && (hr = Io(ar, Ke),
        ol[ye] = ci <= hr ? $a(ye, ru, hr) : $a(ye, Oa, Ke))
    }, mh = function(ye, Ke) {
        var ar = 32767 & ye
          , hr = 65535 & Ke;
        return ar == hr ? Le(32768 | ar, 2) : Le(ar, 2) + Le(hr, 2)
    }, hs = function(ye) {
        var Ke = Xi(ye, function(hr) {
            return fl(hr)
        })
          , ar = sr(Ke, _i);
        return Oi(ye.length) + Le(ar, z[he(250)](Ke.length / 8))
    }, zg = he(226), qg = he(227), Gg = he(228), Vg = he(229), bh = he(230), Yg = he(231), Xg = he(232), Zg = he(233), vh = he(234), Kg = he(235), Jg = he(236), Ya = function(ye) {
        return ye.slice(2) + "-" + ye.slice(2, 2)
    }, Qg = "20181001000000", e1 = ["20030107", "20100101"], ca = function(ye, Ke, ar) {
        fi(ar) && (al[ye] = $a(ye, Ke, ar)),
        Ke != yo && ao(Ca, ye, ar)
    }, t1 = (us = 2,
    qa = Ma.split("."),
    la = parseInt(qa[0], 10) - 1,
    ot = parseInt(qa[1], 10),
    Bs = parseInt(qa[2], 10),
    Le(us << 13 | (3 & la) << 11 | (31 & ot) << 6 | 63 & Bs, 2)), r1 = 0, n1 = 4, i1 = Oi(La), o1 = 4, wh = function(ye, Ke) {
        return Oi((7 & ye) << 5 | 31 & Ke)
    }, a1 = function(ye, Ke, ar, hr) {
        var pr, wr = Sa(ol), jr = Sa(al), zr = (zr = [0 < cr.G.g, _u(), 0 < ta(wo), 0 < Ee.g, ta(El) > Vu && ((zr = rc(Fr.G)) != null ? zr : ci) > Vu, 0 < xe.g, 0 < Se.g, !!(zr = Zs(Ic)) && zr.C === ci && zr.q === ci],
        Cr = _u() ? Ne : tr,
        Vr = to(Tn.G),
        Lr = ro(Tn.G),
        pr = [rc(tt.G), rc(we.G), Bc(be.G), Bc(Pr.G), Bc(lr.G), rc(Cr.G), to(br.G), ro(br.G), to(lr.G), ro(lr.G), to(xr.G), ro(xr.G), to(Rr.G), ro(Rr.G), to(Pr.G), ro(Pr.G), to(mr.G), ro(mr.G), to(fr.G), ro(fr.G), to(_r.G), ro(_r.G), to(Ir.G), ro(Ir.G), to(Nr.G), ro(Nr.G), (Cr = Nr.G,
        Ho(Cr.L)), (Cr = Nr.G,
        Ho(Cr.M)), to(Zr.G), ro(Zr.G), to(gn.G), ro(gn.G), Po(to(Zn.G), Vr), Po(ro(Zn.G), Lr), Po(to(Cn.G), Vr), Po(ro(Cn.G), Lr), Po(to(Gn.G), Vr), Po(ro(Gn.G), Lr), to(oi), ro(xi), to(Ci), ro($i), Wu(rr.G), Du(rr.G), to(pi), ro(pi), to(Yn), ro(Yn), to(yi), ro(yi), jc(rr.G), to(ni.G), ro(ni.G)],
        Cr = [Ha(ta(Gl)), Ha(ta(Ji)), Ha(ta(wo)), Ha(ta(oo)), Ha(ta(Vi)), Ha(ta(Vl)), Ha(Po(ta(zi), ta(Fo))), Ha(1 < Yn.g ? Yn.g - 1 : ci), Ha($e.g)],
        Vr = sr(zr, 12),
        [Oi((Lr = o1 << 12 | 4095 & Vr) >> 8) + Oi(Lr), function() {
            for (var Xr, bn = "", Wr = 0, Jr = pr; Wr < Jr.length; Wr++)
                bn += Oi(po(Xr = Jr[Wr]) ? (Xr = z[he(249)](Xr, 0)) <= 15 ? 64 | bp.e(Xr + 1) : 128 | mp.e(z[he(244)](Xr, vp) - 14) : 0);
            return bn
        }(), nr(Cr)]), Vr = Oi(Wa(256)), Lr = ba(), Cr = (Cr = Qu(Lr),
        Lr = parseInt(Lr.toString().slice(-3), 10),
        Lr = Le(Lr, 2),
        qr = me(Wa(Ds)),
        Fc(Cr, qr) + Fc(Lr, qr)), qr = (Lr = wh(r1, wr.length),
        wh(n1, jr.length));
        return Lr = Lr + wr.join("") + qr + jr.join("") + zr.join("") + i1,
        wr = nc(Cr, 4, Cr.charAt(3), Lr),
        qr = nc(Ke, 8, Ke.charAt(9), Cr + wr),
        zr = Oi((jr = ar + hr + t1 + Ke + qr).length),
        Lr = rs(jr + zr, Vr),
        Cr = rt(Vr + Lr),
        Xu(ye, Cr) || ""
    }, mc = function(ye, Ke, ar, hr) {
        var pr = mo(ye);
        try {
            pr.cookie = "".concat(Ke, "=").concat(ar, ";path=/;").concat(hr).concat("SameSite=Lax")
        } catch {}
    }, s1 = vn(1970), yh = function(ye, Ke, ar) {
        for (var hr = 0, pr = Hs(ye).hostname, wr = pr.split("."), jr = wr.length === 1; hr < wr.length - 1 || jr; )
            pr = wr.slice(-1 - ++hr).join("."),
            mc(ye, Ke, "", "expires=".concat(ar || s1, ";domain=").concat(pr, ";")),
            jr = !1
    }, l1 = Oi(9), xh = {}, uu = !1, $h = !1, bc = [], Ch = function(ye, Ke, ar, hr) {
        Fd(ye, Ke, ar, hr || ms)
    }, _h = function(ye, Ke, ar) {
        var hr, pr = (pr = ic) ? "domain=".concat(pr, ";") : "", wr = Bo();
        wr = "expires=".concat((wr = wr.nn.rn,
        (hr = new Date).setSeconds(hr.getSeconds() + wr),
        hr.toUTCString()), ";").concat(pr),
        mc(ye, Ke, ar, wr)
    }, Eh = function(ye) {
        if (!Bo().Xt)
            throw tl;
        if (uu) {
            $h = !0;
            for (var Ke = bc.length, ar = du().nr, hr = 0; hr < Ke; hr++)
                bc[hr][1]._value = ar,
                bc[hr][0](ar)
        }
    }, du = function() {
        return xh[Sd]
    }, Th = function(ye) {
        xh[Sd] = ye
    }, hu = function(ye, Ke) {
        var ar = {
            tr: Ke,
            nr: Bo().Xt ? a1(ye, Ke, l1, Fl(Bo().Xt.slice(3))) : ""
        };
        return Th(ar),
        ar
    }, Sh = function(ye) {
        var Ke = du();
        if (Ke)
            return hu(ye, Ke.tr)
    }, ll = function(ye, Ke) {
        return ye.then = function(ar, hr) {
            return ar(Ke),
            ye
        }
        ,
        ye
    }, c1 = "POST", u1 = "withCredentials", d1 = 4, kh = function(ye, Ke, ar) {
        if (ar.rr && (clearTimeout(ar.rr),
        ar.rr = _i),
        ar.er === _i)
            for (var hr = ye.length, pr = 0; pr < hr; pr++)
                ye[pr](Ke);
        ar.er = Ke
    }, vc = function(ye, Ke) {
        ye.send(Ke)
    }, h1 = pl(vc, 300), wc = function(ye, Ke, ar, hr, pr, wr, jr) {
        var zr, Vr, Lr = function() {
            try {
                var Cr;
                if (typeof XMLHttpRequest != hl)
                    return Cr = new XMLHttpRequest,
                    u1 in Cr ? Cr : void 0
            } catch {}
        }();
        return Lr && Lr.setRequestHeader ? (Lr.open(c1, Ke, !0),
        zr = {
            er: _i,
            rr: _i
        },
        Vr = [],
        Lr.setRequestHeader("Content-Type", "application/json"),
        Lr.setRequestHeader("X-Castle-Publishable-Api-Key", ar),
        wr.then = function(Cr, qr) {
            return zr.er !== _i ? Cr(zr.er) : Vr.push(Cr),
            wr
        }
        ,
        Lr.onreadystatechange = function() {
            var Cr;
            Lr.readyState === d1 && (Cr = Lr.status,
            kh(Vr, 200 <= Cr && Cr < 400, zr))
        }
        ,
        hr(function(Cr) {
            zr.rr = setTimeout(function() {
                kh(Vr, hn, zr),
                Lr.abort()
            }, jr),
            pr(Lr, To(Cr))
        }),
        wr) : ll(wr, !1)
    }, p1 = "Castle: ", pu = function(ye, Ke) {
        var ar;
        Ri(ye, "console") && (ar = ye.console,
        Ri(ar, "warn")) && ar.warn(p1 + Ke)
    }, f1 = 0, g1 = 1, m1 = 2, b1 = 4, v1 = 5, w1 = 3, fu = function(ye) {
        return ga(ye) ? ye : To(ye)
    }, gu = function(ye, Ke, ar, hr, pr, wr) {
        return mu(Ke, ar, hr, pr, pr, wr) + Le(ye.length, w1) + Fl(ye)
    }, mu = function(ye, Ke, ar, hr, pr, wr) {
        for (var jr = [], zr = wr ? jd : dc, Vr = ci; Vr < ar.length; Vr++) {
            var Lr = ar[Vr]
              , Cr = Io(hr, Lr) >= ci
              , qr = Io(pr, Lr) >= ci;
            if ((Wr = Ri(Ke, Lr) && bs(Ke[Lr])) || Cr) {
                var Xr = void 0;
                if (Cr) {
                    if ((Cr = Wr ? Ke[Lr] : qr ? {} : _i) === _i)
                        continue;
                    var bn = $c(Cr)
                      , Wr = ma(bn).slice(ci, La);
                    Xr = Oi(Wr.length);
                    for (var Jr = 0, wn = Wr; Jr < wn.length; Jr++) {
                        var In = wn[Jr];
                        Xr = (Xr += dc(fu(In))) + dc(fu(bn[In]))
                    }
                } else
                    Xr = zr(fu(Ke[Lr]));
                jr.push(Oi(Vr) + Xr)
            }
        }
        return Oi(ye) + Oi(jr.length) + jr.join("")
    }, y1 = "id", x1 = "email", $1 = "phone", C1 = "registered_at", Ah = "traits", _1 = "signature", Ih = "address", E1 = "name", bu = function(ye) {
        return mu(f1, ye, [y1, x1, $1, C1, Ah, _1, E1, Ih], [Ah, Ih], Us, !1)
    }, T1 = he(237), vu = function(ye) {
        return mu(b1, ye, [T1], Us, Us, !0)
    }, S1 = 3, yc = function(ye, Ke, ar, hr) {
        var pr = Oi(Wa(256))
          , wr = ba()
          , jr = (wr = Qu(wr),
        jr = me(Wa(Ds)),
        wr = Fc(wr, jr),
        Oi(hr.length))
          , zr = Ke.slice(3)
          , Vr = (jr = ar + jr + hr.join(""),
        Oi(jr.length & La));
        return jr = nc(wr, 4, wr.charAt(3), jr + Vr),
        Vr = nc(zl(zr), 8, zl(zr[9]), wr + jr),
        zr = Oi((15 & S1) << 4),
        wr = rs(zr + Vr, pr),
        jr = rt(pr + wr),
        Xu(ye, jr) || ""
    }, wu = "url", yu = "name", xu = "referrer", k1 = "name", Ph = "values", Oh = 0, A1 = 300, I1 = "name", Nh = "properties", Rh = function(ye) {
        return ye.userJwt ? vu({
            jwt: ye.userJwt
        }) : bu(ye.user)
    }, Bh = function(ye, Ke) {
        return gu(ye, v1, Ke, [I1, Nh], [Nh], !1)
    }, Ms = {}, jh = function(ye) {
        var Ke = Ms[ye]
          , ar = {};
        if (Ke.cr)
            ar.then = function(pr) {
                return setTimeout(function() {
                    jh(ye).then(function(wr) {
                        pr(wr)
                    })
                }, Ad),
                ar
            }
            ;
        else {
            if (Ke.ir)
                return ll(ar, Ke.ur);
            Ke.cr = !0,
            Ke.ir = !1,
            Ke.ur = void 0;
            var hr = Bo();
            ar.then = function(pr) {
                var wr, jr;
                return wc(0, hr.K, hr.Xt, (wr = ye,
                jr = hr.Xt,
                function(zr) {
                    var Vr = ((Vr = Ms[wr]).ar = Vr._.splice(0, A0),
                    Xi(Vr.ar, function(Lr) {
                        return Bh(Lr.nr, Lr._r)
                    }));
                    zr({
                        data: yc(Ju, jr, wr, Vr)
                    })
                }
                ), vc, {}, hr.X).then(function(zr) {
                    Ke.cr = !1,
                    Ke.ir = !0,
                    Ke.ur = zr,
                    pr(zr)
                }),
                ar
            }
        }
        return ar
    }, P1 = function(ye, Ke, ar) {
        var hr, pr, wr = {}, jr = Bo();
        if (jr.Xt)
            return fi(hr = ar) && (fi(hr.user) || fi(hr.userJwt)) && fi(hr.name) ? jr.en ? ((pr = {}).then = function(zr, Vr) {
                return Ke.then(function(Lr) {
                    var Cr, qr, Xr, bn, Wr = {
                        sr: Rh(ar),
                        _r: ar,
                        nr: Lr
                    };
                    Ms[Wr.sr] || (Ms[Wr.sr] = {
                        _: [],
                        ar: [],
                        vr: 0
                    }),
                    Ms[Wr.sr]._.push({
                        _r: Wr._r,
                        nr: Wr.nr
                    }),
                    qr = Ms[Cr = Wr.sr],
                    (Xr = (Wr = Ms[Cr]).vr && 0 < (Wr = Wr.vr - ba()) ? Wr : 0) == 0 && (qr.vr = ba() + Ad),
                    (bn = {
                        then: function(Jr) {
                            var wn = function(In) {
                                jh(Cr).then(function(Nn) {
                                    qr.ar.pop(),
                                    qr.ar.length === 0 && (qr.ir = !1,
                                    qr.ur = void 0,
                                    qr.cr = !1),
                                    In(Nn)
                                })
                            };
                            return Xr == 0 ? wn(Jr) : setTimeout(function() {
                                wn(Jr)
                            }, Xr),
                            bn
                        }
                    }).then(function(Jr) {
                        return zr(Jr)
                    })
                }),
                pr
            }
            ,
            pr) : wc(0, jr.K, jr.Xt, function(zr) {
                Ke.then(function(Vr) {
                    var Lr = jr.Xt
                      , Cr = Vr;
                    Cr = yc(ye, Lr, Rh(Lr = ar), [Bh(Cr, Lr)]),
                    zr({
                        data: Cr
                    })
                })
            }, vc, wr, jr.X) : (jr.$ && pu(ye, Qc),
            ll(wr, !1));
        throw tl
    }, Mh = "data-castle-value", O1 = "data-castle-name", N1 = "name", Lh = "name", Wh = "castle_request_token", cl = function() {
        if (Hc)
            return Hc;
        throw kd
    }, Dh = !0, Uh = _i;
    Oe = function(ye) {
        var Ke, ar, hr, pr, wr, jr, zr, Vr = ye || {};
        if ((Js = Ri(Vr, "window") ? Vr.window : Js) || typeof window != hl && (Js = window),
        !Js)
            throw kd;
        if (Ri(Vr, "storageNamespace") && (Lr = Vr.storageNamespace) && (ya.nn.tn = Lr),
        Ri(Vr, "storage") && (Lr = Vr.storage) && (Lr.name && (ya.nn.tn = Lr.name),
        Ml(Lr.expireIn)) && (ya.nn.rn = Lr.expireIn),
        Ri(Vr, "avoidCookies") && (Lr = !!Vr.avoidCookies,
        ya.J = Lr),
        Ri(Vr, "cookieDomain") && (Lr = Vr.cookieDomain) && /\S+\.\S{2,}$/.test(Lr) && (ic = Lr),
        Bo().J || (ic = ic || function(Cr) {
            for (var qr = 0, Xr = mo(Cr), bn = Hs(Cr).hostname, Wr = "".concat(el).concat(ba()), Jr = bn.split("."); qr < Jr.length - 1 && (bn = Jr.slice(-1 - ++qr).join("."),
            mc(Cr, Wr, Wr, "domain=".concat(bn, ";")),
            !Uo(Xr.cookie, "".concat(Wr, "=").concat(Wr))); )
                ;
            return yh(Cr, Wr),
            bn
        }(Js)),
        Ri(Vr, "eFn") && (Lr = Vr.eFn,
        ya.cn = Lr),
        Ri(Vr, "pk")) {
            var Lr = Vr.pk;
            if (!bs(Lr) || Lr.length !== 35 || Lr.slice(0, 3) !== "pk_")
                throw tl;
            ya.Xt = Lr,
            Eh()
        }
        if (Ri(Vr, "apiUrl") && (Lr = Vr.apiUrl) && (ya.K = Lr),
        Ri(Vr, "timeout") && (Lr = Vr.timeout,
        po(Lr) && (ya.X = Lr)),
        Ri(Vr, "verbose") && (Lr = !!Vr.verbose,
        ya.$ = Lr),
        Ri(Vr, "throttling") && (Lr = Vr.throttling,
        fi(Lr) && (ya.en = Lr)),
        Dh) {
            if (!Bo().Xt)
                throw tl;
            Vr = Ke = Js,
            Lr = Bo(),
            rl.en = Lr.en,
            rl.J = Lr.J,
            rl._n = !!(Lr = Vr).localStorage,
            Fd(Lr, el, S0, function() {
                rl._n && (rl.sn = !0)
            }),
            function(Cr, qr) {
                try {
                    var Xr = Cr.localStorage;
                    if (Xr)
                        return Xr.removeItem(qr)
                } catch {}
            }(Lr, el),
            Hc = zr = {
                createRequestToken: function() {
                    var Cr = {
                        then: function(qr, Xr) {
                            return $h && !Cr._value && (Sh(jr),
                            Cr._value = function() {
                                var bn;
                                if (uu)
                                    return bn = jr,
                                    (du() || hu(bn, Or(bn))).nr
                            }()),
                            Cr._value ? qr(Cr._value) : bc.push([qr, Cr]),
                            Cr
                        }
                    };
                    return Cr
                },
                page: function(Cr) {
                    var qr, Xr, bn, Wr = jr, Jr = zr.createRequestToken(), wn = Cr, In = {}, Nn = Bo();
                    if (Nn.Xt)
                        return fi(wn) && (fi(wn.user) || fi(wn.userJwt)) ? (qr = Ri(wn, wu) ? wn[wu] : Hs(Wr).href,
                        Xr = Ri(wn, yu) ? wn[yu] : mo(Wr).title || qr,
                        bn = Ri(wn, xu) ? wn[xu] : mo(Wr).referrer,
                        wc(0, Nn.K, Nn.Xt, function(vi) {
                            Jr.then(function(Zi) {
                                var Pn = Nn.Xt
                                  , Mi = Zi
                                  , ui = {
                                    user: wn.user,
                                    userJwt: wn.userJwt,
                                    name: Xr,
                                    url: qr,
                                    referrer: bn
                                };
                                Pn = yc(Wr, Pn, ui.userJwt ? vu({
                                    jwt: ui.userJwt
                                }) : bu(ui.user), [gu(Mi, g1, ui, [yu, wu, xu], Us, !1)]),
                                vi({
                                    data: Pn
                                })
                            })
                        }, h1, In, Nn.X)) : (Nn.$ && pu(Wr, Qc),
                        ll(In, !1));
                    throw tl
                },
                form: function(Cr) {
                    var qr, Xr = jr, bn = zr.createRequestToken(), Wr = Cr, Jr = {}, wn = Bo();
                    if (wn.Xt)
                        return fi(Wr) && (fi(Wr.user) || fi(Wr.userJwt)) && fi(Wr.name) ? (qr = ba()) - Oh < A1 ? ll(Jr, !1) : (Oh = qr,
                        wc(0, wn.K, wn.Xt, function(In) {
                            bn.then(function(Nn) {
                                var vi = wn.Xt
                                  , Zi = Nn;
                                Zi = yc(Xr, vi, (vi = Wr).userJwt ? vu({
                                    jwt: vi.userJwt
                                }) : bu(vi.user), [gu(Zi, m1, vi, [k1, Ph], [Ph], !1)]),
                                In({
                                    data: Zi
                                })
                            })
                        }, vc, Jr, wn.X)) : (wn.$ && pu(Xr, Qc),
                        ll(Jr, !1));
                    throw tl
                },
                custom: function(Cr) {
                    return P1(jr, zr.createRequestToken(), Cr)
                },
                injectTokenOnSubmit: function(Cr, qr) {
                    Cr.preventDefault ? Cr.preventDefault() : Cr.returnValue = !1;
                    var Xr = Cr.target || Cr.srcElement;
                    zr.createRequestToken().then(function(bn) {
                        Ko(function(Wr, Jr) {
                            for (var wn = 0, In = Jr.childNodes; wn < In.length; wn++) {
                                var Nn = In[wn];
                                if (Fs(Nn, Lh) === Wh)
                                    return Nn
                            }
                            var vi = bo(Wr, "input");
                            return Ko(vi, "type", "hidden"),
                            Ko(vi, Lh, Wh),
                            fa(Jr, vi),
                            vi
                        }(jr, Xr), "value", bn),
                        qr ? qr(Cr) : Xr.submit()
                    })
                },
                formEventOnSubmit: function(Cr, qr, Xr, bn) {
                    if (!Cr.preventDefault)
                        return !bn || void bn(Cr, null);
                    Cr.preventDefault();
                    var Wr = Cr.target || Cr.srcElement
                      , Jr = jl(ga(qr) ? {
                        userJwt: qr
                    } : {
                        user: qr || {}
                    }, function(wn) {
                        for (var In = new FormData(wn), Nn = {}, vi = 0, Zi = wn.querySelectorAll("[".concat(Mh, "]")); vi < Zi.length; vi++) {
                            var Pn = Zi[vi]
                              , Mi = Fs(Pn, Mh);
                            Pn = Fs(Pn, N1),
                            In.has(Pn) && (Nn[Mi] = "" + In.get(Pn))
                        }
                        return {
                            name: Fs(wn, O1),
                            values: Nn
                        }
                    }(Wr));
                    zr.form(Jr).then(function(wn) {
                        Xr && Xr.injectToken ? zr.injectTokenOnSubmit(Cr, function(In) {
                            return bn ? bn(In, wn) : Wr.submit()
                        }) : bn ? bn(Cr, wn) : Wr.submit()
                    })
                }
            },
			window.createtooken = zr,
            Ju = jr = Ke,
            ge = Ll(4, hn),
            Ne = qi(ra, Ps),
            tt = qi(Au, Ps),
            tr = qi(ra, Ps),
            we = qi(Au, Ps),
            Ut = qi(Sc, Ps),
            rr = qi(Sc, Ps, hn, hn, hn, 2, !0, ea),
            xi = Ua(!1, ea),
            oi = Ua(!1, ea),
            $i = Ua(!1, ea),
            Ci = Ua(!1, ea),
            Yn = Ua(!1, ea),
            pi = Ua(!1, ea),
            yi = Ua(!1, ea),
            dr = qi(Sc, hn, hn, hn, hn, 2, !0, ea),
            Sr = qi(ra, hn, hn, hn, hn, 2, !0, ea),
            lr = qi(ra, hn, [zi, Fo], hn, Ks),
            cr = qi(Sl, Lu, [Vi, Ji], hn, Ks),
            be = qi(Kh, Lu, [Vi, Ji], hn, Ks),
            Rr = qi(ra, tc, [Vi]),
            Pr = qi(ra, tc, [Ji]),
            mr = qi(ra, tc, [Vi, Ji], hn, Ks),
            fr = qi(ra, tc, [Ji, Vi], hn, Ks),
            gn = qi(ra, hn, [oo, wa, ss], Oc, rp),
            Zr = qi(ra, hn, [oo, wa, ss], Oc, tp),
            Fr = qi(Zh),
            br = qi(ra, hn, [wo]),
            _r = qi(ku, hn, hn, hn, hn, 3, !1, ea),
            Ir = qi(ku, Ps, hn, hn, hn, 3, !1, ea),
            Nr = qi(Xh, hn, hn, hn, hn, 3, !1, ea),
            xr = qi(ra, hn, [wo, Vi], hn, Ks),
            Tn = qi(Sl, hn, [Vi], hn, ap),
            Zn = qi(Sl, hn, [Vi], hn, np),
            Cn = qi(Sl, hn, [Vi], hn, ip),
            Gn = qi(Sl, hn, [Vi], hn, op),
            ni = qi(ra, hn, hn, hn, hn, 2, !0, Yh),
            xe = Zl(Jh, [Vi]),
            $e = Zl(Qh),
            Se = Zl(hn, [oo], ep),
            Ee = Zl(hn),
            fe = Ll(Yl.length, 0),
            ar = Ke,
            hr = function() {
                var Cr, qr, Xr, bn, Wr, Jr, wn, In, Nn = qr = Ke, vi = Yl, Zi = $u, Pn = void 0;
                Fu = pl(ms, pp, void 0);
                for (var Mi = Nn, ui = Gr = function(so) {
                    return dp(Nn, so, vi, Zi, Pn)
                }
                , jo = vi, Xn = Zi, di = mi(Mi), ai = jo.length - 1; 0 <= ai; ai--) {
                    var Ti = zu(Mi, ai, Xn);
                    if (ai === El && di && di.query)
                        for (var xo = qu.length - 1; 0 <= xo; xo--)
                            (function(so, ho, Fi, Mo) {
                                so.query({
                                    name: qu[xo]
                                }).then(function(Vo) {
                                    var _a = Vo.state;
                                    Gu || _a === hp && (Gu = !0,
                                    es(ho, Fi, Mo))
                                }).catch(ms)
                            }
                            )(di, Ti, jo[ai], ui);
                    else
                        es(Ti, jo[ai], ui)
                }
                Xr = Bo(),
                wn = qr,
                In = Xr.nn.tn,
                (Cr = Xr = function(so, ho) {
                    try {
                        var Fi = so.localStorage;
                        return Fi ? Fi.getItem(ho) : hn
                    } catch {
                        return hn
                    }
                }(wn, In) || function(so) {
                    var ho = mo(wn);
                    try {
                        return (ho.cookie.match("(^|; )".concat(so, "=([^;]*)")) || 0)[2]
                    } catch {
                        return null
                    }
                }(In)) && new RegExp("^[".concat($r, "]{8}[").concat($r, "]{4}[0-5][").concat($r, "]{3}[89ab][").concat($r, "]{3}[").concat($r, "]{12}$")).test(Cr) || (Xr = Or(qr)),
                qr = hu(Cr = qr, Xr),
                (Xr = Bo()).J ? mc(Cr, Xr.nn.tn, "", "expires=".concat(k0, ";")) : yh(Cr, Xr.nn.tn),
                bn = Cr,
                Th(Wr = qr),
                (Jr = Bo()).J ? Ch(bn, Jr.nn.tn, Wr.tr, function() {
                    return _h(bn, Jr.nn.tn, Wr.tr)
                }) : (_h(bn, Jr.nn.tn, Wr.tr),
                Ch(bn, Jr.nn.tn, Wr.tr)),
                uu = !0,
                Eh()
            }
            ,
            pr = function() {
                return Sh(Ke)
            }
            ,
            Uc = void 0,
            ye = function() {
                Va.Vt = hr,
                Va.Zt = pr;
                var Cr, qr, Xr, bn, Wr, Jr, wn, In, Nn, vi, Zi, Pn = ar, Mi = (ph(wn = Pn, "animationstart", In = function(Xn) {
                    var di = js(Sa(Xn));
                    ca(Hd, yo, hs(di)),
                    ao(Ca, Hd, di)
                }
                ),
                ph(wn, "input", In),
                ds(U0, _l(Pn), [zg, qg, Gg, Vg]),
                ds(H0, gr(Pn), [Id, Pd]),
                ds(F0, Mr(Pn), [Ya(bh), Ya(Yg), Ya(Xg), Ya(Zg), Ya(vh), Ya(Kg), Ya(Jg), Hr(Ya(bh)), Hr(Ya(vh))]),
                gh(z0, On(Pn)),
                wn = q0,
                Mi = Dr(In = Pn),
                Xr = ia(oa(In).availWidth),
                ui = Yr(In),
                bn = ia(oa(In).availHeight),
                Wr = mh(Mi, Xr),
                Jr = mh(ui, bn),
                ko(wn, yo, Wr + Jr),
                ao(Go, wn, [Mi, ui, Xr, bn]),
                ko(G0, Ga, (Wr = oa(Pn),
                fi(Wr[vo]) ? Wr[vo] : Wr[Ia])),
                ko(V0, Ga, Sn(Pn)),
                gh(Y0, (Jr = oa(In = Pn),
                fi(Jr[Vc]) && fi(Jr[Yc]) && Jr[Vc] > Jr[Yc] ? qs(Jr[Vc], Jr[Yc]) : fi(In[oc]) ? In[oc] : 1)),
                wn = X0,
                Mi = Ts()[uc](),
                (ui = Ts()).setDate(1),
                ui.setMonth(0),
                Xr = ui[uc](),
                ui.setMonth(6),
                Xr = Po(Xr, ui[uc]()),
                ui = Oi(Mi / 15) + Oi(Xr / 15),
                ko(wn, yo, ui),
                ao(Go, wn, [Mi, Xr]),
                gc(Z0, qo(function() {
                    return Xi(Un(Pn), function(Xn) {
                        return Xn && Xn.type
                    })
                })),
                gc(K0, qo(function() {
                    return Xi(Ii(Pn), function(Xn) {
                        return Xn.name + Xn.description + Xn.length + Xn.filename
                    })
                })),
                In = Pn,
                wn = J0,
                bn = [O0(), mo(In)[eo], Ja(bn = In, os) || Ja(bn, sa), ki(In)[ri], yd(In), go(In), bi(In), mi(In), ki(In)[Aa], ki(In)[wp], ki(In)[va], ki(In)[Ss]],
                ko(wn, yo, hs(bn)),
                ao(Go, wn, js(bn)),
                In = cf,
                Jr = [!!(wn = Pn)["__".concat(Gp)], wd([Kc[0]in (Wr = wn), Kc[1]in Wr, Kc[2]in Wr]), (ui = mo(Jr = Wr = wn),
                Wr = Eo(Wr),
                wd([za in Jr, "_".concat(Xp)in Jr, Lp in Jr, "_".concat(lc)in Jr, "__".concat(za, "_").concat(md)in ui, "__".concat(Il, "_").concat(sc)in ui, "__".concat(za, "_").concat(sc)in ui, "__".concat(lc, "_").concat(sc)in ui, "__fx".concat(Il, "_").concat(sc)in ui, "__".concat(Il, "_").concat(cc)in ui, "__".concat(za, "_").concat(cc)in ui, "__".concat(lc, "_").concat(cc)in ui, "__fx".concat(Il, "_").concat(cc)in ui, "__".concat(za, "_").concat(md)in ui, "__".concat(za, "_").concat(Yp)in ui, Zc(Wr, lc), Zc(Wr, za), Zc(Wr, Il)])), !!wn.external && Jo(wn.external.toString) && Uo(wn.external.toString(), Zp), !!wn.spawn, !(!wn[hd] && !wn["".concat(hd, "Controller")]), !!wn.emit, !!wn.Buffer],
                ko(In, yo, hs(Jr)),
                ao(Go, In, js(Jr)),
                wn = Q0,
                In = Tr(Pn),
                fi(In) && (ko(wn, yo, jd(In, 512)),
                ao(Go, wn, In)),
                qo(function() {
                    var Xn, di, ai, Ti = Pn, xo = bo(Ti, zc), so = nd(xo) ? xo.getContext(td) : _i;
                    if (so)
                        return {
                            hr: (di = so,
                            cd(Xn = xo, 500, 100),
                            ai = yp + String.fromCharCode(55357, 56836),
                            di.textBaseline = Sp,
                            Qs(di, "#f60"),
                            ad(di, 125, 1, 62, 20),
                            Qs(di, "#069"),
                            ld(di, xp),
                            sd(di, ai, 2, 20),
                            Qs(di, Cp),
                            ld(di, $p),
                            sd(di, ai, 4, 22),
                            od(Xn)),
                            dr: function(ho, Fi) {
                                cd(ho, 400, 200),
                                Fi.globalCompositeOperation = kp;
                                for (var Mo = 0, Vo = Pp; Mo < Vo.length; Mo++) {
                                    var _a = Vo[Mo]
                                      , hi = _a[0];
                                    _a[1],
                                    _a[2],
                                    Qs(Fi, hi),
                                    Fi.beginPath(),
                                    qc(Fi),
                                    Fi.closePath(),
                                    ud(Fi, _i)
                                }
                                return Qs(Fi, "#70f"),
                                qc(Fi),
                                qc(Fi),
                                ud(Fi, _p),
                                od(ho)
                            }(xo, so),
                            lr: function() {
                                var ho = bo(Ti, zc);
                                try {
                                    var Fi = ho.getContext(rd) || ho.getContext(Ep + rd)
                                      , Mo = Fi.getExtension(Tp);
                                    return Mo ? Fi.getParameter(Mo.UNMASKED_RENDERER_WEBGL) : _i
                                } catch {
                                    return _i
                                }
                            }()
                        }
                })), ui = (Mi && (ko(ef, Oa, Mi.hr),
                ko(af, Oa, Mi.dr),
                ko(sf, Oa, Mi.lr)),
                fh(rf, (Xr = ki(wn = Pn),
                uo in Xr ? Xr[uo] : uo in wn ? wn[uo] : wi("ms", uo)in Xr ? Xr[wi("ms", uo)] : void 0)),
                fh(nf, function(Xn) {
                    try {
                        var di = ki(Xn)[aa];
                        return Jo(di) && di() ? 1 : _i
                    } catch {
                        return _i
                    }
                }(Pn)),
                ds(of, ki(Pn)[Ai], e1),
                ko(lf, Oa, ((bn = Ts()).setTime(0),
                bn.toLocaleString())),
                ko(uf, Ga, (In = Pn)[fo] ? In[fo].toString().length : ci),
                ds(df, ki(Pn)[no], [Qg]),
                I0()), jo = (ko(hf, Ga, ui.un),
                ds(pf, ui.an, [Nd, N0, R0]),
                ds(ff, ui.on, [W0, D0, eu]),
                ko(gf, Ga, ui.fn),
                wn = mf,
                Wr = function(Xn) {
                    var di, ai, Ti = ki(Xn), xo = mo(Xn), so = 0;
                    fi(Ti[Pl]) ? so = Ti[Pl] : (ai = Ti["ms".concat(Pl)],
                    fi(Ti[ai]) && (so = Ti[ai]));
                    try {
                        xo.createEvent(l0),
                        di = !0
                    } catch {
                        di = !1
                    }
                    return {
                        pr: so,
                        gr: di,
                        yr: "on".concat(c0)in Xn
                    }
                }(Pn),
                Jr = parseInt("".concat(fl(Wr.gr)).concat(fl(Wr.yr)), 2),
                Wr = Oi((63 & Wr.pr) << 2 | Jr),
                ko(wn, yo, Wr),
                ao(Go, wn, Jr),
                ds(bf, P0(), [B0, j0, M0, L0]),
                gc(vf, function(Xn) {
                    var di = [];
                    if (!(Ri(Pi, fs) && Ri(Pi, Ba) && Ri(Pi, ha)))
                        return di;
                    var ai = ki(Xn)
                      , Ti = ai;
                    do
                        for (var xo = 0, so = Qa(Ti); xo < so.length; xo++) {
                            var ho = so[xo];
                            di.push(ho)
                        }
                    while (Ti = ws(Ti));
                    for (var Fi, Mo = [], Vo = 0, _a = di; Vo < _a.length; Vo++) {
                        ho = _a[Vo];
                        var hi = pa(ws(ai), ho);
                        fi(hi) ? vs(hi.value) ? Fi = hi.value.toString() : vs(hi.get) && (Fi = hi.get.toString()) : Fi = "",
                        Mo.push("".concat(ho, "~~~").concat(Fi))
                    }
                    return Mo
                }(Pn)),
                In = Md,
                (wn = function(Xn) {
                    try {
                        return ai = bo(Xn, Hi),
                        [Jc(ai, E0), Jc(ai, _0), Jc(ai, C0)].concat((di = bo(Xn, Ni),
                        [Ol(di, $0), Ol(di, x0), Ol(di, y0), Ol(di, w0), Ol(di, v0)]))
                    } catch {
                        return []
                    }
                    var di, ai
                }(Pn)) && wn.length && (Mi = Le(parseInt(Xi(wn, pe).join(""), 2), 2),
                ko(Md, yo, Mi),
                ao(Go, In, wn)),
                il(Va, f0, [Pn], function(Xn) {
                    var di, ai;
                    di = tf,
                    Xn.length && (ai = [Xn[_d], Xn[Cd], Xn[$d]],
                    ko(di, yo, hs(ai)),
                    ao(Go, di, js(ai)))
                }),
                ca(wf, ru, T0),
                ca(yf, Oa, function() {
                    var Xn = io();
                    if (Xn)
                        return Xn[Da]
                }()),
                ca(xf, Oa, (Xr = ki(Pn)[Li + "s"],
                bn = io(),
                wl(Xr) && Xr.length && (qr = Xr.join(",")),
                bn && (bn = bn[yl]) && (qr ? Uo(Xr, bn) || (qr = qr + "," + bn) : qr = bn),
                qr)),
                In = Cf,
                ui = Sa(rl),
                ca(In, yo, hs(ui)),
                ao(Ca, In, ui),
                !(!(Wr = mi(Pn)) || !Wr.query) && il(Va, hg, [Pn], function(Xn) {
                    sl(Tf, Xn)
                }),
                sl(_f, (Jr = ki(Pn),
                Mi = ti(Bi),
                Xr = "is".concat(Mi),
                Ja(Jr, Bi) && gl(ws(Jr[Bi])) == Mi && Jr[Bi][Xr].toString() == "function ".concat(Xr, "() { ").concat(Wo, " }"))),
                (bn = ki(Pn).userAgentData) ? bn[Ro] === "" ? sl(nu, !0) : fd in bn && il(Va, pg, [bn], function(Xn) {
                    sl(nu, Xn)
                }) : sl(nu, !1),
                ca(Ef, Ga, ac),
                wn = Sf,
                qr = gg(Cr = Pn),
                Wr = [(ui = -50,
                En(ma(Wr = Cr).slice(ui), Gi) && En(Qa(Wr).slice(ui), Gi)), $g(Cr), qr.xn, qr.Cn, qr.qn, (Wr = Cr,
                (ui = new RegExp(pd)).test(Tr(Wr)) || ui.test(ki(Wr)[ka])), ah(Cr), qo(function() {
                    return !!Cr.matchMedia && Cr.matchMedia(Dp).matches
                }), (qr = ki(Cr),
                gd in qr && qr[gd] === !1), ia((Wr = Cr).innerWidth) === Dr(Wr) && ia(Wr.outerHeight) === Yr(Wr) || An(Wr) && An(Wr).width === Dr(Wr) && An(Wr).height === Yr(Wr), (qr = ki(ui = Cr),
                Fa && ou(ui, Rp) && (!(Kp in qr) || !(Wp in qr))), qo(function() {
                    return ou(Cr, Mp)
                }), yd(Cr) == _i],
                ca(wn, yo, hs(Wr)),
                ao(Ca, wn, js(Wr)),
                Mi = In = Pn,
                Fa && Cg in Array.prototype && !Ja(Mi, _g) && ki(In)[Pa] === hn);
                jo && ca(Ld, Oa, Bi),
                dg(Pn),
                Eg(Pn),
                vi = function(Xn) {
                    try {
                        var di;
                        _a = (Vo = cg(Pn) || {}).En,
                        Vo = Vo.Dn,
                        Ku = _a,
                        Zu = Vo,
                        qo(function() {
                            var hi = nh(Ku).wn.gn();
                            hc = $s(ma(hi), function(Yi, $o, Co) {
                                var Na;
                                return Yi[$o] = (Na = hi[$o]) && xs(Na, function(Ao) {
                                    return !new RegExp(Pf).test(Ao)
                                }).length,
                                Yi
                            }, {})
                        }),
                        Fi = Gd.vn(),
                        Mo = $s(ma(Fi), function(hi, Yi) {
                            return hi + Fi[Yi].length
                        }, 0),
                        ca($f, Ga, Mo),
                        Ti = Af,
                        xo = Xi([mg, bg, vg, wg, au, yg, lh, xg], function(hi) {
                            return xs(hi, function(Yi) {
                                return hc[Yi]
                            }).length
                        }),
                        so = Xi(xo, me).join(""),
                        ho = $a(Ti, yo, so),
                        al[Ti] = ho,
                        ao(Ca, Ti, xo, so),
                        jo || (di = Sg(),
                        ca(Ld, Oa, di));
                        var ai = [qo(function() {
                            var hi = bo(Pn, zc);
                            if (nd(hi)) {
                                Yi = Co = Rs,
                                $o = hi.getContext(td, Np),
                                hi.width = Co,
                                hi.height = Yi;
                                var Yi, $o, Co = $o, Na = function(Lo) {
                                    for (var Yo = [], Ra = 0; Ra < Rs; Ra++)
                                        for (var Ea = 0; Ea < Rs; Ea++) {
                                            var ps = "".concat(Gc(), ", ").concat(Gc(), ", ").concat(Gc(), ", ").concat(Op);
                                            Qs(Lo, "rgba(".concat(ps, ")")),
                                            ad(Lo, Ra, Ea, 1, 1),
                                            Yo.push(ps)
                                        }
                                    return Yo
                                }(Co), Ao = function(Lo) {
                                    for (var Yo = [], Ra = 0; Ra < Rs; Ra++)
                                        for (var Ea = 0; Ea < Rs; Ea++) {
                                            var ps = (Bl = (Lo[Ap](Ra, Ea, 1, 1) || {}).data)[0]
                                              , R1 = Bl[1]
                                              , B1 = Bl[2]
                                              , Bl = Bl[3];
                                            ps = "".concat(ps, ", ").concat(R1, ", ").concat(B1, ", ").concat(Bl),
                                            Yo.push(ps)
                                        }
                                    return Yo
                                }(Co);
                                Co.clearRect(0, 0, Rs, Rs);
                                for (var Oo = 0; Oo < Na.length; Oo++)
                                    if (Na[Oo] != Ao[Oo])
                                        return !0
                            }
                            return !1
                        }), qo(function() {
                            var hi = oa(Pn)
                              , Yi = !(hi.width - hi.availWidth || hi.height - hi.availHeight);
                            if (800 < hi.width && Yi)
                                return !0
                        }), qo(function() {
                            var hi = Pn
                              , Yi = hi[oc];
                            if (Yi = !hi.matchMedia("(resolution:".concat(Yi, "dp").concat(da, ")")).matches,
                            !dd && Yi)
                                return !0
                        }), qo(function() {
                            var hi = Pn
                              , Yi = hi[oc]
                              , $o = oa(hi);
                            if (!(Xc && Yi != 1 || hi.matchMedia("(".concat(Qi, "-width:").concat($o.width).concat(da, ") and (").concat(Qi, "-height:").concat($o.height).concat(da, ")")).matches))
                                return !0
                        }), qo(function() {
                            return hi = Ii(Pn),
                            Yi = Un(Pn),
                            $o = !1,
                            Ta(hi, function(Ao) {
                                try {
                                    Pi[Ba](Ao[0]).constructor.name == "MimeType" || ($o = !0)
                                } catch {
                                    $o = !0
                                }
                            }),
                            Co = xs(Qa(Yi), function(Ao) {
                                return isNaN(+Ao)
                            }),
                            Na = Xi(hi, function(Ao) {
                                for (var Oo = Sa(Ao), Lo = [], Yo = 0, Ra = Oo; Yo < Ra.length; Yo++) {
                                    var Ea = Ra[Yo];
                                    wl(Oo[Ea]) ? Ta(Oo[Ea], function(ps) {
                                        Lo.push(ps)
                                    }) : Lo.push(Oo[Ea])
                                }
                                return Lo
                            }),
                            Na = Xi(Na, function(Ao) {
                                return Ao && Ao.type
                            }),
                            Ta(Na, function(Ao) {
                                if (!_s(Co, Ao))
                                    for (var Oo = Co, Lo = Ao, Yo = 0; Yo < Oo.length; )
                                        Oo[Yo] === Lo ? Oo.splice(Yo, 1) : Yo++
                            }),
                            Ta(hi, function(Ao) {
                                var Oo = Xi(Sa(Ao), function(Lo) {
                                    return Lo && Lo.type
                                });
                                Ta(Oo, function(Lo) {
                                    _s(Co, Lo) || ($o = !0)
                                })
                            }),
                            $o;
                            var hi, Yi, $o, Co, Na
                        }), function(hi) {
                            try {
                                var Yi = bo(hi, gi);
                                return Yi.srcdoc = Or(hi),
                                !!Yi.contentWindow
                            } catch {
                                return !0
                            }
                        }(Pn), qo(function() {
                            var hi = Pn
                              , Yi = ih();
                            if (!Fa)
                                return !1;
                            var $o, Co = Yi;
                            try {
                                return Yi || (Co = bo(hi, si),
                                fa(Zo(hi), Co)),
                                !!Co && (Ko(Co, ei, jp),
                                !!hi.getComputedStyle) && hi.getComputedStyle(Co).backgroundColor === "".concat(Vp, "(255, ").concat(ci, ", ").concat(ci, ")")
                            } finally {
                                Yi || ($o = Zo(hi)) && $o.removeChild(Co)
                            }
                        }), !!hc[ja + "." + za], !!hc[qd]];
                        ca(Wd, yo, hs(ai)),
                        ao(Ca, Wd, js(ai)),
                        il(Va, Dg, [Pn], function(hi) {
                            hi && gc(kf, hi, Ca)
                        })
                    } finally {
                        ml(ih())
                    }
                    var Ti, xo, so, ho, Fi, Mo, Vo, _a
                }
                ,
                Zi = mo(Nn = Pn),
                Ns = function(Xn) {
                    var di = zs(Nn) ? Xn || Nn.event : Xn;
                    (di && di.type !== "readystatechange" || Zi.readyState === kr) && (ts(Nn) && Es(Zi, Ar, Ns),
                    Es(Zi, "readystatechange", Ns),
                    Es(Nn, "load", Ns),
                    dh(Nn))
                }
                ,
                ts(Nn) && es(Zi, Ar, Ns),
                es(Zi, "readystatechange", Ns),
                es(Nn, "load", Ns),
                (Zi.readyState === kr || Zi.readyState === _n && !Uo(Tr(Nn), Qn)) && dh(Nn),
                lu ? setTimeout(function() {
                    vi.call(Zi)
                }, 1) : Rl.push(vi),
                il(Va, Ig, [Fg], function(Xn) {
                    var di, ai, Ti;
                    Xn && (di = [(ai = Xn,
                    Ti = Mr(Pn),
                    !!(ai && ai.l && Ti) && ai.l !== Ti), (ai = Xn,
                    Ti = On(Pn),
                    !!(ai && ai.dm && Ti) && ai.dm !== Ti), (ai = Xn,
                    Ti = Sn(Pn),
                    !!(ai && ai.hc && Ti) && ai.hc !== Ti), (ai = Xn,
                    Ti = _l(Pn),
                    !!(ai && ai.p && Ti) && ai.p !== Ti), (ai = Xn,
                    Ti = Tr(Pn),
                    !!(ai && ai.ua && Ti) && ai.ua !== Ti), !!(ai = Xn) && new RegExp(Jp).test(ai.r), !!(Ti = Xn) && new RegExp(pd).test(Ti.ua)],
                    ca(Dd, yo, hs(di)),
                    ao(Ca, Dd, js(di)))
                }),
                il(Va, jg, [Pn], function(Xn) {
                    sl(Ud, Xn, !0),
                    ao(Ca, Ud, Xn)
                })
            }
            ,
            (wr = Va).$t || (ye(),
            wr.$t = !0,
            wr.Jt === ci || wr.Kt === ci ? (su(wr),
            ch(wr)) : setTimeout(function() {
                wr.Qt || su(wr)
            }, wr.Kt)),
            Dh = !1
        }
        return Uh
    }
    ,
    ir = function(ye, Ke) {
        return cl().injectTokenOnSubmit(ye, Ke)
    }
    ,
    Qr = function(ye, Ke, ar, hr) {
        return cl().formEventOnSubmit(ye, Ke, ar, hr)
    }
    ,
    us = function(ye) {
        return cl().page(ye)
    }
    ,
    la = function(ye) {
        return cl().form(ye)
    }
    ,
    ot = function(ye) {
        return cl().custom(ye)
    }
    ,
    Uh = {
        configure: Oe,
        createRequestToken: qa = function() {
            return cl().createRequestToken()
        }
        ,
        injectTokenOnSubmit: ir,
        formEventOnSubmit: Qr,
        page: us,
        form: la,
        custom: ot,
        getVersion: Bs = function() {
            return Ma
        }
    },
    W.configure = Oe,
    W.createRequestToken = qa,
    W.custom = ot,
    W.form = la,
    W.formEventOnSubmit = Qr,
    W.getVersion = Bs,
    W.injectTokenOnSubmit = ir,
    W.page = us
}
)(castle.exports);
var castleExports = castle.exports;
function commonjsRequire(W) {
    throw new Error('Could not dynamically require "' + W + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
}
var parallax = {
    exports: {}
};
parallax.exports = function W(z, Y, ne) {
    function le(he, fe) {
        if (!Y[he]) {
            if (!z[he]) {
                var ge = typeof commonjsRequire == "function" && commonjsRequire;
                if (!fe && ge)
                    return ge(he, !0);
                if (ue)
                    return ue(he, !0);
                var xe = new Error("Cannot find module '" + he + "'");
                throw xe.code = "MODULE_NOT_FOUND",
                xe
            }
            var $e = Y[he] = {
                exports: {}
            };
            z[he][0].call($e.exports, function(Ee) {
                var Se = z[he][1][Ee];
                return le(Se || Ee)
            }, $e, $e.exports, W, z, Y, ne)
        }
        return Y[he].exports
    }
    for (var ue = typeof commonjsRequire == "function" && commonjsRequire, de = 0; de < ne.length; de++)
        le(ne[de]);
    return le
}({
    1: [function(W, z, Y) {
        var ne = Object.getOwnPropertySymbols
          , le = Object.prototype.hasOwnProperty
          , ue = Object.prototype.propertyIsEnumerable;
        function de(fe) {
            if (fe == null)
                throw new TypeError("Object.assign cannot be called with null or undefined");
            return Object(fe)
        }
        function he() {
            try {
                if (!Object.assign)
                    return !1;
                var fe = new String("abc");
                if (fe[5] = "de",
                Object.getOwnPropertyNames(fe)[0] === "5")
                    return !1;
                for (var ge = {}, xe = 0; xe < 10; xe++)
                    ge["_" + String.fromCharCode(xe)] = xe;
                var $e = Object.getOwnPropertyNames(ge).map(function(Se) {
                    return ge[Se]
                });
                if ($e.join("") !== "0123456789")
                    return !1;
                var Ee = {};
                return "abcdefghijklmnopqrst".split("").forEach(function(Se) {
                    Ee[Se] = Se
                }),
                Object.keys(Object.assign({}, Ee)).join("") === "abcdefghijklmnopqrst"
            } catch {
                return !1
            }
        }
        z.exports = he() ? Object.assign : function(fe, ge) {
            for (var xe, $e, Ee = de(fe), Se = 1; Se < arguments.length; Se++) {
                for (var Ne in xe = Object(arguments[Se]))
                    le.call(xe, Ne) && (Ee[Ne] = xe[Ne]);
                if (ne) {
                    $e = ne(xe);
                    for (var tt = 0; tt < $e.length; tt++)
                        ue.call(xe, $e[tt]) && (Ee[$e[tt]] = xe[$e[tt]])
                }
            }
            return Ee
        }
    }
    , {}],
    2: [function(W, z, Y) {
        (function(ne) {
            (function() {
                var le, ue, de, he, fe, ge;
                typeof performance < "u" && performance !== null && performance.now ? z.exports = function() {
                    return performance.now()
                }
                : ne != null && ne.hrtime ? (z.exports = function() {
                    return (le() - fe) / 1e6
                }
                ,
                ue = ne.hrtime,
                he = (le = function() {
                    var xe;
                    return 1e9 * (xe = ue())[0] + xe[1]
                }
                )(),
                ge = 1e9 * ne.uptime(),
                fe = he - ge) : Date.now ? (z.exports = function() {
                    return Date.now() - de
                }
                ,
                de = Date.now()) : (z.exports = function() {
                    return new Date().getTime() - de
                }
                ,
                de = new Date().getTime())
            }
            ).call(this)
        }
        ).call(this, W("_process"))
    }
    , {
        _process: 3
    }],
    3: [function(W, z, Y) {
        var ne, le, ue = z.exports = {};
        function de() {
            throw new Error("setTimeout has not been defined")
        }
        function he() {
            throw new Error("clearTimeout has not been defined")
        }
        function fe(we) {
            if (ne === setTimeout)
                return setTimeout(we, 0);
            if ((ne === de || !ne) && setTimeout)
                return ne = setTimeout,
                setTimeout(we, 0);
            try {
                return ne(we, 0)
            } catch {
                try {
                    return ne.call(null, we, 0)
                } catch {
                    return ne.call(this, we, 0)
                }
            }
        }
        function ge(we) {
            if (le === clearTimeout)
                return clearTimeout(we);
            if ((le === he || !le) && clearTimeout)
                return le = clearTimeout,
                clearTimeout(we);
            try {
                return le(we)
            } catch {
                try {
                    return le.call(null, we)
                } catch {
                    return le.call(this, we)
                }
            }
        }
        (function() {
            try {
                ne = typeof setTimeout == "function" ? setTimeout : de
            } catch {
                ne = de
            }
            try {
                le = typeof clearTimeout == "function" ? clearTimeout : he
            } catch {
                le = he
            }
        }
        )();
        var xe, $e = [], Ee = !1, Se = -1;
        function Ne() {
            Ee && xe && (Ee = !1,
            xe.length ? $e = xe.concat($e) : Se = -1,
            $e.length && tt())
        }
        function tt() {
            if (!Ee) {
                var we = fe(Ne);
                Ee = !0;
                for (var Ut = $e.length; Ut; ) {
                    for (xe = $e,
                    $e = []; ++Se < Ut; )
                        xe && xe[Se].run();
                    Se = -1,
                    Ut = $e.length
                }
                xe = null,
                Ee = !1,
                ge(we)
            }
        }
        function rr(we, Ut) {
            this.fun = we,
            this.array = Ut
        }
        function tr() {}
        ue.nextTick = function(we) {
            var Ut = new Array(arguments.length - 1);
            if (arguments.length > 1)
                for (var lr = 1; lr < arguments.length; lr++)
                    Ut[lr - 1] = arguments[lr];
            $e.push(new rr(we,Ut)),
            $e.length !== 1 || Ee || fe(tt)
        }
        ,
        rr.prototype.run = function() {
            this.fun.apply(null, this.array)
        }
        ,
        ue.title = "browser",
        ue.browser = !0,
        ue.env = {},
        ue.argv = [],
        ue.version = "",
        ue.versions = {},
        ue.on = tr,
        ue.addListener = tr,
        ue.once = tr,
        ue.off = tr,
        ue.removeListener = tr,
        ue.removeAllListeners = tr,
        ue.emit = tr,
        ue.prependListener = tr,
        ue.prependOnceListener = tr,
        ue.listeners = function(we) {
            return []
        }
        ,
        ue.binding = function(we) {
            throw new Error("process.binding is not supported")
        }
        ,
        ue.cwd = function() {
            return "/"
        }
        ,
        ue.chdir = function(we) {
            throw new Error("process.chdir is not supported")
        }
        ,
        ue.umask = function() {
            return 0
        }
    }
    , {}],
    4: [function(W, z, Y) {
        (function(ne) {
            for (var le = W("performance-now"), ue = typeof window > "u" ? ne : window, de = ["moz", "webkit"], he = "AnimationFrame", fe = ue["request" + he], ge = ue["cancel" + he] || ue["cancelRequest" + he], xe = 0; !fe && xe < de.length; xe++)
                fe = ue[de[xe] + "Request" + he],
                ge = ue[de[xe] + "Cancel" + he] || ue[de[xe] + "CancelRequest" + he];
            if (!fe || !ge) {
                var $e = 0
                  , Ee = 0
                  , Se = []
                  , Ne = 1e3 / 60;
                fe = function(tt) {
                    if (Se.length === 0) {
                        var rr = le()
                          , tr = Math.max(0, Ne - (rr - $e));
                        $e = tr + rr,
                        setTimeout(function() {
                            var we = Se.slice(0);
                            Se.length = 0;
                            for (var Ut = 0; Ut < we.length; Ut++)
                                if (!we[Ut].cancelled)
                                    try {
                                        we[Ut].callback($e)
                                    } catch (lr) {
                                        setTimeout(function() {
                                            throw lr
                                        }, 0)
                                    }
                        }, Math.round(tr))
                    }
                    return Se.push({
                        handle: ++Ee,
                        callback: tt,
                        cancelled: !1
                    }),
                    Ee
                }
                ,
                ge = function(tt) {
                    for (var rr = 0; rr < Se.length; rr++)
                        Se[rr].handle === tt && (Se[rr].cancelled = !0)
                }
            }
            z.exports = function(tt) {
                return fe.call(ue, tt)
            }
            ,
            z.exports.cancel = function() {
                ge.apply(ue, arguments)
            }
            ,
            z.exports.polyfill = function() {
                ue.requestAnimationFrame = fe,
                ue.cancelAnimationFrame = ge
            }
        }
        ).call(this, commonjsGlobal !== void 0 ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {})
    }
    , {
        "performance-now": 2
    }],
    5: [function(W, z, Y) {
        var ne = function() {
            function $e(Ee, Se) {
                for (var Ne = 0; Ne < Se.length; Ne++) {
                    var tt = Se[Ne];
                    tt.enumerable = tt.enumerable || !1,
                    tt.configurable = !0,
                    "value"in tt && (tt.writable = !0),
                    Object.defineProperty(Ee, tt.key, tt)
                }
            }
            return function(Ee, Se, Ne) {
                return Se && $e(Ee.prototype, Se),
                Ne && $e(Ee, Ne),
                Ee
            }
        }();
        function le($e, Ee) {
            if (!($e instanceof Ee))
                throw new TypeError("Cannot call a class as a function")
        }
        var ue = W("raf")
          , de = W("object-assign")
          , he = {
            propertyCache: {},
            vendors: [null, ["-webkit-", "webkit"], ["-moz-", "Moz"], ["-o-", "O"], ["-ms-", "ms"]],
            clamp: function($e, Ee, Se) {
                return Ee < Se ? $e < Ee ? Ee : $e > Se ? Se : $e : $e < Se ? Se : $e > Ee ? Ee : $e
            },
            data: function($e, Ee) {
                return he.deserialize($e.getAttribute("data-" + Ee))
            },
            deserialize: function($e) {
                return $e === "true" || $e !== "false" && ($e === "null" ? null : !isNaN(parseFloat($e)) && isFinite($e) ? parseFloat($e) : $e)
            },
            camelCase: function($e) {
                return $e.replace(/-+(.)?/g, function(Ee, Se) {
                    return Se ? Se.toUpperCase() : ""
                })
            },
            accelerate: function($e) {
                he.css($e, "transform", "translate3d(0,0,0) rotate(0.0001deg)"),
                he.css($e, "transform-style", "preserve-3d"),
                he.css($e, "backface-visibility", "hidden")
            },
            transformSupport: function($e) {
                for (var Ee = document.createElement("div"), Se = !1, Ne = null, tt = !1, rr = null, tr = null, we = 0, Ut = he.vendors.length; we < Ut; we++)
                    if (he.vendors[we] !== null ? (rr = he.vendors[we][0] + "transform",
                    tr = he.vendors[we][1] + "Transform") : (rr = "transform",
                    tr = "transform"),
                    Ee.style[tr] !== void 0) {
                        Se = !0;
                        break
                    }
                switch ($e) {
                case "2D":
                    tt = Se;
                    break;
                case "3D":
                    if (Se) {
                        var lr = document.body || document.createElement("body")
                          , cr = document.documentElement
                          , be = cr.style.overflow
                          , mr = !1;
                        document.body || (mr = !0,
                        cr.style.overflow = "hidden",
                        cr.appendChild(lr),
                        lr.style.overflow = "hidden",
                        lr.style.background = ""),
                        lr.appendChild(Ee),
                        Ee.style[tr] = "translate3d(1px,1px,1px)",
                        tt = (Ne = window.getComputedStyle(Ee).getPropertyValue(rr)) !== void 0 && Ne.length > 0 && Ne !== "none",
                        cr.style.overflow = be,
                        lr.removeChild(Ee),
                        mr && (lr.removeAttribute("style"),
                        lr.parentNode.removeChild(lr))
                    }
                }
                return tt
            },
            css: function($e, Ee, Se) {
                var Ne = he.propertyCache[Ee];
                if (!Ne) {
                    for (var tt = 0, rr = he.vendors.length; tt < rr; tt++)
                        if (Ne = he.vendors[tt] !== null ? he.camelCase(he.vendors[tt][1] + "-" + Ee) : Ee,
                        $e.style[Ne] !== void 0) {
                            he.propertyCache[Ee] = Ne;
                            break
                        }
                }
                $e.style[Ne] = Se
            }
        }
          , fe = 30
          , ge = {
            relativeInput: !1,
            clipRelativeInput: !1,
            inputElement: null,
            hoverOnly: !1,
            calibrationThreshold: 100,
            calibrationDelay: 500,
            supportDelay: 500,
            calibrateX: !1,
            calibrateY: !0,
            invertX: !0,
            invertY: !0,
            limitX: !1,
            limitY: !1,
            scalarX: 10,
            scalarY: 10,
            frictionX: .1,
            frictionY: .1,
            originX: .5,
            originY: .5,
            pointerEvents: !1,
            precision: 1,
            onReady: null,
            selector: null
        }
          , xe = function() {
            function $e(Ee, Se) {
                le(this, $e),
                this.element = Ee;
                var Ne = {
                    calibrateX: he.data(this.element, "calibrate-x"),
                    calibrateY: he.data(this.element, "calibrate-y"),
                    invertX: he.data(this.element, "invert-x"),
                    invertY: he.data(this.element, "invert-y"),
                    limitX: he.data(this.element, "limit-x"),
                    limitY: he.data(this.element, "limit-y"),
                    scalarX: he.data(this.element, "scalar-x"),
                    scalarY: he.data(this.element, "scalar-y"),
                    frictionX: he.data(this.element, "friction-x"),
                    frictionY: he.data(this.element, "friction-y"),
                    originX: he.data(this.element, "origin-x"),
                    originY: he.data(this.element, "origin-y"),
                    pointerEvents: he.data(this.element, "pointer-events"),
                    precision: he.data(this.element, "precision"),
                    relativeInput: he.data(this.element, "relative-input"),
                    clipRelativeInput: he.data(this.element, "clip-relative-input"),
                    hoverOnly: he.data(this.element, "hover-only"),
                    inputElement: document.querySelector(he.data(this.element, "input-element")),
                    selector: he.data(this.element, "selector")
                };
                for (var tt in Ne)
                    Ne[tt] === null && delete Ne[tt];
                de(this, ge, Ne, Se),
                this.inputElement || (this.inputElement = this.element),
                this.calibrationTimer = null,
                this.calibrationFlag = !0,
                this.enabled = !1,
                this.depthsX = [],
                this.depthsY = [],
                this.raf = null,
                this.bounds = null,
                this.elementPositionX = 0,
                this.elementPositionY = 0,
                this.elementWidth = 0,
                this.elementHeight = 0,
                this.elementCenterX = 0,
                this.elementCenterY = 0,
                this.elementRangeX = 0,
                this.elementRangeY = 0,
                this.calibrationX = 0,
                this.calibrationY = 0,
                this.inputX = 0,
                this.inputY = 0,
                this.motionX = 0,
                this.motionY = 0,
                this.velocityX = 0,
                this.velocityY = 0,
                this.onMouseMove = this.onMouseMove.bind(this),
                this.onDeviceOrientation = this.onDeviceOrientation.bind(this),
                this.onDeviceMotion = this.onDeviceMotion.bind(this),
                this.onOrientationTimer = this.onOrientationTimer.bind(this),
                this.onMotionTimer = this.onMotionTimer.bind(this),
                this.onCalibrationTimer = this.onCalibrationTimer.bind(this),
                this.onAnimationFrame = this.onAnimationFrame.bind(this),
                this.onWindowResize = this.onWindowResize.bind(this),
                this.windowWidth = null,
                this.windowHeight = null,
                this.windowCenterX = null,
                this.windowCenterY = null,
                this.windowRadiusX = null,
                this.windowRadiusY = null,
                this.portrait = !1,
                this.desktop = !navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry|BB10|mobi|tablet|opera mini|nexus 7)/i),
                this.motionSupport = !!window.DeviceMotionEvent && !this.desktop,
                this.orientationSupport = !!window.DeviceOrientationEvent && !this.desktop,
                this.orientationStatus = 0,
                this.motionStatus = 0,
                this.initialise()
            }
            return ne($e, [{
                key: "initialise",
                value: function() {
                    this.transform2DSupport === void 0 && (this.transform2DSupport = he.transformSupport("2D"),
                    this.transform3DSupport = he.transformSupport("3D")),
                    this.transform3DSupport && he.accelerate(this.element),
                    window.getComputedStyle(this.element).getPropertyValue("position") === "static" && (this.element.style.position = "relative"),
                    this.pointerEvents || (this.element.style.pointerEvents = "none"),
                    this.updateLayers(),
                    this.updateDimensions(),
                    this.enable(),
                    this.queueCalibration(this.calibrationDelay)
                }
            }, {
                key: "doReadyCallback",
                value: function() {
                    this.onReady && this.onReady()
                }
            }, {
                key: "updateLayers",
                value: function() {
                    this.selector ? this.layers = this.element.querySelectorAll(this.selector) : this.layers = this.element.children,
                    this.layers.length || console.warn("ParallaxJS: Your scene does not have any layers."),
                    this.depthsX = [],
                    this.depthsY = [];
                    for (var Ee = 0; Ee < this.layers.length; Ee++) {
                        var Se = this.layers[Ee];
                        this.transform3DSupport && he.accelerate(Se),
                        Se.style.position = Ee ? "absolute" : "relative",
                        Se.style.display = "block",
                        Se.style.left = 0,
                        Se.style.top = 0;
                        var Ne = he.data(Se, "depth") || 0;
                        this.depthsX.push(he.data(Se, "depth-x") || Ne),
                        this.depthsY.push(he.data(Se, "depth-y") || Ne)
                    }
                }
            }, {
                key: "updateDimensions",
                value: function() {
                    this.windowWidth = window.innerWidth,
                    this.windowHeight = window.innerHeight,
                    this.windowCenterX = this.windowWidth * this.originX,
                    this.windowCenterY = this.windowHeight * this.originY,
                    this.windowRadiusX = Math.max(this.windowCenterX, this.windowWidth - this.windowCenterX),
                    this.windowRadiusY = Math.max(this.windowCenterY, this.windowHeight - this.windowCenterY)
                }
            }, {
                key: "updateBounds",
                value: function() {
                    this.bounds = this.inputElement.getBoundingClientRect(),
                    this.elementPositionX = this.bounds.left,
                    this.elementPositionY = this.bounds.top,
                    this.elementWidth = this.bounds.width,
                    this.elementHeight = this.bounds.height,
                    this.elementCenterX = this.elementWidth * this.originX,
                    this.elementCenterY = this.elementHeight * this.originY,
                    this.elementRangeX = Math.max(this.elementCenterX, this.elementWidth - this.elementCenterX),
                    this.elementRangeY = Math.max(this.elementCenterY, this.elementHeight - this.elementCenterY)
                }
            }, {
                key: "queueCalibration",
                value: function(Ee) {
                    clearTimeout(this.calibrationTimer),
                    this.calibrationTimer = setTimeout(this.onCalibrationTimer, Ee)
                }
            }, {
                key: "enable",
                value: function() {
                    this.enabled || (this.enabled = !0,
                    this.orientationSupport ? (this.portrait = !1,
                    window.addEventListener("deviceorientation", this.onDeviceOrientation),
                    this.detectionTimer = setTimeout(this.onOrientationTimer, this.supportDelay)) : this.motionSupport ? (this.portrait = !1,
                    window.addEventListener("devicemotion", this.onDeviceMotion),
                    this.detectionTimer = setTimeout(this.onMotionTimer, this.supportDelay)) : (this.calibrationX = 0,
                    this.calibrationY = 0,
                    this.portrait = !1,
                    window.addEventListener("mousemove", this.onMouseMove),
                    this.doReadyCallback()),
                    window.addEventListener("resize", this.onWindowResize),
                    this.raf = ue(this.onAnimationFrame))
                }
            }, {
                key: "disable",
                value: function() {
                    this.enabled && (this.enabled = !1,
                    this.orientationSupport ? window.removeEventListener("deviceorientation", this.onDeviceOrientation) : this.motionSupport ? window.removeEventListener("devicemotion", this.onDeviceMotion) : window.removeEventListener("mousemove", this.onMouseMove),
                    window.removeEventListener("resize", this.onWindowResize),
                    ue.cancel(this.raf))
                }
            }, {
                key: "calibrate",
                value: function(Ee, Se) {
                    this.calibrateX = Ee === void 0 ? this.calibrateX : Ee,
                    this.calibrateY = Se === void 0 ? this.calibrateY : Se
                }
            }, {
                key: "invert",
                value: function(Ee, Se) {
                    this.invertX = Ee === void 0 ? this.invertX : Ee,
                    this.invertY = Se === void 0 ? this.invertY : Se
                }
            }, {
                key: "friction",
                value: function(Ee, Se) {
                    this.frictionX = Ee === void 0 ? this.frictionX : Ee,
                    this.frictionY = Se === void 0 ? this.frictionY : Se
                }
            }, {
                key: "scalar",
                value: function(Ee, Se) {
                    this.scalarX = Ee === void 0 ? this.scalarX : Ee,
                    this.scalarY = Se === void 0 ? this.scalarY : Se
                }
            }, {
                key: "limit",
                value: function(Ee, Se) {
                    this.limitX = Ee === void 0 ? this.limitX : Ee,
                    this.limitY = Se === void 0 ? this.limitY : Se
                }
            }, {
                key: "origin",
                value: function(Ee, Se) {
                    this.originX = Ee === void 0 ? this.originX : Ee,
                    this.originY = Se === void 0 ? this.originY : Se
                }
            }, {
                key: "setInputElement",
                value: function(Ee) {
                    this.inputElement = Ee,
                    this.updateDimensions()
                }
            }, {
                key: "setPosition",
                value: function(Ee, Se, Ne) {
                    Se = Se.toFixed(this.precision) + "px",
                    Ne = Ne.toFixed(this.precision) + "px",
                    this.transform3DSupport ? he.css(Ee, "transform", "translate3d(" + Se + "," + Ne + ",0)") : this.transform2DSupport ? he.css(Ee, "transform", "translate(" + Se + "," + Ne + ")") : (Ee.style.left = Se,
                    Ee.style.top = Ne)
                }
            }, {
                key: "onOrientationTimer",
                value: function() {
                    this.orientationSupport && this.orientationStatus === 0 ? (this.disable(),
                    this.orientationSupport = !1,
                    this.enable()) : this.doReadyCallback()
                }
            }, {
                key: "onMotionTimer",
                value: function() {
                    this.motionSupport && this.motionStatus === 0 ? (this.disable(),
                    this.motionSupport = !1,
                    this.enable()) : this.doReadyCallback()
                }
            }, {
                key: "onCalibrationTimer",
                value: function() {
                    this.calibrationFlag = !0
                }
            }, {
                key: "onWindowResize",
                value: function() {
                    this.updateDimensions()
                }
            }, {
                key: "onAnimationFrame",
                value: function() {
                    this.updateBounds();
                    var Ee = this.inputX - this.calibrationX
                      , Se = this.inputY - this.calibrationY;
                    (Math.abs(Ee) > this.calibrationThreshold || Math.abs(Se) > this.calibrationThreshold) && this.queueCalibration(0),
                    this.portrait ? (this.motionX = this.calibrateX ? Se : this.inputY,
                    this.motionY = this.calibrateY ? Ee : this.inputX) : (this.motionX = this.calibrateX ? Ee : this.inputX,
                    this.motionY = this.calibrateY ? Se : this.inputY),
                    this.motionX *= this.elementWidth * (this.scalarX / 100),
                    this.motionY *= this.elementHeight * (this.scalarY / 100),
                    isNaN(parseFloat(this.limitX)) || (this.motionX = he.clamp(this.motionX, -this.limitX, this.limitX)),
                    isNaN(parseFloat(this.limitY)) || (this.motionY = he.clamp(this.motionY, -this.limitY, this.limitY)),
                    this.velocityX += (this.motionX - this.velocityX) * this.frictionX,
                    this.velocityY += (this.motionY - this.velocityY) * this.frictionY;
                    for (var Ne = 0; Ne < this.layers.length; Ne++) {
                        var tt = this.layers[Ne]
                          , rr = this.depthsX[Ne]
                          , tr = this.depthsY[Ne]
                          , we = this.velocityX * (rr * (this.invertX ? -1 : 1))
                          , Ut = this.velocityY * (tr * (this.invertY ? -1 : 1));
                        this.setPosition(tt, we, Ut)
                    }
                    this.raf = ue(this.onAnimationFrame)
                }
            }, {
                key: "rotate",
                value: function(Ee, Se) {
                    var Ne = (Ee || 0) / fe
                      , tt = (Se || 0) / fe
                      , rr = this.windowHeight > this.windowWidth;
                    this.portrait !== rr && (this.portrait = rr,
                    this.calibrationFlag = !0),
                    this.calibrationFlag && (this.calibrationFlag = !1,
                    this.calibrationX = Ne,
                    this.calibrationY = tt),
                    this.inputX = Ne,
                    this.inputY = tt
                }
            }, {
                key: "onDeviceOrientation",
                value: function(Ee) {
                    var Se = Ee.beta
                      , Ne = Ee.gamma;
                    Se !== null && Ne !== null && (this.orientationStatus = 1,
                    this.rotate(Se, Ne))
                }
            }, {
                key: "onDeviceMotion",
                value: function(Ee) {
                    var Se = Ee.rotationRate.beta
                      , Ne = Ee.rotationRate.gamma;
                    Se !== null && Ne !== null && (this.motionStatus = 1,
                    this.rotate(Se, Ne))
                }
            }, {
                key: "onMouseMove",
                value: function(Ee) {
                    var Se = Ee.clientX
                      , Ne = Ee.clientY;
                    if (this.hoverOnly && (Se < this.elementPositionX || Se > this.elementPositionX + this.elementWidth || Ne < this.elementPositionY || Ne > this.elementPositionY + this.elementHeight))
                        return this.inputX = 0,
                        void (this.inputY = 0);
                    this.relativeInput ? (this.clipRelativeInput && (Se = Math.max(Se, this.elementPositionX),
                    Se = Math.min(Se, this.elementPositionX + this.elementWidth),
                    Ne = Math.max(Ne, this.elementPositionY),
                    Ne = Math.min(Ne, this.elementPositionY + this.elementHeight)),
                    this.elementRangeX && this.elementRangeY && (this.inputX = (Se - this.elementPositionX - this.elementCenterX) / this.elementRangeX,
                    this.inputY = (Ne - this.elementPositionY - this.elementCenterY) / this.elementRangeY)) : this.windowRadiusX && this.windowRadiusY && (this.inputX = (Se - this.windowCenterX) / this.windowRadiusX,
                    this.inputY = (Ne - this.windowCenterY) / this.windowRadiusY)
                }
            }, {
                key: "destroy",
                value: function() {
                    this.disable(),
                    clearTimeout(this.calibrationTimer),
                    clearTimeout(this.detectionTimer),
                    this.element.removeAttribute("style");
                    for (var Ee = 0; Ee < this.layers.length; Ee++)
                        this.layers[Ee].removeAttribute("style");
                    delete this.element,
                    delete this.layers
                }
            }, {
                key: "version",
                value: function() {
                    return "3.1.0"
                }
            }]),
            $e
        }();
        z.exports = xe
    }
    , {
        "object-assign": 1,
        raf: 4
    }]
}, {}, [5])(5);
var parallaxExports = parallax.exports;
const Parallax = getDefaultExportFromCjs(parallaxExports);
(function(W) {
    var z, Y, ne, le, ue, de, he = "Close", fe = "BeforeClose", ge = "AfterClose", xe = "BeforeAppend", $e = "MarkupParse", Ee = "Open", Se = "Change", Ne = "mfp", tt = "." + Ne, rr = "mfp-ready", tr = "mfp-removing", we = "mfp-prevent-close", Ut = function() {}, lr = !!window.jQuery, cr = W(window), be = function(dr, Sr) {
        z.ev.on(Ne + dr + tt, Sr)
    }, mr = function(dr, Sr, Gr, Qr) {
        var vn = document.createElement("div");
        return vn.className = "mfp-" + dr,
        Gr && (vn.innerHTML = Gr),
        Qr ? Sr && Sr.appendChild(vn) : (vn = W(vn),
        Sr && vn.appendTo(Sr)),
        vn
    }, fr = function(dr, Sr) {
        z.ev.triggerHandler(Ne + dr, Sr),
        z.st.callbacks && (dr = dr.charAt(0).toLowerCase() + dr.slice(1),
        z.st.callbacks[dr] && z.st.callbacks[dr].apply(z, W.isArray(Sr) ? Sr : [Sr]))
    }, Rr = function(dr) {
        return dr === de && z.currTemplate.closeBtn || (z.currTemplate.closeBtn = W(z.st.closeMarkup.replace("%title%", z.st.tClose)),
        de = dr),
        z.currTemplate.closeBtn
    }, Pr = function() {
        W.magnificPopup.instance || ((z = new Ut).init(),
        W.magnificPopup.instance = z)
    }, Fr = function() {
        var dr = document.createElement("p").style
          , Sr = ["ms", "O", "Moz", "Webkit"];
        if (dr.transition !== void 0)
            return !0;
        for (; Sr.length; )
            if (Sr.pop() + "Transition"in dr)
                return !0;
        return !1
    };
    Ut.prototype = {
        constructor: Ut,
        init: function() {
            var dr = navigator.appVersion;
            z.isLowIE = z.isIE8 = document.all && !document.addEventListener,
            z.isAndroid = /android/gi.test(dr),
            z.isIOS = /iphone|ipad|ipod/gi.test(dr),
            z.supportsTransition = Fr(),
            z.probablyMobile = z.isAndroid || z.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent),
            ne = W(document),
            z.popupsCache = {}
        },
        open: function(dr) {
            var Sr;
            if (dr.isObj === !1) {
                z.items = dr.items.toArray(),
                z.index = 0;
                var Gr, Qr = dr.items;
                for (Sr = 0; Sr < Qr.length; Sr++)
                    if ((Gr = Qr[Sr]).parsed && (Gr = Gr.el[0]),
                    Gr === dr.el[0]) {
                        z.index = Sr;
                        break
                    }
            } else
                z.items = W.isArray(dr.items) ? dr.items : [dr.items],
                z.index = dr.index || 0;
            if (!z.isOpen) {
                z.types = [],
                ue = "",
                dr.mainEl && dr.mainEl.length ? z.ev = dr.mainEl.eq(0) : z.ev = ne,
                dr.key ? (z.popupsCache[dr.key] || (z.popupsCache[dr.key] = {}),
                z.currTemplate = z.popupsCache[dr.key]) : z.currTemplate = {},
                z.st = W.extend(!0, {}, W.magnificPopup.defaults, dr),
                z.fixedContentPos = z.st.fixedContentPos === "auto" ? !z.probablyMobile : z.st.fixedContentPos,
                z.st.modal && (z.st.closeOnContentClick = !1,
                z.st.closeOnBgClick = !1,
                z.st.showCloseBtn = !1,
                z.st.enableEscapeKey = !1),
                z.bgOverlay || (z.bgOverlay = mr("bg").on("click" + tt, function() {
                    z.close()
                }),
                z.wrap = mr("wrap").attr("tabindex", -1).on("click" + tt, function(Ar) {
                    z._checkIfClose(Ar.target) && z.close()
                }),
                z.container = mr("container", z.wrap)),
                z.contentContainer = mr("content"),
                z.st.preloader && (z.preloader = mr("preloader", z.container, z.st.tLoading));
                var vn = W.magnificPopup.modules;
                for (Sr = 0; Sr < vn.length; Sr++) {
                    var Oe = vn[Sr];
                    Oe = Oe.charAt(0).toUpperCase() + Oe.slice(1),
                    z["init" + Oe].call(z)
                }
                fr("BeforeOpen"),
                z.st.showCloseBtn && (z.st.closeBtnInside ? (be($e, function(Ar, kr, _n, Qn) {
                    _n.close_replaceWith = Rr(Qn.type)
                }),
                ue += " mfp-close-btn-in") : z.wrap.append(Rr())),
                z.st.alignTop && (ue += " mfp-align-top"),
                z.fixedContentPos ? z.wrap.css({
                    overflow: z.st.overflowY,
                    overflowX: "hidden",
                    overflowY: z.st.overflowY
                }) : z.wrap.css({
                    top: cr.scrollTop(),
                    position: "absolute"
                }),
                (z.st.fixedBgPos === !1 || z.st.fixedBgPos === "auto" && !z.fixedContentPos) && z.bgOverlay.css({
                    height: ne.height(),
                    position: "absolute"
                }),
                z.st.enableEscapeKey && ne.on("keyup" + tt, function(Ar) {
                    Ar.keyCode === 27 && z.close()
                }),
                cr.on("resize" + tt, function() {
                    z.updateSize()
                }),
                z.st.closeOnContentClick || (ue += " mfp-auto-cursor"),
                ue && z.wrap.addClass(ue);
                var ot = z.wH = cr.height()
                  , ir = {};
                if (z.fixedContentPos && z._hasScrollBar(ot)) {
                    var vr = z._getScrollbarSize();
                    vr && (ir.marginRight = vr)
                }
                z.fixedContentPos && (z.isIE7 ? W("body, html").css("overflow", "hidden") : ir.overflow = "hidden");
                var Er = z.st.mainClass;
                return z.isIE7 && (Er += " mfp-ie7"),
                Er && z._addClassToMFP(Er),
                z.updateItemHTML(),
                fr("BuildControls"),
                W("html").css(ir),
                z.bgOverlay.add(z.wrap).prependTo(z.st.prependTo || W(document.body)),
                z._lastFocusedEl = document.activeElement,
                setTimeout(function() {
                    z.content ? (z._addClassToMFP(rr),
                    z._setFocus()) : z.bgOverlay.addClass(rr),
                    ne.on("focusin" + tt, z._onFocusIn)
                }, 16),
                z.isOpen = !0,
                z.updateSize(ot),
                fr(Ee),
                dr
            }
            z.updateItemHTML()
        },
        close: function() {
            z.isOpen && (fr(fe),
            z.isOpen = !1,
            z.st.removalDelay && !z.isLowIE && z.supportsTransition ? (z._addClassToMFP(tr),
            setTimeout(function() {
                z._close()
            }, z.st.removalDelay)) : z._close())
        },
        _close: function() {
            fr(he);
            var dr = tr + " " + rr + " ";
            if (z.bgOverlay.detach(),
            z.wrap.detach(),
            z.container.empty(),
            z.st.mainClass && (dr += z.st.mainClass + " "),
            z._removeClassFromMFP(dr),
            z.fixedContentPos) {
                var Sr = {
                    marginRight: ""
                };
                z.isIE7 ? W("body, html").css("overflow", "") : Sr.overflow = "",
                W("html").css(Sr)
            }
            ne.off("keyup" + tt + " focusin" + tt),
            z.ev.off(tt),
            z.wrap.attr("class", "mfp-wrap").removeAttr("style"),
            z.bgOverlay.attr("class", "mfp-bg"),
            z.container.attr("class", "mfp-container"),
            !z.st.showCloseBtn || z.st.closeBtnInside && z.currTemplate[z.currItem.type] !== !0 || z.currTemplate.closeBtn && z.currTemplate.closeBtn.detach(),
            z.st.autoFocusLast && z._lastFocusedEl && W(z._lastFocusedEl).focus(),
            z.currItem = null,
            z.content = null,
            z.currTemplate = null,
            z.prevHeight = 0,
            fr(ge)
        },
        updateSize: function(dr) {
            if (z.isIOS) {
                var Sr = document.documentElement.clientWidth / window.innerWidth
                  , Gr = window.innerHeight * Sr;
                z.wrap.css("height", Gr),
                z.wH = Gr
            } else
                z.wH = dr || cr.height();
            z.fixedContentPos || z.wrap.css("height", z.wH),
            fr("Resize")
        },
        updateItemHTML: function() {
            var dr = z.items[z.index];
            z.contentContainer.detach(),
            z.content && z.content.detach(),
            dr.parsed || (dr = z.parseEl(z.index));
            var Sr = dr.type;
            if (fr("BeforeChange", [z.currItem ? z.currItem.type : "", Sr]),
            z.currItem = dr,
            !z.currTemplate[Sr]) {
                var Gr = !!z.st[Sr] && z.st[Sr].markup;
                fr("FirstMarkupParse", Gr),
                z.currTemplate[Sr] = !Gr || W(Gr)
            }
            le && le !== dr.type && z.container.removeClass("mfp-" + le + "-holder");
            var Qr = z["get" + Sr.charAt(0).toUpperCase() + Sr.slice(1)](dr, z.currTemplate[Sr]);
            z.appendContent(Qr, Sr),
            dr.preloaded = !0,
            fr(Se, dr),
            le = dr.type,
            z.container.prepend(z.contentContainer),
            fr("AfterChange")
        },
        appendContent: function(dr, Sr) {
            z.content = dr,
            dr ? z.st.showCloseBtn && z.st.closeBtnInside && z.currTemplate[Sr] === !0 ? z.content.find(".mfp-close").length || z.content.append(Rr()) : z.content = dr : z.content = "",
            fr(xe),
            z.container.addClass("mfp-" + Sr + "-holder"),
            z.contentContainer.append(z.content)
        },
        parseEl: function(dr) {
            var Sr, Gr = z.items[dr];
            if (Gr.tagName ? Gr = {
                el: W(Gr)
            } : (Sr = Gr.type,
            Gr = {
                data: Gr,
                src: Gr.src
            }),
            Gr.el) {
                for (var Qr = z.types, vn = 0; vn < Qr.length; vn++)
                    if (Gr.el.hasClass("mfp-" + Qr[vn])) {
                        Sr = Qr[vn];
                        break
                    }
                Gr.src = Gr.el.attr("data-mfp-src"),
                Gr.src || (Gr.src = Gr.el.attr("href"))
            }
            return Gr.type = Sr || z.st.type || "inline",
            Gr.index = dr,
            Gr.parsed = !0,
            z.items[dr] = Gr,
            fr("ElementParse", Gr),
            z.items[dr]
        },
        addGroup: function(dr, Sr) {
            var Gr = function(vn) {
                vn.mfpEl = this,
                z._openClick(vn, dr, Sr)
            };
            Sr || (Sr = {});
            var Qr = "click.magnificPopup";
            Sr.mainEl = dr,
            Sr.items ? (Sr.isObj = !0,
            dr.off(Qr).on(Qr, Gr)) : (Sr.isObj = !1,
            Sr.delegate ? dr.off(Qr).on(Qr, Sr.delegate, Gr) : (Sr.items = dr,
            dr.off(Qr).on(Qr, Gr)))
        },
        _openClick: function(dr, Sr, Gr) {
            if ((Gr.midClick !== void 0 ? Gr.midClick : W.magnificPopup.defaults.midClick) || !(dr.which === 2 || dr.ctrlKey || dr.metaKey || dr.altKey || dr.shiftKey)) {
                var Qr = Gr.disableOn !== void 0 ? Gr.disableOn : W.magnificPopup.defaults.disableOn;
                if (Qr) {
                    if (W.isFunction(Qr)) {
                        if (!Qr.call(z))
                            return !0
                    } else if (cr.width() < Qr)
                        return !0
                }
                dr.type && (dr.preventDefault(),
                z.isOpen && dr.stopPropagation()),
                Gr.el = W(dr.mfpEl),
                Gr.delegate && (Gr.items = Sr.find(Gr.delegate)),
                z.open(Gr)
            }
        },
        updateStatus: function(dr, Sr) {
            if (z.preloader) {
                Y !== dr && z.container.removeClass("mfp-s-" + Y),
                Sr || dr !== "loading" || (Sr = z.st.tLoading);
                var Gr = {
                    status: dr,
                    text: Sr
                };
                fr("UpdateStatus", Gr),
                dr = Gr.status,
                Sr = Gr.text,
                z.preloader.html(Sr),
                z.preloader.find("a").on("click", function(Qr) {
                    Qr.stopImmediatePropagation()
                }),
                z.container.addClass("mfp-s-" + dr),
                Y = dr
            }
        },
        _checkIfClose: function(dr) {
            if (!W(dr).hasClass(we)) {
                var Sr = z.st.closeOnContentClick
                  , Gr = z.st.closeOnBgClick;
                if (Sr && Gr || !z.content || W(dr).hasClass("mfp-close") || z.preloader && dr === z.preloader[0])
                    return !0;
                if (dr === z.content[0] || W.contains(z.content[0], dr)) {
                    if (Sr)
                        return !0
                } else if (Gr && W.contains(document, dr))
                    return !0;
                return !1
            }
        },
        _addClassToMFP: function(dr) {
            z.bgOverlay.addClass(dr),
            z.wrap.addClass(dr)
        },
        _removeClassFromMFP: function(dr) {
            this.bgOverlay.removeClass(dr),
            z.wrap.removeClass(dr)
        },
        _hasScrollBar: function(dr) {
            return (z.isIE7 ? ne.height() : document.body.scrollHeight) > (dr || cr.height())
        },
        _setFocus: function() {
            (z.st.focus ? z.content.find(z.st.focus).eq(0) : z.wrap).focus()
        },
        _onFocusIn: function(dr) {
            if (dr.target !== z.wrap[0] && !W.contains(z.wrap[0], dr.target))
                return z._setFocus(),
                !1
        },
        _parseMarkup: function(dr, Sr, Gr) {
            var Qr;
            Gr.data && (Sr = W.extend(Gr.data, Sr)),
            fr($e, [dr, Sr, Gr]),
            W.each(Sr, function(vn, Oe) {
                if (Oe === void 0 || Oe === !1)
                    return !0;
                if ((Qr = vn.split("_")).length > 1) {
                    var ot = dr.find(tt + "-" + Qr[0]);
                    if (ot.length > 0) {
                        var ir = Qr[1];
                        ir === "replaceWith" ? ot[0] !== Oe[0] && ot.replaceWith(Oe) : ir === "img" ? ot.is("img") ? ot.attr("src", Oe) : ot.replaceWith(W("<img>").attr("src", Oe).attr("class", ot.attr("class"))) : ot.attr(Qr[1], Oe)
                    }
                } else
                    dr.find(tt + "-" + vn).html(Oe)
            })
        },
        _getScrollbarSize: function() {
            if (z.scrollbarSize === void 0) {
                var dr = document.createElement("div");
                dr.style.cssText = "width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;",
                document.body.appendChild(dr),
                z.scrollbarSize = dr.offsetWidth - dr.clientWidth,
                document.body.removeChild(dr)
            }
            return z.scrollbarSize
        }
    },
    W.magnificPopup = {
        instance: null,
        proto: Ut.prototype,
        modules: [],
        open: function(dr, Sr) {
            return Pr(),
            (dr = dr ? W.extend(!0, {}, dr) : {}).isObj = !0,
            dr.index = Sr || 0,
            this.instance.open(dr)
        },
        close: function() {
            return W.magnificPopup.instance && W.magnificPopup.instance.close()
        },
        registerModule: function(dr, Sr) {
            Sr.options && (W.magnificPopup.defaults[dr] = Sr.options),
            W.extend(this.proto, Sr.proto),
            this.modules.push(dr)
        },
        defaults: {
            disableOn: 0,
            key: null,
            midClick: !1,
            mainClass: "",
            preloader: !0,
            focus: "",
            closeOnContentClick: !1,
            closeOnBgClick: !0,
            closeBtnInside: !0,
            showCloseBtn: !0,
            enableEscapeKey: !0,
            modal: !1,
            alignTop: !1,
            removalDelay: 0,
            prependTo: null,
            fixedContentPos: "auto",
            fixedBgPos: "auto",
            overflowY: "auto",
            closeMarkup: '<button title="%title%" type="button" class="mfp-close">&#215;</button>',
            tClose: "Close (Esc)",
            tLoading: "Loading...",
            autoFocusLast: !0
        }
    },
    W.fn.magnificPopup = function(dr) {
        Pr();
        var Sr = W(this);
        if (typeof dr == "string")
            if (dr === "open") {
                var Gr, Qr = lr ? Sr.data("magnificPopup") : Sr[0].magnificPopup, vn = parseInt(arguments[1], 10) || 0;
                Qr.items ? Gr = Qr.items[vn] : (Gr = Sr,
                Qr.delegate && (Gr = Gr.find(Qr.delegate)),
                Gr = Gr.eq(vn)),
                z._openClick({
                    mfpEl: Gr
                }, Sr, Qr)
            } else
                z.isOpen && z[dr].apply(z, Array.prototype.slice.call(arguments, 1));
        else
            dr = W.extend(!0, {}, dr),
            lr ? Sr.data("magnificPopup", dr) : Sr[0].magnificPopup = dr,
            z.addGroup(Sr, dr);
        return Sr
    }
    ;
    var br, xr, _r, Ir = "inline", Nr = function() {
        _r && (xr.after(_r.addClass(br)).detach(),
        _r = null)
    };
    W.magnificPopup.registerModule(Ir, {
        options: {
            hiddenClass: "hide",
            markup: "",
            tNotFound: "Content not found"
        },
        proto: {
            initInline: function() {
                z.types.push(Ir),
                be(he + "." + Ir, function() {
                    Nr()
                })
            },
            getInline: function(dr, Sr) {
                if (Nr(),
                dr.src) {
                    var Gr = z.st.inline
                      , Qr = W(dr.src);
                    if (Qr.length) {
                        var vn = Qr[0].parentNode;
                        vn && vn.tagName && (xr || (br = Gr.hiddenClass,
                        xr = mr(br),
                        br = "mfp-" + br),
                        _r = Qr.after(xr).detach().removeClass(br)),
                        z.updateStatus("ready")
                    } else
                        z.updateStatus("error", Gr.tNotFound),
                        Qr = W("<div>");
                    return dr.inlineElement = Qr,
                    Qr
                }
                return z.updateStatus("ready"),
                z._parseMarkup(Sr, {}, dr),
                Sr
            }
        }
    });
    var gn, Zr = "ajax", Tn = function() {
        gn && W(document.body).removeClass(gn)
    }, Zn = function() {
        Tn(),
        z.req && z.req.abort()
    };
    W.magnificPopup.registerModule(Zr, {
        options: {
            settings: null,
            cursor: "mfp-ajax-cur",
            tError: '<a href="%url%">The content</a> could not be loaded.'
        },
        proto: {
            initAjax: function() {
                z.types.push(Zr),
                gn = z.st.ajax.cursor,
                be(he + "." + Zr, Zn),
                be("BeforeChange." + Zr, Zn)
            },
            getAjax: function(dr) {
                gn && W(document.body).addClass(gn),
                z.updateStatus("loading");
                var Sr = W.extend({
                    url: dr.src,
                    success: function(Gr, Qr, vn) {
                        var Oe = {
                            data: Gr,
                            xhr: vn
                        };
                        fr("ParseAjax", Oe),
                        z.appendContent(W(Oe.data), Zr),
                        dr.finished = !0,
                        Tn(),
                        z._setFocus(),
                        setTimeout(function() {
                            z.wrap.addClass(rr)
                        }, 16),
                        z.updateStatus("ready"),
                        fr("AjaxContentAdded")
                    },
                    error: function() {
                        Tn(),
                        dr.finished = dr.loadError = !0,
                        z.updateStatus("error", z.st.ajax.tError.replace("%url%", dr.src))
                    }
                }, z.st.ajax.settings);
                return z.req = W.ajax(Sr),
                ""
            }
        }
    });
    var Cn, Gn = function(dr) {
        if (dr.data && dr.data.title !== void 0)
            return dr.data.title;
        var Sr = z.st.image.titleSrc;
        if (Sr) {
            if (W.isFunction(Sr))
                return Sr.call(z, dr);
            if (dr.el)
                return dr.el.attr(Sr) || ""
        }
        return ""
    };
    W.magnificPopup.registerModule("image", {
        options: {
            markup: '<div class="mfp-figure"><div class="mfp-close"></div><figure><div class="mfp-img"></div><figcaption><div class="mfp-bottom-bar"><div class="mfp-title"></div><div class="mfp-counter"></div></div></figcaption></figure></div>',
            cursor: "mfp-zoom-out-cur",
            titleSrc: "title",
            verticalFit: !0,
            tError: '<a href="%url%">The image</a> could not be loaded.'
        },
        proto: {
            initImage: function() {
                var dr = z.st.image
                  , Sr = ".image";
                z.types.push("image"),
                be(Ee + Sr, function() {
                    z.currItem.type === "image" && dr.cursor && W(document.body).addClass(dr.cursor)
                }),
                be(he + Sr, function() {
                    dr.cursor && W(document.body).removeClass(dr.cursor),
                    cr.off("resize" + tt)
                }),
                be("Resize" + Sr, z.resizeImage),
                z.isLowIE && be("AfterChange", z.resizeImage)
            },
            resizeImage: function() {
                var dr = z.currItem;
                if (dr && dr.img && z.st.image.verticalFit) {
                    var Sr = 0;
                    z.isLowIE && (Sr = parseInt(dr.img.css("padding-top"), 10) + parseInt(dr.img.css("padding-bottom"), 10)),
                    dr.img.css("max-height", z.wH - Sr)
                }
            },
            _onImageHasSize: function(dr) {
                dr.img && (dr.hasSize = !0,
                Cn && clearInterval(Cn),
                dr.isCheckingImgSize = !1,
                fr("ImageHasSize", dr),
                dr.imgHidden && (z.content && z.content.removeClass("mfp-loading"),
                dr.imgHidden = !1))
            },
            findImageSize: function(dr) {
                var Sr = 0
                  , Gr = dr.img[0]
                  , Qr = function(vn) {
                    Cn && clearInterval(Cn),
                    Cn = setInterval(function() {
                        Gr.naturalWidth > 0 ? z._onImageHasSize(dr) : (Sr > 200 && clearInterval(Cn),
                        ++Sr == 3 ? Qr(10) : Sr === 40 ? Qr(50) : Sr === 100 && Qr(500))
                    }, vn)
                };
                Qr(1)
            },
            getImage: function(dr, Sr) {
                var Gr = 0
                  , Qr = function() {
                    dr && (dr.img[0].complete ? (dr.img.off(".mfploader"),
                    dr === z.currItem && (z._onImageHasSize(dr),
                    z.updateStatus("ready")),
                    dr.hasSize = !0,
                    dr.loaded = !0,
                    fr("ImageLoadComplete")) : ++Gr < 200 ? setTimeout(Qr, 100) : vn())
                }
                  , vn = function() {
                    dr && (dr.img.off(".mfploader"),
                    dr === z.currItem && (z._onImageHasSize(dr),
                    z.updateStatus("error", Oe.tError.replace("%url%", dr.src))),
                    dr.hasSize = !0,
                    dr.loaded = !0,
                    dr.loadError = !0)
                }
                  , Oe = z.st.image
                  , ot = Sr.find(".mfp-img");
                if (ot.length) {
                    var ir = document.createElement("img");
                    ir.className = "mfp-img",
                    dr.el && dr.el.find("img").length && (ir.alt = dr.el.find("img").attr("alt")),
                    dr.img = W(ir).on("load.mfploader", Qr).on("error.mfploader", vn),
                    ir.src = dr.src,
                    ot.is("img") && (dr.img = dr.img.clone()),
                    (ir = dr.img[0]).naturalWidth > 0 ? dr.hasSize = !0 : ir.width || (dr.hasSize = !1)
                }
                return z._parseMarkup(Sr, {
                    title: Gn(dr),
                    img_replaceWith: dr.img
                }, dr),
                z.resizeImage(),
                dr.hasSize ? (Cn && clearInterval(Cn),
                dr.loadError ? (Sr.addClass("mfp-loading"),
                z.updateStatus("error", Oe.tError.replace("%url%", dr.src))) : (Sr.removeClass("mfp-loading"),
                z.updateStatus("ready")),
                Sr) : (z.updateStatus("loading"),
                dr.loading = !0,
                dr.hasSize || (dr.imgHidden = !0,
                Sr.addClass("mfp-loading"),
                z.findImageSize(dr)),
                Sr)
            }
        }
    });
    var ni, xi = function() {
        return ni === void 0 && (ni = document.createElement("p").style.MozTransform !== void 0),
        ni
    };
    W.magnificPopup.registerModule("zoom", {
        options: {
            enabled: !1,
            easing: "ease-in-out",
            duration: 300,
            opener: function(dr) {
                return dr.is("img") ? dr : dr.find("img")
            }
        },
        proto: {
            initZoom: function() {
                var dr, Sr = z.st.zoom, Gr = ".zoom";
                if (Sr.enabled && z.supportsTransition) {
                    var Qr, vn, Oe = Sr.duration, ot = function(vr) {
                        var Er = vr.clone().removeAttr("style").removeAttr("class").addClass("mfp-animated-image")
                          , Ar = "all " + Sr.duration / 1e3 + "s " + Sr.easing
                          , kr = {
                            position: "fixed",
                            zIndex: 9999,
                            left: 0,
                            top: 0,
                            "-webkit-backface-visibility": "hidden"
                        }
                          , _n = "transition";
                        return kr["-webkit-" + _n] = kr["-moz-" + _n] = kr["-o-" + _n] = kr[_n] = Ar,
                        Er.css(kr),
                        Er
                    }, ir = function() {
                        z.content.css("visibility", "visible")
                    };
                    be("BuildControls" + Gr, function() {
                        if (z._allowZoom()) {
                            if (clearTimeout(Qr),
                            z.content.css("visibility", "hidden"),
                            !(dr = z._getItemToZoom()))
                                return void ir();
                            (vn = ot(dr)).css(z._getOffset()),
                            z.wrap.append(vn),
                            Qr = setTimeout(function() {
                                vn.css(z._getOffset(!0)),
                                Qr = setTimeout(function() {
                                    ir(),
                                    setTimeout(function() {
                                        vn.remove(),
                                        dr = vn = null,
                                        fr("ZoomAnimationEnded")
                                    }, 16)
                                }, Oe)
                            }, 16)
                        }
                    }),
                    be(fe + Gr, function() {
                        if (z._allowZoom()) {
                            if (clearTimeout(Qr),
                            z.st.removalDelay = Oe,
                            !dr) {
                                if (!(dr = z._getItemToZoom()))
                                    return;
                                vn = ot(dr)
                            }
                            vn.css(z._getOffset(!0)),
                            z.wrap.append(vn),
                            z.content.css("visibility", "hidden"),
                            setTimeout(function() {
                                vn.css(z._getOffset())
                            }, 16)
                        }
                    }),
                    be(he + Gr, function() {
                        z._allowZoom() && (ir(),
                        vn && vn.remove(),
                        dr = null)
                    })
                }
            },
            _allowZoom: function() {
                return z.currItem.type === "image"
            },
            _getItemToZoom: function() {
                return !!z.currItem.hasSize && z.currItem.img
            },
            _getOffset: function(dr) {
                var Sr, Gr = (Sr = dr ? z.currItem.img : z.st.zoom.opener(z.currItem.el || z.currItem)).offset(), Qr = parseInt(Sr.css("padding-top"), 10), vn = parseInt(Sr.css("padding-bottom"), 10);
                Gr.top -= W(window).scrollTop() - Qr;
                var Oe = {
                    width: Sr.width(),
                    height: (lr ? Sr.innerHeight() : Sr[0].offsetHeight) - vn - Qr
                };
                return xi() ? Oe["-moz-transform"] = Oe.transform = "translate(" + Gr.left + "px," + Gr.top + "px)" : (Oe.left = Gr.left,
                Oe.top = Gr.top),
                Oe
            }
        }
    });
    var oi = "iframe"
      , $i = "//about:blank"
      , Ci = function(dr) {
        if (z.currTemplate[oi]) {
            var Sr = z.currTemplate[oi].find("iframe");
            Sr.length && (dr || (Sr[0].src = $i),
            z.isIE8 && Sr.css("display", dr ? "block" : "none"))
        }
    };
    W.magnificPopup.registerModule(oi, {
        options: {
            markup: '<div class="mfp-iframe-scaler"><div class="mfp-close"></div><iframe class="mfp-iframe" src="//about:blank" frameborder="0" allowfullscreen></iframe></div>',
            srcAction: "iframe_src",
            patterns: {
                youtube: {
                    index: "youtube.com",
                    id: "v=",
                    src: "//www.youtube.com/embed/%id%?autoplay=1"
                },
                vimeo: {
                    index: "vimeo.com/",
                    id: "/",
                    src: "//player.vimeo.com/video/%id%?autoplay=1"
                },
                gmaps: {
                    index: "//maps.google.",
                    src: "%id%&output=embed"
                }
            }
        },
        proto: {
            initIframe: function() {
                z.types.push(oi),
                be("BeforeChange", function(dr, Sr, Gr) {
                    Sr !== Gr && (Sr === oi ? Ci() : Gr === oi && Ci(!0))
                }),
                be(he + "." + oi, function() {
                    Ci()
                })
            },
            getIframe: function(dr, Sr) {
                var Gr = dr.src
                  , Qr = z.st.iframe;
                W.each(Qr.patterns, function() {
                    if (Gr.indexOf(this.index) > -1)
                        return this.id && (Gr = typeof this.id == "string" ? Gr.substr(Gr.lastIndexOf(this.id) + this.id.length, Gr.length) : this.id.call(this, Gr)),
                        Gr = this.src.replace("%id%", Gr),
                        !1
                });
                var vn = {};
                return Qr.srcAction && (vn[Qr.srcAction] = Gr),
                z._parseMarkup(Sr, vn, dr),
                z.updateStatus("ready"),
                Sr
            }
        }
    });
    var Yn = function(dr) {
        var Sr = z.items.length;
        return dr > Sr - 1 ? dr - Sr : dr < 0 ? Sr + dr : dr
    }
      , pi = function(dr, Sr, Gr) {
        return dr.replace(/%curr%/gi, Sr + 1).replace(/%total%/gi, Gr)
    };
    W.magnificPopup.registerModule("gallery", {
        options: {
            enabled: !1,
            arrowMarkup: '<button title="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"></button>',
            preload: [0, 2],
            navigateByImgClick: !0,
            arrows: !0,
            tPrev: "Previous (Left arrow key)",
            tNext: "Next (Right arrow key)",
            tCounter: "%curr% of %total%"
        },
        proto: {
            initGallery: function() {
                var dr = z.st.gallery
                  , Sr = ".mfp-gallery";
                if (z.direction = !0,
                !dr || !dr.enabled)
                    return !1;
                ue += " mfp-gallery",
                be(Ee + Sr, function() {
                    dr.navigateByImgClick && z.wrap.on("click" + Sr, ".mfp-img", function() {
                        if (z.items.length > 1)
                            return z.next(),
                            !1
                    }),
                    ne.on("keydown" + Sr, function(Gr) {
                        Gr.keyCode === 37 ? z.prev() : Gr.keyCode === 39 && z.next()
                    })
                }),
                be("UpdateStatus" + Sr, function(Gr, Qr) {
                    Qr.text && (Qr.text = pi(Qr.text, z.currItem.index, z.items.length))
                }),
                be($e + Sr, function(Gr, Qr, vn, Oe) {
                    var ot = z.items.length;
                    vn.counter = ot > 1 ? pi(dr.tCounter, Oe.index, ot) : ""
                }),
                be("BuildControls" + Sr, function() {
                    if (z.items.length > 1 && dr.arrows && !z.arrowLeft) {
                        var Gr = dr.arrowMarkup
                          , Qr = z.arrowLeft = W(Gr.replace(/%title%/gi, dr.tPrev).replace(/%dir%/gi, "left")).addClass(we)
                          , vn = z.arrowRight = W(Gr.replace(/%title%/gi, dr.tNext).replace(/%dir%/gi, "right")).addClass(we);
                        Qr.click(function() {
                            z.prev()
                        }),
                        vn.click(function() {
                            z.next()
                        }),
                        z.container.append(Qr.add(vn))
                    }
                }),
                be(Se + Sr, function() {
                    z._preloadTimeout && clearTimeout(z._preloadTimeout),
                    z._preloadTimeout = setTimeout(function() {
                        z.preloadNearbyImages(),
                        z._preloadTimeout = null
                    }, 16)
                }),
                be(he + Sr, function() {
                    ne.off(Sr),
                    z.wrap.off("click" + Sr),
                    z.arrowRight = z.arrowLeft = null
                })
            },
            next: function() {
                z.direction = !0,
                z.index = Yn(z.index + 1),
                z.updateItemHTML()
            },
            prev: function() {
                z.direction = !1,
                z.index = Yn(z.index - 1),
                z.updateItemHTML()
            },
            goTo: function(dr) {
                z.direction = dr >= z.index,
                z.index = dr,
                z.updateItemHTML()
            },
            preloadNearbyImages: function() {
                var dr, Sr = z.st.gallery.preload, Gr = Math.min(Sr[0], z.items.length), Qr = Math.min(Sr[1], z.items.length);
                for (dr = 1; dr <= (z.direction ? Qr : Gr); dr++)
                    z._preloadItem(z.index + dr);
                for (dr = 1; dr <= (z.direction ? Gr : Qr); dr++)
                    z._preloadItem(z.index - dr)
            },
            _preloadItem: function(dr) {
                if (dr = Yn(dr),
                !z.items[dr].preloaded) {
                    var Sr = z.items[dr];
                    Sr.parsed || (Sr = z.parseEl(dr)),
                    fr("LazyLoad", Sr),
                    Sr.type === "image" && (Sr.img = W('<img class="mfp-img" />').on("load.mfploader", function() {
                        Sr.hasSize = !0
                    }).on("error.mfploader", function() {
                        Sr.hasSize = !0,
                        Sr.loadError = !0,
                        fr("LazyLoadError", Sr)
                    }).attr("src", Sr.src)),
                    Sr.preloaded = !0
                }
            }
        }
    });
    var yi = "retina";
    W.magnificPopup.registerModule(yi, {
        options: {
            replaceSrc: function(dr) {
                return dr.src.replace(/\.\w+$/, function(Sr) {
                    return "@2x" + Sr
                })
            },
            ratio: 1
        },
        proto: {
            initRetina: function() {
                if (window.devicePixelRatio > 1) {
                    var dr = z.st.retina
                      , Sr = dr.ratio;
                    (Sr = isNaN(Sr) ? Sr() : Sr) > 1 && (be("ImageHasSize." + yi, function(Gr, Qr) {
                        Qr.img.css({
                            "max-width": Qr.img[0].naturalWidth / Sr,
                            width: "100%"
                        })
                    }),
                    be("ElementParse." + yi, function(Gr, Qr) {
                        Qr.src = dr.replaceSrc(Qr, Sr)
                    }))
                }
            }
        }
    }),
    Pr()
}
)(jqueryExports);
var jBox_all_min = {
    exports: {}
};
function isObject$2(W) {
    return W !== null && typeof W == "object" && "constructor"in W && W.constructor === Object
}
function extend$1(W, z) {
    W === void 0 && (W = {}),
    z === void 0 && (z = {}),
    Object.keys(z).forEach(Y=>{
        W[Y] === void 0 ? W[Y] = z[Y] : isObject$2(z[Y]) && isObject$2(W[Y]) && Object.keys(z[Y]).length > 0 && extend$1(W[Y], z[Y])
    }
    )
}
(function(module) {
    function jBoxWrapper(W) {
        function z(le, ue) {
            return this.options = {
                id: null,
                width: "auto",
                height: "auto",
                minWidth: null,
                minHeight: null,
                maxWidth: null,
                maxHeight: null,
                responsiveWidth: !0,
                responsiveHeight: !0,
                responsiveMinWidth: 100,
                responsiveMinHeight: 100,
                attach: null,
                trigger: "click",
                preventDefault: !1,
                content: null,
                getContent: null,
                title: null,
                getTitle: null,
                footer: null,
                isolateScroll: !0,
                ajax: {
                    url: null,
                    data: "",
                    reload: !1,
                    getURL: "data-url",
                    getData: "data-ajax",
                    setContent: !0,
                    loadingClass: !0,
                    spinner: !0,
                    spinnerDelay: 300,
                    spinnerReposition: !0
                },
                cancelAjaxOnClose: !0,
                target: null,
                position: {
                    x: "center",
                    y: "center"
                },
                outside: null,
                offset: 0,
                attributes: {
                    x: "left",
                    y: "top"
                },
                fixed: !1,
                adjustPosition: !0,
                adjustTracker: !1,
                adjustDistance: 5,
                reposition: !0,
                repositionOnOpen: !0,
                repositionOnContent: !0,
                holdPosition: !0,
                pointer: !1,
                pointTo: "target",
                fade: 180,
                animation: null,
                theme: "Default",
                addClass: null,
                overlay: !1,
                overlayClass: null,
                zIndex: 1e4,
                delayOpen: 0,
                delayClose: 0,
                closeOnEsc: !1,
                closeOnClick: !1,
                closeOnMouseleave: !1,
                closeButton: !1,
                appendTo: W("body"),
                createOnInit: !1,
                blockScroll: !1,
                blockScrollAdjust: !0,
                draggable: !1,
                dragOver: !0,
                autoClose: !1,
                delayOnHover: !1,
                showCountdown: !1,
                preloadAudio: !0,
                audio: null,
                volume: 100,
                onInit: null,
                onAttach: null,
                onPosition: null,
                onCreated: null,
                onOpen: null,
                onOpenComplete: null,
                onClose: null,
                onCloseComplete: null,
                onDragStart: null,
                onDragEnd: null
            },
            this._pluginOptions = {
                Tooltip: {
                    getContent: "title",
                    trigger: "mouseenter",
                    position: {
                        x: "center",
                        y: "top"
                    },
                    outside: "y",
                    pointer: !0
                },
                Mouse: {
                    responsiveWidth: !1,
                    responsiveHeight: !1,
                    adjustPosition: "flip",
                    target: "mouse",
                    trigger: "mouseenter",
                    position: {
                        x: "right",
                        y: "bottom"
                    },
                    outside: "xy",
                    offset: 5
                },
                Modal: {
                    target: W(window),
                    fixed: !0,
                    blockScroll: !0,
                    closeOnEsc: !0,
                    closeOnClick: "overlay",
                    closeButton: !0,
                    overlay: !0,
                    animation: "zoomIn"
                }
            },
            this.options = W.extend(!0, this.options, this._pluginOptions[le] || z._pluginOptions[le], ue),
            W.type(le) == "string" && (this.type = le),
            this.isTouchDevice = function() {
                var de, he = " -webkit- -moz- -o- -ms- ".split(" ");
                return !!("ontouchstart"in window || window.DocumentTouch && document instanceof DocumentTouch) || (de = he = ["(", he.join("touch-enabled),("), "heartz", ")"].join(""),
                window.matchMedia(de).matches)
            }(),
            this.isTouchDevice && this.options.trigger === "mouseenter" && this.options.closeOnClick === !1 && (this.options.closeOnClick = "body"),
            this._fireEvent = function(de, he) {
                this.options["_" + de] && this.options["_" + de].bind(this)(he),
                this.options[de] && this.options[de].bind(this)(he)
            }
            ,
            this.options.id === null && (this.options.id = "jBox" + z._getUniqueID()),
            this.id = this.options.id,
            (this.options.position.x == "center" && this.options.outside == "x" || this.options.position.y == "center" && this.options.outside == "y") && (this.options.outside = null),
            this.options.pointTo != "target" || this.options.outside && this.options.outside != "xy" || (this.options.pointer = !1),
            W.type(this.options.offset) != "object" ? this.options.offset = {
                x: this.options.offset,
                y: this.options.offset
            } : this.options.offset = W.extend({
                x: 0,
                y: 0
            }, this.options.offset),
            W.type(this.options.adjustDistance) != "object" ? this.options.adjustDistance = {
                top: this.options.adjustDistance,
                right: this.options.adjustDistance,
                bottom: this.options.adjustDistance,
                left: this.options.adjustDistance
            } : this.options.adjustDistance = W.extend({
                top: 5,
                left: 5,
                right: 5,
                bottom: 5
            }, this.options.adjustDistance),
            this.outside = !(!this.options.outside || this.options.outside == "xy") && this.options.position[this.options.outside],
            this.align = this.outside || (this.options.position.y != "center" && W.type(this.options.position.y) != "number" ? this.options.position.x : this.options.position.x != "center" && W.type(this.options.position.x) != "number" ? this.options.position.y : this.options.attributes.x),
            z.zIndexMax = Math.max(z.zIndexMax || 0, this.options.zIndex === "auto" ? 1e4 : this.options.zIndex),
            this.options.zIndex === "auto" && (this.adjustZIndexOnOpen = !0,
            this.options.zIndex = z.zIndexMax += 2,
            this.trueModal = this.options.overlay),
            this._getOpp = function(de) {
                return {
                    left: "right",
                    right: "left",
                    top: "bottom",
                    bottom: "top",
                    x: "y",
                    y: "x"
                }[de]
            }
            ,
            this._getXY = function(de) {
                return {
                    left: "x",
                    right: "x",
                    top: "y",
                    bottom: "y",
                    center: "x"
                }[de]
            }
            ,
            this._getTL = function(de) {
                return {
                    left: "left",
                    right: "left",
                    top: "top",
                    bottom: "top",
                    center: "left",
                    x: "left",
                    y: "top"
                }[de]
            }
            ,
            this._getInt = function(de, he) {
                return de == "auto" ? "auto" : de && W.type(de) == "string" && de.slice(-1) == "%" ? W(window)[he == "height" ? "innerHeight" : "innerWidth"]() * parseInt(de.replace("%", "")) / 100 : de
            }
            ,
            this._createSVG = function(de, he) {
                var fe = document.createElementNS("http://www.w3.org/2000/svg", de);
                return W.each(he, function(ge, xe) {
                    fe.setAttribute(xe[0], xe[1] || "")
                }),
                fe
            }
            ,
            this._isolateScroll = function(de) {
                de && de.length && de.on("DOMMouseScroll.jBoxIsolateScroll mousewheel.jBoxIsolateScroll", function(he) {
                    var fe = he.wheelDelta || he.originalEvent && he.originalEvent.wheelDelta || -he.detail
                      , ge = 0 <= this.scrollTop + de.outerHeight() - this.scrollHeight
                      , xe = this.scrollTop <= 0;
                    (fe < 0 && ge || 0 < fe && xe) && he.preventDefault()
                })
            }
            ,
            this._setTitleWidth = function() {
                if (!this.titleContainer || this.content[0].style.width == "auto" && !this.content[0].style.maxWidth)
                    return null;
                var de;
                this.wrapper.css("display") == "none" ? (this.wrapper.css("display", "block"),
                de = this.content.outerWidth(),
                this.wrapper.css("display", "none")) : de = this.content.outerWidth(),
                this.titleContainer.css({
                    maxWidth: Math.max(de, parseInt(this.content[0].style.maxWidth)) || null
                })
            }
            ,
            this._draggable = function() {
                if (!this.options.draggable)
                    return !1;
                var de = this.options.draggable == "title" ? this.titleContainer : this.options.draggable instanceof W ? this.options.draggable : W.type(this.options.draggable) == "string" ? W(this.options.draggable) : this.wrapper;
                return !(!(de && de instanceof W && de.length) || de.data("jBox-draggable")) && (de.addClass("jBox-draggable").data("jBox-draggable", !0).on("touchstart mousedown", function(he) {
                    var fe, ge, xe, $e, Ee, Se;
                    he.button == 2 || W(he.target).hasClass("jBox-noDrag") || W(he.target).parents(".jBox-noDrag").length ? he.type == "touchstart" && (W(he.target).hasClass("jBox-closeButton") || W(he.target).parents(".jBox-closeButton").length) && this.close({
                        ignoreDelay: !0
                    }) : (ge = he.type == "touchstart" && he.touches && he.touches[0] ? (fe = he.touches[0].pageX,
                    he.touches[0].pageY) : (fe = he.pageX,
                    he.pageY),
                    this.draggingStartX = fe,
                    this.draggingStartY = ge,
                    this.options.dragOver && !this.trueModal && parseInt(this.wrapper.css("zIndex"), 10) <= z.zIndexMaxDragover && (z.zIndexMaxDragover += 1,
                    this.wrapper.css("zIndex", z.zIndexMaxDragover)),
                    xe = this.wrapper.outerHeight(),
                    $e = this.wrapper.outerWidth(),
                    Ee = this.wrapper.offset().top + xe - ge,
                    Se = this.wrapper.offset().left + $e - fe,
                    W(document).on("touchmove.jBox-draggable-" + this.id + " mousemove.jBox-draggable-" + this.id, function(Ne) {
                        var tt;
                        Ne = Ne.type == "touchmove" && Ne.touches && Ne.touches[0] ? (tt = Ne.touches[0].pageX,
                        Ne.touches[0].pageY) : (tt = Ne.pageX,
                        Ne.pageY),
                        this.dragging || this.draggingStartX == tt || this.draggingStartY == Ne || (this._fireEvent("onDragStart"),
                        this.dragging = !0),
                        this.wrapper.offset({
                            top: Ne + Ee - xe,
                            left: tt + Se - $e
                        })
                    }
                    .bind(this)),
                    he.preventDefault())
                }
                .bind(this)).on("touchend mouseup", function() {
                    var he;
                    W(document).off("touchmove.jBox-draggable-" + this.id + " mousemove.jBox-draggable-" + this.id),
                    this.dragging && this._fireEvent("onDragEnd"),
                    this.dragging = !1,
                    this.type != "Modal" && this.type != "Confirm" || !this.options.holdPosition || (he = {
                        x: (he = W("#" + this.id).offset()).left - W(document).scrollLeft(),
                        y: he.top - W(document).scrollTop()
                    },
                    this.position({
                        position: he,
                        offset: {
                            x: 0,
                            y: 0
                        }
                    }))
                }
                .bind(this)),
                this.trueModal || (z.zIndexMaxDragover = z.zIndexMaxDragover ? Math.max(z.zIndexMaxDragover, this.options.zIndex) : this.options.zIndex),
                this)
            }
            ,
            this._create = function() {
                var de;
                this.wrapper || (this.wrapper = W("<div/>", {
                    id: this.id,
                    class: "jBox-wrapper" + (this.type ? " jBox-" + this.type : "") + (this.options.theme ? " jBox-" + this.options.theme : "") + (this.options.addClass ? " " + this.options.addClass : "")
                }).css({
                    position: this.options.fixed ? "fixed" : "absolute",
                    display: "none",
                    opacity: 0,
                    zIndex: this.options.zIndex
                }).data("jBox", this),
                this.options.closeOnMouseleave && this.wrapper.on("mouseleave", function(he) {
                    !this.source || he.relatedTarget != this.source[0] && W.inArray(this.source[0], W(he.relatedTarget).parents("*")) === -1 && this.close()
                }
                .bind(this)),
                this.options.closeOnClick == "box" && this.wrapper.on("click tap", function() {
                    this.close({
                        ignoreDelay: !0
                    })
                }
                .bind(this)),
                this.container = W('<div class="jBox-container"/>').appendTo(this.wrapper),
                this.content = W('<div class="jBox-content"/>').appendTo(this.container),
                this.options.footer && (this.footer = W('<div class="jBox-footer"/>').append(this.options.footer).appendTo(this.container)),
                this.options.isolateScroll && this._isolateScroll(this.content),
                this.options.closeButton && ((de = this._createSVG("svg", [["viewBox", "0 0 24 24"]])).appendChild(this._createSVG("path", [["d", "M22.2,4c0,0,0.5,0.6,0,1.1l-6.8,6.8l6.9,6.9c0.5,0.5,0,1.1,0,1.1L20,22.3c0,0-0.6,0.5-1.1,0L12,15.4l-6.9,6.9c-0.5,0.5-1.1,0-1.1,0L1.7,20c0,0-0.5-0.6,0-1.1L8.6,12L1.7,5.1C1.2,4.6,1.7,4,1.7,4L4,1.7c0,0,0.6-0.5,1.1,0L12,8.5l6.8-6.8c0.5-0.5,1.1,0,1.1,0L22.2,4z"]])),
                this.closeButton = W('<div class="jBox-closeButton jBox-noDrag"/>').on("click tap", function(he) {
                    this.close({
                        ignoreDelay: !0
                    })
                }
                .bind(this)).append(de),
                this.options.closeButton != "box" && (this.options.closeButton !== !0 || this.options.overlay || this.options.title || this.options.getTitle) || (this.wrapper.addClass("jBox-closeButton-box"),
                this.closeButton.appendTo(this.container))),
                this.wrapper.appendTo(this.options.appendTo),
                this.wrapper.find(".jBox-closeButton").length && W.each(["top", "right", "bottom", "left"], function(he, fe) {
                    this.wrapper.find(".jBox-closeButton").css(fe) && this.wrapper.find(".jBox-closeButton").css(fe) != "auto" && (this.options.adjustDistance[fe] = Math.max(this.options.adjustDistance[fe], this.options.adjustDistance[fe] + -1 * ((parseInt(this.wrapper.find(".jBox-closeButton").css(fe)) || 0) + (parseInt(this.container.css("border-" + fe + "-width")) || 0))))
                }
                .bind(this)),
                this.options.pointer && (this.pointer = {
                    position: this.options.pointTo != "target" ? this.options.pointTo : this._getOpp(this.outside),
                    xy: this.options.pointTo != "target" ? this._getXY(this.options.pointTo) : this._getXY(this.outside),
                    align: "center",
                    offset: 0
                },
                this.pointer.element = W('<div class="jBox-pointer jBox-pointer-' + this.pointer.position + '"/>').appendTo(this.wrapper),
                this.pointer.dimensions = {
                    x: this.pointer.element.outerWidth(),
                    y: this.pointer.element.outerHeight()
                },
                W.type(this.options.pointer) == "string" && ((de = this.options.pointer.split(":"))[0] && (this.pointer.align = de[0]),
                de[1] && (this.pointer.offset = parseInt(de[1]))),
                this.pointer.alignAttribute = this.pointer.xy == "x" ? this.pointer.align == "bottom" ? "bottom" : "top" : this.pointer.align == "right" ? "right" : "left",
                this.wrapper.css("padding-" + this.pointer.position, this.pointer.dimensions[this.pointer.xy]),
                this.pointer.element.css(this.pointer.alignAttribute, this.pointer.align == "center" ? "50%" : 0).css("margin-" + this.pointer.alignAttribute, this.pointer.offset),
                this.pointer.margin = {},
                this.pointer.margin["margin-" + this.pointer.alignAttribute] = this.pointer.offset,
                this.pointer.align == "center" && this.pointer.element.css("transform", "translate(" + (this.pointer.xy == "y" ? -.5 * this.pointer.dimensions.x + "px" : 0) + ", " + (this.pointer.xy == "x" ? -.5 * this.pointer.dimensions.y + "px" : 0) + ")"),
                this.pointer.element.css(this.pointer.xy == "x" ? "width" : "height", parseInt(this.pointer.dimensions[this.pointer.xy]) + parseInt(this.container.css("border-" + this.pointer.alignAttribute + "-width"))),
                this.wrapper.addClass("jBox-pointerPosition-" + this.pointer.position)),
                this.setContent(this.options.content, !0),
                this.setTitle(this.options.title, !0),
                this.options.draggable && this._draggable(),
                this._fireEvent("onCreated"))
            }
            ,
            this.options.createOnInit && this._create(),
            this.options.attach && this.attach(),
            this._attachEvents = function() {
                this.options.delayOnHover && W("#" + this.id).on("mouseenter", function(de) {
                    this.isHovered = !0
                }
                .bind(this)),
                this.options.delayOnHover && W("#" + this.id).on("mouseleave", function(de) {
                    this.isHovered = !1
                }
                .bind(this)),
                (this.options.adjustPosition || this.options.reposition) && !this.fixed && this.outside && (this.options.adjustTracker && W(window).on("scroll.jBox-" + this.id, function(de) {
                    this.position()
                }
                .bind(this)),
                (this.options.adjustPosition || this.options.reposition) && W(window).on("resize.jBox-" + this.id, function(de) {
                    this.position()
                }
                .bind(this))),
                this.options.target == "mouse" && W("body").on("mousemove.jBox-" + this.id, function(de) {
                    this.position({
                        mouseTarget: {
                            top: de.pageY,
                            left: de.pageX
                        }
                    })
                }
                .bind(this))
            }
            ,
            this._detachEvents = function() {
                this.options.closeOnEsc && W(document).off("keyup.jBox-" + this.id),
                this.options.closeOnClick !== !0 && this.options.closeOnClick != "body" || W(document).off("click.jBox-" + this.id + " tap.jBox-" + this.id),
                this.options.adjustTracker && W(window).off("scroll.jBox-" + this.id),
                (this.options.adjustPosition || this.options.reposition) && W(window).off("resize.jBox-" + this.id),
                this.options.target == "mouse" && W("body").off("mousemove.jBox-" + this.id)
            }
            ,
            this._showOverlay = function() {
                this.overlay || (this.overlay = W('<div id="' + this.id + '-overlay"/>').addClass("jBox-overlay" + (this.type ? " jBox-overlay-" + this.type : "")).css({
                    display: "none",
                    opacity: 0,
                    zIndex: this.options.zIndex - 1
                }).appendTo(this.options.appendTo),
                this.options.overlayClass && this.overlay.addClass(this.options.overlayClass),
                this.options.closeButton != "overlay" && this.options.closeButton !== !0 || this.overlay.append(this.closeButton),
                this.options.closeOnClick == "overlay" && this.overlay.on("click tap", function() {
                    this.close({
                        ignoreDelay: !0
                    })
                }
                .bind(this)),
                W("#" + this.id + "-overlay .jBox-closeButton").length && (this.options.adjustDistance.top = Math.max(W("#" + this.id + "-overlay .jBox-closeButton").outerHeight(), this.options.adjustDistance.top))),
                this.adjustZIndexOnOpen === !0 && this.overlay.css("zIndex", parseInt(this.wrapper.css("zIndex"), 10) - 1),
                this.overlay.css("display") != "block" && (this.options.fade ? this.overlay.stop() && this.overlay.animate({
                    opacity: 1
                }, {
                    queue: !1,
                    duration: this.options.fade,
                    start: function() {
                        this.overlay.css({
                            display: "block"
                        })
                    }
                    .bind(this)
                }) : this.overlay.css({
                    display: "block",
                    opacity: 1
                }))
            }
            ,
            this._hideOverlay = function() {
                this.overlay && (this.options.fade ? this.overlay.stop() && this.overlay.animate({
                    opacity: 0
                }, {
                    queue: !1,
                    duration: this.options.fade,
                    complete: function() {
                        this.overlay.css({
                            display: "none"
                        })
                    }
                    .bind(this)
                }) : this.overlay.css({
                    display: "none",
                    opacity: 0
                }))
            }
            ,
            this._exposeDimensions = function() {
                this.wrapper.css({
                    top: -1e4,
                    left: -1e4,
                    right: "auto",
                    bottom: "auto"
                });
                var de = {
                    x: this.wrapper.outerWidth(),
                    y: this.wrapper.outerHeight()
                };
                return this.wrapper.css({
                    top: "auto",
                    left: "auto"
                }),
                de
            }
            ,
            this._generateAnimationCSS = function() {
                if (W.type(this.options.animation) != "object" && (this.options.animation = {
                    pulse: {
                        open: "pulse",
                        close: "zoomOut"
                    },
                    zoomIn: {
                        open: "zoomIn",
                        close: "zoomIn"
                    },
                    zoomOut: {
                        open: "zoomOut",
                        close: "zoomOut"
                    },
                    move: {
                        open: "move",
                        close: "move"
                    },
                    slide: {
                        open: "slide",
                        close: "slide"
                    },
                    flip: {
                        open: "flip",
                        close: "flip"
                    },
                    tada: {
                        open: "tada",
                        close: "zoomOut"
                    }
                }[this.options.animation]),
                !this.options.animation)
                    return null;
                this.options.animation.open && (this.options.animation.open = this.options.animation.open.split(":")),
                this.options.animation.close && (this.options.animation.close = this.options.animation.close.split(":")),
                this.options.animation.openDirection = this.options.animation.open[1] || null,
                this.options.animation.closeDirection = this.options.animation.close[1] || null,
                this.options.animation.open && (this.options.animation.open = this.options.animation.open[0]),
                this.options.animation.close && (this.options.animation.close = this.options.animation.close[0]),
                this.options.animation.open && (this.options.animation.open += "Open"),
                this.options.animation.close && (this.options.animation.close += "Close");
                var de = {
                    pulse: {
                        duration: 350,
                        css: [["0%", "scale(1)"], ["50%", "scale(1.1)"], ["100%", "scale(1)"]]
                    },
                    zoomInOpen: {
                        duration: this.options.fade || 180,
                        css: [["0%", "scale(0.9)"], ["100%", "scale(1)"]]
                    },
                    zoomInClose: {
                        duration: this.options.fade || 180,
                        css: [["0%", "scale(1)"], ["100%", "scale(0.9)"]]
                    },
                    zoomOutOpen: {
                        duration: this.options.fade || 180,
                        css: [["0%", "scale(1.1)"], ["100%", "scale(1)"]]
                    },
                    zoomOutClose: {
                        duration: this.options.fade || 180,
                        css: [["0%", "scale(1)"], ["100%", "scale(1.1)"]]
                    },
                    moveOpen: {
                        duration: this.options.fade || 180,
                        positions: {
                            top: {
                                "0%": -12
                            },
                            right: {
                                "0%": 12
                            },
                            bottom: {
                                "0%": 12
                            },
                            left: {
                                "0%": -12
                            }
                        },
                        css: [["0%", "translate%XY(%Vpx)"], ["100%", "translate%XY(0px)"]]
                    },
                    moveClose: {
                        duration: this.options.fade || 180,
                        timing: "ease-in",
                        positions: {
                            top: {
                                "100%": -12
                            },
                            right: {
                                "100%": 12
                            },
                            bottom: {
                                "100%": 12
                            },
                            left: {
                                "100%": -12
                            }
                        },
                        css: [["0%", "translate%XY(0px)"], ["100%", "translate%XY(%Vpx)"]]
                    },
                    slideOpen: {
                        duration: 400,
                        positions: {
                            top: {
                                "0%": -400
                            },
                            right: {
                                "0%": 400
                            },
                            bottom: {
                                "0%": 400
                            },
                            left: {
                                "0%": -400
                            }
                        },
                        css: [["0%", "translate%XY(%Vpx)"], ["100%", "translate%XY(0px)"]]
                    },
                    slideClose: {
                        duration: 400,
                        timing: "ease-in",
                        positions: {
                            top: {
                                "100%": -400
                            },
                            right: {
                                "100%": 400
                            },
                            bottom: {
                                "100%": 400
                            },
                            left: {
                                "100%": -400
                            }
                        },
                        css: [["0%", "translate%XY(0px)"], ["100%", "translate%XY(%Vpx)"]]
                    },
                    flipOpen: {
                        duration: 600,
                        css: [["0%", "perspective(400px) rotateX(90deg)"], ["40%", "perspective(400px) rotateX(-15deg)"], ["70%", "perspective(400px) rotateX(15deg)"], ["100%", "perspective(400px) rotateX(0deg)"]]
                    },
                    flipClose: {
                        duration: this.options.fade || 300,
                        css: [["0%", "perspective(400px) rotateX(0deg)"], ["100%", "perspective(400px) rotateX(90deg)"]]
                    },
                    tada: {
                        duration: 800,
                        css: [["0%", "scale(1)"], ["10%, 20%", "scale(0.9) rotate(-3deg)"], ["30%, 50%, 70%, 90%", "scale(1.1) rotate(3deg)"], ["40%, 60%, 80%", "scale(1.1) rotate(-3deg)"], ["100%", "scale(1) rotate(0)"]]
                    }
                };
                W.each(["pulse", "tada"], function(fe, ge) {
                    de[ge + "Open"] = de[ge + "Close"] = de[ge]
                });
                var he = function(fe, ge) {
                    var xe = "@keyframes jBox-" + this.id + "-animation-" + this.options.animation[fe] + "-" + fe + (ge ? "-" + ge : "") + " {";
                    return W.each(de[this.options.animation[fe]].css, function($e, Ee) {
                        var Se = ge ? Ee[1].replace("%XY", this._getXY(ge).toUpperCase()) : Ee[1];
                        de[this.options.animation[fe]].positions && (Se = Se.replace("%V", de[this.options.animation[fe]].positions[ge][Ee[0]])),
                        xe += Ee[0] + " {transform:" + Se + ";}"
                    }
                    .bind(this)),
                    xe += "}",
                    xe += ".jBox-" + this.id + "-animation-" + this.options.animation[fe] + "-" + fe + (ge ? "-" + ge : "") + " {",
                    xe += "animation-duration: " + de[this.options.animation[fe]].duration + "ms;",
                    xe += "animation-name: jBox-" + this.id + "-animation-" + this.options.animation[fe] + "-" + fe + (ge ? "-" + ge : "") + ";",
                    xe += de[this.options.animation[fe]].timing ? "animation-timing-function: " + de[this.options.animation[fe]].timing + ";" : "",
                    xe += "}"
                }
                .bind(this);
                this._animationCSS = "",
                W.each(["open", "close"], function(fe, ge) {
                    if (!this.options.animation[ge] || !de[this.options.animation[ge]] || ge == "close" && !this.options.fade)
                        return "";
                    de[this.options.animation[ge]].positions ? W.each(["top", "right", "bottom", "left"], function(xe, $e) {
                        this._animationCSS += he(ge, $e)
                    }
                    .bind(this)) : this._animationCSS += he(ge)
                }
                .bind(this))
            }
            ,
            this.options.animation && this._generateAnimationCSS(),
            this._blockBodyClick = function() {
                this.blockBodyClick = !0,
                setTimeout(function() {
                    this.blockBodyClick = !1
                }
                .bind(this), 10)
            }
            ,
            this._animate = function(de) {
                if (de = de || (this.isOpen ? "open" : "close"),
                !this.options.fade && de == "close")
                    return null;
                var he = this.options.animation[de + "Direction"] || (this.align != "center" ? this.align : this.options.attributes.x);
                this.flipped && this._getXY(he) == this._getXY(this.align) && (he = this._getOpp(he));
                var fe = "jBox-" + this.id + "-animation-" + this.options.animation[de] + "-" + de + " jBox-" + this.id + "-animation-" + this.options.animation[de] + "-" + de + "-" + he;
                this.wrapper.addClass(fe),
                he = 1e3 * parseFloat(this.wrapper.css("animation-duration")),
                de == "close" && (he = Math.min(he, this.options.fade)),
                setTimeout(function() {
                    this.wrapper && this.wrapper.removeClass(fe)
                }
                .bind(this), he)
            }
            ,
            this._abortAnimation = function() {
                var de = this.wrapper.attr("class").split(" ").filter(function(he) {
                    return he.lastIndexOf("jBox-" + this.id + "-animation", 0) !== 0
                }
                .bind(this));
                this.wrapper.attr("class", de.join(" "))
            }
            ,
            (this.options.responsiveWidth || this.options.responsiveHeight) && W(window).on("resize.responsivejBox-" + this.id, function(de) {
                this.isOpen && this.position()
            }
            .bind(this)),
            W.type(this.options.preloadAudio) === "string" && (this.options.preloadAudio = [this.options.preloadAudio]),
            W.type(this.options.audio) === "string" && (this.options.audio = {
                open: this.options.audio
            }),
            W.type(this.options.volume) === "number" && (this.options.volume = {
                open: this.options.volume,
                close: this.options.volume
            }),
            this.options.preloadAudio === !0 && this.options.audio && (this.options.preloadAudio = [],
            W.each(this.options.audio, function(de, he) {
                this.options.preloadAudio.push(he + ".mp3"),
                this.options.preloadAudio.push(he + ".ogg")
            }
            .bind(this))),
            this.options.preloadAudio.length && W.each(this.options.preloadAudio, function(de, he) {
                var fe = new Audio;
                fe.src = he,
                fe.preload = "auto"
            }),
            this._fireEvent("onInit"),
            this
        }
        var Y, ne;
        return z.prototype.attach = function(le, ue) {
            return le = le || this.options.attach,
            W.type(le) == "string" && (le = W(le)),
            ue = ue || this.options.trigger,
            le && le.length && W.each(le, function(de, he) {
                (he = W(he)).data("jBox-attached-" + this.id) || (this.options.getContent == "title" && he.attr("title") != null && he.data("jBox-getContent", he.attr("title")).removeAttr("title"),
                this.attachedElements || (this.attachedElements = []),
                this.attachedElements.push(he[0]),
                he.on(ue + ".jBox-attach-" + this.id, function(fe) {
                    var ge;
                    this.timer && clearTimeout(this.timer),
                    ue == "mouseenter" && this.isOpen && this.source[0] == he[0] || (this.isOpen && this.source && this.source[0] != he[0] && (ge = !0),
                    this.source = he,
                    this.options.target || (this.target = he),
                    ue == "click" && this.options.preventDefault && fe.preventDefault(),
                    this[ue != "click" || ge ? "open" : "toggle"]())
                }
                .bind(this)),
                this.options.trigger == "mouseenter" && he.on("mouseleave", function(fe) {
                    if (!this.wrapper)
                        return null;
                    this.options.closeOnMouseleave && (fe.relatedTarget == this.wrapper[0] || W(fe.relatedTarget).parents("#" + this.id).length) || this.close()
                }
                .bind(this)),
                he.data("jBox-attached-" + this.id, ue),
                this._fireEvent("onAttach", he))
            }
            .bind(this)),
            this
        }
        ,
        z.prototype.detach = function(le) {
            return (le = le || this.attachedElements || []) && le.length && W.each(le, function(ue, de) {
                (de = W(de)).data("jBox-attached-" + this.id) && (de.off(de.data("jBox-attached-" + this.id) + ".jBox-attach-" + this.id),
                de.data("jBox-attached-" + this.id, null)),
                this.attachedElements = W.grep(this.attachedElements, function(he) {
                    return he != de[0]
                })
            }
            .bind(this)),
            this
        }
        ,
        z.prototype.setTitle = function(le, ue) {
            if (le == null || le == null)
                return this;
            this.wrapper || this._create();
            var de = this.wrapper.outerHeight()
              , he = this.wrapper.outerWidth();
            return this.title || (this.titleContainer = W('<div class="jBox-title"/>'),
            this.title = W("<div/>").appendTo(this.titleContainer),
            this.options.closeButton != "title" && (this.options.closeButton !== !0 || this.options.overlay) || (this.wrapper.addClass("jBox-closeButton-title"),
            this.closeButton.appendTo(this.titleContainer)),
            this.titleContainer.insertBefore(this.content),
            this._setTitleWidth()),
            this.wrapper[le ? "addClass" : "removeClass"]("jBox-hasTitle"),
            this.title.html(le),
            he != this.wrapper.outerWidth() && this._setTitleWidth(),
            this.options.draggable && this._draggable(),
            ue || !this.options.repositionOnContent || de == this.wrapper.outerHeight() && he == this.wrapper.outerWidth() || this.position(),
            this
        }
        ,
        z.prototype.setContent = function(le, ue) {
            if (le == null || le == null)
                return this;
            this.wrapper || this._create();
            var de = this.wrapper.outerHeight()
              , he = this.wrapper.outerWidth();
            switch (this.content.children("[data-jbox-content-appended]").appendTo("body").css({
                display: "none"
            }),
            W.type(le)) {
            case "string":
                this.content.html(le);
                break;
            case "object":
                le && (le instanceof W || le.constructor.prototype.jquery) ? (this.content.html(""),
                le.attr("data-jbox-content-appended", 1).appendTo(this.content).css({
                    display: "block"
                })) : this.content.html(JSON.stringify(le))
            }
            return he != this.wrapper.outerWidth() && this._setTitleWidth(),
            this.options.draggable && this._draggable(),
            ue || !this.options.repositionOnContent || de == this.wrapper.outerHeight() && he == this.wrapper.outerWidth() || this.position(),
            this
        }
        ,
        z.prototype.setDimensions = function(le, ue, de) {
            this.wrapper || this._create(),
            this.content.css(le, this._getInt(ue = ue ?? "auto")),
            le == "width" && this._setTitleWidth(),
            this.options[le] = ue,
            de != null && !de || this.position()
        }
        ,
        z.prototype.setWidth = function(le, ue) {
            this.setDimensions("width", le, ue)
        }
        ,
        z.prototype.setHeight = function(le, ue) {
            this.setDimensions("height", le, ue)
        }
        ,
        z.prototype.position = function(le) {
            if (le = W.extend(!0, this.options, le = le || {}),
            this.target = le.target || this.target || W(window),
            this.target instanceof W || this.target == "mouse" || (this.target = W(this.target)),
            !this.target.length)
                return this;
            this.content.css({
                width: this._getInt(le.width, "width"),
                height: this._getInt(le.height, "height"),
                minWidth: this._getInt(le.minWidth, "width"),
                minHeight: this._getInt(le.minHeight, "height"),
                maxWidth: this._getInt(le.maxWidth, "width"),
                maxHeight: this._getInt(le.maxHeight, "height")
            }),
            this._setTitleWidth();
            var ue = this._exposeDimensions();
            this.target == "mouse" || this.target.data("jBox-" + this.id + "-fixed") || this.target.data("jBox-" + this.id + "-fixed", this.target[0] != W(window)[0] && (this.target.css("position") == "fixed" || 0 < this.target.parents().filter(function() {
                return W(this).css("position") == "fixed"
            }).length) ? "fixed" : "static");
            var de = {
                x: W(window).outerWidth(),
                y: W(window).outerHeight(),
                top: le.fixed && this.target.data("jBox-" + this.id + "-fixed") ? 0 : W(window).scrollTop(),
                left: le.fixed && this.target.data("jBox-" + this.id + "-fixed") ? 0 : W(window).scrollLeft()
            };
            de.bottom = de.top + de.y,
            de.right = de.left + de.x;
            try {
                var he = this.target.offset()
            } catch {
                he = {
                    top: 0,
                    left: 0
                }
            }
            this.target != "mouse" && this.target.data("jBox-" + this.id + "-fixed") == "fixed" && le.fixed && (he.top = he.top - W(window).scrollTop(),
            he.left = he.left - W(window).scrollLeft());
            var fe = {
                x: this.target == "mouse" ? 12 : this.target.outerWidth(),
                y: this.target == "mouse" ? 20 : this.target.outerHeight(),
                top: this.target == "mouse" && le.mouseTarget ? le.mouseTarget.top : he ? he.top : 0,
                left: this.target == "mouse" && le.mouseTarget ? le.mouseTarget.left : he ? he.left : 0
            }
              , ge = le.outside && !(le.position.x == "center" && le.position.y == "center")
              , xe = {
                x: de.x - le.adjustDistance.left - le.adjustDistance.right,
                y: de.y - le.adjustDistance.top - le.adjustDistance.bottom,
                left: ge ? fe.left - W(window).scrollLeft() - le.adjustDistance.left : 0,
                right: ge ? de.x - fe.left + W(window).scrollLeft() - fe.x - le.adjustDistance.right : 0,
                top: ge ? fe.top - W(window).scrollTop() - this.options.adjustDistance.top : 0,
                bottom: ge ? de.y - fe.top + W(window).scrollTop() - fe.y - le.adjustDistance.bottom : 0
            }
              , $e = {
                x: le.outside != "x" && le.outside != "xy" || W.type(le.position.x) == "number" ? null : le.position.x,
                y: le.outside != "y" && le.outside != "xy" || W.type(le.position.y) == "number" ? null : le.position.y
            }
              , Ee = {
                x: !1,
                y: !1
            };
            $e.x && ue.x > xe[$e.x] && xe[this._getOpp($e.x)] > xe[$e.x] && ($e.x = this._getOpp($e.x)) && (Ee.x = !0),
            $e.y && ue.y > xe[$e.y] && xe[this._getOpp($e.y)] > xe[$e.y] && ($e.y = this._getOpp($e.y)) && (Ee.y = !0),
            (le.responsiveWidth || le.responsiveHeight) && (Ut = function() {
                var mr;
                le.responsiveWidth && ue.x > xe[$e.x || "x"] && (mr = xe[$e.x || "x"] - (this.pointer && ge && le.outside == "x" ? this.pointer.dimensions.x : 0) - parseInt(this.container.css("border-left-width")) - parseInt(this.container.css("border-right-width")),
                this.content.css({
                    width: mr > this.options.responsiveMinWidth ? mr : null,
                    minWidth: mr < parseInt(this.content.css("minWidth")) ? 0 : null
                }),
                this._setTitleWidth()),
                ue = this._exposeDimensions()
            }
            .bind(this),
            le.responsiveWidth && Ut(),
            le.responsiveWidth && !Ee.y && $e.y && ue.y > xe[$e.y] && xe[this._getOpp($e.y)] > xe[$e.y] && ($e.y = this._getOpp($e.y)) && (Ee.y = !0),
            lr = function() {
                var mr;
                le.responsiveHeight && ue.y > xe[$e.y || "y"] && (mr = function() {
                    return this.titleContainer || this.footer ? (this.wrapper.css("display") == "none" ? (this.wrapper.css("display", "block"),
                    fr = (this.titleContainer ? this.titleContainer.outerHeight() : 0) + (this.footer ? this.footer.outerHeight() : 0),
                    this.wrapper.css("display", "none")) : fr = (this.titleContainer ? this.titleContainer.outerHeight() : 0) + (this.footer ? this.footer.outerHeight() : 0),
                    fr || 0) : 0;
                    var fr
                }
                .bind(this),
                mr = xe[$e.y || "y"] - (this.pointer && ge && le.outside == "y" ? this.pointer.dimensions.y : 0) - mr() - parseInt(this.container.css("border-top-width")) - parseInt(this.container.css("border-bottom-width")),
                this.content.css({
                    height: mr > this.options.responsiveMinHeight ? mr : null
                }),
                this._setTitleWidth()),
                ue = this._exposeDimensions()
            }
            .bind(this),
            le.responsiveHeight && lr(),
            le.responsiveHeight && !Ee.x && $e.x && ue.x > xe[$e.x] && xe[this._getOpp($e.x)] > xe[$e.x] && ($e.x = this._getOpp($e.x)) && (Ee.x = !0),
            le.adjustPosition && le.adjustPosition != "move" && (Ee.x && Ut(),
            Ee.y && lr()));
            var Se = {}
              , Ne = function(mr) {
                if (W.type(le.position[mr]) != "number") {
                    var fr = le.attributes[mr] = mr == "x" ? "left" : "top";
                    if (Se[fr] = fe[fr],
                    le.position[mr] == "center")
                        return Se[fr] += Math.ceil((fe[mr] - ue[mr]) / 2),
                        void (this.target != "mouse" && this.target[0] && this.target[0] == W(window)[0] && (Se[fr] += .5 * (le.adjustDistance[fr] - le.adjustDistance[this._getOpp(fr)])));
                    fr != le.position[mr] && (Se[fr] += fe[mr] - ue[mr]),
                    le.outside != mr && le.outside != "xy" || (Se[fr] += ue[mr] * (fr != le.position[mr] ? 1 : -1))
                } else
                    Se[le.attributes[mr]] = le.position[mr]
            }
            .bind(this);
            if (Ne("x"),
            Ne("y"),
            this.pointer && le.pointTo == "target" && W.type(le.position.x) != "number" && W.type(le.position.y) != "number" && (cr = 0,
            this.pointer.align === "center" ? le.position[this._getOpp(le.outside)] != "center" && (cr += ue[this._getOpp(le.outside)] / 2) : le.position[this._getOpp(le.outside)] === "center" ? cr += (ue[this._getOpp(le.outside)] / 2 - this.pointer.dimensions[this._getOpp(le.outside)] / 2) * (this.pointer.align == this._getTL(this.pointer.align) ? 1 : -1) : cr += this.pointer.align != le.position[this._getOpp(le.outside)] ? ue[this._getOpp(le.outside)] * (W.inArray(this.pointer.align, ["top", "left"]) !== -1 ? 1 : -1) + this.pointer.dimensions[this._getOpp(le.outside)] / 2 * (W.inArray(this.pointer.align, ["top", "left"]) !== -1 ? -1 : 1) : this.pointer.dimensions[this._getOpp(le.outside)] / 2 * (W.inArray(this.pointer.align, ["top", "left"]) !== -1 ? 1 : -1),
            cr *= le.position[this._getOpp(le.outside)] == this.pointer.alignAttribute ? -1 : 1,
            cr += this.pointer.offset * (this.pointer.align == this._getOpp(this._getTL(this.pointer.align)) ? 1 : -1),
            Se[this._getTL(this._getOpp(this.pointer.xy))] += cr),
            Se[le.attributes.x] += le.offset.x,
            Se[le.attributes.y] += le.offset.y,
            this.wrapper.css(Se),
            le.adjustPosition) {
                this.positionAdjusted && (this.pointer && this.wrapper.css("padding", 0).css("padding-" + this._getOpp(this.outside), this.pointer.dimensions[this._getXY(this.outside)]).removeClass("jBox-pointerPosition-" + this._getOpp(this.pointer.position)).addClass("jBox-pointerPosition-" + this.pointer.position),
                this.pointer && this.pointer.element.attr("class", "jBox-pointer jBox-pointer-" + this._getOpp(this.outside)).css(this.pointer.margin),
                this.positionAdjusted = !1,
                this.flipped = !1);
                var tt = de.top > Se.top - (le.adjustDistance.top || 0)
                  , rr = de.right < Se.left + ue.x + (le.adjustDistance.right || 0)
                  , tr = de.bottom < Se.top + ue.y + (le.adjustDistance.bottom || 0)
                  , we = de.left > Se.left - (le.adjustDistance.left || 0)
                  , Ut = tt ? "top" : tr ? "bottom" : null;
                if ((he = we ? "left" : rr ? "right" : null) || Ut) {
                    if ((this.type == "Modal" || this.type == "Confirm") && W.type(this.options.position.x) == "number" && W.type(this.options.position.y) == "number") {
                        var lr = 0
                          , cr = 0;
                        return this.options.holdPosition && (we ? lr = de.left - (Se.left - (le.adjustDistance.left || 0)) : rr && (lr = de.right - (Se.left + ue.x + (le.adjustDistance.right || 0))),
                        tt ? cr = de.top - (Se.top - (le.adjustDistance.top || 0)) : tr && (cr = de.bottom - (Se.top + ue.y + (le.adjustDistance.bottom || 0))),
                        this.options.position.x = Math.max(de.top, this.options.position.x + lr),
                        this.options.position.y = Math.max(de.left, this.options.position.y + cr),
                        Ne("x"),
                        Ne("y"),
                        this.wrapper.css(Se)),
                        this._fireEvent("onPosition"),
                        this
                    }
                    le.adjustPosition !== !0 && le.adjustPosition !== "flip" || (be = function(mr) {
                        this.wrapper.css(this._getTL(mr), Se[this._getTL(mr)] + (ue[this._getXY(mr)] + le.offset[this._getXY(mr)] * (mr == "top" || mr == "left" ? -2 : 2) + fe[this._getXY(mr)]) * (mr == "top" || mr == "left" ? 1 : -1)),
                        this.pointer && this.wrapper.removeClass("jBox-pointerPosition-" + this.pointer.position).addClass("jBox-pointerPosition-" + this._getOpp(this.pointer.position)).css("padding", 0).css("padding-" + mr, this.pointer.dimensions[this._getXY(mr)]),
                        this.pointer && this.pointer.element.attr("class", "jBox-pointer jBox-pointer-" + mr),
                        this.positionAdjusted = !0,
                        this.flipped = !0
                    }
                    .bind(this),
                    Ee.x && be(this.options.position.x),
                    Ee.y && be(this.options.position.y));
                    var be = this._getXY(this.outside) == "x" ? Ut : he;
                    this.pointer && le.pointTo == "target" && le.adjustPosition != "flip" && this._getXY(be) == this._getOpp(this._getXY(this.outside)) && (Ut = this.pointer.align == "center" ? ue[this._getXY(be)] / 2 - this.pointer.dimensions[this._getOpp(this.pointer.xy)] / 2 - parseInt(this.pointer.element.css("margin-" + this.pointer.alignAttribute)) * (be != this._getTL(be) ? -1 : 1) : be == this.pointer.alignAttribute ? parseInt(this.pointer.element.css("margin-" + this.pointer.alignAttribute)) : ue[this._getXY(be)] - parseInt(this.pointer.element.css("margin-" + this.pointer.alignAttribute)) - this.pointer.dimensions[this._getXY(be)],
                    he = be == this._getTL(be) ? de[this._getTL(be)] - Se[this._getTL(be)] + le.adjustDistance[be] : -1 * (de[this._getOpp(this._getTL(be))] - Se[this._getTL(be)] - le.adjustDistance[be] - ue[this._getXY(be)]),
                    be == this._getOpp(this._getTL(be)) && Se[this._getTL(be)] - he < de[this._getTL(be)] + le.adjustDistance[this._getTL(be)] && (he -= de[this._getTL(be)] + le.adjustDistance[this._getTL(be)] - (Se[this._getTL(be)] - he)),
                    (he = Math.min(he, Ut)) <= Ut && 0 < he && (this.pointer.element.css("margin-" + this.pointer.alignAttribute, parseInt(this.pointer.element.css("margin-" + this.pointer.alignAttribute)) - he * (be != this.pointer.alignAttribute ? -1 : 1)),
                    this.wrapper.css(this._getTL(be), Se[this._getTL(be)] + he * (be != this._getTL(be) ? -1 : 1)),
                    this.positionAdjusted = !0))
                }
            }
            return this._fireEvent("onPosition"),
            this
        }
        ,
        (z.prototype.unscroll = function(le) {
            if (this.set = function(Ee, Se) {
                window.unscrollStore || (window.unscrollStore = {}),
                window.unscrollStore[Ee] = Se
            }
            ,
            this.get = function(Ee) {
                return window.unscrollStore ? window.unscrollStore[Ee] : null
            }
            ,
            this.getScrollbarWidth = function() {
                if (this.get("scrollbarWidth"))
                    return this.get("scrollbarWidth") + "px";
                var Ee = document.createElement("div");
                Ee.style.width = "100px",
                Ee.style.height = "100px",
                Ee.style.overflow = "scroll",
                Ee.style.position = "absolute",
                Ee.style.top = "-10000",
                document.body.appendChild(Ee);
                var Se = Ee.offsetWidth - Ee.clientWidth;
                return document.body.removeChild(Ee),
                this.set("scrollbarWidth", Se),
                Se + "px"
            }
            ,
            this.getElementsToAdjust = function(Ee) {
                (Ee = typeof (Ee = Ee || []) == "string" ? [[Ee, "padding-right"]] : Ee).forEach(function(tt, rr) {
                    typeof tt == "string" && (Ee[rr] = [tt, "padding-right"])
                });
                for (var Se = !1, Ne = 0; Ne < Ee.length; Ne++)
                    Ee[Ne][0].indexOf("body") !== -1 && (Se = !0);
                return Se === !1 && Ee.push(["body", "padding-right"]),
                Ee
            }
            ,
            this.pageHasScrollbar = function() {
                return this.getScrollbarWidth() && document.body.offsetHeight > window.innerHeight
            }
            ,
            this.pageHasScrollbar()) {
                le = this.getElementsToAdjust(le);
                for (var ue = 0; ue < le.length; ue++)
                    for (var de = document.querySelectorAll(le[ue][0]), he = 0; he < de.length; he++) {
                        if (de[he].getAttribute("data-unscroll"))
                            return;
                        var fe = le[ue][1]
                          , ge = window.getComputedStyle(de[he]).getPropertyValue(fe);
                        de[he].setAttribute("data-unscroll", fe),
                        de[he].style[fe] = "calc(" + (ge = ge || "0px") + " " + (fe == "padding-right" || fe == "right" ? "+" : "-") + " " + this.getScrollbarWidth() + ")"
                    }
            }
            var xe, $e;
            document.getElementById("unscroll-class-name") || (xe = document.head || document.getElementsByTagName("head")[0],
            ($e = document.createElement("style")).type = "text/css",
            $e.setAttribute("id", "unscroll-class-name"),
            $e.appendChild(document.createTextNode(".unscrollable { overflow: hidden !important; }")),
            xe.appendChild($e)),
            document.body.classList.add("unscrollable")
        }
        ).reset = function() {
            for (var le = document.querySelectorAll("[data-unscroll]"), ue = 0; ue < le.length; ue++) {
                var de = le[ue].getAttribute("data-unscroll");
                le[ue].style[de] = null,
                le[ue].removeAttribute("data-unscroll")
            }
            document.body.classList.remove("unscrollable")
        }
        ,
        z.prototype.open = function(le) {
            if (le = le || {},
            this.isDestroyed)
                return this;
            if (this.wrapper || this._create(),
            this._styles || (this._styles = W("<style/>").append(this._animationCSS).appendTo(W("head"))),
            this.timer && clearTimeout(this.timer),
            this._blockBodyClick(),
            this.isDisabled)
                return this;
            this.options.closeOnEsc && W(document).on("keyup.jBox-" + this.id, function(de) {
                de.keyCode == 27 && this.close({
                    ignoreDelay: !0
                })
            }
            .bind(this)),
            this.options.closeOnClick !== !0 && this.options.closeOnClick !== "body" || (W("body").on("click.jBox-" + this.id + " tap.jBox-" + this.id, function(de) {
                this.blockBodyClick || this.options.closeOnClick == "body" && (de.target == this.wrapper[0] || this.wrapper.has(de.target).length) || this.close({
                    ignoreDelay: !0
                })
            }
            .bind(this)),
            this.isTouchDevice && W("body > *").on("click.jBox-" + this.id + " tap.jBox-" + this.id, function() {
                return !0
            }));
            var ue = function() {
                this.adjustZIndexOnOpen === !0 && (z.zIndexMax = Math.max(parseInt(this.wrapper.css("zIndex"), 10), this.options.zIndex, z.zIndexMax || 0, z.zIndexMaxDragover || 0) + 2,
                this.wrapper.css("zIndex", z.zIndexMax),
                this.options.zIndex = z.zIndexMax),
                this.source && this.options.getTitle && this.source.attr(this.options.getTitle) && this.setTitle(this.source.attr(this.options.getTitle), !0),
                this.source && this.options.getContent && (this.source.data("jBox-getContent") ? this.setContent(this.source.data("jBox-getContent"), !0) : this.source.attr(this.options.getContent) ? this.setContent(this.source.attr(this.options.getContent), !0) : this.options.getContent == "html" && this.setContent(this.source.html(), !0)),
                this._fireEvent("onOpen"),
                (this.options.ajax && (this.options.ajax.url || this.source && this.source.attr(this.options.ajax.getURL)) && (!this.ajaxLoaded || this.options.ajax.reload) || le.ajax && (le.ajax.url || le.ajax.data)) && (this.options.ajax.reload == "strict" || !this.source || !this.source.data("jBox-ajax-data") || le.ajax && (le.ajax.url || le.ajax.data) ? this.ajax(le.ajax || null, !0) : this.setContent(this.source.data("jBox-ajax-data"))),
                this.positionedOnOpen && !this.options.repositionOnOpen || !this.position(le) || (this.positionedOnOpen = !0),
                this.isClosing && this._abortAnimation(),
                this.isOpen || (this.isOpen = !0,
                this.options.autoClose && (this.options.delayClose = this.options.autoClose) && this.close(),
                this._attachEvents(),
                this.options.blockScroll && (this.options.blockScrollAdjust ? z.blockScrollScopes ? z.blockScrollScopes++ : (z.blockScrollScopes = 1,
                this.unscroll(Array.isArray(this.options.blockScrollAdjust) || typeof this.options.blockScrollAdjust == "string" ? this.options.blockScrollAdjust : null)) : W("body").addClass("jBox-blockScroll-" + this.id)),
                this.options.overlay && (this._showOverlay(),
                this.position()),
                this.options.animation && !this.isClosing && this._animate("open"),
                this.options.audio && this.options.audio.open && this.audio(this.options.audio.open, this.options.volume.open),
                this.options.fade ? this.wrapper.stop().animate({
                    opacity: 1
                }, {
                    queue: !1,
                    duration: this.options.fade,
                    start: function() {
                        this.isOpening = !0,
                        this.wrapper.css({
                            display: "block"
                        })
                    }
                    .bind(this),
                    complete: function() {
                        this._fireEvent("onOpenComplete")
                    }
                    .bind(this),
                    always: function() {
                        this.isOpening = !1,
                        setTimeout(function() {
                            this.positionOnFadeComplete && this.position() && (this.positionOnFadeComplete = !1)
                        }
                        .bind(this), 10)
                    }
                    .bind(this)
                }) : (this.wrapper.css({
                    display: "block",
                    opacity: 1
                }),
                this.positionOnFadeComplete && this.position() && (this.positionOnFadeComplete = !1),
                this._fireEvent("onOpenComplete")))
            }
            .bind(this);
            return !this.options.delayOpen || this.isOpen || this.isClosing || le.ignoreDelay ? ue() : this.timer = setTimeout(ue, this.options.delayOpen),
            this
        }
        ,
        z.prototype.close = function(le) {
            if (le = le || {},
            W("body").off("click.jBox-" + this.id + " tap.jBox-" + this.id),
            this.isTouchDevice && W("body > *").off("click.jBox-" + this.id + " tap.jBox-" + this.id),
            this.isDestroyed || this.isClosing)
                return this;
            if (this.timer && clearTimeout(this.timer),
            this._blockBodyClick(),
            this.isDisabled)
                return this;
            var ue, de, he, fe = function() {
                var ge;
                this._fireEvent("onClose"),
                this.options.cancelAjaxOnClose && this.cancelAjax(),
                this.isOpen && (this.isOpen = !1,
                this._detachEvents(),
                this.options.blockScroll && (this.options.blockScrollAdjust ? (z.blockScrollScopes = z.blockScrollScopes ? --z.blockScrollScopes : 0) || this.unscroll.reset() : W("body").removeClass("jBox-blockScroll-" + this.id)),
                this.options.overlay && this._hideOverlay(),
                this.options.animation && !this.isOpening && this._animate("close"),
                this.options.audio && this.options.audio.close && this.audio(this.options.audio.close, this.options.volume.close),
                (ge = this.isTouchDevice && this.options.target == "mouse" ? 0 : this.options.fade) ? this.wrapper.stop().animate({
                    opacity: 0
                }, {
                    queue: !1,
                    duration: ge,
                    start: function() {
                        this.isClosing = !0
                    }
                    .bind(this),
                    complete: function() {
                        this.wrapper.css({
                            display: "none"
                        }),
                        this._fireEvent("onCloseComplete")
                    }
                    .bind(this),
                    always: function() {
                        this.isClosing = !1
                    }
                    .bind(this)
                }) : (this.wrapper.css({
                    display: "none",
                    opacity: 0
                }),
                this._fireEvent("onCloseComplete")))
            }
            .bind(this);
            return le.ignoreDelay || this.isTouchDevice && this.options.target == "mouse" ? fe() : (this.options.delayOnHover || this.options.showCountdown) && 10 < this.options.delayClose ? (de = (ue = this).options.delayClose,
            he = Date.now(),
            this.options.showCountdown && !this.inner && (le = W('<div class="jBox-countdown" />'),
            this.inner = W('<div class="jBox-countdown-inner" />'),
            le.prepend(this.inner),
            W("#" + this.id).append(le)),
            this.countdown = function() {
                var ge = Date.now();
                ue.isHovered || (de -= ge - he),
                he = ge,
                0 < de ? (ue.options.showCountdown && ue.inner.css("width", 100 * de / ue.options.delayClose + "%"),
                window.requestAnimationFrame(ue.countdown)) : fe()
            }
            ,
            window.requestAnimationFrame(this.countdown)) : this.timer = setTimeout(fe, Math.max(this.options.delayClose, 10)),
            this
        }
        ,
        z.prototype.toggle = function(le) {
            return this[this.isOpen ? "close" : "open"](le),
            this
        }
        ,
        z.prototype.disable = function() {
            return this.isDisabled = !0,
            this
        }
        ,
        z.prototype.enable = function() {
            return this.isDisabled = !1,
            this
        }
        ,
        z.prototype.hide = function() {
            return this.disable(),
            this.wrapper && (this.cacheWrapperDisplay = this.wrapper.css("display"),
            this.wrapper.css({
                display: "none"
            })),
            this.overlay && (this.cacheOverlayDisplay = this.overlay.css("display"),
            this.overlay.css({
                display: "none"
            })),
            this
        }
        ,
        z.prototype.show = function() {
            return this.enable(),
            this.wrapper && this.cacheWrapperDisplay && (this.wrapper.css({
                display: this.cacheWrapperDisplay
            }),
            this.cacheWrapperDisplay = null),
            this.overlay && this.cacheOverlayDisplay && (this.overlay.css({
                display: this.cacheOverlayDisplay
            }),
            this.cacheOverlayDisplay = null),
            this
        }
        ,
        z.prototype.ajax = function(le, ue) {
            le = le || {},
            W.each([["getData", "data"], ["getURL", "url"]], function(Ee, Se) {
                this.options.ajax[Se[0]] && !le[Se[1]] && this.source && this.source.attr(this.options.ajax[Se[0]]) != null && (le[Se[1]] = this.source.attr(this.options.ajax[Se[0]]) || "")
            }
            .bind(this));
            var de = W.extend(!0, {}, this.options.ajax);
            this.cancelAjax();
            var he = le.beforeSend || de.beforeSend || function() {}
              , fe = le.complete || de.complete || function() {}
              , ge = le.success || de.success || function() {}
              , xe = le.error || de.error || function() {}
              , $e = W.extend(!0, de, le);
            return $e.beforeSend = function(Ee) {
                $e.loadingClass && this.wrapper.addClass($e.loadingClass === !0 ? "jBox-loading" : $e.loadingClass),
                $e.spinner && (this.spinnerDelay = setTimeout(function() {
                    this.wrapper.addClass("jBox-loading-spinner"),
                    $e.spinnerReposition && (ue ? this.positionOnFadeComplete = !0 : this.position()),
                    this.spinner = W($e.spinner !== !0 ? $e.spinner : '<div class="jBox-spinner"></div>').appendTo(this.container),
                    this.titleContainer && this.spinner.css("position") == "absolute" && this.spinner.css({
                        transform: "translateY(" + .5 * this.titleContainer.outerHeight() + "px)"
                    })
                }
                .bind(this), this.content.html() != "" && $e.spinnerDelay || 0)),
                he.bind(this)(Ee)
            }
            .bind(this),
            $e.complete = function(Ee) {
                this.spinnerDelay && clearTimeout(this.spinnerDelay),
                this.wrapper.removeClass("jBox-loading jBox-loading-spinner jBox-loading-spinner-delay"),
                this.spinner && this.spinner.length && this.spinner.remove() && $e.spinnerReposition && (ue ? this.positionOnFadeComplete = !0 : this.position()),
                this.ajaxLoaded = !0,
                fe.bind(this)(Ee)
            }
            .bind(this),
            $e.success = function(Ee) {
                $e.setContent && this.setContent(Ee, !0) && (ue ? this.positionOnFadeComplete = !0 : this.position()),
                $e.setContent && this.source && this.source.data("jBox-ajax-data", Ee),
                ge.bind(this)(Ee)
            }
            .bind(this),
            $e.error = function(Ee) {
                xe.bind(this)(Ee)
            }
            .bind(this),
            this.ajaxRequest = W.ajax($e),
            this
        }
        ,
        z.prototype.cancelAjax = function() {
            this.ajaxRequest && (this.ajaxRequest.abort(),
            this.ajaxLoaded = !1)
        }
        ,
        z.prototype.audio = function(le, ue) {
            if (!le)
                return this;
            var de;
            (z._audio = z._audio ? z._audio : {})[le] || (de = W("<audio/>"),
            W("<source/>", {
                src: le + ".mp3"
            }).appendTo(de),
            W("<source/>", {
                src: le + ".ogg"
            }).appendTo(de),
            z._audio[le] = de[0]),
            z._audio[le].volume = Math.min((ue ?? 100) / 100, 1);
            try {
                z._audio[le].pause(),
                z._audio[le].currentTime = 0
            } catch {}
            return z._audio[le].play(),
            this
        }
        ,
        z._animationSpeeds = {
            tada: 1e3,
            tadaSmall: 1e3,
            flash: 500,
            shake: 400,
            pulseUp: 250,
            pulseDown: 250,
            popIn: 250,
            popOut: 250,
            fadeIn: 200,
            fadeOut: 200,
            slideUp: 400,
            slideRight: 400,
            slideLeft: 400,
            slideDown: 400
        },
        z.prototype.animate = function(le, ue) {
            ue = ue || {},
            this.animationTimeout || (this.animationTimeout = {}),
            ue.element || (ue.element = this.wrapper),
            ue.element.data("jBox-animating-id") || ue.element.data("jBox-animating-id", z._getUniqueElementID()),
            ue.element.data("jBox-animating") && (ue.element.removeClass(ue.element.data("jBox-animating")).data("jBox-animating", null),
            this.animationTimeout[ue.element.data("jBox-animating-id")] && clearTimeout(this.animationTimeout[ue.element.data("jBox-animating-id")])),
            ue.element.addClass("jBox-animated-" + le).data("jBox-animating", "jBox-animated-" + le),
            this.animationTimeout[ue.element.data("jBox-animating-id")] = setTimeout(function() {
                ue.element.removeClass(ue.element.data("jBox-animating")).data("jBox-animating", null),
                ue.complete && ue.complete()
            }, z._animationSpeeds[le])
        }
        ,
        z.prototype.swipeDetector = function(le, ue) {
            var de = 0
              , he = 0
              , fe = 0
              , ge = 0
              , xe = 0;
            return ue = W.extend({
                swipeThreshold: 70,
                useOnlyTouch: !1
            }, ue),
            le.on("mousedown touchstart", function($e) {
                ue.useOnlyTouch && !$e.originalEvent.touches || ($e.originalEvent.touches && ($e = $e.originalEvent.touches[0]),
                de === 0 && (de = 1,
                he = $e.clientX,
                fe = $e.clientY))
            }),
            W("html").on("mouseup touchend", function($e) {
                de === 2 && (de = 0,
                Math.abs(ge) > Math.abs(xe) && Math.abs(ge) > ue.swipeThreshold ? ge < 0 ? le.trigger(W.Event("swipeLeft.sd")) : le.trigger(W.Event("swipeRight.sd")) : Math.abs(xe) > ue.swipeThreshold && (xe < 0 ? le.trigger(W.Event("swipeUp.sd")) : le.trigger(W.Event("swipeDown.sd"))))
            }),
            W("html").on("mousemove touchmove", function($e) {
                var Ee;
                de === 1 && (Ee = ($e = $e.originalEvent.touches ? $e.originalEvent.touches[0] : $e).clientX - he,
                $e = $e.clientY - fe,
                (Math.abs(Ee) > ue.swipeThreshold || Math.abs($e) > ue.swipeThreshold) && (de = 2,
                ge = Ee,
                xe = $e))
            }),
            le
        }
        ,
        z.prototype.destroy = function() {
            return this.detach(),
            this.isOpen && this.close({
                ignoreDelay: !0
            }),
            this.wrapper && this.wrapper.remove(),
            this.overlay && this.overlay.remove(),
            this._styles && this._styles.remove(),
            this.isDestroyed = !0,
            this
        }
        ,
        z._getUniqueID = (Y = 1,
        function() {
            return Y++
        }
        ),
        z._getUniqueElementID = (ne = 1,
        function() {
            return ne++
        }
        ),
        z._pluginOptions = {},
        z.plugin = function(le, ue) {
            z._pluginOptions[le] = ue
        }
        ,
        W.fn.jBox = function(le, ue) {
            return new z(le = le || {},W.extend(ue = ue || {}, {
                attach: this
            }))
        }
        ,
        z
    }
    function jBoxConfirmWrapper(jBox, jQuery) {
        new jBox.plugin("Confirm",{
            confirmButton: "Submit",
            cancelButton: "Cancel",
            confirm: null,
            cancel: null,
            closeOnConfirm: !0,
            target: window,
            fixed: !0,
            attach: "[data-confirm]",
            getContent: "data-confirm",
            content: "Do you really want to do this?",
            minWidth: 360,
            maxWidth: 500,
            blockScroll: !0,
            closeOnEsc: !0,
            closeOnClick: !1,
            closeButton: !1,
            overlay: !0,
            animation: "zoomIn",
            preventDefault: !0,
            _onAttach: function(W) {
                var z;
                this.options.confirm || (z = W.attr("onclick") ? W.attr("onclick") : W.attr("href") ? W.attr("target") ? 'window.open("' + W.attr("href") + '", "' + W.attr("target") + '");' : 'window.location.href = "' + W.attr("href") + '";' : "",
                W.prop("onclick", null).data("jBox-Confirm-submit", z))
            },
            _onCreated: function() {
                this.wrapper.addClass("jBox-Modal"),
                this.footer = jQuery('<div class="jBox-Confirm-footer"/>'),
                jQuery('<div class="jBox-Confirm-button jBox-Confirm-button-cancel"/>').html(this.options.cancelButton).on("click tap", function() {
                    this.options.cancel && this.options.cancel(this.source),
                    this.close()
                }
                .bind(this)).appendTo(this.footer),
                this.submitButton = jQuery('<div class="jBox-Confirm-button jBox-Confirm-button-submit"/>').html(this.options.confirmButton).appendTo(this.footer),
                this.footer.appendTo(this.container)
            },
            _onOpen: function() {
                this.submitButton.off("click.jBox-Confirm" + this.id + " tap.jBox-Confirm" + this.id).on("click.jBox-Confirm" + this.id + " tap.jBox-Confirm" + this.id, function() {
                    this.options.confirm ? this.options.confirm(this.source) : eval(this.source.data("jBox-Confirm-submit")),
                    this.options.closeOnConfirm && this.close()
                }
                .bind(this))
            }
        })
    }
    function jBoxImageWrapper(W, z) {
        new W.plugin("Image",{
            src: "href",
            gallery: "data-jbox-image",
            imageLabel: "title",
            imageFade: 360,
            imageSize: "contain",
            imageCounter: !1,
            imageCounterSeparator: "/",
            downloadButton: !1,
            downloadButtonText: null,
            downloadButtonUrl: null,
            mobileImageAttr: null,
            mobileImageBreakpoint: null,
            preloadFirstImage: !1,
            target: window,
            attach: "[data-jbox-image]",
            fixed: !0,
            blockScroll: !0,
            closeOnEsc: !0,
            closeOnClick: "button",
            closeButton: !0,
            overlay: !0,
            animation: "zoomIn",
            preventDefault: !0,
            width: "100%",
            height: "100%",
            adjustDistance: {
                top: 40,
                right: 0,
                bottom: 40,
                left: 0
            },
            _onInit: function() {
                this.images = this.currentImage = {},
                this.imageZIndex = 1,
                this.initImage = function(le) {
                    var ue, de;
                    (le = z(le)).data("jBox-image-gallery") || (ue = le.attr(this.options.src),
                    this.options.mobileImageAttr && this.options.mobileImageBreakpoint && le.attr(this.options.mobileImageAttr) && z(window).width() <= this.options.mobileImageBreakpoint && (ue = le.attr(this.options.mobileImageAttr)),
                    de = le.attr(this.options.gallery) || "default",
                    this.images[de] || (this.images[de] = []),
                    this.images[de].push({
                        src: ue,
                        label: le.attr(this.options.imageLabel) || "",
                        downloadUrl: this.options.downloadButtonUrl && le.attr(this.options.downloadButtonUrl) ? le.attr(this.options.downloadButtonUrl) : null
                    }),
                    this.options.imageLabel == "title" && le.removeAttr("title"),
                    le.data("jBox-image-gallery", de),
                    le.data("jBox-image-id", this.images[de].length - 1))
                }
                .bind(this),
                this.attachedElements && this.attachedElements.length && z.each(this.attachedElements, function(le, ue) {
                    this.initImage(ue)
                }
                .bind(this));
                var Y = function(le, ue, de, he) {
                    if (!z("#jBox-image-" + le + "-" + ue).length) {
                        var fe = z("<div/>", {
                            id: "jBox-image-" + le + "-" + ue,
                            class: "jBox-image-container" + (de ? " jBox-image-" + le + "-current" : "")
                        }).css({
                            backgroundSize: this.options.imageSize,
                            opacity: he ? 1 : 0,
                            zIndex: de ? this.imageZIndex++ : 0
                        }).appendTo(this.content);
                        return this.swipeDetector(fe).on("swipeLeft.sd swipeRight.sd", function(ge) {
                            ge.type === "swipeLeft" ? this.showImage("next") : ge.type === "swipeRight" && this.showImage("prev")
                        }
                        .bind(this)),
                        z("<div/>", {
                            id: "jBox-image-label-" + le + "-" + ue,
                            class: "jBox-image-label" + (de ? " active" : "")
                        }).html(this.images[le][ue].label).on("click tap", function() {
                            z(this).toggleClass("expanded")
                        }).appendTo(this.imageLabelContainer),
                        de && fe.animate({
                            opacity: 1
                        }, he ? 0 : this.options.imageFade),
                        fe
                    }
                }
                .bind(this);
                this.downloadImage = function(le) {
                    var ue = document.createElement("a");
                    ue.href = le,
                    ue.setAttribute("download", le.substring(le.lastIndexOf("/") + 1)),
                    document.body.appendChild(ue),
                    ue.click()
                }
                ;
                var ne = function(le, ue, de, he) {
                    var fe = Y(le, ue, de, he);
                    fe.addClass("jBox-image-loading"),
                    z('<img src="' + this.images[le][ue].src + '" />').each(function() {
                        var ge = new Image;
                        ge.onload = function() {
                            fe.removeClass("jBox-image-loading"),
                            fe.css({
                                backgroundImage: 'url("' + this.images[le][ue].src + '")'
                            })
                        }
                        .bind(this),
                        ge.onerror = function() {
                            fe.removeClass("jBox-image-loading"),
                            fe.addClass("jBox-image-not-found")
                        }
                        .bind(this),
                        ge.src = this.images[le][ue].src
                    }
                    .bind(this))
                }
                .bind(this);
                this.showImage = function(le) {
                    var ue, de, he;
                    if (le != "open")
                        ue = this.currentImage.gallery,
                        he = (he = this.currentImage.id + (+(le == "prev") ? -1 : 1)) > this.images[ue].length - 1 ? 0 : he < 0 ? this.images[ue].length - 1 : he;
                    else {
                        if (this.source)
                            ue = this.source.data("jBox-image-gallery"),
                            he = this.source.data("jBox-image-id");
                        else {
                            if (!this.attachedElements || !this.attachedElements.length)
                                return;
                            ue = z(this.attachedElements[0]).data("jBox-image-gallery"),
                            he = z(this.attachedElements[0]).data("jBox-image-id")
                        }
                        this.images && this.images[ue] && z(".jBox-image-pointer-prev, .jBox-image-pointer-next").css({
                            display: 1 < this.images[ue].length ? "block" : "none"
                        })
                    }
                    z(".jBox-image-" + ue + "-current").length && z(".jBox-image-" + ue + "-current").removeClass("jBox-image-" + ue + "-current").animate({
                        opacity: 0
                    }, le == "open" ? 0 : this.options.imageFade),
                    this.currentImage = {
                        gallery: ue,
                        id: he
                    },
                    z("#jBox-image-" + ue + "-" + he).length ? z("#jBox-image-" + ue + "-" + he).addClass("jBox-image-" + ue + "-current").css({
                        zIndex: this.imageZIndex++,
                        opacity: 0
                    }).animate({
                        opacity: 1
                    }, le == "open" ? 0 : this.options.imageFade) : ne(ue, he, !0, le === "open"),
                    de = ue,
                    le = he,
                    z(".jBox-image-label.active").removeClass("active expanded"),
                    z("#jBox-image-label-" + de + "-" + le).addClass("active"),
                    this.imageCounter && (this.images[ue] && 1 < this.images[ue].length ? (this.wrapper.addClass("jBox-image-has-counter"),
                    this.imageCounter.find(".jBox-image-counter-all").html(this.images[ue].length),
                    this.imageCounter.find(".jBox-image-counter-current").html(he + 1)) : this.wrapper.removeClass("jBox-image-has-counter")),
                    this.images[ue] && this.images[ue].length - 1 && (he = (he += 1) > this.images[ue].length - 1 ? 0 : he < 0 ? this.images[ue].length - 1 : he,
                    z("#jBox-image-" + ue + "-" + he).length || ne(ue, he, !1, !1))
                }
                ,
                this.options.preloadFirstImage && z(window).on("load", function() {
                    this.showImage("open")
                }
                .bind(this))
            },
            _onAttach: function(Y) {
                this.initImage && this.initImage(Y)
            },
            _onCreated: function() {
                this.imageLabelWrapper = z('<div class="jBox-image-label-wrapper"/>').appendTo(this.wrapper),
                this.imagePrevButton = z('<div class="jBox-image-pointer-prev"/>').on("click tap", function() {
                    this.showImage("prev")
                }
                .bind(this)),
                this.imageNextButton = z('<div class="jBox-image-pointer-next"/>').on("click tap", function() {
                    this.showImage("next")
                }
                .bind(this)),
                this.imageLabelContainer = z('<div class="jBox-image-label-container"/>'),
                this.imageLabelWrapper.append(this.imagePrevButton).append(this.imageLabelContainer).append(this.imageNextButton),
                this.options.downloadButton && (this.downloadButton = z("<div/>", {
                    class: "jBox-image-download-button-wrapper"
                }).appendTo(this.wrapper).append(this.options.downloadButtonText ? z("<div/>", {
                    class: "jBox-image-download-button-text"
                }).html(this.options.downloadButtonText) : null).append(z("<div/>", {
                    class: "jBox-image-download-button-icon"
                })).on("click tap", function() {
                    var Y;
                    Y = this.images[this.currentImage.gallery][this.currentImage.id].downloadUrl || this.wrapper.find(".jBox-image-" + this.currentImage.gallery + "-current")[0].style.backgroundImage.slice(4, -1).replace(/["']/g, ""),
                    this.downloadImage(Y)
                }
                .bind(this))),
                this.options.imageCounter && (this.imageCounter = z("<div/>", {
                    class: "jBox-image-counter-container"
                }).insertAfter(this.imageLabelContainer),
                this.imageCounter.append(z("<span/>", {
                    class: "jBox-image-counter-current"
                })).append(z("<span/>").html(this.options.imageCounterSeparator)).append(z("<span/>", {
                    class: "jBox-image-counter-all"
                })))
            },
            _onOpen: function() {
                z(document).on("keyup.jBox-Image-" + this.id, function(Y) {
                    Y.keyCode == 37 && this.showImage("prev"),
                    Y.keyCode == 39 && this.showImage("next")
                }
                .bind(this)),
                this.showImage("open")
            },
            _onClose: function() {
                z(document).off("keyup.jBox-Image-" + this.id)
            },
            _onCloseComplete: function() {
                this.wrapper.find(".jBox-image-container").css("opacity", 0)
            }
        })
    }
    function jBoxNoticeWrapper(W, z) {
        new W.plugin("Notice",{
            color: null,
            stack: !0,
            stackSpacing: 10,
            autoClose: 6e3,
            attributes: {
                x: "right",
                y: "top"
            },
            position: {
                x: 15,
                y: 15
            },
            responsivePositions: {
                500: {
                    x: 5,
                    y: 5
                },
                768: {
                    x: 10,
                    y: 10
                }
            },
            target: window,
            fixed: !0,
            animation: "zoomIn",
            closeOnClick: "box",
            zIndex: 12e3,
            _onInit: function() {
                this.defaultNoticePosition = z.extend({}, this.options.position),
                this._adjustNoticePositon = function() {
                    var Y = z(window)
                      , ne = Y.width();
                    Y.height(),
                    this.options.position = z.extend({}, this.defaultNoticePosition),
                    z.each(this.options.responsivePositions, function(le, ue) {
                        if (ne <= le)
                            return this.options.position = ue,
                            !1
                    }
                    .bind(this)),
                    this.options.adjustDistance = {
                        top: this.options.position.y,
                        right: this.options.position.x,
                        bottom: this.options.position.y,
                        left: this.options.position.x
                    }
                }
                ,
                this.options.content instanceof z && (this.options.content = this.options.content.clone().attr("id", "")),
                z(window).on("resize.responsivejBoxNotice-" + this.id, function(Y) {
                    this.isOpen && this._adjustNoticePositon()
                }
                .bind(this)),
                this.open()
            },
            _onCreated: function() {
                this.wrapper.addClass("jBox-Notice-color jBox-Notice-" + (this.options.color || "gray")),
                this.wrapper.data("jBox-Notice-position", this.options.attributes.x + "-" + this.options.attributes.y)
            },
            _onOpen: function() {
                this.options.stack || (this._adjustNoticePositon(),
                z.each(z(".jBox-Notice"), function(Y, ne) {
                    (ne = z(ne)).attr("id") != this.id && ne.data("jBox-Notice-position") == this.options.attributes.x + "-" + this.options.attributes.y && (this.options.stack || ne.data("jBox").close({
                        ignoreDelay: !0
                    }))
                }
                .bind(this)))
            },
            _onPosition: function() {
                var Y, ne = {};
                for (Y in z.each(z(".jBox-Notice"), function(fe, ge) {
                    var xe = (ge = z(ge)).data("jBox-Notice-position");
                    ne[xe] || (ne[xe] = []),
                    ne[xe].push(ge)
                }),
                ne) {
                    var le = Y.split("-")[1];
                    ne[Y].reverse();
                    var ue, de = 0;
                    for (ue in ne[Y]) {
                        var he = z(ne[Y][ue]);
                        he.css("margin-" + le, de),
                        de += he.outerHeight() + this.options.stackSpacing
                    }
                }
            },
            _onCloseComplete: function() {
                this.destroy(),
                this.options._onPosition.bind(this).call()
            }
        })
    }
    (function(W, z) {
        module.exports ? module.exports = W.jBox = z(jqueryExports) : W.jBox = z(W.jQuery)
    }
    )(commonjsGlobal, function(W) {
        var z = jBoxWrapper(W);
        try {
            jBoxConfirmWrapper !== void 0 && jBoxConfirmWrapper && jBoxConfirmWrapper(z, W)
        } catch (Y) {
            console.error(Y)
        }
        try {
            jBoxImageWrapper !== void 0 && jBoxImageWrapper && jBoxImageWrapper(z, W)
        } catch (Y) {
            console.error(Y)
        }
        try {
            jBoxNoticeWrapper !== void 0 && jBoxNoticeWrapper && jBoxNoticeWrapper(z, W)
        } catch (Y) {
            console.error(Y)
        }
        return z
    })
}
)(jBox_all_min),
function() {
    var W = 0
      , z = {};
    function Y(ne) {
        if (!ne)
            throw new Error("No options passed to Waypoint constructor");
        if (!ne.element)
            throw new Error("No element option passed to Waypoint constructor");
        if (!ne.handler)
            throw new Error("No handler option passed to Waypoint constructor");
        this.key = "waypoint-" + W,
        this.options = Y.Adapter.extend({}, Y.defaults, ne),
        this.element = this.options.element,
        this.adapter = new Y.Adapter(this.element),
        this.callback = ne.handler,
        this.axis = this.options.horizontal ? "horizontal" : "vertical",
        this.enabled = this.options.enabled,
        this.triggerPoint = null,
        this.group = Y.Group.findOrCreate({
            name: this.options.group,
            axis: this.axis
        }),
        this.context = Y.Context.findOrCreateByElement(this.options.context),
        Y.offsetAliases[this.options.offset] && (this.options.offset = Y.offsetAliases[this.options.offset]),
        this.group.add(this),
        this.context.add(this),
        z[this.key] = this,
        W += 1
    }
    Y.prototype.queueTrigger = function(ne) {
        this.group.queueTrigger(this, ne)
    }
    ,
    Y.prototype.trigger = function(ne) {
        this.enabled && this.callback && this.callback.apply(this, ne)
    }
    ,
    Y.prototype.destroy = function() {
        this.context.remove(this),
        this.group.remove(this),
        delete z[this.key]
    }
    ,
    Y.prototype.disable = function() {
        return this.enabled = !1,
        this
    }
    ,
    Y.prototype.enable = function() {
        return this.context.refresh(),
        this.enabled = !0,
        this
    }
    ,
    Y.prototype.next = function() {
        return this.group.next(this)
    }
    ,
    Y.prototype.previous = function() {
        return this.group.previous(this)
    }
    ,
    Y.invokeAll = function(ne) {
        var le = [];
        for (var ue in z)
            le.push(z[ue]);
        for (var de = 0, he = le.length; de < he; de++)
            le[de][ne]()
    }
    ,
    Y.destroyAll = function() {
        Y.invokeAll("destroy")
    }
    ,
    Y.disableAll = function() {
        Y.invokeAll("disable")
    }
    ,
    Y.enableAll = function() {
        for (var ne in Y.Context.refreshAll(),
        z)
            z[ne].enabled = !0;
        return this
    }
    ,
    Y.refreshAll = function() {
        Y.Context.refreshAll()
    }
    ,
    Y.viewportHeight = function() {
        return window.innerHeight || document.documentElement.clientHeight
    }
    ,
    Y.viewportWidth = function() {
        return document.documentElement.clientWidth
    }
    ,
    Y.adapters = [],
    Y.defaults = {
        context: window,
        continuous: !0,
        enabled: !0,
        group: "default",
        horizontal: !1,
        offset: 0
    },
    Y.offsetAliases = {
        "bottom-in-view": function() {
            return this.context.innerHeight() - this.adapter.outerHeight()
        },
        "right-in-view": function() {
            return this.context.innerWidth() - this.adapter.outerWidth()
        }
    },
    window.Waypoint = Y
}(),
function() {
    function W(de) {
        window.setTimeout(de, 1e3 / 60)
    }
    var z = 0
      , Y = {}
      , ne = window.Waypoint
      , le = window.onload;
    function ue(de) {
        this.element = de,
        this.Adapter = ne.Adapter,
        this.adapter = new this.Adapter(de),
        this.key = "waypoint-context-" + z,
        this.didScroll = !1,
        this.didResize = !1,
        this.oldScroll = {
            x: this.adapter.scrollLeft(),
            y: this.adapter.scrollTop()
        },
        this.waypoints = {
            vertical: {},
            horizontal: {}
        },
        de.waypointContextKey = this.key,
        Y[de.waypointContextKey] = this,
        z += 1,
        ne.windowContext || (ne.windowContext = !0,
        ne.windowContext = new ue(window)),
        this.createThrottledScrollHandler(),
        this.createThrottledResizeHandler()
    }
    ue.prototype.add = function(de) {
        var he = de.options.horizontal ? "horizontal" : "vertical";
        this.waypoints[he][de.key] = de,
        this.refresh()
    }
    ,
    ue.prototype.checkEmpty = function() {
        var de = this.Adapter.isEmptyObject(this.waypoints.horizontal)
          , he = this.Adapter.isEmptyObject(this.waypoints.vertical)
          , fe = this.element == this.element.window;
        de && he && !fe && (this.adapter.off(".waypoints"),
        delete Y[this.key])
    }
    ,
    ue.prototype.createThrottledResizeHandler = function() {
        var de = this;
        function he() {
            de.handleResize(),
            de.didResize = !1
        }
        this.adapter.on("resize.waypoints", function() {
            de.didResize || (de.didResize = !0,
            ne.requestAnimationFrame(he))
        })
    }
    ,
    ue.prototype.createThrottledScrollHandler = function() {
        var de = this;
        function he() {
            de.handleScroll(),
            de.didScroll = !1
        }
        this.adapter.on("scroll.waypoints", function() {
            de.didScroll && !ne.isTouch || (de.didScroll = !0,
            ne.requestAnimationFrame(he))
        })
    }
    ,
    ue.prototype.handleResize = function() {
        ne.Context.refreshAll()
    }
    ,
    ue.prototype.handleScroll = function() {
        var de = {}
          , he = {
            horizontal: {
                newScroll: this.adapter.scrollLeft(),
                oldScroll: this.oldScroll.x,
                forward: "right",
                backward: "left"
            },
            vertical: {
                newScroll: this.adapter.scrollTop(),
                oldScroll: this.oldScroll.y,
                forward: "down",
                backward: "up"
            }
        };
        for (var fe in he) {
            var ge = he[fe]
              , xe = ge.newScroll > ge.oldScroll ? ge.forward : ge.backward;
            for (var $e in this.waypoints[fe]) {
                var Ee = this.waypoints[fe][$e];
                if (Ee.triggerPoint !== null) {
                    var Se = ge.oldScroll < Ee.triggerPoint
                      , Ne = ge.newScroll >= Ee.triggerPoint;
                    (Se && Ne || !Se && !Ne) && (Ee.queueTrigger(xe),
                    de[Ee.group.id] = Ee.group)
                }
            }
        }
        for (var tt in de)
            de[tt].flushTriggers();
        this.oldScroll = {
            x: he.horizontal.newScroll,
            y: he.vertical.newScroll
        }
    }
    ,
    ue.prototype.innerHeight = function() {
        return this.element == this.element.window ? ne.viewportHeight() : this.adapter.innerHeight()
    }
    ,
    ue.prototype.remove = function(de) {
        delete this.waypoints[de.axis][de.key],
        this.checkEmpty()
    }
    ,
    ue.prototype.innerWidth = function() {
        return this.element == this.element.window ? ne.viewportWidth() : this.adapter.innerWidth()
    }
    ,
    ue.prototype.destroy = function() {
        var de = [];
        for (var he in this.waypoints)
            for (var fe in this.waypoints[he])
                de.push(this.waypoints[he][fe]);
        for (var ge = 0, xe = de.length; ge < xe; ge++)
            de[ge].destroy()
    }
    ,
    ue.prototype.refresh = function() {
        var de, he = this.element == this.element.window, fe = he ? void 0 : this.adapter.offset(), ge = {};
        for (var xe in this.handleScroll(),
        de = {
            horizontal: {
                contextOffset: he ? 0 : fe.left,
                contextScroll: he ? 0 : this.oldScroll.x,
                contextDimension: this.innerWidth(),
                oldScroll: this.oldScroll.x,
                forward: "right",
                backward: "left",
                offsetProp: "left"
            },
            vertical: {
                contextOffset: he ? 0 : fe.top,
                contextScroll: he ? 0 : this.oldScroll.y,
                contextDimension: this.innerHeight(),
                oldScroll: this.oldScroll.y,
                forward: "down",
                backward: "up",
                offsetProp: "top"
            }
        }) {
            var $e = de[xe];
            for (var Ee in this.waypoints[xe]) {
                var Se, Ne, tt, rr, tr = this.waypoints[xe][Ee], we = tr.options.offset, Ut = tr.triggerPoint, lr = 0, cr = Ut == null;
                tr.element !== tr.element.window && (lr = tr.adapter.offset()[$e.offsetProp]),
                typeof we == "function" ? we = we.apply(tr) : typeof we == "string" && (we = parseFloat(we),
                tr.options.offset.indexOf("%") > -1 && (we = Math.ceil($e.contextDimension * we / 100))),
                Se = $e.contextScroll - $e.contextOffset,
                tr.triggerPoint = Math.floor(lr + Se - we),
                Ne = Ut < $e.oldScroll,
                tt = tr.triggerPoint >= $e.oldScroll,
                rr = !Ne && !tt,
                !cr && Ne && tt ? (tr.queueTrigger($e.backward),
                ge[tr.group.id] = tr.group) : (!cr && rr || cr && $e.oldScroll >= tr.triggerPoint) && (tr.queueTrigger($e.forward),
                ge[tr.group.id] = tr.group)
            }
        }
        return ne.requestAnimationFrame(function() {
            for (var be in ge)
                ge[be].flushTriggers()
        }),
        this
    }
    ,
    ue.findOrCreateByElement = function(de) {
        return ue.findByElement(de) || new ue(de)
    }
    ,
    ue.refreshAll = function() {
        for (var de in Y)
            Y[de].refresh()
    }
    ,
    ue.findByElement = function(de) {
        return Y[de.waypointContextKey]
    }
    ,
    window.onload = function() {
        le && le(),
        ue.refreshAll()
    }
    ,
    ne.requestAnimationFrame = function(de) {
        (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || W).call(window, de)
    }
    ,
    ne.Context = ue
}(),
function() {
    function W(ue, de) {
        return ue.triggerPoint - de.triggerPoint
    }
    function z(ue, de) {
        return de.triggerPoint - ue.triggerPoint
    }
    var Y = {
        vertical: {},
        horizontal: {}
    }
      , ne = window.Waypoint;
    function le(ue) {
        this.name = ue.name,
        this.axis = ue.axis,
        this.id = this.name + "-" + this.axis,
        this.waypoints = [],
        this.clearTriggerQueues(),
        Y[this.axis][this.name] = this
    }
    le.prototype.add = function(ue) {
        this.waypoints.push(ue)
    }
    ,
    le.prototype.clearTriggerQueues = function() {
        this.triggerQueues = {
            up: [],
            down: [],
            left: [],
            right: []
        }
    }
    ,
    le.prototype.flushTriggers = function() {
        for (var ue in this.triggerQueues) {
            var de = this.triggerQueues[ue]
              , he = ue === "up" || ue === "left";
            de.sort(he ? z : W);
            for (var fe = 0, ge = de.length; fe < ge; fe += 1) {
                var xe = de[fe];
                (xe.options.continuous || fe === de.length - 1) && xe.trigger([ue])
            }
        }
        this.clearTriggerQueues()
    }
    ,
    le.prototype.next = function(ue) {
        this.waypoints.sort(W);
        var de = ne.Adapter.inArray(ue, this.waypoints);
        return de === this.waypoints.length - 1 ? null : this.waypoints[de + 1]
    }
    ,
    le.prototype.previous = function(ue) {
        this.waypoints.sort(W);
        var de = ne.Adapter.inArray(ue, this.waypoints);
        return de ? this.waypoints[de - 1] : null
    }
    ,
    le.prototype.queueTrigger = function(ue, de) {
        this.triggerQueues[de].push(ue)
    }
    ,
    le.prototype.remove = function(ue) {
        var de = ne.Adapter.inArray(ue, this.waypoints);
        de > -1 && this.waypoints.splice(de, 1)
    }
    ,
    le.prototype.first = function() {
        return this.waypoints[0]
    }
    ,
    le.prototype.last = function() {
        return this.waypoints[this.waypoints.length - 1]
    }
    ,
    le.findOrCreate = function(ue) {
        return Y[ue.axis][ue.name] || new le(ue)
    }
    ,
    ne.Group = le
}(),
function() {
    var W = window.Waypoint;
    function z(le) {
        return le === le.window
    }
    function Y(le) {
        return z(le) ? le : le.defaultView
    }
    function ne(le) {
        this.element = le,
        this.handlers = {}
    }
    ne.prototype.innerHeight = function() {
        return z(this.element) ? this.element.innerHeight : this.element.clientHeight
    }
    ,
    ne.prototype.innerWidth = function() {
        return z(this.element) ? this.element.innerWidth : this.element.clientWidth
    }
    ,
    ne.prototype.off = function(le, ue) {
        function de(Se, Ne, tt) {
            for (var rr = 0, tr = Ne.length - 1; rr < tr; rr++) {
                var we = Ne[rr];
                tt && tt !== we || Se.removeEventListener(we)
            }
        }
        var he = le.split(".")
          , fe = he[0]
          , ge = he[1]
          , xe = this.element;
        if (ge && this.handlers[ge] && fe)
            de(xe, this.handlers[ge][fe], ue),
            this.handlers[ge][fe] = [];
        else if (fe)
            for (var $e in this.handlers)
                de(xe, this.handlers[$e][fe] || [], ue),
                this.handlers[$e][fe] = [];
        else if (ge && this.handlers[ge]) {
            for (var Ee in this.handlers[ge])
                de(xe, this.handlers[ge][Ee], ue);
            this.handlers[ge] = {}
        }
    }
    ,
    ne.prototype.offset = function() {
        if (!this.element.ownerDocument)
            return null;
        var le = this.element.ownerDocument.documentElement
          , ue = Y(this.element.ownerDocument)
          , de = {
            top: 0,
            left: 0
        };
        return this.element.getBoundingClientRect && (de = this.element.getBoundingClientRect()),
        {
            top: de.top + ue.pageYOffset - le.clientTop,
            left: de.left + ue.pageXOffset - le.clientLeft
        }
    }
    ,
    ne.prototype.on = function(le, ue) {
        var de = le.split(".")
          , he = de[0]
          , fe = de[1] || "__default"
          , ge = this.handlers[fe] = this.handlers[fe] || {};
        (ge[he] = ge[he] || []).push(ue),
        this.element.addEventListener(he, ue)
    }
    ,
    ne.prototype.outerHeight = function(le) {
        var ue, de = this.innerHeight();
        return le && !z(this.element) && (ue = window.getComputedStyle(this.element),
        de += parseInt(ue.marginTop, 10),
        de += parseInt(ue.marginBottom, 10)),
        de
    }
    ,
    ne.prototype.outerWidth = function(le) {
        var ue, de = this.innerWidth();
        return le && !z(this.element) && (ue = window.getComputedStyle(this.element),
        de += parseInt(ue.marginLeft, 10),
        de += parseInt(ue.marginRight, 10)),
        de
    }
    ,
    ne.prototype.scrollLeft = function() {
        var le = Y(this.element);
        return le ? le.pageXOffset : this.element.scrollLeft
    }
    ,
    ne.prototype.scrollTop = function() {
        var le = Y(this.element);
        return le ? le.pageYOffset : this.element.scrollTop
    }
    ,
    ne.extend = function() {
        var le = Array.prototype.slice.call(arguments);
        function ue(fe, ge) {
            if (typeof fe == "object" && typeof ge == "object")
                for (var xe in ge)
                    ge.hasOwnProperty(xe) && (fe[xe] = ge[xe]);
            return fe
        }
        for (var de = 1, he = le.length; de < he; de++)
            ue(le[0], le[de]);
        return le[0]
    }
    ,
    ne.inArray = function(le, ue, de) {
        return ue == null ? -1 : ue.indexOf(le, de)
    }
    ,
    ne.isEmptyObject = function(le) {
        for (var ue in le)
            return !1;
        return !0
    }
    ,
    W.adapters.push({
        name: "noframework",
        Adapter: ne
    }),
    W.Adapter = ne
}();
const ssrDocument = {
    body: {},
    addEventListener() {},
    removeEventListener() {},
    activeElement: {
        blur() {},
        nodeName: ""
    },
    querySelector: ()=>null,
    querySelectorAll: ()=>[],
    getElementById: ()=>null,
    createEvent: ()=>({
        initEvent() {}
    }),
    createElement: ()=>({
        children: [],
        childNodes: [],
        style: {},
        setAttribute() {},
        getElementsByTagName: ()=>[]
    }),
    createElementNS: ()=>({}),
    importNode: ()=>null,
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    }
};
function getDocument$1() {
    const W = typeof document < "u" ? document : {};
    return extend$1(W, ssrDocument),
    W
}
const ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: ""
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    },
    history: {
        replaceState() {},
        pushState() {},
        go() {},
        back() {}
    },
    CustomEvent: function() {
        return this
    },
    addEventListener() {},
    removeEventListener() {},
    getComputedStyle: ()=>({
        getPropertyValue: ()=>""
    }),
    Image() {},
    Date() {},
    screen: {},
    setTimeout() {},
    clearTimeout() {},
    matchMedia: ()=>({}),
    requestAnimationFrame: W=>typeof setTimeout > "u" ? (W(),
    null) : setTimeout(W, 0),
    cancelAnimationFrame(W) {
        typeof setTimeout < "u" && clearTimeout(W)
    }
};
function getWindow() {
    const W = typeof window < "u" ? window : {};
    return extend$1(W, ssrWindow),
    W
}
function classesToTokens(W) {
    return W === void 0 && (W = ""),
    W.trim().split(" ").filter(z=>!!z.trim())
}
function deleteProps(W) {
    const z = W;
    Object.keys(z).forEach(Y=>{
        try {
            z[Y] = null
        } catch {}
        try {
            delete z[Y]
        } catch {}
    }
    )
}
function nextTick(W, z) {
    return z === void 0 && (z = 0),
    setTimeout(W, z)
}
function now$1() {
    return Date.now()
}
function getComputedStyle$1(W) {
    const z = getWindow();
    let Y;
    return z.getComputedStyle && (Y = z.getComputedStyle(W, null)),
    !Y && W.currentStyle && (Y = W.currentStyle),
    Y || (Y = W.style),
    Y
}
function getTranslate(W, z) {
    z === void 0 && (z = "x");
    const Y = getWindow();
    let ne, le, ue;
    const de = getComputedStyle$1(W);
    return Y.WebKitCSSMatrix ? (le = de.transform || de.webkitTransform,
    le.split(",").length > 6 && (le = le.split(", ").map(he=>he.replace(",", ".")).join(", ")),
    ue = new Y.WebKitCSSMatrix(le === "none" ? "" : le)) : (ue = de.MozTransform || de.OTransform || de.MsTransform || de.msTransform || de.transform || de.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"),
    ne = ue.toString().split(",")),
    z === "x" && (le = Y.WebKitCSSMatrix ? ue.m41 : ne.length === 16 ? parseFloat(ne[12]) : parseFloat(ne[4])),
    z === "y" && (le = Y.WebKitCSSMatrix ? ue.m42 : ne.length === 16 ? parseFloat(ne[13]) : parseFloat(ne[5])),
    le || 0
}
function isObject$1(W) {
    return typeof W == "object" && W !== null && W.constructor && Object.prototype.toString.call(W).slice(8, -1) === "Object"
}
function isNode(W) {
    return typeof window < "u" && window.HTMLElement !== void 0 ? W instanceof HTMLElement : W && (W.nodeType === 1 || W.nodeType === 11)
}
function extend() {
    const W = Object(arguments.length <= 0 ? void 0 : arguments[0])
      , z = ["__proto__", "constructor", "prototype"];
    for (let Y = 1; Y < arguments.length; Y += 1) {
        const ne = Y < 0 || arguments.length <= Y ? void 0 : arguments[Y];
        if (ne != null && !isNode(ne)) {
            const le = Object.keys(Object(ne)).filter(ue=>z.indexOf(ue) < 0);
            for (let ue = 0, de = le.length; ue < de; ue += 1) {
                const he = le[ue]
                  , fe = Object.getOwnPropertyDescriptor(ne, he);
                fe !== void 0 && fe.enumerable && (isObject$1(W[he]) && isObject$1(ne[he]) ? ne[he].__swiper__ ? W[he] = ne[he] : extend(W[he], ne[he]) : !isObject$1(W[he]) && isObject$1(ne[he]) ? (W[he] = {},
                ne[he].__swiper__ ? W[he] = ne[he] : extend(W[he], ne[he])) : W[he] = ne[he])
            }
        }
    }
    return W
}
function setCSSProperty(W, z, Y) {
    W.style.setProperty(z, Y)
}
function animateCSSModeScroll(W) {
    let {swiper: z, targetPosition: Y, side: ne} = W;
    const le = getWindow()
      , ue = -z.translate;
    let de, he = null;
    const fe = z.params.speed;
    z.wrapperEl.style.scrollSnapType = "none",
    le.cancelAnimationFrame(z.cssModeFrameID);
    const ge = Y > ue ? "next" : "prev"
      , xe = (Ee,Se)=>ge === "next" && Ee >= Se || ge === "prev" && Ee <= Se
      , $e = ()=>{
        de = new Date().getTime(),
        he === null && (he = de);
        const Ee = Math.max(Math.min((de - he) / fe, 1), 0)
          , Se = .5 - Math.cos(Ee * Math.PI) / 2;
        let Ne = ue + Se * (Y - ue);
        if (xe(Ne, Y) && (Ne = Y),
        z.wrapperEl.scrollTo({
            [ne]: Ne
        }),
        xe(Ne, Y))
            return z.wrapperEl.style.overflow = "hidden",
            z.wrapperEl.style.scrollSnapType = "",
            setTimeout(()=>{
                z.wrapperEl.style.overflow = "",
                z.wrapperEl.scrollTo({
                    [ne]: Ne
                })
            }
            ),
            void le.cancelAnimationFrame(z.cssModeFrameID);
        z.cssModeFrameID = le.requestAnimationFrame($e)
    }
    ;
    $e()
}
function elementChildren(W, z) {
    return z === void 0 && (z = ""),
    [...W.children].filter(Y=>Y.matches(z))
}
function showWarning(W) {
    try {
        return void console.warn(W)
    } catch {}
}
function createElement(W, z) {
    z === void 0 && (z = []);
    const Y = document.createElement(W);
    return Y.classList.add(...Array.isArray(z) ? z : classesToTokens(z)),
    Y
}
function elementPrevAll(W, z) {
    const Y = [];
    for (; W.previousElementSibling; ) {
        const ne = W.previousElementSibling;
        z ? ne.matches(z) && Y.push(ne) : Y.push(ne),
        W = ne
    }
    return Y
}
function elementNextAll(W, z) {
    const Y = [];
    for (; W.nextElementSibling; ) {
        const ne = W.nextElementSibling;
        z ? ne.matches(z) && Y.push(ne) : Y.push(ne),
        W = ne
    }
    return Y
}
function elementStyle(W, z) {
    return getWindow().getComputedStyle(W, null).getPropertyValue(z)
}
function elementIndex(W) {
    let z, Y = W;
    if (Y) {
        for (z = 0; (Y = Y.previousSibling) !== null; )
            Y.nodeType === 1 && (z += 1);
        return z
    }
}
function elementParents(W, z) {
    const Y = [];
    let ne = W.parentElement;
    for (; ne; )
        z ? ne.matches(z) && Y.push(ne) : Y.push(ne),
        ne = ne.parentElement;
    return Y
}
function elementOuterSize(W, z, Y) {
    const ne = getWindow();
    return Y ? W[z === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(ne.getComputedStyle(W, null).getPropertyValue(z === "width" ? "margin-right" : "margin-top")) + parseFloat(ne.getComputedStyle(W, null).getPropertyValue(z === "width" ? "margin-left" : "margin-bottom")) : W.offsetWidth
}
function createElementIfNotDefined(W, z, Y, ne) {
    return W.params.createElements && Object.keys(ne).forEach(le=>{
        if (!Y[le] && Y.auto === !0) {
            let ue = elementChildren(W.el, `.${ne[le]}`)[0];
            ue || (ue = createElement("div", ne[le]),
            ue.className = ne[le],
            W.el.append(ue)),
            Y[le] = ue,
            z[le] = ue
        }
    }
    ),
    Y
}
function classesToSelector(W) {
    return W === void 0 && (W = ""),
    `.${W.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}`
}
function Pagination(W) {
    let {swiper: z, extendParams: Y, on: ne, emit: le} = W;
    const ue = "swiper-pagination";
    let de;
    Y({
        pagination: {
            el: null,
            bulletElement: "span",
            clickable: !1,
            hideOnClick: !1,
            renderBullet: null,
            renderProgressbar: null,
            renderFraction: null,
            renderCustom: null,
            progressbarOpposite: !1,
            type: "bullets",
            dynamicBullets: !1,
            dynamicMainBullets: 1,
            formatFractionCurrent: tr=>tr,
            formatFractionTotal: tr=>tr,
            bulletClass: `${ue}-bullet`,
            bulletActiveClass: `${ue}-bullet-active`,
            modifierClass: `${ue}-`,
            currentClass: `${ue}-current`,
            totalClass: `${ue}-total`,
            hiddenClass: `${ue}-hidden`,
            progressbarFillClass: `${ue}-progressbar-fill`,
            progressbarOppositeClass: `${ue}-progressbar-opposite`,
            clickableClass: `${ue}-clickable`,
            lockClass: `${ue}-lock`,
            horizontalClass: `${ue}-horizontal`,
            verticalClass: `${ue}-vertical`,
            paginationDisabledClass: `${ue}-disabled`
        }
    }),
    z.pagination = {
        el: null,
        bullets: []
    };
    let he = 0;
    const fe = tr=>(Array.isArray(tr) ? tr : [tr]).filter(we=>!!we);
    function ge() {
        return !z.params.pagination.el || !z.pagination.el || Array.isArray(z.pagination.el) && z.pagination.el.length === 0
    }
    function xe(tr, we) {
        const {bulletActiveClass: Ut} = z.params.pagination;
        tr && (tr = tr[(we === "prev" ? "previous" : "next") + "ElementSibling"]) && (tr.classList.add(`${Ut}-${we}`),
        (tr = tr[(we === "prev" ? "previous" : "next") + "ElementSibling"]) && tr.classList.add(`${Ut}-${we}-${we}`))
    }
    function $e(tr) {
        const we = tr.target.closest(classesToSelector(z.params.pagination.bulletClass));
        if (!we)
            return;
        tr.preventDefault();
        const Ut = elementIndex(we) * z.params.slidesPerGroup;
        if (z.params.loop) {
            if (z.realIndex === Ut)
                return;
            z.slideToLoop(Ut)
        } else
            z.slideTo(Ut)
    }
    function Ee() {
        const tr = z.rtl
          , we = z.params.pagination;
        if (ge())
            return;
        let Ut, lr, cr = z.pagination.el;
        cr = fe(cr);
        const be = z.virtual && z.params.virtual.enabled ? z.virtual.slides.length : z.slides.length
          , mr = z.params.loop ? Math.ceil(be / z.params.slidesPerGroup) : z.snapGrid.length;
        if (z.params.loop ? (lr = z.previousRealIndex || 0,
        Ut = z.params.slidesPerGroup > 1 ? Math.floor(z.realIndex / z.params.slidesPerGroup) : z.realIndex) : z.snapIndex !== void 0 ? (Ut = z.snapIndex,
        lr = z.previousSnapIndex) : (lr = z.previousIndex || 0,
        Ut = z.activeIndex || 0),
        we.type === "bullets" && z.pagination.bullets && z.pagination.bullets.length > 0) {
            const fr = z.pagination.bullets;
            let Rr, Pr, Fr;
            if (we.dynamicBullets && (de = elementOuterSize(fr[0], z.isHorizontal() ? "width" : "height", !0),
            cr.forEach(br=>{
                br.style[z.isHorizontal() ? "width" : "height"] = de * (we.dynamicMainBullets + 4) + "px"
            }
            ),
            we.dynamicMainBullets > 1 && lr !== void 0 && (he += Ut - (lr || 0),
            he > we.dynamicMainBullets - 1 ? he = we.dynamicMainBullets - 1 : he < 0 && (he = 0)),
            Rr = Math.max(Ut - he, 0),
            Pr = Rr + (Math.min(fr.length, we.dynamicMainBullets) - 1),
            Fr = (Pr + Rr) / 2),
            fr.forEach(br=>{
                const xr = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(_r=>`${we.bulletActiveClass}${_r}`)].map(_r=>typeof _r == "string" && _r.includes(" ") ? _r.split(" ") : _r).flat();
                br.classList.remove(...xr)
            }
            ),
            cr.length > 1)
                fr.forEach(br=>{
                    const xr = elementIndex(br);
                    xr === Ut ? br.classList.add(...we.bulletActiveClass.split(" ")) : z.isElement && br.setAttribute("part", "bullet"),
                    we.dynamicBullets && (xr >= Rr && xr <= Pr && br.classList.add(...`${we.bulletActiveClass}-main`.split(" ")),
                    xr === Rr && xe(br, "prev"),
                    xr === Pr && xe(br, "next"))
                }
                );
            else {
                const br = fr[Ut];
                if (br && br.classList.add(...we.bulletActiveClass.split(" ")),
                z.isElement && fr.forEach((xr,_r)=>{
                    xr.setAttribute("part", _r === Ut ? "bullet-active" : "bullet")
                }
                ),
                we.dynamicBullets) {
                    const xr = fr[Rr]
                      , _r = fr[Pr];
                    for (let Ir = Rr; Ir <= Pr; Ir += 1)
                        fr[Ir] && fr[Ir].classList.add(...`${we.bulletActiveClass}-main`.split(" "));
                    xe(xr, "prev"),
                    xe(_r, "next")
                }
            }
            if (we.dynamicBullets) {
                const br = Math.min(fr.length, we.dynamicMainBullets + 4)
                  , xr = (de * br - de) / 2 - Fr * de
                  , _r = tr ? "right" : "left";
                fr.forEach(Ir=>{
                    Ir.style[z.isHorizontal() ? _r : "top"] = `${xr}px`
                }
                )
            }
        }
        cr.forEach((fr,Rr)=>{
            if (we.type === "fraction" && (fr.querySelectorAll(classesToSelector(we.currentClass)).forEach(Pr=>{
                Pr.textContent = we.formatFractionCurrent(Ut + 1)
            }
            ),
            fr.querySelectorAll(classesToSelector(we.totalClass)).forEach(Pr=>{
                Pr.textContent = we.formatFractionTotal(mr)
            }
            )),
            we.type === "progressbar") {
                let Pr;
                Pr = we.progressbarOpposite ? z.isHorizontal() ? "vertical" : "horizontal" : z.isHorizontal() ? "horizontal" : "vertical";
                const Fr = (Ut + 1) / mr;
                let br = 1
                  , xr = 1;
                Pr === "horizontal" ? br = Fr : xr = Fr,
                fr.querySelectorAll(classesToSelector(we.progressbarFillClass)).forEach(_r=>{
                    _r.style.transform = `translate3d(0,0,0) scaleX(${br}) scaleY(${xr})`,
                    _r.style.transitionDuration = `${z.params.speed}ms`
                }
                )
            }
            we.type === "custom" && we.renderCustom ? (fr.innerHTML = we.renderCustom(z, Ut + 1, mr),
            Rr === 0 && le("paginationRender", fr)) : (Rr === 0 && le("paginationRender", fr),
            le("paginationUpdate", fr)),
            z.params.watchOverflow && z.enabled && fr.classList[z.isLocked ? "add" : "remove"](we.lockClass)
        }
        )
    }
    function Se() {
        const tr = z.params.pagination;
        if (ge())
            return;
        const we = z.virtual && z.params.virtual.enabled ? z.virtual.slides.length : z.grid && z.params.grid.rows > 1 ? z.slides.length / Math.ceil(z.params.grid.rows) : z.slides.length;
        let Ut = z.pagination.el;
        Ut = fe(Ut);
        let lr = "";
        if (tr.type === "bullets") {
            let cr = z.params.loop ? Math.ceil(we / z.params.slidesPerGroup) : z.snapGrid.length;
            z.params.freeMode && z.params.freeMode.enabled && cr > we && (cr = we);
            for (let be = 0; be < cr; be += 1)
                tr.renderBullet ? lr += tr.renderBullet.call(z, be, tr.bulletClass) : lr += `<${tr.bulletElement} ${z.isElement ? 'part="bullet"' : ""} class="${tr.bulletClass}"></${tr.bulletElement}>`
        }
        tr.type === "fraction" && (lr = tr.renderFraction ? tr.renderFraction.call(z, tr.currentClass, tr.totalClass) : `<span class="${tr.currentClass}"></span> / <span class="${tr.totalClass}"></span>`),
        tr.type === "progressbar" && (lr = tr.renderProgressbar ? tr.renderProgressbar.call(z, tr.progressbarFillClass) : `<span class="${tr.progressbarFillClass}"></span>`),
        z.pagination.bullets = [],
        Ut.forEach(cr=>{
            tr.type !== "custom" && (cr.innerHTML = lr || ""),
            tr.type === "bullets" && z.pagination.bullets.push(...cr.querySelectorAll(classesToSelector(tr.bulletClass)))
        }
        ),
        tr.type !== "custom" && le("paginationRender", Ut[0])
    }
    function Ne() {
        z.params.pagination = createElementIfNotDefined(z, z.originalParams.pagination, z.params.pagination, {
            el: "swiper-pagination"
        });
        const tr = z.params.pagination;
        if (!tr.el)
            return;
        let we;
        typeof tr.el == "string" && z.isElement && (we = z.el.querySelector(tr.el)),
        we || typeof tr.el != "string" || (we = [...document.querySelectorAll(tr.el)]),
        we || (we = tr.el),
        we && we.length !== 0 && (z.params.uniqueNavElements && typeof tr.el == "string" && Array.isArray(we) && we.length > 1 && (we = [...z.el.querySelectorAll(tr.el)],
        we.length > 1 && (we = we.filter(Ut=>elementParents(Ut, ".swiper")[0] === z.el)[0])),
        Array.isArray(we) && we.length === 1 && (we = we[0]),
        Object.assign(z.pagination, {
            el: we
        }),
        we = fe(we),
        we.forEach(Ut=>{
            tr.type === "bullets" && tr.clickable && Ut.classList.add(...(tr.clickableClass || "").split(" ")),
            Ut.classList.add(tr.modifierClass + tr.type),
            Ut.classList.add(z.isHorizontal() ? tr.horizontalClass : tr.verticalClass),
            tr.type === "bullets" && tr.dynamicBullets && (Ut.classList.add(`${tr.modifierClass}${tr.type}-dynamic`),
            he = 0,
            tr.dynamicMainBullets < 1 && (tr.dynamicMainBullets = 1)),
            tr.type === "progressbar" && tr.progressbarOpposite && Ut.classList.add(tr.progressbarOppositeClass),
            tr.clickable && Ut.addEventListener("click", $e),
            z.enabled || Ut.classList.add(tr.lockClass)
        }
        ))
    }
    function tt() {
        const tr = z.params.pagination;
        if (ge())
            return;
        let we = z.pagination.el;
        we && (we = fe(we),
        we.forEach(Ut=>{
            Ut.classList.remove(tr.hiddenClass),
            Ut.classList.remove(tr.modifierClass + tr.type),
            Ut.classList.remove(z.isHorizontal() ? tr.horizontalClass : tr.verticalClass),
            tr.clickable && (Ut.classList.remove(...(tr.clickableClass || "").split(" ")),
            Ut.removeEventListener("click", $e))
        }
        )),
        z.pagination.bullets && z.pagination.bullets.forEach(Ut=>Ut.classList.remove(...tr.bulletActiveClass.split(" ")))
    }
    ne("changeDirection", ()=>{
        if (!z.pagination || !z.pagination.el)
            return;
        const tr = z.params.pagination;
        let {el: we} = z.pagination;
        we = fe(we),
        we.forEach(Ut=>{
            Ut.classList.remove(tr.horizontalClass, tr.verticalClass),
            Ut.classList.add(z.isHorizontal() ? tr.horizontalClass : tr.verticalClass)
        }
        )
    }
    ),
    ne("init", ()=>{
        z.params.pagination.enabled === !1 ? rr() : (Ne(),
        Se(),
        Ee())
    }
    ),
    ne("activeIndexChange", ()=>{
        z.snapIndex === void 0 && Ee()
    }
    ),
    ne("snapIndexChange", ()=>{
        Ee()
    }
    ),
    ne("snapGridLengthChange", ()=>{
        Se(),
        Ee()
    }
    ),
    ne("destroy", ()=>{
        tt()
    }
    ),
    ne("enable disable", ()=>{
        let {el: tr} = z.pagination;
        tr && (tr = fe(tr),
        tr.forEach(we=>we.classList[z.enabled ? "remove" : "add"](z.params.pagination.lockClass)))
    }
    ),
    ne("lock unlock", ()=>{
        Ee()
    }
    ),
    ne("click", (tr,we)=>{
        const Ut = we.target
          , lr = fe(z.pagination.el);
        if (z.params.pagination.el && z.params.pagination.hideOnClick && lr && lr.length > 0 && !Ut.classList.contains(z.params.pagination.bulletClass)) {
            if (z.navigation && (z.navigation.nextEl && Ut === z.navigation.nextEl || z.navigation.prevEl && Ut === z.navigation.prevEl))
                return;
            const cr = lr[0].classList.contains(z.params.pagination.hiddenClass);
            le(cr === !0 ? "paginationShow" : "paginationHide"),
            lr.forEach(be=>be.classList.toggle(z.params.pagination.hiddenClass))
        }
    }
    );
    const rr = ()=>{
        z.el.classList.add(z.params.pagination.paginationDisabledClass);
        let {el: tr} = z.pagination;
        tr && (tr = fe(tr),
        tr.forEach(we=>we.classList.add(z.params.pagination.paginationDisabledClass))),
        tt()
    }
    ;
    Object.assign(z.pagination, {
        enable: ()=>{
            z.el.classList.remove(z.params.pagination.paginationDisabledClass);
            let {el: tr} = z.pagination;
            tr && (tr = fe(tr),
            tr.forEach(we=>we.classList.remove(z.params.pagination.paginationDisabledClass))),
            Ne(),
            Se(),
            Ee()
        }
        ,
        disable: rr,
        render: Se,
        update: Ee,
        init: Ne,
        destroy: tt
    })
}
function Autoplay(W) {
    let z, Y, {swiper: ne, extendParams: le, on: ue, emit: de, params: he} = W;
    ne.autoplay = {
        running: !1,
        paused: !1,
        timeLeft: 0
    },
    le({
        autoplay: {
            enabled: !1,
            delay: 3e3,
            waitForTransition: !0,
            disableOnInteraction: !1,
            stopOnLastSlide: !1,
            reverseDirection: !1,
            pauseOnMouseEnter: !1
        }
    });
    let fe, ge, xe, $e, Ee, Se, Ne, tt, rr = he && he.autoplay ? he.autoplay.delay : 3e3, tr = he && he.autoplay ? he.autoplay.delay : 3e3, we = new Date().getTime();
    function Ut(xr) {
        ne && !ne.destroyed && ne.wrapperEl && xr.target === ne.wrapperEl && (ne.wrapperEl.removeEventListener("transitionend", Ut),
        tt || Rr())
    }
    const lr = ()=>{
        if (ne.destroyed || !ne.autoplay.running)
            return;
        ne.autoplay.paused ? ge = !0 : ge && (tr = fe,
        ge = !1);
        const xr = ne.autoplay.paused ? fe : we + tr - new Date().getTime();
        ne.autoplay.timeLeft = xr,
        de("autoplayTimeLeft", xr, xr / rr),
        Y = requestAnimationFrame(()=>{
            lr()
        }
        )
    }
      , cr = xr=>{
        if (ne.destroyed || !ne.autoplay.running)
            return;
        cancelAnimationFrame(Y),
        lr();
        let _r = xr === void 0 ? ne.params.autoplay.delay : xr;
        rr = ne.params.autoplay.delay,
        tr = ne.params.autoplay.delay;
        const Ir = (()=>{
            let Zr;
            if (Zr = ne.virtual && ne.params.virtual.enabled ? ne.slides.filter(Tn=>Tn.classList.contains("swiper-slide-active"))[0] : ne.slides[ne.activeIndex],
            !!Zr)
                return parseInt(Zr.getAttribute("data-swiper-autoplay"), 10)
        }
        )();
        !Number.isNaN(Ir) && Ir > 0 && xr === void 0 && (_r = Ir,
        rr = Ir,
        tr = Ir),
        fe = _r;
        const Nr = ne.params.speed
          , gn = ()=>{
            ne && !ne.destroyed && (ne.params.autoplay.reverseDirection ? !ne.isBeginning || ne.params.loop || ne.params.rewind ? (ne.slidePrev(Nr, !0, !0),
            de("autoplay")) : ne.params.autoplay.stopOnLastSlide || (ne.slideTo(ne.slides.length - 1, Nr, !0, !0),
            de("autoplay")) : !ne.isEnd || ne.params.loop || ne.params.rewind ? (ne.slideNext(Nr, !0, !0),
            de("autoplay")) : ne.params.autoplay.stopOnLastSlide || (ne.slideTo(0, Nr, !0, !0),
            de("autoplay")),
            ne.params.cssMode && (we = new Date().getTime(),
            requestAnimationFrame(()=>{
                cr()
            }
            )))
        }
        ;
        return _r > 0 ? (clearTimeout(z),
        z = setTimeout(()=>{
            gn()
        }
        , _r)) : requestAnimationFrame(()=>{
            gn()
        }
        ),
        _r
    }
      , be = ()=>{
        we = new Date().getTime(),
        ne.autoplay.running = !0,
        cr(),
        de("autoplayStart")
    }
      , mr = ()=>{
        ne.autoplay.running = !1,
        clearTimeout(z),
        cancelAnimationFrame(Y),
        de("autoplayStop")
    }
      , fr = (xr,_r)=>{
        if (ne.destroyed || !ne.autoplay.running)
            return;
        clearTimeout(z),
        xr || (Ne = !0);
        const Ir = ()=>{
            de("autoplayPause"),
            ne.params.autoplay.waitForTransition ? ne.wrapperEl.addEventListener("transitionend", Ut) : Rr()
        }
        ;
        if (ne.autoplay.paused = !0,
        _r)
            return Se && (fe = ne.params.autoplay.delay),
            Se = !1,
            void Ir();
        fe = (fe || ne.params.autoplay.delay) - (new Date().getTime() - we),
        ne.isEnd && fe < 0 && !ne.params.loop || (fe < 0 && (fe = 0),
        Ir())
    }
      , Rr = ()=>{
        ne.isEnd && fe < 0 && !ne.params.loop || ne.destroyed || !ne.autoplay.running || (we = new Date().getTime(),
        Ne ? (Ne = !1,
        cr(fe)) : cr(),
        ne.autoplay.paused = !1,
        de("autoplayResume"))
    }
      , Pr = ()=>{
        if (ne.destroyed || !ne.autoplay.running)
            return;
        const xr = getDocument$1();
        xr.visibilityState === "hidden" && (Ne = !0,
        fr(!0)),
        xr.visibilityState === "visible" && Rr()
    }
      , Fr = xr=>{
        xr.pointerType === "mouse" && (Ne = !0,
        tt = !0,
        ne.animating || ne.autoplay.paused || fr(!0))
    }
      , br = xr=>{
        xr.pointerType === "mouse" && (tt = !1,
        ne.autoplay.paused && Rr())
    }
    ;
    ue("init", ()=>{
        ne.params.autoplay.enabled && (ne.params.autoplay.pauseOnMouseEnter && (ne.el.addEventListener("pointerenter", Fr),
        ne.el.addEventListener("pointerleave", br)),
        getDocument$1().addEventListener("visibilitychange", Pr),
        be())
    }
    ),
    ue("destroy", ()=>{
        ne.el.removeEventListener("pointerenter", Fr),
        ne.el.removeEventListener("pointerleave", br),
        getDocument$1().removeEventListener("visibilitychange", Pr),
        ne.autoplay.running && mr()
    }
    ),
    ue("_freeModeStaticRelease", ()=>{
        ($e || Ne) && Rr()
    }
    ),
    ue("_freeModeNoMomentumRelease", ()=>{
        ne.params.autoplay.disableOnInteraction ? mr() : fr(!0, !0)
    }
    ),
    ue("beforeTransitionStart", (xr,_r,Ir)=>{
        !ne.destroyed && ne.autoplay.running && (Ir || !ne.params.autoplay.disableOnInteraction ? fr(!0, !0) : mr())
    }
    ),
    ue("sliderFirstMove", ()=>{
        !ne.destroyed && ne.autoplay.running && (ne.params.autoplay.disableOnInteraction ? mr() : (xe = !0,
        $e = !1,
        Ne = !1,
        Ee = setTimeout(()=>{
            Ne = !0,
            $e = !0,
            fr(!0)
        }
        , 200)))
    }
    ),
    ue("touchEnd", ()=>{
        if (!ne.destroyed && ne.autoplay.running && xe) {
            if (clearTimeout(Ee),
            clearTimeout(z),
            ne.params.autoplay.disableOnInteraction)
                return $e = !1,
                void (xe = !1);
            $e && ne.params.cssMode && Rr(),
            $e = !1,
            xe = !1
        }
    }
    ),
    ue("slideChange", ()=>{
        !ne.destroyed && ne.autoplay.running && (Se = !0)
    }
    ),
    Object.assign(ne.autoplay, {
        start: be,
        stop: mr,
        pause: fr,
        resume: Rr
    })
}
var dayjs_min = {
    exports: {}
};
dayjs_min.exports = function() {
    var W = 1e3
      , z = 6e4
      , Y = 36e5
      , ne = "millisecond"
      , le = "second"
      , ue = "minute"
      , de = "hour"
      , he = "day"
      , fe = "week"
      , ge = "month"
      , xe = "quarter"
      , $e = "year"
      , Ee = "date"
      , Se = "Invalid Date"
      , Ne = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/
      , tt = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g
      , rr = {
        name: "en",
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        ordinal: function(br) {
            var xr = ["th", "st", "nd", "rd"]
              , _r = br % 100;
            return "[" + br + (xr[(_r - 20) % 10] || xr[_r] || xr[0]) + "]"
        }
    }
      , tr = function(br, xr, _r) {
        var Ir = String(br);
        return !Ir || Ir.length >= xr ? br : "" + Array(xr + 1 - Ir.length).join(_r) + br
    }
      , we = {
        s: tr,
        z: function(br) {
            var xr = -br.utcOffset()
              , _r = Math.abs(xr)
              , Ir = Math.floor(_r / 60)
              , Nr = _r % 60;
            return (xr <= 0 ? "+" : "-") + tr(Ir, 2, "0") + ":" + tr(Nr, 2, "0")
        },
        m: function br(xr, _r) {
            if (xr.date() < _r.date())
                return -br(_r, xr);
            var Ir = 12 * (_r.year() - xr.year()) + (_r.month() - xr.month())
              , Nr = xr.clone().add(Ir, ge)
              , gn = _r - Nr < 0
              , Zr = xr.clone().add(Ir + (gn ? -1 : 1), ge);
            return +(-(Ir + (_r - Nr) / (gn ? Nr - Zr : Zr - Nr)) || 0)
        },
        a: function(br) {
            return br < 0 ? Math.ceil(br) || 0 : Math.floor(br)
        },
        p: function(br) {
            return {
                M: ge,
                y: $e,
                w: fe,
                d: he,
                D: Ee,
                h: de,
                m: ue,
                s: le,
                ms: ne,
                Q: xe
            }[br] || String(br || "").toLowerCase().replace(/s$/, "")
        },
        u: function(br) {
            return br === void 0
        }
    }
      , Ut = "en"
      , lr = {};
    lr[Ut] = rr;
    var cr = "$isDayjsObject"
      , be = function(br) {
        return br instanceof Pr || !(!br || !br[cr])
    }
      , mr = function br(xr, _r, Ir) {
        var Nr;
        if (!xr)
            return Ut;
        if (typeof xr == "string") {
            var gn = xr.toLowerCase();
            lr[gn] && (Nr = gn),
            _r && (lr[gn] = _r,
            Nr = gn);
            var Zr = xr.split("-");
            if (!Nr && Zr.length > 1)
                return br(Zr[0])
        } else {
            var Tn = xr.name;
            lr[Tn] = xr,
            Nr = Tn
        }
        return !Ir && Nr && (Ut = Nr),
        Nr || !Ir && Ut
    }
      , fr = function(br, xr) {
        if (be(br))
            return br.clone();
        var _r = typeof xr == "object" ? xr : {};
        return _r.date = br,
        _r.args = arguments,
        new Pr(_r)
    }
      , Rr = we;
    Rr.l = mr,
    Rr.i = be,
    Rr.w = function(br, xr) {
        return fr(br, {
            locale: xr.$L,
            utc: xr.$u,
            x: xr.$x,
            $offset: xr.$offset
        })
    }
    ;
    var Pr = function() {
        function br(_r) {
            this.$L = mr(_r.locale, null, !0),
            this.parse(_r),
            this.$x = this.$x || _r.x || {},
            this[cr] = !0
        }
        var xr = br.prototype;
        return xr.parse = function(_r) {
            this.$d = function(Ir) {
                var Nr = Ir.date
                  , gn = Ir.utc;
                if (Nr === null)
                    return new Date(NaN);
                if (Rr.u(Nr))
                    return new Date;
                if (Nr instanceof Date)
                    return new Date(Nr);
                if (typeof Nr == "string" && !/Z$/i.test(Nr)) {
                    var Zr = Nr.match(Ne);
                    if (Zr) {
                        var Tn = Zr[2] - 1 || 0
                          , Zn = (Zr[7] || "0").substring(0, 3);
                        return gn ? new Date(Date.UTC(Zr[1], Tn, Zr[3] || 1, Zr[4] || 0, Zr[5] || 0, Zr[6] || 0, Zn)) : new Date(Zr[1],Tn,Zr[3] || 1,Zr[4] || 0,Zr[5] || 0,Zr[6] || 0,Zn)
                    }
                }
                return new Date(Nr)
            }(_r),
            this.init()
        }
        ,
        xr.init = function() {
            var _r = this.$d;
            this.$y = _r.getFullYear(),
            this.$M = _r.getMonth(),
            this.$D = _r.getDate(),
            this.$W = _r.getDay(),
            this.$H = _r.getHours(),
            this.$m = _r.getMinutes(),
            this.$s = _r.getSeconds(),
            this.$ms = _r.getMilliseconds()
        }
        ,
        xr.$utils = function() {
            return Rr
        }
        ,
        xr.isValid = function() {
            return this.$d.toString() !== Se
        }
        ,
        xr.isSame = function(_r, Ir) {
            var Nr = fr(_r);
            return this.startOf(Ir) <= Nr && Nr <= this.endOf(Ir)
        }
        ,
        xr.isAfter = function(_r, Ir) {
            return fr(_r) < this.startOf(Ir)
        }
        ,
        xr.isBefore = function(_r, Ir) {
            return this.endOf(Ir) < fr(_r)
        }
        ,
        xr.$g = function(_r, Ir, Nr) {
            return Rr.u(_r) ? this[Ir] : this.set(Nr, _r)
        }
        ,
        xr.unix = function() {
            return Math.floor(this.valueOf() / 1e3)
        }
        ,
        xr.valueOf = function() {
            return this.$d.getTime()
        }
        ,
        xr.startOf = function(_r, Ir) {
            var Nr = this
              , gn = !!Rr.u(Ir) || Ir
              , Zr = Rr.p(_r)
              , Tn = function(Ci, Yn) {
                var pi = Rr.w(Nr.$u ? Date.UTC(Nr.$y, Yn, Ci) : new Date(Nr.$y,Yn,Ci), Nr);
                return gn ? pi : pi.endOf(he)
            }
              , Zn = function(Ci, Yn) {
                return Rr.w(Nr.toDate()[Ci].apply(Nr.toDate("s"), (gn ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Yn)), Nr)
            }
              , Cn = this.$W
              , Gn = this.$M
              , ni = this.$D
              , xi = "set" + (this.$u ? "UTC" : "");
            switch (Zr) {
            case $e:
                return gn ? Tn(1, 0) : Tn(31, 11);
            case ge:
                return gn ? Tn(1, Gn) : Tn(0, Gn + 1);
            case fe:
                var oi = this.$locale().weekStart || 0
                  , $i = (Cn < oi ? Cn + 7 : Cn) - oi;
                return Tn(gn ? ni - $i : ni + (6 - $i), Gn);
            case he:
            case Ee:
                return Zn(xi + "Hours", 0);
            case de:
                return Zn(xi + "Minutes", 1);
            case ue:
                return Zn(xi + "Seconds", 2);
            case le:
                return Zn(xi + "Milliseconds", 3);
            default:
                return this.clone()
            }
        }
        ,
        xr.endOf = function(_r) {
            return this.startOf(_r, !1)
        }
        ,
        xr.$set = function(_r, Ir) {
            var Nr, gn = Rr.p(_r), Zr = "set" + (this.$u ? "UTC" : ""), Tn = (Nr = {},
            Nr[he] = Zr + "Date",
            Nr[Ee] = Zr + "Date",
            Nr[ge] = Zr + "Month",
            Nr[$e] = Zr + "FullYear",
            Nr[de] = Zr + "Hours",
            Nr[ue] = Zr + "Minutes",
            Nr[le] = Zr + "Seconds",
            Nr[ne] = Zr + "Milliseconds",
            Nr)[gn], Zn = gn === he ? this.$D + (Ir - this.$W) : Ir;
            if (gn === ge || gn === $e) {
                var Cn = this.clone().set(Ee, 1);
                Cn.$d[Tn](Zn),
                Cn.init(),
                this.$d = Cn.set(Ee, Math.min(this.$D, Cn.daysInMonth())).$d
            } else
                Tn && this.$d[Tn](Zn);
            return this.init(),
            this
        }
        ,
        xr.set = function(_r, Ir) {
            return this.clone().$set(_r, Ir)
        }
        ,
        xr.get = function(_r) {
            return this[Rr.p(_r)]()
        }
        ,
        xr.add = function(_r, Ir) {
            var Nr, gn = this;
            _r = Number(_r);
            var Zr = Rr.p(Ir)
              , Tn = function(Gn) {
                var ni = fr(gn);
                return Rr.w(ni.date(ni.date() + Math.round(Gn * _r)), gn)
            };
            if (Zr === ge)
                return this.set(ge, this.$M + _r);
            if (Zr === $e)
                return this.set($e, this.$y + _r);
            if (Zr === he)
                return Tn(1);
            if (Zr === fe)
                return Tn(7);
            var Zn = (Nr = {},
            Nr[ue] = z,
            Nr[de] = Y,
            Nr[le] = W,
            Nr)[Zr] || 1
              , Cn = this.$d.getTime() + _r * Zn;
            return Rr.w(Cn, this)
        }
        ,
        xr.subtract = function(_r, Ir) {
            return this.add(-1 * _r, Ir)
        }
        ,
        xr.format = function(_r) {
            var Ir = this
              , Nr = this.$locale();
            if (!this.isValid())
                return Nr.invalidDate || Se;
            var gn = _r || "YYYY-MM-DDTHH:mm:ssZ"
              , Zr = Rr.z(this)
              , Tn = this.$H
              , Zn = this.$m
              , Cn = this.$M
              , Gn = Nr.weekdays
              , ni = Nr.months
              , xi = Nr.meridiem
              , oi = function(Yn, pi, yi, dr) {
                return Yn && (Yn[pi] || Yn(Ir, gn)) || yi[pi].slice(0, dr)
            }
              , $i = function(Yn) {
                return Rr.s(Tn % 12 || 12, Yn, "0")
            }
              , Ci = xi || function(Yn, pi, yi) {
                var dr = Yn < 12 ? "AM" : "PM";
                return yi ? dr.toLowerCase() : dr
            }
            ;
            return gn.replace(tt, function(Yn, pi) {
                return pi || function(yi) {
                    switch (yi) {
                    case "YY":
                        return String(Ir.$y).slice(-2);
                    case "YYYY":
                        return Rr.s(Ir.$y, 4, "0");
                    case "M":
                        return Cn + 1;
                    case "MM":
                        return Rr.s(Cn + 1, 2, "0");
                    case "MMM":
                        return oi(Nr.monthsShort, Cn, ni, 3);
                    case "MMMM":
                        return oi(ni, Cn);
                    case "D":
                        return Ir.$D;
                    case "DD":
                        return Rr.s(Ir.$D, 2, "0");
                    case "d":
                        return String(Ir.$W);
                    case "dd":
                        return oi(Nr.weekdaysMin, Ir.$W, Gn, 2);
                    case "ddd":
                        return oi(Nr.weekdaysShort, Ir.$W, Gn, 3);
                    case "dddd":
                        return Gn[Ir.$W];
                    case "H":
                        return String(Tn);
                    case "HH":
                        return Rr.s(Tn, 2, "0");
                    case "h":
                        return $i(1);
                    case "hh":
                        return $i(2);
                    case "a":
                        return Ci(Tn, Zn, !0);
                    case "A":
                        return Ci(Tn, Zn, !1);
                    case "m":
                        return String(Zn);
                    case "mm":
                        return Rr.s(Zn, 2, "0");
                    case "s":
                        return String(Ir.$s);
                    case "ss":
                        return Rr.s(Ir.$s, 2, "0");
                    case "SSS":
                        return Rr.s(Ir.$ms, 3, "0");
                    case "Z":
                        return Zr
                    }
                    return null
                }(Yn) || Zr.replace(":", "")
            })
        }
        ,
        xr.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
        }
        ,
        xr.diff = function(_r, Ir, Nr) {
            var gn, Zr = this, Tn = Rr.p(Ir), Zn = fr(_r), Cn = (Zn.utcOffset() - this.utcOffset()) * z, Gn = this - Zn, ni = function() {
                return Rr.m(Zr, Zn)
            };
            switch (Tn) {
            case $e:
                gn = ni() / 12;
                break;
            case ge:
                gn = ni();
                break;
            case xe:
                gn = ni() / 3;
                break;
            case fe:
                gn = (Gn - Cn) / 6048e5;
                break;
            case he:
                gn = (Gn - Cn) / 864e5;
                break;
            case de:
                gn = Gn / Y;
                break;
            case ue:
                gn = Gn / z;
                break;
            case le:
                gn = Gn / W;
                break;
            default:
                gn = Gn
            }
            return Nr ? gn : Rr.a(gn)
        }
        ,
        xr.daysInMonth = function() {
            return this.endOf(ge).$D
        }
        ,
        xr.$locale = function() {
            return lr[this.$L]
        }
        ,
        xr.locale = function(_r, Ir) {
            if (!_r)
                return this.$L;
            var Nr = this.clone()
              , gn = mr(_r, Ir, !0);
            return gn && (Nr.$L = gn),
            Nr
        }
        ,
        xr.clone = function() {
            return Rr.w(this.$d, this)
        }
        ,
        xr.toDate = function() {
            return new Date(this.valueOf())
        }
        ,
        xr.toJSON = function() {
            return this.isValid() ? this.toISOString() : null
        }
        ,
        xr.toISOString = function() {
            return this.$d.toISOString()
        }
        ,
        xr.toString = function() {
            return this.$d.toUTCString()
        }
        ,
        br
    }()
      , Fr = Pr.prototype;
    return fr.prototype = Fr,
    [["$ms", ne], ["$s", le], ["$m", ue], ["$H", de], ["$W", he], ["$M", ge], ["$y", $e], ["$D", Ee]].forEach(function(br) {
        Fr[br[1]] = function(xr) {
            return this.$g(xr, br[0], br[1])
        }
    }),
    fr.extend = function(br, xr) {
        return br.$i || (br(xr, Pr, fr),
        br.$i = !0),
        fr
    }
    ,
    fr.locale = mr,
    fr.isDayjs = be,
    fr.unix = function(br) {
        return fr(1e3 * br)
    }
    ,
    fr.en = lr[Ut],
    fr.Ls = lr,
    fr.p = {},
    fr
}();
var dayjs_minExports = dayjs_min.exports;
const dayjs = getDefaultExportFromCjs(dayjs_minExports);
var duration$1 = {
    exports: {}
};
duration$1.exports = function() {
    var W, z, Y = 1e3, ne = 6e4, le = 36e5, ue = 864e5, de = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, he = 31536e6, fe = 2628e6, ge = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/, xe = {
        years: he,
        months: fe,
        days: ue,
        hours: le,
        minutes: ne,
        seconds: Y,
        milliseconds: 1,
        weeks: 6048e5
    }, $e = function(lr) {
        return lr instanceof we
    }, Ee = function(lr, cr, be) {
        return new we(lr,be,cr.$l)
    }, Se = function(lr) {
        return z.p(lr) + "s"
    }, Ne = function(lr) {
        return lr < 0
    }, tt = function(lr) {
        return Ne(lr) ? Math.ceil(lr) : Math.floor(lr)
    }, rr = function(lr) {
        return Math.abs(lr)
    }, tr = function(lr, cr) {
        return lr ? Ne(lr) ? {
            negative: !0,
            format: "" + rr(lr) + cr
        } : {
            negative: !1,
            format: "" + lr + cr
        } : {
            negative: !1,
            format: ""
        }
    }, we = function() {
        function lr(be, mr, fr) {
            var Rr = this;
            if (this.$d = {},
            this.$l = fr,
            be === void 0 && (this.$ms = 0,
            this.parseFromMilliseconds()),
            mr)
                return Ee(be * xe[Se(mr)], this);
            if (typeof be == "number")
                return this.$ms = be,
                this.parseFromMilliseconds(),
                this;
            if (typeof be == "object")
                return Object.keys(be).forEach(function(br) {
                    Rr.$d[Se(br)] = be[br]
                }),
                this.calMilliseconds(),
                this;
            if (typeof be == "string") {
                var Pr = be.match(ge);
                if (Pr) {
                    var Fr = Pr.slice(2).map(function(br) {
                        return br != null ? Number(br) : 0
                    });
                    return this.$d.years = Fr[0],
                    this.$d.months = Fr[1],
                    this.$d.weeks = Fr[2],
                    this.$d.days = Fr[3],
                    this.$d.hours = Fr[4],
                    this.$d.minutes = Fr[5],
                    this.$d.seconds = Fr[6],
                    this.calMilliseconds(),
                    this
                }
            }
            return this
        }
        var cr = lr.prototype;
        return cr.calMilliseconds = function() {
            var be = this;
            this.$ms = Object.keys(this.$d).reduce(function(mr, fr) {
                return mr + (be.$d[fr] || 0) * xe[fr]
            }, 0)
        }
        ,
        cr.parseFromMilliseconds = function() {
            var be = this.$ms;
            this.$d.years = tt(be / he),
            be %= he,
            this.$d.months = tt(be / fe),
            be %= fe,
            this.$d.days = tt(be / ue),
            be %= ue,
            this.$d.hours = tt(be / le),
            be %= le,
            this.$d.minutes = tt(be / ne),
            be %= ne,
            this.$d.seconds = tt(be / Y),
            be %= Y,
            this.$d.milliseconds = be
        }
        ,
        cr.toISOString = function() {
            var be = tr(this.$d.years, "Y")
              , mr = tr(this.$d.months, "M")
              , fr = +this.$d.days || 0;
            this.$d.weeks && (fr += 7 * this.$d.weeks);
            var Rr = tr(fr, "D")
              , Pr = tr(this.$d.hours, "H")
              , Fr = tr(this.$d.minutes, "M")
              , br = this.$d.seconds || 0;
            this.$d.milliseconds && (br += this.$d.milliseconds / 1e3,
            br = Math.round(1e3 * br) / 1e3);
            var xr = tr(br, "S")
              , _r = be.negative || mr.negative || Rr.negative || Pr.negative || Fr.negative || xr.negative
              , Ir = Pr.format || Fr.format || xr.format ? "T" : ""
              , Nr = (_r ? "-" : "") + "P" + be.format + mr.format + Rr.format + Ir + Pr.format + Fr.format + xr.format;
            return Nr === "P" || Nr === "-P" ? "P0D" : Nr
        }
        ,
        cr.toJSON = function() {
            return this.toISOString()
        }
        ,
        cr.format = function(be) {
            var mr = be || "YYYY-MM-DDTHH:mm:ss"
              , fr = {
                Y: this.$d.years,
                YY: z.s(this.$d.years, 2, "0"),
                YYYY: z.s(this.$d.years, 4, "0"),
                M: this.$d.months,
                MM: z.s(this.$d.months, 2, "0"),
                D: this.$d.days,
                DD: z.s(this.$d.days, 2, "0"),
                H: this.$d.hours,
                HH: z.s(this.$d.hours, 2, "0"),
                m: this.$d.minutes,
                mm: z.s(this.$d.minutes, 2, "0"),
                s: this.$d.seconds,
                ss: z.s(this.$d.seconds, 2, "0"),
                SSS: z.s(this.$d.milliseconds, 3, "0")
            };
            return mr.replace(de, function(Rr, Pr) {
                return Pr || String(fr[Rr])
            })
        }
        ,
        cr.as = function(be) {
            return this.$ms / xe[Se(be)]
        }
        ,
        cr.get = function(be) {
            var mr = this.$ms
              , fr = Se(be);
            return fr === "milliseconds" ? mr %= 1e3 : mr = fr === "weeks" ? tt(mr / xe[fr]) : this.$d[fr],
            mr || 0
        }
        ,
        cr.add = function(be, mr, fr) {
            var Rr;
            return Rr = mr ? be * xe[Se(mr)] : $e(be) ? be.$ms : Ee(be, this).$ms,
            Ee(this.$ms + Rr * (fr ? -1 : 1), this)
        }
        ,
        cr.subtract = function(be, mr) {
            return this.add(be, mr, !0)
        }
        ,
        cr.locale = function(be) {
            var mr = this.clone();
            return mr.$l = be,
            mr
        }
        ,
        cr.clone = function() {
            return Ee(this.$ms, this)
        }
        ,
        cr.humanize = function(be) {
            return W().add(this.$ms, "ms").locale(this.$l).fromNow(!be)
        }
        ,
        cr.valueOf = function() {
            return this.asMilliseconds()
        }
        ,
        cr.milliseconds = function() {
            return this.get("milliseconds")
        }
        ,
        cr.asMilliseconds = function() {
            return this.as("milliseconds")
        }
        ,
        cr.seconds = function() {
            return this.get("seconds")
        }
        ,
        cr.asSeconds = function() {
            return this.as("seconds")
        }
        ,
        cr.minutes = function() {
            return this.get("minutes")
        }
        ,
        cr.asMinutes = function() {
            return this.as("minutes")
        }
        ,
        cr.hours = function() {
            return this.get("hours")
        }
        ,
        cr.asHours = function() {
            return this.as("hours")
        }
        ,
        cr.days = function() {
            return this.get("days")
        }
        ,
        cr.asDays = function() {
            return this.as("days")
        }
        ,
        cr.weeks = function() {
            return this.get("weeks")
        }
        ,
        cr.asWeeks = function() {
            return this.as("weeks")
        }
        ,
        cr.months = function() {
            return this.get("months")
        }
        ,
        cr.asMonths = function() {
            return this.as("months")
        }
        ,
        cr.years = function() {
            return this.get("years")
        }
        ,
        cr.asYears = function() {
            return this.as("years")
        }
        ,
        lr
    }(), Ut = function(lr, cr, be) {
        return lr.add(cr.years() * be, "y").add(cr.months() * be, "M").add(cr.days() * be, "d").add(cr.hours() * be, "h").add(cr.minutes() * be, "m").add(cr.seconds() * be, "s").add(cr.milliseconds() * be, "ms")
    };
    return function(lr, cr, be) {
        W = be,
        z = be().$utils(),
        be.duration = function(Rr, Pr) {
            var Fr = be.locale();
            return Ee(Rr, {
                $l: Fr
            }, Pr)
        }
        ,
        be.isDuration = $e;
        var mr = cr.prototype.add
          , fr = cr.prototype.subtract;
        cr.prototype.add = function(Rr, Pr) {
            return $e(Rr) ? Ut(this, Rr, 1) : mr.bind(this)(Rr, Pr)
        }
        ,
        cr.prototype.subtract = function(Rr, Pr) {
            return $e(Rr) ? Ut(this, Rr, -1) : fr.bind(this)(Rr, Pr)
        }
    }
}();
var durationExports = duration$1.exports;
const duration = getDefaultExportFromCjs(durationExports);
function execTyped(W, z) {
    return W.exec(z)?.groups
}
const tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
function formatAbiParameter(W) {
    let z = W.type;
    if (tupleRegex.test(W.type) && "components"in W) {
        z = "(";
        const Y = W.components.length;
        for (let le = 0; le < Y; le++)
            z += formatAbiParameter(W.components[le]),
            le < Y - 1 && (z += ", ");
        const ne = execTyped(tupleRegex, W.type);
        return z += `)${ne?.array ?? ""}`,
        formatAbiParameter({
            ...W,
            type: z
        })
    }
    return "indexed"in W && W.indexed && (z = `${z} indexed`),
    W.name ? `${z} ${W.name}` : z
}
function formatAbiParameters(W) {
    let z = "";
    const Y = W.length;
    for (let ne = 0; ne < Y; ne++)
        z += formatAbiParameter(W[ne]),
        ne !== Y - 1 && (z += ", ");
    return z
}
function formatAbiItem$1(W) {
    return W.type === "function" ? `function ${W.name}(${formatAbiParameters(W.inputs)})${W.stateMutability && W.stateMutability !== "nonpayable" ? ` ${W.stateMutability}` : ""}${W.outputs.length ? ` returns (${formatAbiParameters(W.outputs)})` : ""}` : W.type === "event" ? `event ${W.name}(${formatAbiParameters(W.inputs)})` : W.type === "error" ? `error ${W.name}(${formatAbiParameters(W.inputs)})` : W.type === "constructor" ? `constructor(${formatAbiParameters(W.inputs)})${W.stateMutability === "payable" ? " payable" : ""}` : W.type === "fallback" ? "fallback()" : "receive() external payable"
}
function getAction(W, z, Y) {
    return ne=>W[z.name || Y]?.(ne) ?? z(W, ne)
}
function formatAbiItem(W, {includeName: z=!1}={}) {
    if (W.type !== "function" && W.type !== "event" && W.type !== "error")
        throw new InvalidDefinitionTypeError(W.type);
    return `${W.name}(${formatAbiParams(W.inputs, {
        includeName: z
    })})`
}
function formatAbiParams(W, {includeName: z=!1}={}) {
    return W ? W.map(Y=>formatAbiParam(Y, {
        includeName: z
    })).join(z ? ", " : ",") : ""
}
function formatAbiParam(W, {includeName: z}) {
    return W.type.startsWith("tuple") ? `(${formatAbiParams(W.components, {
        includeName: z
    })})${W.type.slice(5)}` : W.type + (z && W.name ? ` ${W.name}` : "")
}
function isHex(W, {strict: z=!0}={}) {
    return !!W && typeof W == "string" && (z ? /^0x[0-9a-fA-F]*$/.test(W) : W.startsWith("0x"))
}
function size$1(W) {
    return isHex(W, {
        strict: !1
    }) ? Math.ceil((W.length - 2) / 2) : W.length
}
const version$1 = "1.19.10"
  , getContractAddress = W=>W
  , getUrl = W=>W
  , getVersion = ()=>`viem@${version$1}`;
class BaseError extends Error {
    constructor(z, Y={}) {
        super(),
        Object.defineProperty(this, "details", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "docsPath", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "metaMessages", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "shortMessage", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ViemError"
        }),
        Object.defineProperty(this, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: getVersion()
        });
        const ne = Y.cause instanceof BaseError ? Y.cause.details : Y.cause?.message ? Y.cause.message : Y.details
          , le = Y.cause instanceof BaseError && Y.cause.docsPath || Y.docsPath;
        this.message = [z || "An error occurred.", "", ...Y.metaMessages ? [...Y.metaMessages, ""] : [], ...le ? [`Docs: https://viem.sh${le}.html${Y.docsSlug ? `#${Y.docsSlug}` : ""}`] : [], ...ne ? [`Details: ${ne}`] : [], `Version: ${this.version}`].join(`
`),
        Y.cause && (this.cause = Y.cause),
        this.details = ne,
        this.docsPath = le,
        this.metaMessages = Y.metaMessages,
        this.shortMessage = z
    }
    walk(z) {
        return walk(this, z)
    }
}
function walk(W, z) {
    return z?.(W) ? W : W && typeof W == "object" && "cause"in W ? walk(W.cause, z) : z ? null : W
}
class AbiConstructorNotFoundError extends BaseError {
    constructor({docsPath: z}) {
        super(["A constructor was not found on the ABI.", "Make sure you are using the correct ABI and that the constructor exists on it."].join(`
`), {
            docsPath: z
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiConstructorNotFoundError"
        })
    }
}
class AbiConstructorParamsNotFoundError extends BaseError {
    constructor({docsPath: z}) {
        super(["Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.", "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."].join(`
`), {
            docsPath: z
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiConstructorParamsNotFoundError"
        })
    }
}
class AbiDecodingDataSizeTooSmallError extends BaseError {
    constructor({data: z, params: Y, size: ne}) {
        super([`Data size of ${ne} bytes is too small for given parameters.`].join(`
`), {
            metaMessages: [`Params: (${formatAbiParams(Y, {
                includeName: !0
            })})`, `Data:   ${z} (${ne} bytes)`]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiDecodingDataSizeTooSmallError"
        }),
        Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "params", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "size", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.data = z,
        this.params = Y,
        this.size = ne
    }
}
class AbiDecodingZeroDataError extends BaseError {
    constructor() {
        super('Cannot decode zero data ("0x") with ABI parameters.'),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiDecodingZeroDataError"
        })
    }
}
class AbiEncodingArrayLengthMismatchError extends BaseError {
    constructor({expectedLength: z, givenLength: Y, type: ne}) {
        super([`ABI encoding array length mismatch for type ${ne}.`, `Expected length: ${z}`, `Given length: ${Y}`].join(`
`)),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiEncodingArrayLengthMismatchError"
        })
    }
}
class AbiEncodingBytesSizeMismatchError extends BaseError {
    constructor({expectedSize: z, value: Y}) {
        super(`Size of bytes "${Y}" (bytes${size$1(Y)}) does not match expected size (bytes${z}).`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiEncodingBytesSizeMismatchError"
        })
    }
}
class AbiEncodingLengthMismatchError extends BaseError {
    constructor({expectedLength: z, givenLength: Y}) {
        super(["ABI encoding params/values length mismatch.", `Expected length (params): ${z}`, `Given length (values): ${Y}`].join(`
`)),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiEncodingLengthMismatchError"
        })
    }
}
class AbiErrorSignatureNotFoundError extends BaseError {
    constructor(z, {docsPath: Y}) {
        super([`Encoded error signature "${z}" not found on ABI.`, "Make sure you are using the correct ABI and that the error exists on it.", `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${z}.`].join(`
`), {
            docsPath: Y
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiErrorSignatureNotFoundError"
        }),
        Object.defineProperty(this, "signature", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.signature = z
    }
}
class AbiEventSignatureEmptyTopicsError extends BaseError {
    constructor({docsPath: z}) {
        super("Cannot extract event signature from empty topics.", {
            docsPath: z
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiEventSignatureEmptyTopicsError"
        })
    }
}
class AbiEventSignatureNotFoundError extends BaseError {
    constructor(z, {docsPath: Y}) {
        super([`Encoded event signature "${z}" not found on ABI.`, "Make sure you are using the correct ABI and that the event exists on it.", `You can look up the signature here: https://openchain.xyz/signatures?query=${z}.`].join(`
`), {
            docsPath: Y
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiEventSignatureNotFoundError"
        })
    }
}
class AbiEventNotFoundError extends BaseError {
    constructor(z, {docsPath: Y}={}) {
        super([`Event ${z ? `"${z}" ` : ""}not found on ABI.`, "Make sure you are using the correct ABI and that the event exists on it."].join(`
`), {
            docsPath: Y
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiEventNotFoundError"
        })
    }
}
class AbiFunctionNotFoundError extends BaseError {
    constructor(z, {docsPath: Y}={}) {
        super([`Function ${z ? `"${z}" ` : ""}not found on ABI.`, "Make sure you are using the correct ABI and that the function exists on it."].join(`
`), {
            docsPath: Y
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiFunctionNotFoundError"
        })
    }
}
class AbiFunctionOutputsNotFoundError extends BaseError {
    constructor(z, {docsPath: Y}) {
        super([`Function "${z}" does not contain any \`outputs\` on ABI.`, "Cannot decode function result without knowing what the parameter types are.", "Make sure you are using the correct ABI and that the function exists on it."].join(`
`), {
            docsPath: Y
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AbiFunctionOutputsNotFoundError"
        })
    }
}
class BytesSizeMismatchError extends BaseError {
    constructor({expectedSize: z, givenSize: Y}) {
        super(`Expected bytes${z}, got bytes${Y}.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "BytesSizeMismatchError"
        })
    }
}
class DecodeLogDataMismatch extends BaseError {
    constructor({abiItem: z, data: Y, params: ne, size: le}) {
        super([`Data size of ${le} bytes is too small for non-indexed event parameters.`].join(`
`), {
            metaMessages: [`Params: (${formatAbiParams(ne, {
                includeName: !0
            })})`, `Data:   ${Y} (${le} bytes)`]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "DecodeLogDataMismatch"
        }),
        Object.defineProperty(this, "abiItem", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "params", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "size", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.abiItem = z,
        this.data = Y,
        this.params = ne,
        this.size = le
    }
}
class DecodeLogTopicsMismatch extends BaseError {
    constructor({abiItem: z, param: Y}) {
        super([`Expected a topic for indexed event parameter${Y.name ? ` "${Y.name}"` : ""} on event "${formatAbiItem(z, {
            includeName: !0
        })}".`].join(`
`)),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "DecodeLogTopicsMismatch"
        }),
        Object.defineProperty(this, "abiItem", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.abiItem = z
    }
}
class InvalidAbiEncodingTypeError extends BaseError {
    constructor(z, {docsPath: Y}) {
        super([`Type "${z}" is not a valid encoding type.`, "Please provide a valid ABI type."].join(`
`), {
            docsPath: Y
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidAbiEncodingType"
        })
    }
}
class InvalidAbiDecodingTypeError extends BaseError {
    constructor(z, {docsPath: Y}) {
        super([`Type "${z}" is not a valid decoding type.`, "Please provide a valid ABI type."].join(`
`), {
            docsPath: Y
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidAbiDecodingType"
        })
    }
}
class InvalidArrayError extends BaseError {
    constructor(z) {
        super([`Value "${z}" is not a valid array.`].join(`
`)),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidArrayError"
        })
    }
}
class InvalidDefinitionTypeError extends BaseError {
    constructor(z) {
        super([`"${z}" is not a valid definition type.`, 'Valid types: "function", "event", "error"'].join(`
`)),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidDefinitionTypeError"
        })
    }
}
class FilterTypeNotSupportedError extends BaseError {
    constructor(z) {
        super(`Filter type "${z}" is not supported.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "FilterTypeNotSupportedError"
        })
    }
}
class SliceOffsetOutOfBoundsError extends BaseError {
    constructor({offset: z, position: Y, size: ne}) {
        super(`Slice ${Y === "start" ? "starting" : "ending"} at offset "${z}" is out-of-bounds (size: ${ne}).`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "SliceOffsetOutOfBoundsError"
        })
    }
}
class SizeExceedsPaddingSizeError extends BaseError {
    constructor({size: z, targetSize: Y, type: ne}) {
        super(`${ne.charAt(0).toUpperCase()}${ne.slice(1).toLowerCase()} size (${z}) exceeds padding size (${Y}).`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "SizeExceedsPaddingSizeError"
        })
    }
}
function pad(W, {dir: z, size: Y=32}={}) {
    return typeof W == "string" ? padHex(W, {
        dir: z,
        size: Y
    }) : padBytes(W, {
        dir: z,
        size: Y
    })
}
function padHex(W, {dir: z, size: Y=32}={}) {
    if (Y === null)
        return W;
    const ne = W.replace("0x", "");
    if (ne.length > 2 * Y)
        throw new SizeExceedsPaddingSizeError({
            size: Math.ceil(ne.length / 2),
            targetSize: Y,
            type: "hex"
        });
    return `0x${ne[z === "right" ? "padEnd" : "padStart"](2 * Y, "0")}`
}
function padBytes(W, {dir: z, size: Y=32}={}) {
    if (Y === null)
        return W;
    if (W.length > Y)
        throw new SizeExceedsPaddingSizeError({
            size: W.length,
            targetSize: Y,
            type: "bytes"
        });
    const ne = new Uint8Array(Y);
    for (let le = 0; le < Y; le++) {
        const ue = z === "right";
        ne[ue ? le : Y - le - 1] = W[ue ? le : W.length - le - 1]
    }
    return ne
}
class IntegerOutOfRangeError extends BaseError {
    constructor({max: z, min: Y, signed: ne, size: le, value: ue}) {
        super(`Number "${ue}" is not in safe ${le ? `${8 * le}-bit ${ne ? "signed" : "unsigned"} ` : ""}integer range ${z ? `(${Y} to ${z})` : `(above ${Y})`}`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "IntegerOutOfRangeError"
        })
    }
}
class InvalidHexBooleanError extends BaseError {
    constructor(z) {
        super(`Hex value "${z}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidHexBooleanError"
        })
    }
}
class SizeOverflowError extends BaseError {
    constructor({givenSize: z, maxSize: Y}) {
        super(`Size cannot exceed ${Y} bytes. Given size: ${z} bytes.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "SizeOverflowError"
        })
    }
}
function trim(W, {dir: z="left"}={}) {
    let Y = typeof W == "string" ? W.replace("0x", "") : W
      , ne = 0;
    for (let le = 0; le < Y.length - 1 && Y[z === "left" ? le : Y.length - le - 1].toString() === "0"; le++)
        ne++;
    return Y = z === "left" ? Y.slice(ne) : Y.slice(0, Y.length - ne),
    typeof W == "string" ? (Y.length === 1 && z === "right" && (Y = `${Y}0`),
    `0x${Y.length % 2 == 1 ? `0${Y}` : Y}`) : Y
}
function assertSize(W, {size: z}) {
    if (size$1(W) > z)
        throw new SizeOverflowError({
            givenSize: size$1(W),
            maxSize: z
        })
}
function hexToBigInt(W, z={}) {
    const {signed: Y} = z;
    z.size && assertSize(W, {
        size: z.size
    });
    const ne = BigInt(W);
    if (!Y)
        return ne;
    const le = (W.length - 2) / 2;
    return ne <= (1n << 8n * BigInt(le) - 1n) - 1n ? ne : ne - BigInt(`0x${"f".padStart(2 * le, "f")}`) - 1n
}
function hexToBool(W, z={}) {
    let Y = W;
    if (z.size && (assertSize(Y, {
        size: z.size
    }),
    Y = trim(Y)),
    trim(Y) === "0x00")
        return !1;
    if (trim(Y) === "0x01")
        return !0;
    throw new InvalidHexBooleanError(Y)
}
function hexToNumber(W, z={}) {
    return Number(hexToBigInt(W, z))
}
function hexToString(W, z={}) {
    let Y = hexToBytes(W);
    return z.size && (assertSize(Y, {
        size: z.size
    }),
    Y = trim(Y, {
        dir: "right"
    })),
    new TextDecoder().decode(Y)
}
const hexes = Array.from({
    length: 256
}, (W,z)=>z.toString(16).padStart(2, "0"));
function toHex(W, z={}) {
    return typeof W == "number" || typeof W == "bigint" ? numberToHex(W, z) : typeof W == "string" ? stringToHex(W, z) : typeof W == "boolean" ? boolToHex(W, z) : bytesToHex(W, z)
}
function boolToHex(W, z={}) {
    const Y = `0x${Number(W)}`;
    return typeof z.size == "number" ? (assertSize(Y, {
        size: z.size
    }),
    pad(Y, {
        size: z.size
    })) : Y
}
function bytesToHex(W, z={}) {
    let Y = "";
    for (let le = 0; le < W.length; le++)
        Y += hexes[W[le]];
    const ne = `0x${Y}`;
    return typeof z.size == "number" ? (assertSize(ne, {
        size: z.size
    }),
    pad(ne, {
        dir: "right",
        size: z.size
    })) : ne
}
function numberToHex(W, z={}) {
    const {signed: Y, size: ne} = z
      , le = BigInt(W);
    let ue;
    ne ? ue = Y ? (1n << 8n * BigInt(ne) - 1n) - 1n : 2n ** (8n * BigInt(ne)) - 1n : typeof W == "number" && (ue = BigInt(Number.MAX_SAFE_INTEGER));
    const de = typeof ue == "bigint" && Y ? -ue - 1n : 0;
    if (ue && le > ue || le < de) {
        const fe = typeof W == "bigint" ? "n" : "";
        throw new IntegerOutOfRangeError({
            max: ue ? `${ue}${fe}` : void 0,
            min: `${de}${fe}`,
            signed: Y,
            size: ne,
            value: `${W}${fe}`
        })
    }
    const he = `0x${(Y && le < 0 ? (1n << BigInt(8 * ne)) + BigInt(le) : le).toString(16)}`;
    return ne ? pad(he, {
        size: ne
    }) : he
}
const encoder$1 = new TextEncoder;
function stringToHex(W, z={}) {
    return bytesToHex(encoder$1.encode(W), z)
}
const encoder = new TextEncoder;
function toBytes$1(W, z={}) {
    return typeof W == "number" || typeof W == "bigint" ? numberToBytes(W, z) : typeof W == "boolean" ? boolToBytes(W, z) : isHex(W) ? hexToBytes(W, z) : stringToBytes(W, z)
}
function boolToBytes(W, z={}) {
    const Y = new Uint8Array(1);
    return Y[0] = Number(W),
    typeof z.size == "number" ? (assertSize(Y, {
        size: z.size
    }),
    pad(Y, {
        size: z.size
    })) : Y
}
const charCodeMap = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function charCodeToBase16(W) {
    return W >= charCodeMap.zero && W <= charCodeMap.nine ? W - charCodeMap.zero : W >= charCodeMap.A && W <= charCodeMap.F ? W - (charCodeMap.A - 10) : W >= charCodeMap.a && W <= charCodeMap.f ? W - (charCodeMap.a - 10) : void 0
}
function hexToBytes(W, z={}) {
    let Y = W;
    z.size && (assertSize(Y, {
        size: z.size
    }),
    Y = pad(Y, {
        dir: "right",
        size: z.size
    }));
    let ne = Y.slice(2);
    ne.length % 2 && (ne = `0${ne}`);
    const le = ne.length / 2
      , ue = new Uint8Array(le);
    for (let de = 0, he = 0; de < le; de++) {
        const fe = charCodeToBase16(ne.charCodeAt(he++))
          , ge = charCodeToBase16(ne.charCodeAt(he++));
        if (fe === void 0 || ge === void 0)
            throw new BaseError(`Invalid byte sequence ("${ne[he - 2]}${ne[he - 1]}" in "${ne}").`);
        ue[de] = 16 * fe + ge
    }
    return ue
}
function numberToBytes(W, z) {
    return hexToBytes(numberToHex(W, z))
}
function stringToBytes(W, z={}) {
    const Y = encoder.encode(W);
    return typeof z.size == "number" ? (assertSize(Y, {
        size: z.size
    }),
    pad(Y, {
        dir: "right",
        size: z.size
    })) : Y
}
function normalizeSignature(W) {
    let z = !0
      , Y = ""
      , ne = 0
      , le = ""
      , ue = !1;
    for (let de = 0; de < W.length; de++) {
        const he = W[de];
        if (["(", ")", ","].includes(he) && (z = !0),
        he === "(" && ne++,
        he === ")" && ne--,
        z) {
            if (ne !== 0)
                he !== " " ? (le += he,
                Y += he) : W[de - 1] !== "," && Y !== "," && Y !== ",(" && (Y = "",
                z = !1);
            else if (he === " " && ["event", "function", ""].includes(le))
                le = "";
            else if (le += he,
            he === ")") {
                ue = !0;
                break
            }
        }
    }
    if (!ue)
        throw new BaseError("Unable to normalize signature.");
    return le
}
const getFunctionSignature = W=>normalizeSignature(typeof W == "string" ? W : formatAbiItem$1(W))
  , getEventSignature = W=>getFunctionSignature(W);
function number(W) {
    if (!Number.isSafeInteger(W) || W < 0)
        throw new Error(`Wrong positive integer: ${W}`)
}
function bytes(W, ...z) {
    if (!(W instanceof Uint8Array))
        throw new Error("Expected Uint8Array");
    if (z.length > 0 && !z.includes(W.length))
        throw new Error(`Expected Uint8Array of length ${z}, not of length=${W.length}`)
}
function exists(W, z=!0) {
    if (W.destroyed)
        throw new Error("Hash instance has been destroyed");
    if (z && W.finished)
        throw new Error("Hash#digest() has already been called")
}
function output(W, z) {
    bytes(W);
    const Y = z.outputLen;
    if (W.length < Y)
        throw new Error(`digestInto() expects output buffer of length at least ${Y}`)
}
const U32_MASK64 = BigInt(2 ** 32 - 1)
  , _32n = BigInt(32);
function fromBig(W, z=!1) {
    return z ? {
        h: Number(W & U32_MASK64),
        l: Number(W >> _32n & U32_MASK64)
    } : {
        h: 0 | Number(W >> _32n & U32_MASK64),
        l: 0 | Number(W & U32_MASK64)
    }
}
function split(W, z=!1) {
    let Y = new Uint32Array(W.length)
      , ne = new Uint32Array(W.length);
    for (let le = 0; le < W.length; le++) {
        const {h: ue, l: de} = fromBig(W[le], z);
        [Y[le],ne[le]] = [ue, de]
    }
    return [Y, ne]
}
const rotlSH = (W,z,Y)=>W << Y | z >>> 32 - Y
  , rotlSL = (W,z,Y)=>z << Y | W >>> 32 - Y
  , rotlBH = (W,z,Y)=>z << Y - 32 | W >>> 64 - Y
  , rotlBL = (W,z,Y)=>W << Y - 32 | z >>> 64 - Y
  , u8a = W=>W instanceof Uint8Array
  , u32 = W=>new Uint32Array(W.buffer,W.byteOffset,Math.floor(W.byteLength / 4))
  , isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
    throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes(W) {
    if (typeof W != "string")
        throw new Error("utf8ToBytes expected string, got " + typeof W);
    return new Uint8Array(new TextEncoder().encode(W))
}
function toBytes(W) {
    if (typeof W == "string" && (W = utf8ToBytes(W)),
    !u8a(W))
        throw new Error("expected Uint8Array, got " + typeof W);
    return W
}
class Hash {
    clone() {
        return this._cloneInto()
    }
}
function wrapConstructor(W) {
    const z = ne=>W().update(toBytes(ne)).digest()
      , Y = W();
    return z.outputLen = Y.outputLen,
    z.blockLen = Y.blockLen,
    z.create = ()=>W(),
    z
}
const [SHA3_PI,SHA3_ROTL,_SHA3_IOTA] = [[], [], []]
  , _0n = BigInt(0)
  , _1n = BigInt(1)
  , _2n = BigInt(2)
  , _7n = BigInt(7)
  , _256n = BigInt(256)
  , _0x71n = BigInt(113);
for (let W = 0, z = _1n, Y = 1, ne = 0; W < 24; W++) {
    [Y,ne] = [ne, (2 * Y + 3 * ne) % 5],
    SHA3_PI.push(2 * (5 * ne + Y)),
    SHA3_ROTL.push((W + 1) * (W + 2) / 2 % 64);
    let le = _0n;
    for (let ue = 0; ue < 7; ue++)
        z = (z << _1n ^ (z >> _7n) * _0x71n) % _256n,
        z & _2n && (le ^= _1n << (_1n << BigInt(ue)) - _1n);
    _SHA3_IOTA.push(le)
}
const [SHA3_IOTA_H,SHA3_IOTA_L] = split(_SHA3_IOTA, !0)
  , rotlH = (W,z,Y)=>Y > 32 ? rotlBH(W, z, Y) : rotlSH(W, z, Y)
  , rotlL = (W,z,Y)=>Y > 32 ? rotlBL(W, z, Y) : rotlSL(W, z, Y);
function keccakP(W, z=24) {
    const Y = new Uint32Array(10);
    for (let ne = 24 - z; ne < 24; ne++) {
        for (let de = 0; de < 10; de++)
            Y[de] = W[de] ^ W[de + 10] ^ W[de + 20] ^ W[de + 30] ^ W[de + 40];
        for (let de = 0; de < 10; de += 2) {
            const he = (de + 8) % 10
              , fe = (de + 2) % 10
              , ge = Y[fe]
              , xe = Y[fe + 1]
              , $e = rotlH(ge, xe, 1) ^ Y[he]
              , Ee = rotlL(ge, xe, 1) ^ Y[he + 1];
            for (let Se = 0; Se < 50; Se += 10)
                W[de + Se] ^= $e,
                W[de + Se + 1] ^= Ee
        }
        let le = W[2]
          , ue = W[3];
        for (let de = 0; de < 24; de++) {
            const he = SHA3_ROTL[de]
              , fe = rotlH(le, ue, he)
              , ge = rotlL(le, ue, he)
              , xe = SHA3_PI[de];
            le = W[xe],
            ue = W[xe + 1],
            W[xe] = fe,
            W[xe + 1] = ge
        }
        for (let de = 0; de < 50; de += 10) {
            for (let he = 0; he < 10; he++)
                Y[he] = W[de + he];
            for (let he = 0; he < 10; he++)
                W[de + he] ^= ~Y[(he + 2) % 10] & Y[(he + 4) % 10]
        }
        W[0] ^= SHA3_IOTA_H[ne],
        W[1] ^= SHA3_IOTA_L[ne]
    }
    Y.fill(0)
}
class Keccak extends Hash {
    constructor(z, Y, ne, le=!1, ue=24) {
        if (super(),
        this.blockLen = z,
        this.suffix = Y,
        this.outputLen = ne,
        this.enableXOF = le,
        this.rounds = ue,
        this.pos = 0,
        this.posOut = 0,
        this.finished = !1,
        this.destroyed = !1,
        number(ne),
        0 >= this.blockLen || this.blockLen >= 200)
            throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200),
        this.state32 = u32(this.state)
    }
    keccak() {
        keccakP(this.state32, this.rounds),
        this.posOut = 0,
        this.pos = 0
    }
    update(z) {
        exists(this);
        const {blockLen: Y, state: ne} = this
          , le = (z = toBytes(z)).length;
        for (let ue = 0; ue < le; ) {
            const de = Math.min(Y - this.pos, le - ue);
            for (let he = 0; he < de; he++)
                ne[this.pos++] ^= z[ue++];
            this.pos === Y && this.keccak()
        }
        return this
    }
    finish() {
        if (this.finished)
            return;
        this.finished = !0;
        const {state: z, suffix: Y, pos: ne, blockLen: le} = this;
        z[ne] ^= Y,
        128 & Y && ne === le - 1 && this.keccak(),
        z[le - 1] ^= 128,
        this.keccak()
    }
    writeInto(z) {
        exists(this, !1),
        bytes(z),
        this.finish();
        const Y = this.state
          , {blockLen: ne} = this;
        for (let le = 0, ue = z.length; le < ue; ) {
            this.posOut >= ne && this.keccak();
            const de = Math.min(ne - this.posOut, ue - le);
            z.set(Y.subarray(this.posOut, this.posOut + de), le),
            this.posOut += de,
            le += de
        }
        return z
    }
    xofInto(z) {
        if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
        return this.writeInto(z)
    }
    xof(z) {
        return number(z),
        this.xofInto(new Uint8Array(z))
    }
    digestInto(z) {
        if (output(z, this),
        this.finished)
            throw new Error("digest() was already called");
        return this.writeInto(z),
        this.destroy(),
        z
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
    }
    destroy() {
        this.destroyed = !0,
        this.state.fill(0)
    }
    _cloneInto(z) {
        const {blockLen: Y, suffix: ne, outputLen: le, rounds: ue, enableXOF: de} = this;
        return z || (z = new Keccak(Y,ne,le,de,ue)),
        z.state32.set(this.state32),
        z.pos = this.pos,
        z.posOut = this.posOut,
        z.finished = this.finished,
        z.rounds = ue,
        z.suffix = ne,
        z.outputLen = le,
        z.enableXOF = de,
        z.destroyed = this.destroyed,
        z
    }
}
const gen = (W,z,Y)=>wrapConstructor(()=>new Keccak(z,W,Y))
  , keccak_256 = gen(1, 136, 32);
function keccak256(W, z) {
    const Y = z || "hex"
      , ne = keccak_256(isHex(W, {
        strict: !1
    }) ? toBytes$1(W) : W);
    return Y === "bytes" ? ne : toHex(ne)
}
const hash$2 = W=>keccak256(toBytes$1(W))
  , getEventSelector = W=>hash$2(getEventSignature(W));
class InvalidAddressError extends BaseError {
    constructor({address: z}) {
        super(`Address "${z}" is invalid.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidAddressError"
        })
    }
}
const addressRegex = /^0x[a-fA-F0-9]{40}$/;
function isAddress(W) {
    return addressRegex.test(W)
}
function concat$1(W) {
    return typeof W[0] == "string" ? concatHex(W) : concatBytes(W)
}
function concatBytes(W) {
    let z = 0;
    for (const le of W)
        z += le.length;
    const Y = new Uint8Array(z);
    let ne = 0;
    for (const le of W)
        Y.set(le, ne),
        ne += le.length;
    return Y
}
function concatHex(W) {
    return `0x${W.reduce((z,Y)=>z + Y.replace("0x", ""), "")}`
}
function slice(W, z, Y, {strict: ne}={}) {
    return isHex(W, {
        strict: !1
    }) ? sliceHex(W, z, Y, {
        strict: ne
    }) : sliceBytes(W, z, Y, {
        strict: ne
    })
}
function assertStartOffset(W, z) {
    if (typeof z == "number" && z > 0 && z > size$1(W) - 1)
        throw new SliceOffsetOutOfBoundsError({
            offset: z,
            position: "start",
            size: size$1(W)
        })
}
function assertEndOffset(W, z, Y) {
    if (typeof z == "number" && typeof Y == "number" && size$1(W) !== Y - z)
        throw new SliceOffsetOutOfBoundsError({
            offset: Y,
            position: "end",
            size: size$1(W)
        })
}
function sliceBytes(W, z, Y, {strict: ne}={}) {
    assertStartOffset(W, z);
    const le = W.slice(z, Y);
    return ne && assertEndOffset(le, z, Y),
    le
}
function sliceHex(W, z, Y, {strict: ne}={}) {
    assertStartOffset(W, z);
    const le = `0x${W.replace("0x", "").slice(2 * (z ?? 0), 2 * (Y ?? W.length))}`;
    return ne && assertEndOffset(le, z, Y),
    le
}
function encodeAbiParameters(W, z) {
    if (W.length !== z.length)
        throw new AbiEncodingLengthMismatchError({
            expectedLength: W.length,
            givenLength: z.length
        });
    const Y = encodeParams(prepareParams({
        params: W,
        values: z
    }));
    return Y.length === 0 ? "0x" : Y
}
function prepareParams({params: W, values: z}) {
    const Y = [];
    for (let ne = 0; ne < W.length; ne++)
        Y.push(prepareParam({
            param: W[ne],
            value: z[ne]
        }));
    return Y
}
function prepareParam({param: W, value: z}) {
    const Y = getArrayComponents(W.type);
    if (Y) {
        const [ne,le] = Y;
        return encodeArray(z, {
            length: ne,
            param: {
                ...W,
                type: le
            }
        })
    }
    if (W.type === "tuple")
        return encodeTuple(z, {
            param: W
        });
    if (W.type === "address")
        return encodeAddress(z);
    if (W.type === "bool")
        return encodeBool(z);
    if (W.type.startsWith("uint") || W.type.startsWith("int"))
        return encodeNumber(z, {
            signed: W.type.startsWith("int")
        });
    if (W.type.startsWith("bytes"))
        return encodeBytes(z, {
            param: W
        });
    if (W.type === "string")
        return encodeString(z);
    throw new InvalidAbiEncodingTypeError(W.type,{
        docsPath: "/docs/contract/encodeAbiParameters"
    })
}
function encodeParams(W) {
    let z = 0;
    for (let ue = 0; ue < W.length; ue++) {
        const {dynamic: de, encoded: he} = W[ue];
        z += de ? 32 : size$1(he)
    }
    const Y = []
      , ne = [];
    let le = 0;
    for (let ue = 0; ue < W.length; ue++) {
        const {dynamic: de, encoded: he} = W[ue];
        de ? (Y.push(numberToHex(z + le, {
            size: 32
        })),
        ne.push(he),
        le += size$1(he)) : Y.push(he)
    }
    return concat$1([...Y, ...ne])
}
function encodeAddress(W) {
    if (!isAddress(W))
        throw new InvalidAddressError({
            address: W
        });
    return {
        dynamic: !1,
        encoded: padHex(W.toLowerCase())
    }
}
function encodeArray(W, {length: z, param: Y}) {
    const ne = z === null;
    if (!Array.isArray(W))
        throw new InvalidArrayError(W);
    if (!ne && W.length !== z)
        throw new AbiEncodingArrayLengthMismatchError({
            expectedLength: z,
            givenLength: W.length,
            type: `${Y.type}[${z}]`
        });
    let le = !1;
    const ue = [];
    for (let de = 0; de < W.length; de++) {
        const he = prepareParam({
            param: Y,
            value: W[de]
        });
        he.dynamic && (le = !0),
        ue.push(he)
    }
    if (ne || le) {
        const de = encodeParams(ue);
        if (ne) {
            const he = numberToHex(ue.length, {
                size: 32
            });
            return {
                dynamic: !0,
                encoded: ue.length > 0 ? concat$1([he, de]) : he
            }
        }
        if (le)
            return {
                dynamic: !0,
                encoded: de
            }
    }
    return {
        dynamic: !1,
        encoded: concat$1(ue.map(({encoded: de})=>de))
    }
}
function encodeBytes(W, {param: z}) {
    const [,Y] = z.type.split("bytes")
      , ne = size$1(W);
    if (!Y) {
        let le = W;
        return ne % 32 != 0 && (le = padHex(le, {
            dir: "right",
            size: 32 * Math.ceil((W.length - 2) / 2 / 32)
        })),
        {
            dynamic: !0,
            encoded: concat$1([padHex(numberToHex(ne, {
                size: 32
            })), le])
        }
    }
    if (ne !== parseInt(Y))
        throw new AbiEncodingBytesSizeMismatchError({
            expectedSize: parseInt(Y),
            value: W
        });
    return {
        dynamic: !1,
        encoded: padHex(W, {
            dir: "right"
        })
    }
}
function encodeBool(W) {
    return {
        dynamic: !1,
        encoded: padHex(boolToHex(W))
    }
}
function encodeNumber(W, {signed: z}) {
    return {
        dynamic: !1,
        encoded: numberToHex(W, {
            size: 32,
            signed: z
        })
    }
}
function encodeString(W) {
    const z = stringToHex(W)
      , Y = Math.ceil(size$1(z) / 32)
      , ne = [];
    for (let le = 0; le < Y; le++)
        ne.push(padHex(slice(z, 32 * le, 32 * (le + 1)), {
            dir: "right"
        }));
    return {
        dynamic: !0,
        encoded: concat$1([padHex(numberToHex(size$1(z), {
            size: 32
        })), ...ne])
    }
}
function encodeTuple(W, {param: z}) {
    let Y = !1;
    const ne = [];
    for (let le = 0; le < z.components.length; le++) {
        const ue = z.components[le]
          , de = prepareParam({
            param: ue,
            value: W[Array.isArray(W) ? le : ue.name]
        });
        ne.push(de),
        de.dynamic && (Y = !0)
    }
    return {
        dynamic: Y,
        encoded: Y ? encodeParams(ne) : concat$1(ne.map(({encoded: le})=>le))
    }
}
function getArrayComponents(W) {
    const z = W.match(/^(.*)\[(\d+)?\]$/);
    return z ? [z[2] ? Number(z[2]) : null, z[1]] : void 0
}
const hash$1 = W=>keccak256(toBytes$1(W))
  , getFunctionSelector = W=>slice(hash$1(getFunctionSignature(W)), 0, 4);
function getAbiItem({abi: W, args: z=[], name: Y}) {
    const ne = isHex(Y, {
        strict: !1
    })
      , le = W.filter(ue=>ne ? ue.type === "function" ? getFunctionSelector(ue) === Y : ue.type === "event" && getEventSelector(ue) === Y : "name"in ue && ue.name === Y);
    if (le.length !== 0) {
        if (le.length === 1)
            return le[0];
        for (const ue of le) {
            if (!("inputs"in ue))
                continue;
            if (!z || z.length === 0) {
                if (!ue.inputs || ue.inputs.length === 0)
                    return ue;
                continue
            }
            if (!ue.inputs || ue.inputs.length === 0 || ue.inputs.length !== z.length)
                continue;
            if (z.every((he,fe)=>{
                const ge = "inputs"in ue && ue.inputs[fe];
                return !!ge && isArgOfType(he, ge)
            }
            ))
                return ue
        }
        return le[0]
    }
}
function isArgOfType(W, z) {
    const Y = typeof W
      , ne = z.type;
    switch (ne) {
    case "address":
        return isAddress(W);
    case "bool":
        return Y === "boolean";
    case "function":
    case "string":
        return Y === "string";
    default:
        return ne === "tuple" && "components"in z ? Object.values(z.components).every((le,ue)=>isArgOfType(Object.values(W)[ue], le)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(ne) ? Y === "number" || Y === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(ne) ? Y === "string" || W instanceof Uint8Array : !!/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(ne) && Array.isArray(W) && W.every(le=>isArgOfType(le, {
            ...z,
            type: ne.replace(/(\[[0-9]{0,}\])$/, "")
        }))
    }
}
function encodeEventTopics({abi: W, eventName: z, args: Y}) {
    let ne = W[0];
    if (z && (ne = getAbiItem({
        abi: W,
        args: Y,
        name: z
    }),
    !ne))
        throw new AbiEventNotFoundError(z,{
            docsPath: "/docs/contract/encodeEventTopics"
        });
    if (ne.type !== "event")
        throw new AbiEventNotFoundError(void 0,{
            docsPath: "/docs/contract/encodeEventTopics"
        });
    const le = formatAbiItem(ne)
      , ue = getEventSelector(le);
    let de = [];
    if (Y && "inputs"in ne) {
        const he = ne.inputs?.filter(ge=>"indexed"in ge && ge.indexed)
          , fe = Array.isArray(Y) ? Y : Object.values(Y).length > 0 ? he?.map(ge=>Y[ge.name]) ?? [] : [];
        fe.length > 0 && (de = he?.map((ge,xe)=>Array.isArray(fe[xe]) ? fe[xe].map(($e,Ee)=>encodeArg({
            param: ge,
            value: fe[xe][Ee]
        })) : fe[xe] ? encodeArg({
            param: ge,
            value: fe[xe]
        }) : null) ?? [])
    }
    return [ue, ...de]
}
function encodeArg({param: W, value: z}) {
    if (W.type === "string" || W.type === "bytes")
        return keccak256(toBytes$1(z));
    if (W.type === "tuple" || W.type.match(/^(.*)\[(\d+)?\]$/))
        throw new FilterTypeNotSupportedError(W.type);
    return encodeAbiParameters([W], [z])
}
function createFilterRequestScope(W, {method: z}) {
    const Y = {};
    return W.transport.type === "fallback" && W.transport.onResponse?.(({method: ne, response: le, status: ue, transport: de})=>{
        ue === "success" && z === ne && (Y[le] = de.request)
    }
    ),
    ne=>Y[ne] || W.request
}
async function createContractEventFilter(W, {address: z, abi: Y, args: ne, eventName: le, fromBlock: ue, strict: de, toBlock: he}) {
    const fe = createFilterRequestScope(W, {
        method: "eth_newFilter"
    })
      , ge = le ? encodeEventTopics({
        abi: Y,
        args: ne,
        eventName: le
    }) : void 0
      , xe = await W.request({
        method: "eth_newFilter",
        params: [{
            address: z,
            fromBlock: typeof ue == "bigint" ? numberToHex(ue) : ue,
            toBlock: typeof he == "bigint" ? numberToHex(he) : he,
            topics: ge
        }]
    });
    return {
        abi: Y,
        args: ne,
        eventName: le,
        id: xe,
        request: fe(xe),
        strict: de,
        type: "event"
    }
}
function parseAccount(W) {
    return typeof W == "string" ? {
        address: W,
        type: "json-rpc"
    } : W
}
function encodeFunctionData({abi: W, args: z, functionName: Y}) {
    let ne = W[0];
    if (Y && (ne = getAbiItem({
        abi: W,
        args: z,
        name: Y
    }),
    !ne))
        throw new AbiFunctionNotFoundError(Y,{
            docsPath: "/docs/contract/encodeFunctionData"
        });
    if (ne.type !== "function")
        throw new AbiFunctionNotFoundError(void 0,{
            docsPath: "/docs/contract/encodeFunctionData"
        });
    const le = formatAbiItem(ne);
    return concatHex([getFunctionSelector(le), ("inputs"in ne && ne.inputs ? encodeAbiParameters(ne.inputs, z ?? []) : void 0) ?? "0x"])
}
const panicReasons = {
    1: "An `assert` condition failed.",
    17: "Arithmic operation resulted in underflow or overflow.",
    18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
    33: "Attempted to convert to an invalid type.",
    34: "Attempted to access a storage byte array that is incorrectly encoded.",
    49: "Performed `.pop()` on an empty array",
    50: "Array index is out of bounds.",
    65: "Allocated too much memory or created an array which is too large.",
    81: "Attempted to call a zero-initialized variable of internal function type."
}
  , solidityError = {
    inputs: [{
        name: "message",
        type: "string"
    }],
    name: "Error",
    type: "error"
}
  , solidityPanic = {
    inputs: [{
        name: "reason",
        type: "uint256"
    }],
    name: "Panic",
    type: "error"
};
function checksumAddress(W, z) {
    const Y = z ? `${z}${W.toLowerCase()}` : W.substring(2).toLowerCase()
      , ne = keccak256(stringToBytes(Y), "bytes")
      , le = (z ? Y.substring(`${z}0x`.length) : Y).split("");
    for (let ue = 0; ue < 40; ue += 2)
        ne[ue >> 1] >> 4 >= 8 && le[ue] && (le[ue] = le[ue].toUpperCase()),
        (15 & ne[ue >> 1]) >= 8 && le[ue + 1] && (le[ue + 1] = le[ue + 1].toUpperCase());
    return `0x${le.join("")}`
}
function getAddress(W, z) {
    if (!isAddress(W))
        throw new InvalidAddressError({
            address: W
        });
    return checksumAddress(W, z)
}
function decodeAbiParameters(W, z) {
    if (z === "0x" && W.length > 0)
        throw new AbiDecodingZeroDataError;
    if (size$1(z) && size$1(z) < 32)
        throw new AbiDecodingDataSizeTooSmallError({
            data: z,
            params: W,
            size: size$1(z)
        });
    return decodeParams({
        data: z,
        params: W
    })
}
function decodeParams({data: W, params: z}) {
    const Y = [];
    let ne = 0;
    for (let le = 0; le < z.length; le++) {
        if (ne >= size$1(W))
            throw new AbiDecodingDataSizeTooSmallError({
                data: W,
                params: z,
                size: size$1(W)
            });
        const ue = z[le]
          , {consumed: de, value: he} = decodeParam({
            data: W,
            param: ue,
            position: ne
        });
        Y.push(he),
        ne += de
    }
    return Y
}
function decodeParam({data: W, param: z, position: Y}) {
    const ne = getArrayComponents(z.type);
    if (ne) {
        const [ue,de] = ne;
        return decodeArray(W, {
            length: ue,
            param: {
                ...z,
                type: de
            },
            position: Y
        })
    }
    if (z.type === "tuple")
        return decodeTuple(W, {
            param: z,
            position: Y
        });
    if (z.type === "string")
        return decodeString(W, {
            position: Y
        });
    if (z.type.startsWith("bytes"))
        return decodeBytes(W, {
            param: z,
            position: Y
        });
    const le = slice(W, Y, Y + 32, {
        strict: !0
    });
    if (z.type.startsWith("uint") || z.type.startsWith("int"))
        return decodeNumber(le, {
            param: z
        });
    if (z.type === "address")
        return decodeAddress(le);
    if (z.type === "bool")
        return decodeBool(le);
    throw new InvalidAbiDecodingTypeError(z.type,{
        docsPath: "/docs/contract/decodeAbiParameters"
    })
}
function decodeAddress(W) {
    return {
        consumed: 32,
        value: checksumAddress(slice(W, -20))
    }
}
function decodeArray(W, {param: z, length: Y, position: ne}) {
    if (!Y) {
        const de = hexToNumber(slice(W, ne, ne + 32, {
            strict: !0
        }))
          , he = hexToNumber(slice(W, de, de + 32, {
            strict: !0
        }));
        let fe = 0;
        const ge = [];
        for (let xe = 0; xe < he; ++xe) {
            const $e = decodeParam({
                data: slice(W, de + 32),
                param: z,
                position: fe
            });
            fe += $e.consumed,
            ge.push($e.value)
        }
        return {
            value: ge,
            consumed: 32
        }
    }
    if (hasDynamicChild(z)) {
        const de = getArrayComponents(z.type)
          , he = !de?.[0];
        let fe = 0;
        const ge = [];
        for (let xe = 0; xe < Y; ++xe) {
            const $e = hexToNumber(slice(W, ne, ne + 32, {
                strict: !0
            }))
              , Ee = decodeParam({
                data: slice(W, $e),
                param: z,
                position: he ? fe : 32 * xe
            });
            fe += Ee.consumed,
            ge.push(Ee.value)
        }
        return {
            value: ge,
            consumed: 32
        }
    }
    let le = 0;
    const ue = [];
    for (let de = 0; de < Y; ++de) {
        const he = decodeParam({
            data: W,
            param: z,
            position: ne + le
        });
        le += he.consumed,
        ue.push(he.value)
    }
    return {
        value: ue,
        consumed: le
    }
}
function decodeBool(W) {
    return {
        consumed: 32,
        value: hexToBool(W)
    }
}
function decodeBytes(W, {param: z, position: Y}) {
    const [ne,le] = z.type.split("bytes");
    if (!le) {
        const ue = hexToNumber(slice(W, Y, Y + 32, {
            strict: !0
        }))
          , de = hexToNumber(slice(W, ue, ue + 32, {
            strict: !0
        }));
        return de === 0 ? {
            consumed: 32,
            value: "0x"
        } : {
            consumed: 32,
            value: slice(W, ue + 32, ue + 32 + de, {
                strict: !0
            })
        }
    }
    return {
        consumed: 32,
        value: slice(W, Y, Y + parseInt(le), {
            strict: !0
        })
    }
}
function decodeNumber(W, {param: z}) {
    const Y = z.type.startsWith("int");
    return {
        consumed: 32,
        value: parseInt(z.type.split("int")[1] || "256") > 48 ? hexToBigInt(W, {
            signed: Y
        }) : hexToNumber(W, {
            signed: Y
        })
    }
}
function decodeString(W, {position: z}) {
    const Y = hexToNumber(slice(W, z, z + 32, {
        strict: !0
    }))
      , ne = hexToNumber(slice(W, Y, Y + 32, {
        strict: !0
    }));
    return ne === 0 ? {
        consumed: 32,
        value: ""
    } : {
        consumed: 32,
        value: hexToString(trim(slice(W, Y + 32, Y + 32 + ne, {
            strict: !0
        })))
    }
}
function decodeTuple(W, {param: z, position: Y}) {
    const ne = z.components.length === 0 || z.components.some(({name: de})=>!de)
      , le = ne ? [] : {};
    let ue = 0;
    if (hasDynamicChild(z)) {
        const de = hexToNumber(slice(W, Y, Y + 32, {
            strict: !0
        }));
        for (let he = 0; he < z.components.length; ++he) {
            const fe = z.components[he]
              , ge = decodeParam({
                data: slice(W, de),
                param: fe,
                position: ue
            });
            ue += ge.consumed,
            le[ne ? he : fe?.name] = ge.value
        }
        return {
            consumed: 32,
            value: le
        }
    }
    for (let de = 0; de < z.components.length; ++de) {
        const he = z.components[de]
          , fe = decodeParam({
            data: W,
            param: he,
            position: Y + ue
        });
        ue += fe.consumed,
        le[ne ? de : he?.name] = fe.value
    }
    return {
        consumed: ue,
        value: le
    }
}
function hasDynamicChild(W) {
    const {type: z} = W;
    if (z === "string" || z === "bytes" || z.endsWith("[]"))
        return !0;
    if (z === "tuple")
        return W.components?.some(hasDynamicChild);
    const Y = getArrayComponents(W.type);
    return !(!Y || !hasDynamicChild({
        ...W,
        type: Y[1]
    }))
}
function decodeErrorResult({abi: W, data: z}) {
    const Y = slice(z, 0, 4);
    if (Y === "0x")
        throw new AbiDecodingZeroDataError;
    const ne = [...W || [], solidityError, solidityPanic].find(le=>le.type === "error" && Y === getFunctionSelector(formatAbiItem(le)));
    if (!ne)
        throw new AbiErrorSignatureNotFoundError(Y,{
            docsPath: "/docs/contract/decodeErrorResult"
        });
    return {
        abiItem: ne,
        args: "inputs"in ne && ne.inputs && ne.inputs.length > 0 ? decodeAbiParameters(ne.inputs, slice(z, 4)) : void 0,
        errorName: ne.name
    }
}
const stringify = (W,z,Y)=>JSON.stringify(W, (ne,le)=>{
    const ue = typeof le == "bigint" ? le.toString() : le;
    return typeof z == "function" ? z(ne, ue) : ue
}
, Y);
function formatAbiItemWithArgs({abiItem: W, args: z, includeFunctionName: Y=!0, includeName: ne=!1}) {
    if ("name"in W && "inputs"in W && W.inputs)
        return `${Y ? W.name : ""}(${W.inputs.map((le,ue)=>`${ne && le.name ? `${le.name}: ` : ""}${typeof z[ue] == "object" ? stringify(z[ue]) : z[ue]}`).join(", ")})`
}
const etherUnits = {
    gwei: 9,
    wei: 18
}
  , gweiUnits = {
    ether: -9,
    wei: 9
}
  , weiUnits = {
    ether: -18,
    gwei: -9
};
function formatUnits(W, z) {
    let Y = W.toString();
    const ne = Y.startsWith("-");
    ne && (Y = Y.slice(1)),
    Y = Y.padStart(z, "0");
    let[le,ue] = [Y.slice(0, Y.length - z), Y.slice(Y.length - z)];
    return ue = ue.replace(/(0+)$/, ""),
    `${ne ? "-" : ""}${le || "0"}${ue ? `.${ue}` : ""}`
}
function formatEther(W, z="wei") {
    return formatUnits(W, etherUnits[z])
}
function formatGwei(W, z="wei") {
    return formatUnits(W, gweiUnits[z])
}
function prettyPrint(W) {
    const z = Object.entries(W).map(([ne,le])=>le === void 0 || le === !1 ? null : [ne, le]).filter(Boolean)
      , Y = z.reduce((ne,[le])=>Math.max(ne, le.length), 0);
    return z.map(([ne,le])=>`  ${`${ne}:`.padEnd(Y + 1)}  ${le}`).join(`
`)
}
class FeeConflictError extends BaseError {
    constructor() {
        super(["Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.", "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."].join(`
`)),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "FeeConflictError"
        })
    }
}
class InvalidSerializableTransactionError extends BaseError {
    constructor({transaction: z}) {
        super("Cannot infer a transaction type from provided transaction.", {
            metaMessages: ["Provided Transaction:", "{", prettyPrint(z), "}", "", "To infer the type, either provide:", "- a `type` to the Transaction, or", "- an EIP-1559 Transaction with `maxFeePerGas`, or", "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or", "- a Legacy Transaction with `gasPrice`"]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidSerializableTransactionError"
        })
    }
}
class TransactionExecutionError extends BaseError {
    constructor(z, {account: Y, docsPath: ne, chain: le, data: ue, gas: de, gasPrice: he, maxFeePerGas: fe, maxPriorityFeePerGas: ge, nonce: xe, to: $e, value: Ee}) {
        const Se = prettyPrint({
            chain: le && `${le?.name} (id: ${le?.id})`,
            from: Y?.address,
            to: $e,
            value: Ee !== void 0 && `${formatEther(Ee)} ${le?.nativeCurrency?.symbol || "ETH"}`,
            data: ue,
            gas: de,
            gasPrice: he !== void 0 && `${formatGwei(he)} gwei`,
            maxFeePerGas: fe !== void 0 && `${formatGwei(fe)} gwei`,
            maxPriorityFeePerGas: ge !== void 0 && `${formatGwei(ge)} gwei`,
            nonce: xe
        });
        super(z.shortMessage, {
            cause: z,
            docsPath: ne,
            metaMessages: [...z.metaMessages ? [...z.metaMessages, " "] : [], "Request Arguments:", Se].filter(Boolean)
        }),
        Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TransactionExecutionError"
        }),
        this.cause = z
    }
}
class TransactionNotFoundError extends BaseError {
    constructor({blockHash: z, blockNumber: Y, blockTag: ne, hash: le, index: ue}) {
        let de = "Transaction";
        ne && ue !== void 0 && (de = `Transaction at block time "${ne}" at index "${ue}"`),
        z && ue !== void 0 && (de = `Transaction at block hash "${z}" at index "${ue}"`),
        Y && ue !== void 0 && (de = `Transaction at block number "${Y}" at index "${ue}"`),
        le && (de = `Transaction with hash "${le}"`),
        super(`${de} could not be found.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TransactionNotFoundError"
        })
    }
}
class TransactionReceiptNotFoundError extends BaseError {
    constructor({hash: z}) {
        super(`Transaction receipt with hash "${z}" could not be found. The Transaction may not be processed on a block yet.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TransactionReceiptNotFoundError"
        })
    }
}
class WaitForTransactionReceiptTimeoutError extends BaseError {
    constructor({hash: z}) {
        super(`Timed out while waiting for transaction with hash "${z}" to be confirmed.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "WaitForTransactionReceiptTimeoutError"
        })
    }
}
class CallExecutionError extends BaseError {
    constructor(z, {account: Y, docsPath: ne, chain: le, data: ue, gas: de, gasPrice: he, maxFeePerGas: fe, maxPriorityFeePerGas: ge, nonce: xe, to: $e, value: Ee}) {
        const Se = Y ? parseAccount(Y) : void 0
          , Ne = prettyPrint({
            from: Se?.address,
            to: $e,
            value: Ee !== void 0 && `${formatEther(Ee)} ${le?.nativeCurrency?.symbol || "ETH"}`,
            data: ue,
            gas: de,
            gasPrice: he !== void 0 && `${formatGwei(he)} gwei`,
            maxFeePerGas: fe !== void 0 && `${formatGwei(fe)} gwei`,
            maxPriorityFeePerGas: ge !== void 0 && `${formatGwei(ge)} gwei`,
            nonce: xe
        });
        super(z.shortMessage, {
            cause: z,
            docsPath: ne,
            metaMessages: [...z.metaMessages ? [...z.metaMessages, " "] : [], "Raw Call Arguments:", Ne].filter(Boolean)
        }),
        Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "CallExecutionError"
        }),
        this.cause = z
    }
}
class ContractFunctionExecutionError extends BaseError {
    constructor(z, {abi: Y, args: ne, contractAddress: le, docsPath: ue, functionName: de, sender: he}) {
        const fe = getAbiItem({
            abi: Y,
            args: ne,
            name: de
        })
          , ge = fe ? formatAbiItemWithArgs({
            abiItem: fe,
            args: ne,
            includeFunctionName: !1,
            includeName: !1
        }) : void 0
          , xe = fe ? formatAbiItem(fe, {
            includeName: !0
        }) : void 0
          , $e = prettyPrint({
            address: le && getContractAddress(le),
            function: xe,
            args: ge && ge !== "()" && `${[...Array(de?.length ?? 0).keys()].map(()=>" ").join("")}${ge}`,
            sender: he
        });
        super(z.shortMessage || `An unknown error occurred while executing the contract function "${de}".`, {
            cause: z,
            docsPath: ue,
            metaMessages: [...z.metaMessages ? [...z.metaMessages, " "] : [], "Contract Call:", $e].filter(Boolean)
        }),
        Object.defineProperty(this, "abi", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "args", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "contractAddress", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "formattedArgs", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "functionName", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "sender", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ContractFunctionExecutionError"
        }),
        this.abi = Y,
        this.args = ne,
        this.cause = z,
        this.contractAddress = le,
        this.functionName = de,
        this.sender = he
    }
}
class ContractFunctionRevertedError extends BaseError {
    constructor({abi: z, data: Y, functionName: ne, message: le}) {
        let ue, de, he, fe, ge;
        if (Y && Y !== "0x")
            try {
                de = decodeErrorResult({
                    abi: z,
                    data: Y
                });
                const {abiItem: xe, errorName: $e, args: Ee} = de;
                if ($e === "Error")
                    fe = Ee[0];
                else if ($e === "Panic") {
                    const [Se] = Ee;
                    fe = panicReasons[Se]
                } else {
                    const Se = xe ? formatAbiItem(xe, {
                        includeName: !0
                    }) : void 0
                      , Ne = xe && Ee ? formatAbiItemWithArgs({
                        abiItem: xe,
                        args: Ee,
                        includeFunctionName: !1,
                        includeName: !1
                    }) : void 0;
                    he = [Se ? `Error: ${Se}` : "", Ne && Ne !== "()" ? `       ${[...Array($e?.length ?? 0).keys()].map(()=>" ").join("")}${Ne}` : ""]
                }
            } catch (xe) {
                ue = xe
            }
        else
            le && (fe = le);
        ue instanceof AbiErrorSignatureNotFoundError && (ge = ue.signature,
        he = [`Unable to decode signature "${ge}" as it was not found on the provided ABI.`, "Make sure you are using the correct ABI and that the error exists on it.", `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${ge}.`]),
        super(fe && fe !== "execution reverted" || ge ? [`The contract function "${ne}" reverted with the following ${ge ? "signature" : "reason"}:`, fe || ge].join(`
`) : `The contract function "${ne}" reverted.`, {
            cause: ue,
            metaMessages: he
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ContractFunctionRevertedError"
        }),
        Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "reason", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "signature", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.data = de,
        this.reason = fe,
        this.signature = ge
    }
}
class ContractFunctionZeroDataError extends BaseError {
    constructor({functionName: z}) {
        super(`The contract function "${z}" returned no data ("0x").`, {
            metaMessages: ["This could be due to any of the following:", `  - The contract does not have the function "${z}",`, "  - The parameters passed to the contract function may be invalid, or", "  - The address is not a contract."]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ContractFunctionZeroDataError"
        })
    }
}
class RawContractError extends BaseError {
    constructor({data: z, message: Y}) {
        super(Y || ""),
        Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: 3
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RawContractError"
        }),
        Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.data = z
    }
}
class HttpRequestError extends BaseError {
    constructor({body: z, details: Y, headers: ne, status: le, url: ue}) {
        super("HTTP request failed.", {
            details: Y,
            metaMessages: [le && `Status: ${le}`, `URL: ${getUrl(ue)}`, z && `Request body: ${stringify(z)}`].filter(Boolean)
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "HttpRequestError"
        }),
        Object.defineProperty(this, "body", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "headers", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "status", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "url", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.body = z,
        this.headers = ne,
        this.status = le,
        this.url = ue
    }
}
class WebSocketRequestError extends BaseError {
    constructor({body: z, details: Y, url: ne}) {
        super("WebSocket request failed.", {
            details: Y,
            metaMessages: [`URL: ${getUrl(ne)}`, `Request body: ${stringify(z)}`]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "WebSocketRequestError"
        })
    }
}
class RpcRequestError extends BaseError {
    constructor({body: z, error: Y, url: ne}) {
        super("RPC Request failed.", {
            cause: Y,
            details: Y.message,
            metaMessages: [`URL: ${getUrl(ne)}`, `Request body: ${stringify(z)}`]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcRequestError"
        }),
        Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.code = Y.code
    }
}
class TimeoutError extends BaseError {
    constructor({body: z, url: Y}) {
        super("The request took too long to respond.", {
            details: "The request timed out.",
            metaMessages: [`URL: ${getUrl(Y)}`, `Request body: ${stringify(z)}`]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TimeoutError"
        })
    }
}
const unknownErrorCode = -1;
class RpcError extends BaseError {
    constructor(z, {code: Y, docsPath: ne, metaMessages: le, shortMessage: ue}) {
        super(ue, {
            cause: z,
            docsPath: ne,
            metaMessages: le || z?.metaMessages
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "RpcError"
        }),
        Object.defineProperty(this, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.name = z.name,
        this.code = z instanceof RpcRequestError ? z.code : Y ?? unknownErrorCode
    }
}
class ProviderRpcError extends RpcError {
    constructor(z, Y) {
        super(z, Y),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ProviderRpcError"
        }),
        Object.defineProperty(this, "data", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.data = Y.data
    }
}
class ParseRpcError extends RpcError {
    constructor(z) {
        super(z, {
            code: ParseRpcError.code,
            shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ParseRpcError"
        })
    }
}
Object.defineProperty(ParseRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32700
});
class InvalidRequestRpcError extends RpcError {
    constructor(z) {
        super(z, {
            code: InvalidRequestRpcError.code,
            shortMessage: "JSON is not a valid request object."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidRequestRpcError"
        })
    }
}
Object.defineProperty(InvalidRequestRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32600
});
class MethodNotFoundRpcError extends RpcError {
    constructor(z) {
        super(z, {
            code: MethodNotFoundRpcError.code,
            shortMessage: "The method does not exist / is not available."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "MethodNotFoundRpcError"
        })
    }
}
Object.defineProperty(MethodNotFoundRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32601
});
class InvalidParamsRpcError extends RpcError {
    constructor(z) {
        super(z, {
            code: InvalidParamsRpcError.code,
            shortMessage: ["Invalid parameters were provided to the RPC method.", "Double check you have provided the correct parameters."].join(`
`)
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidParamsRpcError"
        })
    }
}
Object.defineProperty(InvalidParamsRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32602
});
class InternalRpcError extends RpcError {
    constructor(z) {
        super(z, {
            code: InternalRpcError.code,
            shortMessage: "An internal error was received."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InternalRpcError"
        })
    }
}
Object.defineProperty(InternalRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32603
});
class InvalidInputRpcError extends RpcError {
    constructor(z) {
        super(z, {
            code: InvalidInputRpcError.code,
            shortMessage: ["Missing or invalid parameters.", "Double check you have provided the correct parameters."].join(`
`)
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InvalidInputRpcError"
        })
    }
}
Object.defineProperty(InvalidInputRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32e3
});
class ResourceNotFoundRpcError extends RpcError {
    constructor(z) {
        super(z, {
            code: ResourceNotFoundRpcError.code,
            shortMessage: "Requested resource not found."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ResourceNotFoundRpcError"
        })
    }
}
Object.defineProperty(ResourceNotFoundRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32001
});
class ResourceUnavailableRpcError extends RpcError {
    constructor(z) {
        super(z, {
            code: ResourceUnavailableRpcError.code,
            shortMessage: "Requested resource not available."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ResourceUnavailableRpcError"
        })
    }
}
Object.defineProperty(ResourceUnavailableRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32002
});
class TransactionRejectedRpcError extends RpcError {
    constructor(z) {
        super(z, {
            code: TransactionRejectedRpcError.code,
            shortMessage: "Transaction creation failed."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TransactionRejectedRpcError"
        })
    }
}
Object.defineProperty(TransactionRejectedRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32003
});
class MethodNotSupportedRpcError extends RpcError {
    constructor(z) {
        super(z, {
            code: MethodNotSupportedRpcError.code,
            shortMessage: "Method is not implemented."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "MethodNotSupportedRpcError"
        })
    }
}
Object.defineProperty(MethodNotSupportedRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32004
});
class LimitExceededRpcError extends RpcError {
    constructor(z) {
        super(z, {
            code: LimitExceededRpcError.code,
            shortMessage: "Request exceeds defined limit."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "LimitExceededRpcError"
        })
    }
}
Object.defineProperty(LimitExceededRpcError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32005
});
class JsonRpcVersionUnsupportedError extends RpcError {
    constructor(z) {
        super(z, {
            code: JsonRpcVersionUnsupportedError.code,
            shortMessage: "Version of JSON-RPC protocol is not supported."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "JsonRpcVersionUnsupportedError"
        })
    }
}
Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: -32006
});
class UserRejectedRequestError extends ProviderRpcError {
    constructor(z) {
        super(z, {
            code: UserRejectedRequestError.code,
            shortMessage: "User rejected the request."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UserRejectedRequestError"
        })
    }
}
Object.defineProperty(UserRejectedRequestError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4001
});
class UnauthorizedProviderError extends ProviderRpcError {
    constructor(z) {
        super(z, {
            code: UnauthorizedProviderError.code,
            shortMessage: "The requested method and/or account has not been authorized by the user."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UnauthorizedProviderError"
        })
    }
}
Object.defineProperty(UnauthorizedProviderError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4100
});
class UnsupportedProviderMethodError extends ProviderRpcError {
    constructor(z) {
        super(z, {
            code: UnsupportedProviderMethodError.code,
            shortMessage: "The Provider does not support the requested method."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UnsupportedProviderMethodError"
        })
    }
}
Object.defineProperty(UnsupportedProviderMethodError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4200
});
class ProviderDisconnectedError extends ProviderRpcError {
    constructor(z) {
        super(z, {
            code: ProviderDisconnectedError.code,
            shortMessage: "The Provider is disconnected from all chains."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ProviderDisconnectedError"
        })
    }
}
Object.defineProperty(ProviderDisconnectedError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4900
});
class ChainDisconnectedError extends ProviderRpcError {
    constructor(z) {
        super(z, {
            code: ChainDisconnectedError.code,
            shortMessage: "The Provider is not connected to the requested chain."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ChainDisconnectedError"
        })
    }
}
Object.defineProperty(ChainDisconnectedError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4901
});
class SwitchChainError extends ProviderRpcError {
    constructor(z) {
        super(z, {
            code: SwitchChainError.code,
            shortMessage: "An error occurred when attempting to switch chain."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "SwitchChainError"
        })
    }
}
Object.defineProperty(SwitchChainError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 4902
});
class UnknownRpcError extends RpcError {
    constructor(z) {
        super(z, {
            shortMessage: "An unknown RPC error occurred."
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UnknownRpcError"
        })
    }
}
const EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(W, {abi: z, address: Y, args: ne, docsPath: le, functionName: ue, sender: de}) {
    const {code: he, data: fe, message: ge, shortMessage: xe} = W instanceof RawContractError ? W : W instanceof BaseError ? W.walk(Ee=>"data"in Ee) || W.walk() : {}
      , $e = W instanceof AbiDecodingZeroDataError ? new ContractFunctionZeroDataError({
        functionName: ue
    }) : [EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(he) && (fe || ge || xe) ? new ContractFunctionRevertedError({
        abi: z,
        data: typeof fe == "object" ? fe.data : fe,
        functionName: ue,
        message: xe ?? ge
    }) : W;
    return new ContractFunctionExecutionError($e,{
        abi: z,
        args: ne,
        contractAddress: Y,
        docsPath: le,
        functionName: ue,
        sender: de
    })
}
class AccountNotFoundError extends BaseError {
    constructor({docsPath: z}={}) {
        super(["Could not find an Account to execute with this Action.", "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."].join(`
`), {
            docsPath: z,
            docsSlug: "account"
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "AccountNotFoundError"
        })
    }
}
class EstimateGasExecutionError extends BaseError {
    constructor(z, {account: Y, docsPath: ne, chain: le, data: ue, gas: de, gasPrice: he, maxFeePerGas: fe, maxPriorityFeePerGas: ge, nonce: xe, to: $e, value: Ee}) {
        const Se = prettyPrint({
            from: Y?.address,
            to: $e,
            value: Ee !== void 0 && `${formatEther(Ee)} ${le?.nativeCurrency?.symbol || "ETH"}`,
            data: ue,
            gas: de,
            gasPrice: he !== void 0 && `${formatGwei(he)} gwei`,
            maxFeePerGas: fe !== void 0 && `${formatGwei(fe)} gwei`,
            maxPriorityFeePerGas: ge !== void 0 && `${formatGwei(ge)} gwei`,
            nonce: xe
        });
        super(z.shortMessage, {
            cause: z,
            docsPath: ne,
            metaMessages: [...z.metaMessages ? [...z.metaMessages, " "] : [], "Estimate Gas Arguments:", Se].filter(Boolean)
        }),
        Object.defineProperty(this, "cause", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "EstimateGasExecutionError"
        }),
        this.cause = z
    }
}
class ExecutionRevertedError extends BaseError {
    constructor({cause: z, message: Y}={}) {
        const ne = Y?.replace("execution reverted: ", "")?.replace("execution reverted", "");
        super(`Execution reverted ${ne ? `with reason: ${ne}` : "for an unknown reason"}.`, {
            cause: z
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ExecutionRevertedError"
        })
    }
}
Object.defineProperty(ExecutionRevertedError, "code", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: 3
}),
Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /execution reverted/
});
class FeeCapTooHighError extends BaseError {
    constructor({cause: z, maxFeePerGas: Y}={}) {
        super(`The fee cap (\`maxFeePerGas\`${Y ? ` = ${formatGwei(Y)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
            cause: z
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "FeeCapTooHigh"
        })
    }
}
Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class FeeCapTooLowError extends BaseError {
    constructor({cause: z, maxFeePerGas: Y}={}) {
        super(`The fee cap (\`maxFeePerGas\`${Y ? ` = ${formatGwei(Y)}` : ""} gwei) cannot be lower than the block base fee.`, {
            cause: z
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "FeeCapTooLow"
        })
    }
}
Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class NonceTooHighError extends BaseError {
    constructor({cause: z, nonce: Y}={}) {
        super(`Nonce provided for the transaction ${Y ? `(${Y}) ` : ""}is higher than the next one expected.`, {
            cause: z
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "NonceTooHighError"
        })
    }
}
Object.defineProperty(NonceTooHighError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /nonce too high/
});
class NonceTooLowError extends BaseError {
    constructor({cause: z, nonce: Y}={}) {
        super([`Nonce provided for the transaction ${Y ? `(${Y}) ` : ""}is lower than the current nonce of the account.`, "Try increasing the nonce or find the latest nonce with `getTransactionCount`."].join(`
`), {
            cause: z
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "NonceTooLowError"
        })
    }
}
Object.defineProperty(NonceTooLowError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /nonce too low|transaction already imported|already known/
});
class NonceMaxValueError extends BaseError {
    constructor({cause: z, nonce: Y}={}) {
        super(`Nonce provided for the transaction ${Y ? `(${Y}) ` : ""}exceeds the maximum allowed nonce.`, {
            cause: z
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "NonceMaxValueError"
        })
    }
}
Object.defineProperty(NonceMaxValueError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /nonce has max value/
});
class InsufficientFundsError extends BaseError {
    constructor({cause: z}={}) {
        super(["The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."].join(`
`), {
            cause: z,
            metaMessages: ["This error could arise when the account does not have enough funds to:", " - pay for the total gas fee,", " - pay for the value to send.", " ", "The cost of the transaction is calculated as `gas * gas fee + value`, where:", " - `gas` is the amount of gas needed for transaction to execute,", " - `gas fee` is the gas fee,", " - `value` is the amount of ether to send to the recipient."]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "InsufficientFundsError"
        })
    }
}
Object.defineProperty(InsufficientFundsError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /insufficient funds/
});
class IntrinsicGasTooHighError extends BaseError {
    constructor({cause: z, gas: Y}={}) {
        super(`The amount of gas ${Y ? `(${Y}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
            cause: z
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "IntrinsicGasTooHighError"
        })
    }
}
Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /intrinsic gas too high|gas limit reached/
});
class IntrinsicGasTooLowError extends BaseError {
    constructor({cause: z, gas: Y}={}) {
        super(`The amount of gas ${Y ? `(${Y}) ` : ""}provided for the transaction is too low.`, {
            cause: z
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "IntrinsicGasTooLowError"
        })
    }
}
Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /intrinsic gas too low/
});
class TransactionTypeNotSupportedError extends BaseError {
    constructor({cause: z}) {
        super("The transaction type is not supported for this chain.", {
            cause: z
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TransactionTypeNotSupportedError"
        })
    }
}
Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /transaction type not valid/
});
class TipAboveFeeCapError extends BaseError {
    constructor({cause: z, maxPriorityFeePerGas: Y, maxFeePerGas: ne}={}) {
        super([`The provided tip (\`maxPriorityFeePerGas\`${Y ? ` = ${formatGwei(Y)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${ne ? ` = ${formatGwei(ne)} gwei` : ""}).`].join(`
`), {
            cause: z
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "TipAboveFeeCapError"
        })
    }
}
Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class UnknownNodeError extends BaseError {
    constructor({cause: z}) {
        super(`An error occurred while executing: ${z?.shortMessage}`, {
            cause: z
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "UnknownNodeError"
        })
    }
}
function getNodeError(W, z) {
    const Y = (W.details || "").toLowerCase()
      , ne = W.walk(le=>le.code === ExecutionRevertedError.code);
    return ne instanceof BaseError ? new ExecutionRevertedError({
        cause: W,
        message: ne.details
    }) : ExecutionRevertedError.nodeMessage.test(Y) ? new ExecutionRevertedError({
        cause: W,
        message: W.details
    }) : FeeCapTooHighError.nodeMessage.test(Y) ? new FeeCapTooHighError({
        cause: W,
        maxFeePerGas: z?.maxFeePerGas
    }) : FeeCapTooLowError.nodeMessage.test(Y) ? new FeeCapTooLowError({
        cause: W,
        maxFeePerGas: z?.maxFeePerGas
    }) : NonceTooHighError.nodeMessage.test(Y) ? new NonceTooHighError({
        cause: W,
        nonce: z?.nonce
    }) : NonceTooLowError.nodeMessage.test(Y) ? new NonceTooLowError({
        cause: W,
        nonce: z?.nonce
    }) : NonceMaxValueError.nodeMessage.test(Y) ? new NonceMaxValueError({
        cause: W,
        nonce: z?.nonce
    }) : InsufficientFundsError.nodeMessage.test(Y) ? new InsufficientFundsError({
        cause: W
    }) : IntrinsicGasTooHighError.nodeMessage.test(Y) ? new IntrinsicGasTooHighError({
        cause: W,
        gas: z?.gas
    }) : IntrinsicGasTooLowError.nodeMessage.test(Y) ? new IntrinsicGasTooLowError({
        cause: W,
        gas: z?.gas
    }) : TransactionTypeNotSupportedError.nodeMessage.test(Y) ? new TransactionTypeNotSupportedError({
        cause: W
    }) : TipAboveFeeCapError.nodeMessage.test(Y) ? new TipAboveFeeCapError({
        cause: W,
        maxFeePerGas: z?.maxFeePerGas,
        maxPriorityFeePerGas: z?.maxPriorityFeePerGas
    }) : new UnknownNodeError({
        cause: W
    })
}
function getEstimateGasError(W, {docsPath: z, ...Y}) {
    const ne = (()=>{
        const le = getNodeError(W, Y);
        return le instanceof UnknownNodeError ? W : le
    }
    )();
    return new EstimateGasExecutionError(ne,{
        docsPath: z,
        ...Y
    })
}
function extract(W, {format: z}) {
    if (!z)
        return {};
    const Y = {};
    return function ne(le) {
        const ue = Object.keys(le);
        for (const de of ue)
            de in W && (Y[de] = W[de]),
            le[de] && typeof le[de] == "object" && !Array.isArray(le[de]) && ne(le[de])
    }(z(W || {})),
    Y
}
const rpcTransactionType = {
    legacy: "0x0",
    eip2930: "0x1",
    eip1559: "0x2"
};
function formatTransactionRequest(W) {
    return {
        ...W,
        gas: W.gas !== void 0 ? numberToHex(W.gas) : void 0,
        gasPrice: W.gasPrice !== void 0 ? numberToHex(W.gasPrice) : void 0,
        maxFeePerGas: W.maxFeePerGas !== void 0 ? numberToHex(W.maxFeePerGas) : void 0,
        maxPriorityFeePerGas: W.maxPriorityFeePerGas !== void 0 ? numberToHex(W.maxPriorityFeePerGas) : void 0,
        nonce: W.nonce !== void 0 ? numberToHex(W.nonce) : void 0,
        type: W.type !== void 0 ? rpcTransactionType[W.type] : void 0,
        value: W.value !== void 0 ? numberToHex(W.value) : void 0
    }
}
function assertRequest(W) {
    const {account: z, gasPrice: Y, maxFeePerGas: ne, maxPriorityFeePerGas: le, to: ue} = W
      , de = z ? parseAccount(z) : void 0;
    if (de && !isAddress(de.address))
        throw new InvalidAddressError({
            address: de.address
        });
    if (ue && !isAddress(ue))
        throw new InvalidAddressError({
            address: ue
        });
    if (Y !== void 0 && (ne !== void 0 || le !== void 0))
        throw new FeeConflictError;
    if (ne && ne > 2n ** 256n - 1n)
        throw new FeeCapTooHighError({
            maxFeePerGas: ne
        });
    if (le && ne && le > ne)
        throw new TipAboveFeeCapError({
            maxFeePerGas: ne,
            maxPriorityFeePerGas: le
        })
}
class BaseFeeScalarError extends BaseError {
    constructor() {
        super("`baseFeeMultiplier` must be greater than 1."),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "BaseFeeScalarError"
        })
    }
}
class Eip1559FeesNotSupportedError extends BaseError {
    constructor() {
        super("Chain does not support EIP-1559 fees."),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "Eip1559FeesNotSupportedError"
        })
    }
}
class MaxFeePerGasTooLowError extends BaseError {
    constructor({maxPriorityFeePerGas: z}) {
        super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(z)} gwei).`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "MaxFeePerGasTooLowError"
        })
    }
}
class BlockNotFoundError extends BaseError {
    constructor({blockHash: z, blockNumber: Y}) {
        let ne = "Block";
        z && (ne = `Block at hash "${z}"`),
        Y && (ne = `Block at number "${Y}"`),
        super(`${ne} could not be found.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "BlockNotFoundError"
        })
    }
}
const transactionType = {
    "0x0": "legacy",
    "0x1": "eip2930",
    "0x2": "eip1559"
};
function formatTransaction(W) {
    const z = {
        ...W,
        blockHash: W.blockHash ? W.blockHash : null,
        blockNumber: W.blockNumber ? BigInt(W.blockNumber) : null,
        chainId: W.chainId ? hexToNumber(W.chainId) : void 0,
        gas: W.gas ? BigInt(W.gas) : void 0,
        gasPrice: W.gasPrice ? BigInt(W.gasPrice) : void 0,
        maxFeePerGas: W.maxFeePerGas ? BigInt(W.maxFeePerGas) : void 0,
        maxPriorityFeePerGas: W.maxPriorityFeePerGas ? BigInt(W.maxPriorityFeePerGas) : void 0,
        nonce: W.nonce ? hexToNumber(W.nonce) : void 0,
        to: W.to ? W.to : null,
        transactionIndex: W.transactionIndex ? Number(W.transactionIndex) : null,
        type: W.type ? transactionType[W.type] : void 0,
        typeHex: W.type ? W.type : void 0,
        value: W.value ? BigInt(W.value) : void 0,
        v: W.v ? BigInt(W.v) : void 0
    };
    return z.yParity = (()=>{
        if (W.yParity)
            return Number(W.yParity);
        if (typeof z.v == "bigint") {
            if (z.v === 0n || z.v === 27n)
                return 0;
            if (z.v === 1n || z.v === 28n)
                return 1;
            if (z.v >= 35n)
                return z.v % 2n === 0n ? 1 : 0
        }
    }
    )(),
    z.type === "legacy" && (delete z.accessList,
    delete z.maxFeePerGas,
    delete z.maxPriorityFeePerGas,
    delete z.yParity),
    z.type === "eip2930" && (delete z.maxFeePerGas,
    delete z.maxPriorityFeePerGas),
    z
}
function formatBlock(W) {
    const z = W.transactions?.map(Y=>typeof Y == "string" ? Y : formatTransaction(Y));
    return {
        ...W,
        baseFeePerGas: W.baseFeePerGas ? BigInt(W.baseFeePerGas) : null,
        difficulty: W.difficulty ? BigInt(W.difficulty) : void 0,
        gasLimit: W.gasLimit ? BigInt(W.gasLimit) : void 0,
        gasUsed: W.gasUsed ? BigInt(W.gasUsed) : void 0,
        hash: W.hash ? W.hash : null,
        logsBloom: W.logsBloom ? W.logsBloom : null,
        nonce: W.nonce ? W.nonce : null,
        number: W.number ? BigInt(W.number) : null,
        size: W.size ? BigInt(W.size) : void 0,
        timestamp: W.timestamp ? BigInt(W.timestamp) : void 0,
        transactions: z,
        totalDifficulty: W.totalDifficulty ? BigInt(W.totalDifficulty) : null
    }
}
async function getBlock(W, {blockHash: z, blockNumber: Y, blockTag: ne, includeTransactions: le}={}) {
    const ue = ne ?? "latest"
      , de = le ?? !1
      , he = Y !== void 0 ? numberToHex(Y) : void 0;
    let fe = null;
    if (fe = z ? await W.request({
        method: "eth_getBlockByHash",
        params: [z, de]
    }) : await W.request({
        method: "eth_getBlockByNumber",
        params: [he || ue, de]
    }),
    !fe)
        throw new BlockNotFoundError({
            blockHash: z,
            blockNumber: Y
        });
    return (W.chain?.formatters?.block?.format || formatBlock)(fe)
}
async function getGasPrice(W) {
    const z = await W.request({
        method: "eth_gasPrice"
    });
    return BigInt(z)
}
async function estimateMaxPriorityFeePerGas(W, z) {
    return internal_estimateMaxPriorityFeePerGas(W, z)
}
async function internal_estimateMaxPriorityFeePerGas(W, z) {
    const {block: Y, chain: ne=W.chain, request: le} = z || {};
    if (typeof ne?.fees?.defaultPriorityFee == "function") {
        const ue = Y || await getAction(W, getBlock, "getBlock")({});
        return ne.fees.defaultPriorityFee({
            block: ue,
            client: W,
            request: le
        })
    }
    if (ne?.fees?.defaultPriorityFee !== void 0)
        return ne?.fees?.defaultPriorityFee;
    try {
        return hexToBigInt(await W.request({
            method: "eth_maxPriorityFeePerGas"
        }))
    } catch {
        const [ue,de] = await Promise.all([Y ? Promise.resolve(Y) : getAction(W, getBlock, "getBlock")({}), getAction(W, getGasPrice, "getGasPrice")({})]);
        if (typeof ue.baseFeePerGas != "bigint")
            throw new Eip1559FeesNotSupportedError;
        const he = de - ue.baseFeePerGas;
        return he < 0n ? 0n : he
    }
}
async function estimateFeesPerGas(W, z) {
    return internal_estimateFeesPerGas(W, z)
}
async function internal_estimateFeesPerGas(W, z) {
    const {block: Y, chain: ne=W.chain, request: le, type: ue="eip1559"} = z || {}
      , de = await (async()=>typeof ne?.fees?.baseFeeMultiplier == "function" ? ne.fees.baseFeeMultiplier({
        block: Y,
        client: W,
        request: le
    }) : ne?.fees?.baseFeeMultiplier ?? 1.2)();
    if (de < 1)
        throw new BaseFeeScalarError;
    const he = 10 ** (de.toString().split(".")[1]?.length ?? 0)
      , fe = xe=>xe * BigInt(Math.ceil(de * he)) / BigInt(he)
      , ge = Y || await getAction(W, getBlock, "getBlock")({});
    if (typeof ne?.fees?.estimateFeesPerGas == "function")
        return ne.fees.estimateFeesPerGas({
            block: Y,
            client: W,
            multiply: fe,
            request: le,
            type: ue
        });
    if (ue === "eip1559") {
        if (typeof ge.baseFeePerGas != "bigint")
            throw new Eip1559FeesNotSupportedError;
        const xe = le?.maxPriorityFeePerGas ? le.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(W, {
            block: ge,
            chain: ne,
            request: le
        })
          , $e = fe(ge.baseFeePerGas);
        return {
            maxFeePerGas: le?.maxFeePerGas ?? $e + xe,
            maxPriorityFeePerGas: xe
        }
    }
    return {
        gasPrice: le?.gasPrice ?? fe(await getAction(W, getGasPrice, "getGasPrice")({}))
    }
}
async function getTransactionCount(W, {address: z, blockTag: Y="latest", blockNumber: ne}) {
    return hexToNumber(await W.request({
        method: "eth_getTransactionCount",
        params: [z, ne ? numberToHex(ne) : Y]
    }))
}
function getTransactionType(W) {
    if (W.type)
        return W.type;
    if (W.maxFeePerGas !== void 0 || W.maxPriorityFeePerGas !== void 0)
        return "eip1559";
    if (W.gasPrice !== void 0)
        return W.accessList !== void 0 ? "eip2930" : "legacy";
    throw new InvalidSerializableTransactionError({
        transaction: W
    })
}
async function prepareTransactionRequest(W, z) {
    const {account: Y=W.account, chain: ne, gas: le, nonce: ue, type: de} = z;
    if (!Y)
        throw new AccountNotFoundError;
    const he = parseAccount(Y)
      , fe = await getAction(W, getBlock, "getBlock")({
        blockTag: "latest"
    })
      , ge = {
        ...z,
        from: he.address
    };
    if (ue === void 0 && (ge.nonce = await getAction(W, getTransactionCount, "getTransactionCount")({
        address: he.address,
        blockTag: "pending"
    })),
    de === void 0)
        try {
            ge.type = getTransactionType(ge)
        } catch {
            ge.type = typeof fe.baseFeePerGas == "bigint" ? "eip1559" : "legacy"
        }
    if (ge.type === "eip1559") {
        const {maxFeePerGas: xe, maxPriorityFeePerGas: $e} = await internal_estimateFeesPerGas(W, {
            block: fe,
            chain: ne,
            request: ge
        });
        if (z.maxPriorityFeePerGas === void 0 && z.maxFeePerGas && z.maxFeePerGas < $e)
            throw new MaxFeePerGasTooLowError({
                maxPriorityFeePerGas: $e
            });
        ge.maxPriorityFeePerGas = $e,
        ge.maxFeePerGas = xe
    } else {
        if (z.maxFeePerGas !== void 0 || z.maxPriorityFeePerGas !== void 0)
            throw new Eip1559FeesNotSupportedError;
        const {gasPrice: xe} = await internal_estimateFeesPerGas(W, {
            block: fe,
            chain: ne,
            request: ge,
            type: "legacy"
        });
        ge.gasPrice = xe
    }
    return le === void 0 && (ge.gas = await getAction(W, estimateGas, "estimateGas")({
        ...ge,
        account: {
            address: he.address,
            type: "json-rpc"
        }
    })),
    assertRequest(ge),
    ge
}
async function estimateGas(W, z) {
    const Y = z.account ?? W.account;
    if (!Y)
        throw new AccountNotFoundError({
            docsPath: "/docs/actions/public/estimateGas"
        });
    const ne = parseAccount(Y);
    try {
        const {accessList: le, blockNumber: ue, blockTag: de, data: he, gas: fe, gasPrice: ge, maxFeePerGas: xe, maxPriorityFeePerGas: $e, nonce: Ee, to: Se, value: Ne, ...tt} = ne.type === "local" ? await prepareTransactionRequest(W, z) : z
          , rr = (ue ? numberToHex(ue) : void 0) || de;
        assertRequest(z);
        const tr = W.chain?.formatters?.transactionRequest?.format
          , we = (tr || formatTransactionRequest)({
            ...extract(tt, {
                format: tr
            }),
            from: ne.address,
            accessList: le,
            data: he,
            gas: fe,
            gasPrice: ge,
            maxFeePerGas: xe,
            maxPriorityFeePerGas: $e,
            nonce: Ee,
            to: Se,
            value: Ne
        })
          , Ut = await W.request({
            method: "eth_estimateGas",
            params: rr ? [we, rr] : [we]
        });
        return BigInt(Ut)
    } catch (le) {
        throw getEstimateGasError(le, {
            ...z,
            account: ne,
            chain: W.chain
        })
    }
}
async function estimateContractGas(W, {abi: z, address: Y, args: ne, functionName: le, ...ue}) {
    const de = encodeFunctionData({
        abi: z,
        args: ne,
        functionName: le
    });
    try {
        return await getAction(W, estimateGas, "estimateGas")({
            data: de,
            to: Y,
            ...ue
        })
    } catch (he) {
        const fe = ue.account ? parseAccount(ue.account) : void 0;
        throw getContractError(he, {
            abi: z,
            address: Y,
            args: ne,
            docsPath: "/docs/contract/estimateContractGas",
            functionName: le,
            sender: fe?.address
        })
    }
}
const docsPath$2 = "/docs/contract/decodeEventLog";
function decodeEventLog({abi: W, data: z, strict: Y, topics: ne}) {
    const le = Y ?? !0
      , [ue,...de] = ne;
    if (!ue)
        throw new AbiEventSignatureEmptyTopicsError({
            docsPath: docsPath$2
        });
    const he = W.find(Ne=>Ne.type === "event" && ue === getEventSelector(formatAbiItem(Ne)));
    if (!he || !("name"in he) || he.type !== "event")
        throw new AbiEventSignatureNotFoundError(ue,{
            docsPath: docsPath$2
        });
    const {name: fe, inputs: ge} = he
      , xe = ge?.some(Ne=>!("name"in Ne && Ne.name));
    let $e = xe ? [] : {};
    const Ee = ge.filter(Ne=>"indexed"in Ne && Ne.indexed);
    for (let Ne = 0; Ne < Ee.length; Ne++) {
        const tt = Ee[Ne]
          , rr = de[Ne];
        if (!rr)
            throw new DecodeLogTopicsMismatch({
                abiItem: he,
                param: tt
            });
        $e[tt.name || Ne] = decodeTopic({
            param: tt,
            value: rr
        })
    }
    const Se = ge.filter(Ne=>!("indexed"in Ne && Ne.indexed));
    if (Se.length > 0) {
        if (z && z !== "0x")
            try {
                const Ne = decodeAbiParameters(Se, z);
                if (Ne)
                    if (xe)
                        $e = [...$e, ...Ne];
                    else
                        for (let tt = 0; tt < Se.length; tt++)
                            $e[Se[tt].name] = Ne[tt]
            } catch (Ne) {
                if (le)
                    throw Ne instanceof AbiDecodingDataSizeTooSmallError ? new DecodeLogDataMismatch({
                        abiItem: he,
                        data: Ne.data,
                        params: Ne.params,
                        size: Ne.size
                    }) : Ne
            }
        else if (le)
            throw new DecodeLogDataMismatch({
                abiItem: he,
                data: "0x",
                params: Se,
                size: 0
            })
    }
    return {
        eventName: fe,
        args: Object.values($e).length > 0 ? $e : void 0
    }
}
function decodeTopic({param: W, value: z}) {
    return W.type === "string" || W.type === "bytes" || W.type === "tuple" || W.type.match(/^(.*)\[(\d+)?\]$/) ? z : (decodeAbiParameters([W], z) || [])[0]
}
function formatLog(W, {args: z, eventName: Y}={}) {
    return {
        ...W,
        blockHash: W.blockHash ? W.blockHash : null,
        blockNumber: W.blockNumber ? BigInt(W.blockNumber) : null,
        logIndex: W.logIndex ? Number(W.logIndex) : null,
        transactionHash: W.transactionHash ? W.transactionHash : null,
        transactionIndex: W.transactionIndex ? Number(W.transactionIndex) : null,
        ...Y ? {
            args: z,
            eventName: Y
        } : {}
    }
}
async function getLogs(W, {address: z, blockHash: Y, fromBlock: ne, toBlock: le, event: ue, events: de, args: he, strict: fe}={}) {
    const ge = fe ?? !1
      , xe = de ?? (ue ? [ue] : void 0);
    let $e, Ee = [];
    return xe && (Ee = [xe.flatMap(Se=>encodeEventTopics({
        abi: [Se],
        eventName: Se.name,
        args: he
    }))],
    ue && (Ee = Ee[0])),
    $e = Y ? await W.request({
        method: "eth_getLogs",
        params: [{
            address: z,
            topics: Ee,
            blockHash: Y
        }]
    }) : await W.request({
        method: "eth_getLogs",
        params: [{
            address: z,
            topics: Ee,
            fromBlock: typeof ne == "bigint" ? numberToHex(ne) : ne,
            toBlock: typeof le == "bigint" ? numberToHex(le) : le
        }]
    }),
    $e.map(Se=>{
        try {
            const {eventName: Ne, args: tt} = xe ? decodeEventLog({
                abi: xe,
                data: Se.data,
                topics: Se.topics,
                strict: ge
            }) : {
                eventName: void 0,
                args: void 0
            };
            return formatLog(Se, {
                args: tt,
                eventName: Ne
            })
        } catch (Ne) {
            let tt, rr;
            if (Ne instanceof DecodeLogDataMismatch || Ne instanceof DecodeLogTopicsMismatch) {
                if (ge)
                    return;
                tt = Ne.abiItem.name,
                rr = Ne.abiItem.inputs?.some(tr=>!("name"in tr && tr.name))
            }
            return formatLog(Se, {
                args: rr ? [] : {},
                eventName: tt
            })
        }
    }
    ).filter(Boolean)
}
async function getContractEvents(W, {abi: z, address: Y, args: ne, blockHash: le, eventName: ue, fromBlock: de, toBlock: he, strict: fe}) {
    const ge = ue ? getAbiItem({
        abi: z,
        name: ue
    }) : void 0
      , xe = ge ? void 0 : z.filter($e=>$e.type === "event");
    return getAction(W, getLogs, "getLogs")({
        address: Y,
        args: ne,
        blockHash: le,
        event: ge,
        events: xe,
        fromBlock: de,
        toBlock: he,
        strict: fe
    })
}
const docsPath$1 = "/docs/contract/decodeFunctionResult";
function decodeFunctionResult({abi: W, args: z, functionName: Y, data: ne}) {
    let le = W[0];
    if (Y && (le = getAbiItem({
        abi: W,
        args: z,
        name: Y
    }),
    !le))
        throw new AbiFunctionNotFoundError(Y,{
            docsPath: docsPath$1
        });
    if (le.type !== "function")
        throw new AbiFunctionNotFoundError(void 0,{
            docsPath: docsPath$1
        });
    if (!le.outputs)
        throw new AbiFunctionOutputsNotFoundError(le.name,{
            docsPath: docsPath$1
        });
    const ue = decodeAbiParameters(le.outputs, ne);
    return ue && ue.length > 1 ? ue : ue && ue.length === 1 ? ue[0] : void 0
}
const scriptRel = "modulepreload"
  , assetsURL = function(W) {
    return "/" + W
}
  , seen = {}
  , __vitePreload = function(W, z, Y) {
    if (!z || z.length === 0)
        return W();
    const ne = document.getElementsByTagName("link");
    return Promise.all(z.map(le=>{
        if ((le = assetsURL(le))in seen)
            return;
        seen[le] = !0;
        const ue = le.endsWith(".css")
          , de = ue ? '[rel="stylesheet"]' : "";
        if (Y)
            for (let fe = ne.length - 1; fe >= 0; fe--) {
                const ge = ne[fe];
                if (ge.href === le && (!ue || ge.rel === "stylesheet"))
                    return
            }
        else if (document.querySelector(`link[href="${le}"]${de}`))
            return;
        const he = document.createElement("link");
        return he.rel = ue ? "stylesheet" : scriptRel,
        ue || (he.as = "script",
        he.crossOrigin = ""),
        he.href = le,
        document.head.appendChild(he),
        ue ? new Promise((fe,ge)=>{
            he.addEventListener("load", fe),
            he.addEventListener("error", ()=>ge(new Error(`Unable to preload CSS for ${le}`)))
        }
        ) : void 0
    }
    )).then(()=>W()).catch(le=>{
        const ue = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (ue.payload = le,
        window.dispatchEvent(ue),
        !ue.defaultPrevented)
            throw le
    }
    )
}
  , multicall3Abi = [{
    inputs: [{
        components: [{
            name: "target",
            type: "address"
        }, {
            name: "allowFailure",
            type: "bool"
        }, {
            name: "callData",
            type: "bytes"
        }],
        name: "calls",
        type: "tuple[]"
    }],
    name: "aggregate3",
    outputs: [{
        components: [{
            name: "success",
            type: "bool"
        }, {
            name: "returnData",
            type: "bytes"
        }],
        name: "returnData",
        type: "tuple[]"
    }],
    stateMutability: "view",
    type: "function"
}]
  , universalResolverErrors = [{
    inputs: [],
    name: "ResolverNotFound",
    type: "error"
}, {
    inputs: [],
    name: "ResolverWildcardNotSupported",
    type: "error"
}]
  , universalResolverResolveAbi = [...universalResolverErrors, {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [{
        name: "name",
        type: "bytes"
    }, {
        name: "data",
        type: "bytes"
    }],
    outputs: [{
        name: "",
        type: "bytes"
    }, {
        name: "address",
        type: "address"
    }]
}]
  , universalResolverReverseAbi = [...universalResolverErrors, {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [{
        type: "bytes",
        name: "reverseName"
    }],
    outputs: [{
        type: "string",
        name: "resolvedName"
    }, {
        type: "address",
        name: "resolvedAddress"
    }, {
        type: "address",
        name: "reverseResolver"
    }, {
        type: "address",
        name: "resolver"
    }]
}]
  , textResolverAbi = [{
    name: "text",
    type: "function",
    stateMutability: "view",
    inputs: [{
        name: "name",
        type: "bytes32"
    }, {
        name: "key",
        type: "string"
    }],
    outputs: [{
        name: "",
        type: "string"
    }]
}]
  , addressResolverAbi = [{
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [{
        name: "name",
        type: "bytes32"
    }],
    outputs: [{
        name: "",
        type: "address"
    }]
}, {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [{
        name: "name",
        type: "bytes32"
    }, {
        name: "coinType",
        type: "uint256"
    }],
    outputs: [{
        name: "",
        type: "bytes"
    }]
}]
  , universalSignatureValidatorAbi = [{
    inputs: [{
        internalType: "address",
        name: "_signer",
        type: "address"
    }, {
        internalType: "bytes32",
        name: "_hash",
        type: "bytes32"
    }, {
        internalType: "bytes",
        name: "_signature",
        type: "bytes"
    }],
    stateMutability: "nonpayable",
    type: "constructor"
}]
  , aggregate3Signature = "0x82ad56cb";
class ChainDoesNotSupportContract extends BaseError {
    constructor({blockNumber: z, chain: Y, contract: ne}) {
        super(`Chain "${Y.name}" does not support contract "${ne.name}".`, {
            metaMessages: ["This could be due to any of the following:", ...z && ne.blockCreated && ne.blockCreated > z ? [`- The contract "${ne.name}" was not deployed until block ${ne.blockCreated} (current block ${z}).`] : [`- The chain does not have the contract "${ne.name}" configured.`]]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ChainDoesNotSupportContract"
        })
    }
}
let ChainMismatchError$1 = class extends BaseError {
    constructor({chain: W, currentChainId: z}) {
        super(`The current chain of the wallet (id: ${z}) does not match the target chain for the transaction (id: ${W.id} â ${W.name}).`, {
            metaMessages: [`Current Chain ID:  ${z}`, `Expected Chain ID: ${W.id} â ${W.name}`]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ChainMismatchError"
        })
    }
}
;
class ChainNotFoundError extends BaseError {
    constructor() {
        super(["No chain was provided to the request.", "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."].join(`
`)),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ChainNotFoundError"
        })
    }
}
class ClientChainNotConfiguredError extends BaseError {
    constructor() {
        super("No chain was provided to the Client."),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "ClientChainNotConfiguredError"
        })
    }
}
function getChainContractAddress({blockNumber: W, chain: z, contract: Y}) {
    const ne = z?.contracts?.[Y];
    if (!ne)
        throw new ChainDoesNotSupportContract({
            chain: z,
            contract: {
                name: Y
            }
        });
    if (W && ne.blockCreated && ne.blockCreated > W)
        throw new ChainDoesNotSupportContract({
            blockNumber: W,
            chain: z,
            contract: {
                name: Y,
                blockCreated: ne.blockCreated
            }
        });
    return ne.address
}
function getCallError(W, {docsPath: z, ...Y}) {
    const ne = (()=>{
        const le = getNodeError(W, Y);
        return le instanceof UnknownNodeError ? W : le
    }
    )();
    return new CallExecutionError(ne,{
        docsPath: z,
        ...Y
    })
}
const schedulerCache = new Map;
function createBatchScheduler({fn: W, id: z, shouldSplitBatch: Y, wait: ne=0, sort: le}) {
    const ue = async()=>{
        const ge = he();
        de();
        const xe = ge.map(({args: $e})=>$e);
        xe.length !== 0 && W(xe).then($e=>{
            le && Array.isArray($e) && $e.sort(le);
            for (let Ee = 0; Ee < ge.length; Ee++) {
                const {pendingPromise: Se} = ge[Ee];
                Se.resolve?.([$e[Ee], $e])
            }
        }
        ).catch($e=>{
            for (let Ee = 0; Ee < ge.length; Ee++) {
                const {pendingPromise: Se} = ge[Ee];
                Se.reject?.($e)
            }
        }
        )
    }
      , de = ()=>schedulerCache.delete(z)
      , he = ()=>schedulerCache.get(z) || []
      , fe = ge=>schedulerCache.set(z, [...he(), ge]);
    return {
        flush: de,
        async schedule(ge) {
            const xe = {}
              , $e = new Promise((Se,Ne)=>{
                xe.resolve = Se,
                xe.reject = Ne
            }
            );
            return Y?.([...he().map(({args: Se})=>Se), ge]) && ue(),
            he().length > 0 ? (fe({
                args: ge,
                pendingPromise: xe
            }),
            $e) : (fe({
                args: ge,
                pendingPromise: xe
            }),
            setTimeout(ue, ne),
            $e)
        }
    }
}
async function call(W, z) {
    const {account: Y=W.account, batch: ne=!!W.batch?.multicall, blockNumber: le, blockTag: ue="latest", accessList: de, data: he, gas: fe, gasPrice: ge, maxFeePerGas: xe, maxPriorityFeePerGas: $e, nonce: Ee, to: Se, value: Ne, ...tt} = z
      , rr = Y ? parseAccount(Y) : void 0;
    try {
        assertRequest(z);
        const tr = (le ? numberToHex(le) : void 0) || ue
          , we = W.chain?.formatters?.transactionRequest?.format
          , Ut = (we || formatTransactionRequest)({
            ...extract(tt, {
                format: we
            }),
            from: rr?.address,
            accessList: de,
            data: he,
            gas: fe,
            gasPrice: ge,
            maxFeePerGas: xe,
            maxPriorityFeePerGas: $e,
            nonce: Ee,
            to: Se,
            value: Ne
        });
        if (ne && shouldPerformMulticall({
            request: Ut
        }))
            try {
                return await scheduleMulticall(W, {
                    ...Ut,
                    blockNumber: le,
                    blockTag: ue
                })
            } catch (cr) {
                if (!(cr instanceof ClientChainNotConfiguredError || cr instanceof ChainDoesNotSupportContract))
                    throw cr
            }
        const lr = await W.request({
            method: "eth_call",
            params: tr ? [Ut, tr] : [Ut]
        });
        return lr === "0x" ? {
            data: void 0
        } : {
            data: lr
        }
    } catch (tr) {
        /*const we = getRevertErrorData(tr)
          , {offchainLookup: Ut, offchainLookupSignature: lr} = await __vitePreload(()=>import("./ccip.b001dd89.js"), []);
        if (we?.slice(0, 10) === lr && Se)
            return {
                data: await Ut(W, {
                    data: we,
                    to: Se
                })
            };
        throw getCallError(tr, {
            ...z,
            account: rr,
            chain: W.chain
        })*/
    }
}
function shouldPerformMulticall({request: W}) {
    const {data: z, to: Y, ...ne} = W;
    return !!z && !z.startsWith(aggregate3Signature) && !!Y && !(Object.values(ne).filter(le=>le !== void 0).length > 0)
}
async function scheduleMulticall(W, z) {
    const {batchSize: Y=1024, wait: ne=0} = typeof W.batch?.multicall == "object" ? W.batch.multicall : {}
      , {blockNumber: le, blockTag: ue="latest", data: de, multicallAddress: he, to: fe} = z;
    let ge = he;
    if (!ge) {
        if (!W.chain)
            throw new ClientChainNotConfiguredError;
        ge = getChainContractAddress({
            blockNumber: le,
            chain: W.chain,
            contract: "multicall3"
        })
    }
    const xe = (le ? numberToHex(le) : void 0) || ue
      , {schedule: $e} = createBatchScheduler({
        id: `${W.uid}.${xe}`,
        wait: ne,
        shouldSplitBatch(Ne) {
            return Ne.reduce((rr,{data: tr})=>rr + (tr.length - 2), 0) > 2 * Y
        },
        fn: async Ne=>{
            const tt = Ne.map(we=>({
                allowFailure: !0,
                callData: we.data,
                target: we.to
            }))
              , rr = encodeFunctionData({
                abi: multicall3Abi,
                args: [tt],
                functionName: "aggregate3"
            })
              , tr = await W.request({
                method: "eth_call",
                params: [{
                    data: rr,
                    to: ge
                }, xe]
            });
            return decodeFunctionResult({
                abi: multicall3Abi,
                args: [tt],
                functionName: "aggregate3",
                data: tr || "0x"
            })
        }
    })
      , [{returnData: Ee, success: Se}] = await $e({
        data: de,
        to: fe
    });
    if (!Se)
        throw new RawContractError({
            data: Ee
        });
    return Ee === "0x" ? {
        data: void 0
    } : {
        data: Ee
    }
}
function getRevertErrorData(W) {
    if (!(W instanceof BaseError))
        return;
    const z = W.walk();
    return typeof z.data == "object" ? z.data.data : z.data
}
async function readContract$1(W, {abi: z, address: Y, args: ne, functionName: le, ...ue}) {
    const de = encodeFunctionData({
        abi: z,
        args: ne,
        functionName: le
    });
    try {
        const {data: he} = await getAction(W, call, "call")({
            data: de,
            to: Y,
            ...ue
        });
        return decodeFunctionResult({
            abi: z,
            args: ne,
            functionName: le,
            data: he || "0x"
        })
    } catch (he) {
        throw getContractError(he, {
            abi: z,
            address: Y,
            args: ne,
            docsPath: "/docs/contract/readContract",
            functionName: le
        })
    }
}
async function simulateContract(W, {abi: z, address: Y, args: ne, dataSuffix: le, functionName: ue, ...de}) {
    const he = de.account ? parseAccount(de.account) : void 0
      , fe = encodeFunctionData({
        abi: z,
        args: ne,
        functionName: ue
    });
    try {
        const {data: ge} = await getAction(W, call, "call")({
            batch: !1,
            data: `${fe}${le ? le.replace("0x", "") : ""}`,
            to: Y,
            ...de
        });
        return {
            result: decodeFunctionResult({
                abi: z,
                args: ne,
                functionName: ue,
                data: ge || "0x"
            }),
            request: {
                abi: z,
                address: Y,
                args: ne,
                dataSuffix: le,
                functionName: ue,
                ...de
            }
        }
    } catch (ge) {
        throw getContractError(ge, {
            abi: z,
            address: Y,
            args: ne,
            docsPath: "/docs/contract/simulateContract",
            functionName: ue,
            sender: he?.address
        })
    }
}
const listenersCache = new Map
  , cleanupCache = new Map;
let callbackCount = 0;
function observe(W, z, Y) {
    const ne = ++callbackCount
      , le = ()=>listenersCache.get(W) || []
      , ue = ()=>{
        const ge = cleanupCache.get(W);
        le().length === 1 && ge && ge(),
        (()=>{
            const xe = le();
            listenersCache.set(W, xe.filter($e=>$e.id !== ne))
        }
        )()
    }
      , de = le();
    if (listenersCache.set(W, [...de, {
        id: ne,
        fns: z
    }]),
    de && de.length > 0)
        return ue;
    const he = {};
    for (const ge in z)
        he[ge] = (...xe)=>{
            const $e = le();
            if ($e.length !== 0)
                for (const Ee of $e)
                    Ee.fns[ge]?.(...xe)
        }
        ;
    const fe = Y(he);
    return typeof fe == "function" && cleanupCache.set(W, fe),
    ue
}
async function wait(W) {
    return new Promise(z=>setTimeout(z, W))
}
function poll(W, {emitOnBegin: z, initialWaitTime: Y, interval: ne}) {
    let le = !0;
    const ue = ()=>le = !1;
    return (async()=>{
        let de;
        z && (de = await W({
            unpoll: ue
        }));
        const he = await Y?.(de) ?? ne;
        await wait(he);
        const fe = async()=>{
            le && (await W({
                unpoll: ue
            }),
            await wait(ne),
            fe())
        }
        ;
        fe()
    }
    )(),
    ue
}
const promiseCache = new Map
  , responseCache = new Map;
function getCache(W) {
    const z = (le,ue)=>({
        clear: ()=>ue.delete(le),
        get: ()=>ue.get(le),
        set: de=>ue.set(le, de)
    })
      , Y = z(W, promiseCache)
      , ne = z(W, responseCache);
    return {
        clear: ()=>{
            Y.clear(),
            ne.clear()
        }
        ,
        promise: Y,
        response: ne
    }
}
async function withCache(W, {cacheKey: z, cacheTime: Y=1 / 0}) {
    const ne = getCache(z)
      , le = ne.response.get();
    if (le && Y > 0 && new Date().getTime() - le.created.getTime() < Y)
        return le.data;
    let ue = ne.promise.get();
    ue || (ue = W(),
    ne.promise.set(ue));
    try {
        const de = await ue;
        return ne.response.set({
            created: new Date,
            data: de
        }),
        de
    } finally {
        ne.promise.clear()
    }
}
const cacheKey = W=>`blockNumber.${W}`;
async function getBlockNumber(W, {cacheTime: z=W.cacheTime, maxAge: Y}={}) {
    const ne = await withCache(()=>W.request({
        method: "eth_blockNumber"
    }), {
        cacheKey: cacheKey(W.uid),
        cacheTime: Y ?? z
    });
    return BigInt(ne)
}
async function getFilterChanges(W, {filter: z}) {
    const Y = "strict"in z && z.strict;
    return (await z.request({
        method: "eth_getFilterChanges",
        params: [z.id]
    })).map(ne=>{
        if (typeof ne == "string")
            return ne;
        try {
            const {eventName: le, args: ue} = "abi"in z && z.abi ? decodeEventLog({
                abi: z.abi,
                data: ne.data,
                topics: ne.topics,
                strict: Y
            }) : {
                eventName: void 0,
                args: void 0
            };
            return formatLog(ne, {
                args: ue,
                eventName: le
            })
        } catch (le) {
            let ue, de;
            if (le instanceof DecodeLogDataMismatch || le instanceof DecodeLogTopicsMismatch) {
                if ("strict"in z && z.strict)
                    return;
                ue = le.abiItem.name,
                de = le.abiItem.inputs?.some(he=>!("name"in he && he.name))
            }
            return formatLog(ne, {
                args: de ? [] : {},
                eventName: ue
            })
        }
    }
    ).filter(Boolean)
}
async function uninstallFilter(W, {filter: z}) {
    return z.request({
        method: "eth_uninstallFilter",
        params: [z.id]
    })
}
function watchContractEvent(W, {abi: z, address: Y, args: ne, batch: le=!0, eventName: ue, onError: de, onLogs: he, poll: fe, pollingInterval: ge=W.pollingInterval, strict: xe}) {
    return (fe !== void 0 ? fe : W.transport.type !== "webSocket") ? (()=>{
        const $e = stringify(["watchContractEvent", Y, ne, le, W.uid, ue, ge])
          , Ee = xe ?? !1;
        return observe($e, {
            onLogs: he,
            onError: de
        }, Se=>{
            let Ne, tt, rr = !1;
            const tr = poll(async()=>{
                if (rr)
                    try {
                        let we;
                        if (tt)
                            we = await getAction(W, getFilterChanges, "getFilterChanges")({
                                filter: tt
                            });
                        else {
                            const Ut = await getAction(W, getBlockNumber, "getBlockNumber")({});
                            we = Ne && Ne !== Ut ? await getAction(W, getContractEvents, "getContractEvents")({
                                abi: z,
                                address: Y,
                                args: ne,
                                eventName: ue,
                                fromBlock: Ne + 1n,
                                toBlock: Ut,
                                strict: Ee
                            }) : [],
                            Ne = Ut
                        }
                        if (we.length === 0)
                            return;
                        if (le)
                            Se.onLogs(we);
                        else
                            for (const Ut of we)
                                Se.onLogs([Ut])
                    } catch (we) {
                        tt && we instanceof InvalidInputRpcError && (rr = !1),
                        Se.onError?.(we)
                    }
                else {
                    try {
                        tt = await getAction(W, createContractEventFilter, "createContractEventFilter")({
                            abi: z,
                            address: Y,
                            args: ne,
                            eventName: ue,
                            strict: Ee
                        })
                    } catch {}
                    rr = !0
                }
            }
            , {
                emitOnBegin: !0,
                interval: ge
            });
            return async()=>{
                tt && await getAction(W, uninstallFilter, "uninstallFilter")({
                    filter: tt
                }),
                tr()
            }
        }
        )
    }
    )() : (()=>{
        let $e = !0
          , Ee = ()=>$e = !1;
        return (async()=>{
            try {
                const Se = ue ? encodeEventTopics({
                    abi: z,
                    eventName: ue,
                    args: ne
                }) : []
                  , {unsubscribe: Ne} = await W.transport.subscribe({
                    params: ["logs", {
                        address: Y,
                        topics: Se
                    }],
                    onData(tt) {
                        if (!$e)
                            return;
                        const rr = tt.result;
                        try {
                            const {eventName: tr, args: we} = decodeEventLog({
                                abi: z,
                                data: rr.data,
                                topics: rr.topics,
                                strict: xe
                            })
                              , Ut = formatLog(rr, {
                                args: we,
                                eventName: tr
                            });
                            he([Ut])
                        } catch (tr) {
                            let we, Ut;
                            if (tr instanceof DecodeLogDataMismatch || tr instanceof DecodeLogTopicsMismatch) {
                                if (xe)
                                    return;
                                we = tr.abiItem.name,
                                Ut = tr.abiItem.inputs?.some(cr=>!("name"in cr && cr.name))
                            }
                            const lr = formatLog(rr, {
                                args: Ut ? [] : {},
                                eventName: we
                            });
                            he([lr])
                        }
                    },
                    onError(tt) {
                        de?.(tt)
                    }
                });
                Ee = Ne,
                $e || Ee()
            } catch (Se) {
                de?.(Se)
            }
        }
        )(),
        Ee
    }
    )()
}
function assertCurrentChain({chain: W, currentChainId: z}) {
    if (!W)
        throw new ChainNotFoundError;
    if (z !== W.id)
        throw new ChainMismatchError$1({
            chain: W,
            currentChainId: z
        })
}
function getTransactionError(W, {docsPath: z, ...Y}) {
    const ne = (()=>{
        const le = getNodeError(W, Y);
        return le instanceof UnknownNodeError ? W : le
    }
    )();
    return new TransactionExecutionError(ne,{
        docsPath: z,
        ...Y
    })
}
async function getChainId(W) {
    return hexToNumber(await W.request({
        method: "eth_chainId"
    }))
}
async function sendRawTransaction(W, {serializedTransaction: z}) {
    return W.request({
        method: "eth_sendRawTransaction",
        params: [z]
    })
}
async function sendTransaction(W, z) {
    const {account: Y=W.account, chain: ne=W.chain, accessList: le, data: ue, gas: de, gasPrice: he, maxFeePerGas: fe, maxPriorityFeePerGas: ge, nonce: xe, to: $e, value: Ee, ...Se} = z;
    if (!Y)
        throw new AccountNotFoundError({
            docsPath: "/docs/actions/wallet/sendTransaction"
        });
    const Ne = parseAccount(Y);
    try {
        let tt;
        if (assertRequest(z),
        ne !== null && (tt = await getAction(W, getChainId, "getChainId")({}),
        assertCurrentChain({
            currentChainId: tt,
            chain: ne
        })),
        Ne.type === "local") {
            const we = await getAction(W, prepareTransactionRequest, "prepareTransactionRequest")({
                account: Ne,
                accessList: le,
                chain: ne,
                data: ue,
                gas: de,
                gasPrice: he,
                maxFeePerGas: fe,
                maxPriorityFeePerGas: ge,
                nonce: xe,
                to: $e,
                value: Ee,
                ...Se
            });
            tt || (tt = await getAction(W, getChainId, "getChainId")({}));
            const Ut = ne?.serializers?.transaction
              , lr = await Ne.signTransaction({
                ...we,
                chainId: tt
            }, {
                serializer: Ut
            });
            return await getAction(W, sendRawTransaction, "sendRawTransaction")({
                serializedTransaction: lr
            })
        }
        const rr = W.chain?.formatters?.transactionRequest?.format
          , tr = (rr || formatTransactionRequest)({
            ...extract(Se, {
                format: rr
            }),
            accessList: le,
            data: ue,
            from: Ne.address,
            gas: de,
            gasPrice: he,
            maxFeePerGas: fe,
            maxPriorityFeePerGas: ge,
            nonce: xe,
            to: $e,
            value: Ee
        });
        return await W.request({
            method: "eth_sendTransaction",
            params: [tr]
        })
    } catch (tt) {
        throw getTransactionError(tt, {
            ...z,
            account: Ne,
            chain: z.chain || void 0
        })
    }
}
async function writeContract$1(W, {abi: z, address: Y, args: ne, dataSuffix: le, functionName: ue, ...de}) {
    const he = encodeFunctionData({
        abi: z,
        args: ne,
        functionName: ue
    });
    return await getAction(W, sendTransaction, "sendTransaction")({
        data: `${he}${le ? le.replace("0x", "") : ""}`,
        to: Y,
        ...de
    })
}
async function addChain(W, {chain: z}) {
    const {id: Y, name: ne, nativeCurrency: le, rpcUrls: ue, blockExplorers: de} = z;
    await W.request({
        method: "wallet_addEthereumChain",
        params: [{
            chainId: numberToHex(Y),
            chainName: ne,
            nativeCurrency: le,
            rpcUrls: ue.default.http,
            blockExplorerUrls: de ? Object.values(de).map(({url: he})=>he) : void 0
        }]
    })
}
const size = 256;
let index$1 = size, buffer$1;
function uid(W=11) {
    if (!buffer$1 || index$1 + W > 2 * size) {
        buffer$1 = "",
        index$1 = 0;
        for (let z = 0; z < size; z++)
            buffer$1 += (256 + 256 * Math.random() | 0).toString(16).substring(1)
    }
    return buffer$1.substring(index$1, index$1++ + W)
}
function createClient(W) {
    const {batch: z, cacheTime: Y=W.pollingInterval ?? 4e3, key: ne="base", name: le="Base Client", pollingInterval: ue=4e3, type: de="base"} = W
      , he = W.chain
      , fe = W.account ? parseAccount(W.account) : void 0
      , {config: ge, request: xe, value: $e} = W.transport({
        chain: he,
        pollingInterval: ue
    })
      , Ee = {
        account: fe,
        batch: z,
        cacheTime: Y,
        chain: he,
        key: ne,
        name: le,
        pollingInterval: ue,
        request: xe,
        transport: {
            ...ge,
            ...$e
        },
        type: de,
        uid: uid()
    };
    return Object.assign(Ee, {
        extend: function Se(Ne) {
            return tt=>{
                const rr = tt(Ne);
                for (const we in Ee)
                    delete rr[we];
                const tr = {
                    ...Ne,
                    ...rr
                };
                return Object.assign(tr, {
                    extend: Se(tr)
                })
            }
        }(Ee)
    })
}
function withRetry(W, {delay: z=100, retryCount: Y=2, shouldRetry: ne=()=>!0}={}) {
    return new Promise((le,ue)=>{
        const de = async({count: he=0}={})=>{
            try {
                const fe = await W();
                le(fe)
            } catch (fe) {
                if (he < Y && await ne({
                    count: he,
                    error: fe
                }))
                    return (async({error: ge})=>{
                        const xe = typeof z == "function" ? z({
                            count: he,
                            error: ge
                        }) : z;
                        xe && await wait(xe),
                        de({
                            count: he + 1
                        })
                    }
                    )({
                        error: fe
                    });
                ue(fe)
            }
        }
        ;
        de()
    }
    )
}
const isDeterministicError = W=>"code"in W ? W.code !== -1 && W.code !== -32004 && W.code !== -32005 && W.code !== -32042 && W.code !== -32603 : !!(W instanceof HttpRequestError && W.status) && W.status !== 403 && W.status !== 408 && W.status !== 413 && W.status !== 429 && W.status !== 500 && W.status !== 502 && W.status !== 503 && W.status !== 504;
function buildRequest(W, {retryDelay: z=150, retryCount: Y=3}={}) {
    return async ne=>withRetry(async()=>{
        try {
            return await W(ne)
        } catch (le) {
            const ue = le;
            switch (ue.code) {
            case ParseRpcError.code:
                throw new ParseRpcError(ue);
            case InvalidRequestRpcError.code:
                throw new InvalidRequestRpcError(ue);
            case MethodNotFoundRpcError.code:
                throw new MethodNotFoundRpcError(ue);
            case InvalidParamsRpcError.code:
                throw new InvalidParamsRpcError(ue);
            case InternalRpcError.code:
                throw new InternalRpcError(ue);
            case InvalidInputRpcError.code:
                throw new InvalidInputRpcError(ue);
            case ResourceNotFoundRpcError.code:
                throw new ResourceNotFoundRpcError(ue);
            case ResourceUnavailableRpcError.code:
                throw new ResourceUnavailableRpcError(ue);
            case TransactionRejectedRpcError.code:
                throw new TransactionRejectedRpcError(ue);
            case MethodNotSupportedRpcError.code:
                throw new MethodNotSupportedRpcError(ue);
            case LimitExceededRpcError.code:
                throw new LimitExceededRpcError(ue);
            case JsonRpcVersionUnsupportedError.code:
                throw new JsonRpcVersionUnsupportedError(ue);
            case UserRejectedRequestError.code:
                throw new UserRejectedRequestError(ue);
            case UnauthorizedProviderError.code:
                throw new UnauthorizedProviderError(ue);
            case UnsupportedProviderMethodError.code:
                throw new UnsupportedProviderMethodError(ue);
            case ProviderDisconnectedError.code:
                throw new ProviderDisconnectedError(ue);
            case ChainDisconnectedError.code:
                throw new ChainDisconnectedError(ue);
            case SwitchChainError.code:
                throw new SwitchChainError(ue);
            case 5e3:
                throw new UserRejectedRequestError(ue);
            default:
                throw le instanceof BaseError ? le : new UnknownRpcError(ue)
            }
        }
    }
    , {
        delay: ({count: le, error: ue})=>{
            if (ue && ue instanceof HttpRequestError) {
                const de = ue?.headers?.get("Retry-After");
                if (de?.match(/\d/))
                    return 1e3 * parseInt(de)
            }
            return ~~(1 << le) * z
        }
        ,
        retryCount: Y,
        shouldRetry: ({error: le})=>!isDeterministicError(le)
    })
}
function createTransport({key: W, name: z, request: Y, retryCount: ne=3, retryDelay: le=150, timeout: ue, type: de}, he) {
    return {
        config: {
            key: W,
            name: z,
            request: Y,
            retryCount: ne,
            retryDelay: le,
            timeout: ue,
            type: de
        },
        request: buildRequest(Y, {
            retryCount: ne,
            retryDelay: le
        }),
        value: he
    }
}
function custom(W, z={}) {
    const {key: Y="custom", name: ne="Custom Provider", retryDelay: le} = z;
    return ({retryCount: ue})=>createTransport({
        key: Y,
        name: ne,
        request: W.request.bind(W),
        retryCount: z.retryCount ?? ue,
        retryDelay: le,
        type: "custom"
    })
}
function fallback(W, z={}) {
    const {key: Y="fallback", name: ne="Fallback", rank: le=!1, retryCount: ue, retryDelay: de} = z;
    return ({chain: he, pollingInterval: fe=4e3, timeout: ge})=>{
        let xe = W
          , $e = ()=>{}
        ;
        const Ee = createTransport({
            key: Y,
            name: ne,
            async request({method: Se, params: Ne}) {
                const tt = async(rr=0)=>{
                    const tr = xe[rr]({
                        chain: he,
                        retryCount: 0,
                        timeout: ge
                    });
                    try {
                        const we = await tr.request({
                            method: Se,
                            params: Ne
                        });
                        return $e({
                            method: Se,
                            params: Ne,
                            response: we,
                            transport: tr,
                            status: "success"
                        }),
                        we
                    } catch (we) {
                        if ($e({
                            error: we,
                            method: Se,
                            params: Ne,
                            transport: tr,
                            status: "error"
                        }),
                        isDeterministicError(we) || rr === xe.length - 1)
                            throw we;
                        return tt(rr + 1)
                    }
                }
                ;
                return tt()
            },
            retryCount: ue,
            retryDelay: de,
            type: "fallback"
        }, {
            onResponse: Se=>$e = Se,
            transports: xe.map(Se=>Se({
                chain: he,
                retryCount: 0
            }))
        });
        if (le) {
            const Se = typeof le == "object" ? le : {};
            rankTransports({
                chain: he,
                interval: Se.interval ?? fe,
                onTransports: Ne=>xe = Ne,
                sampleCount: Se.sampleCount,
                timeout: Se.timeout,
                transports: xe,
                weights: Se.weights
            })
        }
        return Ee
    }
}
function rankTransports({chain: W, interval: z=4e3, onTransports: Y, sampleCount: ne=10, timeout: le=1e3, transports: ue, weights: de={}}) {
    const {stability: he=.7, latency: fe=.3} = de
      , ge = []
      , xe = async()=>{
        const $e = await Promise.all(ue.map(async Ne=>{
            const tt = Ne({
                chain: W,
                retryCount: 0,
                timeout: le
            })
              , rr = Date.now();
            let tr, we;
            try {
                await tt.request({
                    method: "net_listening"
                }),
                we = 1
            } catch {
                we = 0
            } finally {
                tr = Date.now()
            }
            return {
                latency: tr - rr,
                success: we
            }
        }
        ));
        ge.push($e),
        ge.length > ne && ge.shift();
        const Ee = Math.max(...ge.map(Ne=>Math.max(...Ne.map(({latency: tt})=>tt))))
          , Se = ue.map((Ne,tt)=>{
            const rr = ge.map(lr=>lr[tt].latency)
              , tr = 1 - rr.reduce((lr,cr)=>lr + cr, 0) / rr.length / Ee
              , we = ge.map(lr=>lr[tt].success)
              , Ut = we.reduce((lr,cr)=>lr + cr, 0) / we.length;
            return Ut === 0 ? [0, tt] : [fe * tr + he * Ut, tt]
        }
        ).sort((Ne,tt)=>tt[0] - Ne[0]);
        Y(Se.map(([,Ne])=>ue[Ne])),
        await wait(z),
        xe()
    }
    ;
    xe()
}
class UrlRequiredError extends BaseError {
    constructor() {
        super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
            docsPath: "/docs/clients/intro"
        })
    }
}
function getNativeWebSocket() {
    if (typeof WebSocket < "u")
        return WebSocket;
    if (global.WebSocket !== void 0)
        return global.WebSocket;
    if (window.WebSocket !== void 0)
        return window.WebSocket;
    if (self.WebSocket !== void 0)
        return self.WebSocket;
    throw new Error("`WebSocket` is not supported in this environment")
}
const WebSocket$1 = getNativeWebSocket();
function withTimeout(W, {errorInstance: z=new Error("timed out"), timeout: Y, signal: ne}) {
    return new Promise((le,ue)=>{
        (async()=>{
            let de;
            try {
                const he = new AbortController;
                Y > 0 && (de = setTimeout(()=>{
                    ne ? he.abort() : ue(z)
                }
                , Y)),
                le(await W({
                    signal: he?.signal
                }))
            } catch (he) {
                he.name === "AbortError" && ue(z),
                ue(he)
            } finally {
                clearTimeout(de)
            }
        }
        )()
    }
    )
}
let id = 0;
async function http$1(W, {body: z, fetchOptions: Y={}, timeout: ne=1e4}) {
    const {headers: le, method: ue, signal: de} = Y;
    try {
        const he = await withTimeout(async({signal: ge})=>await fetch(W, {
            ...Y,
            body: Array.isArray(z) ? stringify(z.map(xe=>({
                jsonrpc: "2.0",
                id: xe.id ?? id++,
                ...xe
            }))) : stringify({
                jsonrpc: "2.0",
                id: z.id ?? id++,
                ...z
            }),
            headers: {
                ...le,
                "Content-Type": "application/json"
            },
            method: ue || "POST",
            signal: de || (ne > 0 ? ge : void 0)
        }), {
            errorInstance: new TimeoutError({
                body: z,
                url: W
            }),
            timeout: ne,
            signal: !0
        });
        let fe;
        if (fe = he.headers.get("Content-Type")?.startsWith("application/json") ? await he.json() : await he.text(),
        !he.ok)
            throw new HttpRequestError({
                body: z,
                details: stringify(fe.error) || he.statusText,
                headers: he.headers,
                status: he.status,
                url: W
            });
        return fe
    } catch (he) {
        throw he instanceof HttpRequestError || he instanceof TimeoutError ? he : new HttpRequestError({
            body: z,
            details: he.message,
            url: W
        })
    }
}
const socketsCache = new Map;
async function getSocket(W) {
    let z = socketsCache.get(W);
    if (z)
        return z;
    const {schedule: Y} = createBatchScheduler({
        id: W,
        fn: async()=>{
            const ue = new WebSocket$1(W)
              , de = new Map
              , he = new Map
              , fe = ({data: xe})=>{
                const $e = JSON.parse(xe)
                  , Ee = $e.method === "eth_subscription"
                  , Se = Ee ? $e.params.subscription : $e.id
                  , Ne = Ee ? he : de
                  , tt = Ne.get(Se);
                tt && tt({
                    data: xe
                }),
                Ee || Ne.delete(Se)
            }
              , ge = ()=>{
                socketsCache.delete(W),
                ue.removeEventListener("close", ge),
                ue.removeEventListener("message", fe)
            }
            ;
            return ue.addEventListener("close", ge),
            ue.addEventListener("message", fe),
            ue.readyState === WebSocket$1.CONNECTING && await new Promise((xe,$e)=>{
                ue && (ue.onopen = xe,
                ue.onerror = $e)
            }
            ),
            z = Object.assign(ue, {
                requests: de,
                subscriptions: he
            }),
            socketsCache.set(W, z),
            [z]
        }
    })
      , [ne,[le]] = await Y();
    return le
}
function webSocket$1(W, {body: z, onResponse: Y}) {
    if (W.readyState === W.CLOSED || W.readyState === W.CLOSING)
        throw new WebSocketRequestError({
            body: z,
            url: W.url,
            details: "Socket is closed."
        });
    const ne = id++
      , le = ({data: ue})=>{
        const de = JSON.parse(ue);
        typeof de.id == "number" && ne !== de.id || (Y?.(de),
        z.method === "eth_subscribe" && typeof de.result == "string" && W.subscriptions.set(de.result, le),
        z.method === "eth_unsubscribe" && W.subscriptions.delete(z.params?.[0]))
    }
    ;
    return W.requests.set(ne, le),
    W.send(JSON.stringify({
        jsonrpc: "2.0",
        ...z,
        id: ne
    })),
    W
}
async function webSocketAsync(W, {body: z, timeout: Y=1e4}) {
    return withTimeout(()=>new Promise(ne=>rpc.webSocket(W, {
        body: z,
        onResponse: ne
    })), {
        errorInstance: new TimeoutError({
            body: z,
            url: W.url
        }),
        timeout: Y
    })
}
const rpc = {
    http: http$1,
    webSocket: webSocket$1,
    webSocketAsync
};
function http(W, z={}) {
    const {batch: Y, fetchOptions: ne, key: le="http", name: ue="HTTP JSON-RPC", retryDelay: de} = z;
    return ({chain: he, retryCount: fe, timeout: ge})=>{
        const {batchSize: xe=1e3, wait: $e=0} = typeof Y == "object" ? Y : {}
          , Ee = z.retryCount ?? fe
          , Se = ge ?? z.timeout ?? 1e4
          , Ne = W || he?.rpcUrls.default.http[0];
        if (!Ne)
            throw new UrlRequiredError;
        return createTransport({
            key: le,
            name: ue,
            async request({method: tt, params: rr}) {
                const tr = {
                    method: tt,
                    params: rr
                }
                  , {schedule: we} = createBatchScheduler({
                    id: `${W}`,
                    wait: $e,
                    shouldSplitBatch: cr=>cr.length > xe,
                    fn: cr=>rpc.http(Ne, {
                        body: cr,
                        fetchOptions: ne,
                        timeout: Se
                    }),
                    sort: (cr,be)=>cr.id - be.id
                })
                  , [{error: Ut, result: lr}] = await (async cr=>Y ? we(cr) : [await rpc.http(Ne, {
                    body: cr,
                    fetchOptions: ne,
                    timeout: Se
                })])(tr);
                if (Ut)
                    throw new RpcRequestError({
                        body: tr,
                        error: Ut,
                        url: Ne
                    });
                return lr
            },
            retryCount: Ee,
            retryDelay: de,
            timeout: Se,
            type: "http"
        }, {
            fetchOptions: ne,
            url: W
        })
    }
}
function isNullUniversalResolverError(W, z) {
    if (!(W instanceof BaseError))
        return !1;
    const Y = W.walk(ne=>ne instanceof ContractFunctionRevertedError);
    return Y instanceof ContractFunctionRevertedError && (Y.data?.errorName === "ResolverNotFound" || Y.data?.errorName === "ResolverWildcardNotSupported" || !!Y.reason?.includes("Wildcard on non-extended resolvers is not supported") || z === "reverse" && Y.reason === panicReasons[50])
}
function encodedLabelToLabelhash(W) {
    if (W.length !== 66 || W.indexOf("[") !== 0 || W.indexOf("]") !== 65)
        return null;
    const z = `0x${W.slice(1, 65)}`;
    return isHex(z) ? z : null
}
function namehash(W) {
    let z = new Uint8Array(32).fill(0);
    if (!W)
        return bytesToHex(z);
    const Y = W.split(".");
    for (let ne = Y.length - 1; ne >= 0; ne -= 1) {
        const le = encodedLabelToLabelhash(Y[ne])
          , ue = le ? toBytes$1(le) : keccak256(stringToBytes(Y[ne]), "bytes");
        z = keccak256(concat$1([z, ue]), "bytes")
    }
    return bytesToHex(z)
}
function encodeLabelhash(W) {
    return `[${W.slice(2)}]`
}
function labelhash(W) {
    const z = new Uint8Array(32).fill(0);
    return W ? encodedLabelToLabelhash(W) || keccak256(stringToBytes(W)) : bytesToHex(z)
}
function packetToBytes(W) {
    const z = W.replace(/^\.|\.$/gm, "");
    if (z.length === 0)
        return new Uint8Array(1);
    const Y = new Uint8Array(stringToBytes(z).byteLength + 2);
    let ne = 0;
    const le = z.split(".");
    for (let ue = 0; ue < le.length; ue++) {
        let de = stringToBytes(le[ue]);
        de.byteLength > 255 && (de = stringToBytes(encodeLabelhash(labelhash(le[ue])))),
        Y[ne] = de.length,
        Y.set(de, ne + 1),
        ne += de.length + 1
    }
    return Y.byteLength !== ne + 1 ? Y.slice(0, ne + 1) : Y
}
async function getEnsAddress(W, {blockNumber: z, blockTag: Y, coinType: ne, name: le, universalResolverAddress: ue}) {
    let de = ue;
    if (!de) {
        if (!W.chain)
            throw new Error("client chain not configured. universalResolverAddress is required.");
        de = getChainContractAddress({
            blockNumber: z,
            chain: W.chain,
            contract: "ensUniversalResolver"
        })
    }
    try {
        const he = encodeFunctionData({
            abi: addressResolverAbi,
            functionName: "addr",
            ...ne != null ? {
                args: [namehash(le), BigInt(ne)]
            } : {
                args: [namehash(le)]
            }
        })
          , fe = await getAction(W, readContract$1, "readContract")({
            address: de,
            abi: universalResolverResolveAbi,
            functionName: "resolve",
            args: [toHex(packetToBytes(le)), he],
            blockNumber: z,
            blockTag: Y
        });
        if (fe[0] === "0x")
            return null;
        const ge = decodeFunctionResult({
            abi: addressResolverAbi,
            args: ne != null ? [namehash(le), BigInt(ne)] : void 0,
            functionName: "addr",
            data: fe[0]
        });
        return ge === "0x" || trim(ge) === "0x00" ? null : ge
    } catch (he) {
        if (isNullUniversalResolverError(he, "resolve"))
            return null;
        throw he
    }
}
class EnsAvatarInvalidMetadataError extends BaseError {
    constructor({data: z}) {
        super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
            metaMessages: ["- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.", "", `Provided data: ${JSON.stringify(z)}`]
        }),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "EnsAvatarInvalidMetadataError"
        })
    }
}
class EnsAvatarInvalidNftUriError extends BaseError {
    constructor({reason: z}) {
        super(`ENS NFT avatar URI is invalid. ${z}`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "EnsAvatarInvalidNftUriError"
        })
    }
}
class EnsAvatarUriResolutionError extends BaseError {
    constructor({uri: z}) {
        super(`Unable to resolve ENS avatar URI "${z}". The URI may be malformed, invalid, or does not respond with a valid image.`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "EnsAvatarUriResolutionError"
        })
    }
}
class EnsAvatarUnsupportedNamespaceError extends BaseError {
    constructor({namespace: z}) {
        super(`ENS NFT avatar namespace "${z}" is not supported. Must be "erc721" or "erc1155".`),
        Object.defineProperty(this, "name", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "EnsAvatarUnsupportedNamespaceError"
        })
    }
}
const networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/
  , ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/
  , base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/
  , dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(W) {
    try {
        const z = await fetch(W, {
            method: "HEAD"
        });
        return z.status === 200 ? z.headers.get("content-type")?.startsWith("image/") : !1
    } catch (z) {
        return (typeof z != "object" || z.response === void 0) && !!globalThis.hasOwnProperty("Image") && new Promise(Y=>{
            const ne = new Image;
            ne.onload = ()=>{
                Y(!0)
            }
            ,
            ne.onerror = ()=>{
                Y(!1)
            }
            ,
            ne.src = W
        }
        )
    }
}
function getGateway(W, z) {
    return W ? W.endsWith("/") ? W.slice(0, -1) : W : z
}
function resolveAvatarUri({uri: W, gatewayUrls: z}) {
    const Y = base64Regex.test(W);
    if (Y)
        return {
            uri: W,
            isOnChain: !0,
            isEncoded: Y
        };
    const ne = getGateway(z?.ipfs, "https://ipfs.io")
      , le = getGateway(z?.arweave, "https://arweave.net")
      , ue = W.match(networkRegex)
      , {protocol: de, subpath: he, target: fe, subtarget: ge=""} = ue?.groups || {}
      , xe = de === "ipns:/" || he === "ipns/"
      , $e = de === "ipfs:/" || he === "ipfs/" || ipfsHashRegex.test(W);
    if (W.startsWith("http") && !xe && !$e) {
        let Se = W;
        return z?.arweave && (Se = W.replace(/https:\/\/arweave.net/g, z?.arweave)),
        {
            uri: Se,
            isOnChain: !1,
            isEncoded: !1
        }
    }
    if ((xe || $e) && fe)
        return {
            uri: `${ne}/${xe ? "ipns" : "ipfs"}/${fe}${ge}`,
            isOnChain: !1,
            isEncoded: !1
        };
    if (de === "ar:/" && fe)
        return {
            uri: `${le}/${fe}${ge || ""}`,
            isOnChain: !1,
            isEncoded: !1
        };
    let Ee = W.replace(dataURIRegex, "");
    if (Ee.startsWith("<svg") && (Ee = `data:image/svg+xml;base64,${btoa(Ee)}`),
    Ee.startsWith("data:") || Ee.startsWith("{"))
        return {
            uri: Ee,
            isOnChain: !0,
            isEncoded: !1
        };
    throw new EnsAvatarUriResolutionError({
        uri: W
    })
}
function getJsonImage(W) {
    if (typeof W != "object" || !("image"in W) && !("image_url"in W) && !("image_data"in W))
        throw new EnsAvatarInvalidMetadataError({
            data: W
        });
    return W.image || W.image_url || W.image_data
}
async function getMetadataAvatarUri({gatewayUrls: W, uri: z}) {
    try {
        const Y = await fetch(z).then(ne=>ne.json());
        return await parseAvatarUri({
            gatewayUrls: W,
            uri: getJsonImage(Y)
        })
    } catch {
        throw new EnsAvatarUriResolutionError({
            uri: z
        })
    }
}
async function parseAvatarUri({gatewayUrls: W, uri: z}) {
    const {uri: Y, isOnChain: ne} = resolveAvatarUri({
        uri: z,
        gatewayUrls: W
    });
    if (ne || await isImageUri(Y))
        return Y;
    throw new EnsAvatarUriResolutionError({
        uri: z
    })
}
function parseNftUri(W) {
    let z = W;
    z.startsWith("did:nft:") && (z = z.replace("did:nft:", "").replace(/_/g, "/"));
    const [Y,ne,le] = z.split("/")
      , [ue,de] = Y.split(":")
      , [he,fe] = ne.split(":");
    if (!ue || ue.toLowerCase() !== "eip155")
        throw new EnsAvatarInvalidNftUriError({
            reason: "Only EIP-155 supported"
        });
    if (!de)
        throw new EnsAvatarInvalidNftUriError({
            reason: "Chain ID not found"
        });
    if (!fe)
        throw new EnsAvatarInvalidNftUriError({
            reason: "Contract address not found"
        });
    if (!le)
        throw new EnsAvatarInvalidNftUriError({
            reason: "Token ID not found"
        });
    if (!he)
        throw new EnsAvatarInvalidNftUriError({
            reason: "ERC namespace not found"
        });
    return {
        chainID: parseInt(de),
        namespace: he.toLowerCase(),
        contractAddress: fe,
        tokenID: le
    }
}
async function getNftTokenUri(W, {nft: z}) {
    if (z.namespace === "erc721")
        return readContract$1(W, {
            address: z.contractAddress,
            abi: [{
                name: "tokenURI",
                type: "function",
                stateMutability: "view",
                inputs: [{
                    name: "tokenId",
                    type: "uint256"
                }],
                outputs: [{
                    name: "",
                    type: "string"
                }]
            }],
            functionName: "tokenURI",
            args: [BigInt(z.tokenID)]
        });
    if (z.namespace === "erc1155")
        return readContract$1(W, {
            address: z.contractAddress,
            abi: [{
                name: "uri",
                type: "function",
                stateMutability: "view",
                inputs: [{
                    name: "_id",
                    type: "uint256"
                }],
                outputs: [{
                    name: "",
                    type: "string"
                }]
            }],
            functionName: "uri",
            args: [BigInt(z.tokenID)]
        });
    throw new EnsAvatarUnsupportedNamespaceError({
        namespace: z.namespace
    })
}
async function parseAvatarRecord(W, {gatewayUrls: z, record: Y}) {
    return /eip155:/i.test(Y) ? parseNftAvatarUri(W, {
        gatewayUrls: z,
        record: Y
    }) : parseAvatarUri({
        uri: Y,
        gatewayUrls: z
    })
}
async function parseNftAvatarUri(W, {gatewayUrls: z, record: Y}) {
    const ne = parseNftUri(Y)
      , le = await getNftTokenUri(W, {
        nft: ne
    })
      , {uri: ue, isOnChain: de, isEncoded: he} = resolveAvatarUri({
        uri: le,
        gatewayUrls: z
    });
    if (de && (ue.includes("data:application/json;base64,") || ue.startsWith("{"))) {
        const ge = he ? atob(ue.replace("data:application/json;base64,", "")) : ue;
        return parseAvatarUri({
            uri: getJsonImage(JSON.parse(ge)),
            gatewayUrls: z
        })
    }
    let fe = ne.tokenID;
    return ne.namespace === "erc1155" && (fe = fe.replace("0x", "").padStart(64, "0")),
    getMetadataAvatarUri({
        gatewayUrls: z,
        uri: ue.replace(/(?:0x)?{id}/, fe)
    })
}
async function getEnsText(W, {blockNumber: z, blockTag: Y, name: ne, key: le, universalResolverAddress: ue}) {
    let de = ue;
    if (!de) {
        if (!W.chain)
            throw new Error("client chain not configured. universalResolverAddress is required.");
        de = getChainContractAddress({
            blockNumber: z,
            chain: W.chain,
            contract: "ensUniversalResolver"
        })
    }
    try {
        const he = await getAction(W, readContract$1, "readContract")({
            address: de,
            abi: universalResolverResolveAbi,
            functionName: "resolve",
            args: [toHex(packetToBytes(ne)), encodeFunctionData({
                abi: textResolverAbi,
                functionName: "text",
                args: [namehash(ne), le]
            })],
            blockNumber: z,
            blockTag: Y
        });
        if (he[0] === "0x")
            return null;
        const fe = decodeFunctionResult({
            abi: textResolverAbi,
            functionName: "text",
            data: he[0]
        });
        return fe === "" ? null : fe
    } catch (he) {
        if (isNullUniversalResolverError(he, "resolve"))
            return null;
        throw he
    }
}
async function getEnsAvatar(W, {blockNumber: z, blockTag: Y, gatewayUrls: ne, name: le, universalResolverAddress: ue}) {
    const de = await getAction(W, getEnsText, "getEnsText")({
        blockNumber: z,
        blockTag: Y,
        key: "avatar",
        name: le,
        universalResolverAddress: ue
    });
    if (!de)
        return null;
    try {
        return await parseAvatarRecord(W, {
            record: de,
            gatewayUrls: ne
        })
    } catch {
        return null
    }
}
async function getEnsName(W, {address: z, blockNumber: Y, blockTag: ne, universalResolverAddress: le}) {
    let ue = le;
    if (!ue) {
        if (!W.chain)
            throw new Error("client chain not configured. universalResolverAddress is required.");
        ue = getChainContractAddress({
            blockNumber: Y,
            chain: W.chain,
            contract: "ensUniversalResolver"
        })
    }
    const de = `${z.toLowerCase().substring(2)}.addr.reverse`;
    try {
        return (await getAction(W, readContract$1, "readContract")({
            address: ue,
            abi: universalResolverReverseAbi,
            functionName: "reverse",
            args: [toHex(packetToBytes(de))],
            blockNumber: Y,
            blockTag: ne
        }))[0]
    } catch (he) {
        if (isNullUniversalResolverError(he, "reverse"))
            return null;
        throw he
    }
}
async function getEnsResolver(W, {blockNumber: z, blockTag: Y, name: ne, universalResolverAddress: le}) {
    let ue = le;
    if (!ue) {
        if (!W.chain)
            throw new Error("client chain not configured. universalResolverAddress is required.");
        ue = getChainContractAddress({
            blockNumber: z,
            chain: W.chain,
            contract: "ensUniversalResolver"
        })
    }
    const [de] = await getAction(W, readContract$1, "readContract")({
        address: ue,
        abi: [{
            inputs: [{
                type: "bytes"
            }],
            name: "findResolver",
            outputs: [{
                type: "address"
            }, {
                type: "bytes32"
            }],
            stateMutability: "view",
            type: "function"
        }],
        functionName: "findResolver",
        args: [toHex(packetToBytes(ne))],
        blockNumber: z,
        blockTag: Y
    });
    return de
}
async function createBlockFilter(W) {
    const z = createFilterRequestScope(W, {
        method: "eth_newBlockFilter"
    })
      , Y = await W.request({
        method: "eth_newBlockFilter"
    });
    return {
        id: Y,
        request: z(Y),
        type: "block"
    }
}
async function createEventFilter(W, {address: z, args: Y, event: ne, events: le, fromBlock: ue, strict: de, toBlock: he}={}) {
    const fe = le ?? (ne ? [ne] : void 0)
      , ge = createFilterRequestScope(W, {
        method: "eth_newFilter"
    });
    let xe = [];
    fe && (xe = [fe.flatMap(Ee=>encodeEventTopics({
        abi: [Ee],
        eventName: Ee.name,
        args: Y
    }))],
    ne && (xe = xe[0]));
    const $e = await W.request({
        method: "eth_newFilter",
        params: [{
            address: z,
            fromBlock: typeof ue == "bigint" ? numberToHex(ue) : ue,
            toBlock: typeof he == "bigint" ? numberToHex(he) : he,
            ...xe.length ? {
                topics: xe
            } : {}
        }]
    });
    return {
        abi: fe,
        args: Y,
        eventName: ne ? ne.name : void 0,
        fromBlock: ue,
        id: $e,
        request: ge($e),
        strict: de,
        toBlock: he,
        type: "event"
    }
}
async function createPendingTransactionFilter(W) {
    const z = createFilterRequestScope(W, {
        method: "eth_newPendingTransactionFilter"
    })
      , Y = await W.request({
        method: "eth_newPendingTransactionFilter"
    });
    return {
        id: Y,
        request: z(Y),
        type: "transaction"
    }
}
async function getBalance(W, {address: z, blockNumber: Y, blockTag: ne="latest"}) {
    const le = Y ? numberToHex(Y) : void 0
      , ue = await W.request({
        method: "eth_getBalance",
        params: [z, le || ne]
    });
    return BigInt(ue)
}
async function getBlockTransactionCount(W, {blockHash: z, blockNumber: Y, blockTag: ne="latest"}={}) {
    const le = Y !== void 0 ? numberToHex(Y) : void 0;
    let ue;
    return ue = z ? await W.request({
        method: "eth_getBlockTransactionCountByHash",
        params: [z]
    }) : await W.request({
        method: "eth_getBlockTransactionCountByNumber",
        params: [le || ne]
    }),
    hexToNumber(ue)
}
async function getBytecode(W, {address: z, blockNumber: Y, blockTag: ne="latest"}) {
    const le = Y !== void 0 ? numberToHex(Y) : void 0
      , ue = await W.request({
        method: "eth_getCode",
        params: [z, le || ne]
    });
    if (ue !== "0x")
        return ue
}
function formatFeeHistory(W) {
    return {
        baseFeePerGas: W.baseFeePerGas.map(z=>BigInt(z)),
        gasUsedRatio: W.gasUsedRatio,
        oldestBlock: BigInt(W.oldestBlock),
        reward: W.reward?.map(z=>z.map(Y=>BigInt(Y)))
    }
}
async function getFeeHistory(W, {blockCount: z, blockNumber: Y, blockTag: ne="latest", rewardPercentiles: le}) {
    const ue = Y ? numberToHex(Y) : void 0;
    return formatFeeHistory(await W.request({
        method: "eth_feeHistory",
        params: [numberToHex(z), ue || ne, le]
    }))
}
async function getFilterLogs(W, {filter: z}) {
    const Y = z.strict ?? !1;
    return (await z.request({
        method: "eth_getFilterLogs",
        params: [z.id]
    })).map(ne=>{
        try {
            const {eventName: le, args: ue} = "abi"in z && z.abi ? decodeEventLog({
                abi: z.abi,
                data: ne.data,
                topics: ne.topics,
                strict: Y
            }) : {
                eventName: void 0,
                args: void 0
            };
            return formatLog(ne, {
                args: ue,
                eventName: le
            })
        } catch (le) {
            let ue, de;
            if (le instanceof DecodeLogDataMismatch || le instanceof DecodeLogTopicsMismatch) {
                if ("strict"in z && z.strict)
                    return;
                ue = le.abiItem.name,
                de = le.abiItem.inputs?.some(he=>!("name"in he && he.name))
            }
            return formatLog(ne, {
                args: de ? [] : {},
                eventName: ue
            })
        }
    }
    ).filter(Boolean)
}
function defineChain(W, z={}) {
    const {fees: Y=W.fees, formatters: ne=W.formatters, serializers: le=W.serializers} = z;
    return {
        ...W,
        fees: Y,
        formatters: ne,
        serializers: le
    }
}
const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/
  , integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function hashTypedData({domain: W, message: z, primaryType: Y, types: ne}) {
    const le = W === void 0 ? {} : W
      , ue = {
        EIP712Domain: getTypesForEIP712Domain({
            domain: le
        }),
        ...ne
    };
    validateTypedData({
        domain: le,
        message: z,
        primaryType: Y,
        types: ue
    });
    const de = ["0x1901"];
    return le && de.push(hashDomain({
        domain: le,
        types: ue
    })),
    Y !== "EIP712Domain" && de.push(hashStruct({
        data: z,
        primaryType: Y,
        types: ue
    })),
    keccak256(concat$1(de))
}
function hashDomain({domain: W, types: z}) {
    return hashStruct({
        data: W,
        primaryType: "EIP712Domain",
        types: z
    })
}
function hashStruct({data: W, primaryType: z, types: Y}) {
    return keccak256(encodeData({
        data: W,
        primaryType: z,
        types: Y
    }))
}
function encodeData({data: W, primaryType: z, types: Y}) {
    const ne = [{
        type: "bytes32"
    }]
      , le = [hashType({
        primaryType: z,
        types: Y
    })];
    for (const ue of Y[z]) {
        const [de,he] = encodeField({
            types: Y,
            name: ue.name,
            type: ue.type,
            value: W[ue.name]
        });
        ne.push(de),
        le.push(he)
    }
    return encodeAbiParameters(ne, le)
}
function hashType({primaryType: W, types: z}) {
    return keccak256(toHex(encodeType({
        primaryType: W,
        types: z
    })))
}
function encodeType({primaryType: W, types: z}) {
    let Y = "";
    const ne = findTypeDependencies({
        primaryType: W,
        types: z
    });
    ne.delete(W);
    const le = [W, ...Array.from(ne).sort()];
    for (const ue of le)
        Y += `${ue}(${z[ue].map(({name: de, type: he})=>`${he} ${de}`).join(",")})`;
    return Y
}
function findTypeDependencies({primaryType: W, types: z}, Y=new Set) {
    const ne = W.match(/^\w*/u)
      , le = ne?.[0];
    if (Y.has(le) || z[le] === void 0)
        return Y;
    Y.add(le);
    for (const ue of z[le])
        findTypeDependencies({
            primaryType: ue.type,
            types: z
        }, Y);
    return Y
}
function encodeField({types: W, name: z, type: Y, value: ne}) {
    if (W[Y] !== void 0)
        return [{
            type: "bytes32"
        }, keccak256(encodeData({
            data: ne,
            primaryType: Y,
            types: W
        }))];
    if (Y === "bytes")
        return [{
            type: "bytes32"
        }, keccak256(ne = `0x${(ne.length % 2 ? "0" : "") + ne.slice(2)}`)];
    if (Y === "string")
        return [{
            type: "bytes32"
        }, keccak256(toHex(ne))];
    if (Y.lastIndexOf("]") === Y.length - 1) {
        const le = Y.slice(0, Y.lastIndexOf("["))
          , ue = ne.map(de=>encodeField({
            name: z,
            type: le,
            types: W,
            value: de
        }));
        return [{
            type: "bytes32"
        }, keccak256(encodeAbiParameters(ue.map(([de])=>de), ue.map(([,de])=>de)))]
    }
    return [{
        type: Y
    }, ne]
}
function validateTypedData({domain: W, message: z, primaryType: Y, types: ne}) {
    const le = ne
      , ue = (de,he)=>{
        for (const fe of de) {
            const {name: ge, type: xe} = fe
              , $e = xe
              , Ee = he[ge]
              , Se = $e.match(integerRegex);
            if (Se && (typeof Ee == "number" || typeof Ee == "bigint")) {
                const [rr,tr,we] = Se;
                numberToHex(Ee, {
                    signed: tr === "int",
                    size: parseInt(we) / 8
                })
            }
            if ($e === "address" && typeof Ee == "string" && !isAddress(Ee))
                throw new InvalidAddressError({
                    address: Ee
                });
            const Ne = $e.match(bytesRegex);
            if (Ne) {
                const [rr,tr] = Ne;
                if (tr && size$1(Ee) !== parseInt(tr))
                    throw new BytesSizeMismatchError({
                        expectedSize: parseInt(tr),
                        givenSize: size$1(Ee)
                    })
            }
            const tt = le[$e];
            tt && ue(tt, Ee)
        }
    }
    ;
    if (le.EIP712Domain && W && ue(le.EIP712Domain, W),
    Y !== "EIP712Domain") {
        const de = le[Y];
        ue(de, z)
    }
}
function getTypesForEIP712Domain({domain: W}) {
    return [typeof W?.name == "string" && {
        name: "name",
        type: "string"
    }, W?.version && {
        name: "version",
        type: "string"
    }, typeof W?.chainId == "number" && {
        name: "chainId",
        type: "uint256"
    }, W?.verifyingContract && {
        name: "verifyingContract",
        type: "address"
    }, W?.salt && {
        name: "salt",
        type: "bytes32"
    }].filter(Boolean)
}
const docsPath = "/docs/contract/encodeDeployData";
function encodeDeployData({abi: W, args: z, bytecode: Y}) {
    if (!z || z.length === 0)
        return Y;
    const ne = W.find(le=>"type"in le && le.type === "constructor");
    if (!ne)
        throw new AbiConstructorNotFoundError({
            docsPath
        });
    if (!("inputs"in ne))
        throw new AbiConstructorParamsNotFoundError({
            docsPath
        });
    if (!ne.inputs || ne.inputs.length === 0)
        throw new AbiConstructorParamsNotFoundError({
            docsPath
        });
    return concatHex([Y, encodeAbiParameters(ne.inputs, z)])
}
const statuses = {
    "0x0": "reverted",
    "0x1": "success"
};
function formatTransactionReceipt(W) {
    return {
        ...W,
        blockNumber: W.blockNumber ? BigInt(W.blockNumber) : null,
        contractAddress: W.contractAddress ? W.contractAddress : null,
        cumulativeGasUsed: W.cumulativeGasUsed ? BigInt(W.cumulativeGasUsed) : null,
        effectiveGasPrice: W.effectiveGasPrice ? BigInt(W.effectiveGasPrice) : null,
        gasUsed: W.gasUsed ? BigInt(W.gasUsed) : null,
        logs: W.logs ? W.logs.map(z=>formatLog(z)) : null,
        to: W.to ? W.to : null,
        transactionIndex: W.transactionIndex ? hexToNumber(W.transactionIndex) : null,
        status: W.status ? statuses[W.status] : null,
        type: W.type ? transactionType[W.type] || W.type : null
    }
}
const presignMessagePrefix = `Ethereum Signed Message:
`;
function hashMessage(W, z) {
    const Y = typeof W == "string" ? stringToBytes(W) : W.raw instanceof Uint8Array ? W.raw : toBytes$1(W.raw);
    return keccak256(concat$1([stringToBytes(`${presignMessagePrefix}${Y.length}`), Y]), z)
}
function parseUnits(W, z) {
    let[Y,ne="0"] = W.split(".");
    const le = Y.startsWith("-");
    if (le && (Y = Y.slice(1)),
    ne = ne.replace(/(0+)$/, ""),
    z === 0)
        Math.round(+`.${ne}`) === 1 && (Y = `${BigInt(Y) + 1n}`),
        ne = "";
    else if (ne.length > z) {
        const [ue,de,he] = [ne.slice(0, z - 1), ne.slice(z - 1, z), ne.slice(z)]
          , fe = Math.round(+`${de}.${he}`);
        ne = fe > 9 ? `${BigInt(ue) + BigInt(1)}0`.padStart(ue.length + 1, "0") : `${ue}${fe}`,
        ne.length > z && (ne = ne.slice(1),
        Y = `${BigInt(Y) + 1n}`),
        ne = ne.slice(0, z)
    } else
        ne = ne.padEnd(z, "0");
    return BigInt(`${le ? "-" : ""}${Y}${ne}`)
}
function formatStorageProof(W) {
    return W.map(z=>({
        ...z,
        value: BigInt(z.value)
    }))
}
function formatProof(W) {
    return {
        ...W,
        balance: W.balance ? BigInt(W.balance) : void 0,
        nonce: W.nonce ? hexToNumber(W.nonce) : void 0,
        storageProof: W.storageProof ? formatStorageProof(W.storageProof) : void 0
    }
}
async function getProof(W, {address: z, blockNumber: Y, blockTag: ne, storageKeys: le}) {
    const ue = ne ?? "latest"
      , de = Y !== void 0 ? numberToHex(Y) : void 0;
    return formatProof(await W.request({
        method: "eth_getProof",
        params: [z, le, de || ue]
    }))
}
async function getStorageAt(W, {address: z, blockNumber: Y, blockTag: ne="latest", slot: le}) {
    const ue = Y !== void 0 ? numberToHex(Y) : void 0;
    return await W.request({
        method: "eth_getStorageAt",
        params: [z, le, ue || ne]
    })
}
async function getTransaction(W, {blockHash: z, blockNumber: Y, blockTag: ne, hash: le, index: ue}) {
    const de = ne || "latest"
      , he = Y !== void 0 ? numberToHex(Y) : void 0;
    let fe = null;
    if (le ? fe = await W.request({
        method: "eth_getTransactionByHash",
        params: [le]
    }) : z ? fe = await W.request({
        method: "eth_getTransactionByBlockHashAndIndex",
        params: [z, numberToHex(ue)]
    }) : (he || de) && (fe = await W.request({
        method: "eth_getTransactionByBlockNumberAndIndex",
        params: [he || de, numberToHex(ue)]
    })),
    !fe)
        throw new TransactionNotFoundError({
            blockHash: z,
            blockNumber: Y,
            blockTag: de,
            hash: le,
            index: ue
        });
    return (W.chain?.formatters?.transaction?.format || formatTransaction)(fe)
}
async function getTransactionConfirmations(W, {hash: z, transactionReceipt: Y}) {
    const [ne,le] = await Promise.all([getAction(W, getBlockNumber, "getBlockNumber")({}), z ? getAction(W, getTransaction, "getBlockNumber")({
        hash: z
    }) : void 0])
      , ue = Y?.blockNumber || le?.blockNumber;
    return ue ? ne - ue + 1n : 0n
}
async function getTransactionReceipt(W, {hash: z}) {
    const Y = await W.request({
        method: "eth_getTransactionReceipt",
        params: [z]
    });
    if (!Y)
        throw new TransactionReceiptNotFoundError({
            hash: z
        });
    return (W.chain?.formatters?.transactionReceipt?.format || formatTransactionReceipt)(Y)
}
async function multicall$1(W, z) {
    const {allowFailure: Y=!0, batchSize: ne, blockNumber: le, blockTag: ue, contracts: de, multicallAddress: he} = z
      , fe = ne ?? (typeof W.batch?.multicall == "object" && W.batch.multicall.batchSize || 1024);
    let ge = he;
    if (!ge) {
        if (!W.chain)
            throw new Error("client chain not configured. multicallAddress is required.");
        ge = getChainContractAddress({
            blockNumber: le,
            chain: W.chain,
            contract: "multicall3"
        })
    }
    const xe = [[]];
    let $e = 0
      , Ee = 0;
    for (let tt = 0; tt < de.length; tt++) {
        const {abi: rr, address: tr, args: we, functionName: Ut} = de[tt];
        try {
            const lr = encodeFunctionData({
                abi: rr,
                args: we,
                functionName: Ut
            });
            Ee += (lr.length - 2) / 2,
            fe > 0 && Ee > fe && xe[$e].length > 0 && ($e++,
            Ee = (lr.length - 2) / 2,
            xe[$e] = []),
            xe[$e] = [...xe[$e], {
                allowFailure: !0,
                callData: lr,
                target: tr
            }]
        } catch (lr) {
            const cr = getContractError(lr, {
                abi: rr,
                address: tr,
                args: we,
                docsPath: "/docs/contract/multicall",
                functionName: Ut
            });
            if (!Y)
                throw cr;
            xe[$e] = [...xe[$e], {
                allowFailure: !0,
                callData: "0x",
                target: tr
            }]
        }
    }
    const Se = await Promise.allSettled(xe.map(tt=>getAction(W, readContract$1, "readContract")({
        abi: multicall3Abi,
        address: ge,
        args: [tt],
        blockNumber: le,
        blockTag: ue,
        functionName: "aggregate3"
    })))
      , Ne = [];
    for (let tt = 0; tt < Se.length; tt++) {
        const rr = Se[tt];
        if (rr.status === "rejected") {
            if (!Y)
                throw rr.reason;
            for (let we = 0; we < xe[tt].length; we++)
                Ne.push({
                    status: "failure",
                    error: rr.reason,
                    result: void 0
                });
            continue
        }
        const tr = rr.value;
        for (let we = 0; we < tr.length; we++) {
            const {returnData: Ut, success: lr} = tr[we]
              , {callData: cr} = xe[tt][we]
              , {abi: be, address: mr, functionName: fr, args: Rr} = de[Ne.length];
            try {
                if (cr === "0x")
                    throw new AbiDecodingZeroDataError;
                if (!lr)
                    throw new RawContractError({
                        data: Ut
                    });
                const Pr = decodeFunctionResult({
                    abi: be,
                    args: Rr,
                    data: Ut,
                    functionName: fr
                });
                Ne.push(Y ? {
                    result: Pr,
                    status: "success"
                } : Pr)
            } catch (Pr) {
                const Fr = getContractError(Pr, {
                    abi: be,
                    address: mr,
                    args: Rr,
                    docsPath: "/docs/contract/multicall",
                    functionName: fr
                });
                if (!Y)
                    throw Fr;
                Ne.push({
                    error: Fr,
                    result: void 0,
                    status: "failure"
                })
            }
        }
    }
    if (Ne.length !== de.length)
        throw new BaseError("multicall results mismatch");
    return Ne
}
const universalSignatureValidatorByteCode = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
function equalBytes(W, z) {
    if (W.length !== z.length)
        return !1;
    for (let Y = 0; Y < W.length; Y++)
        if (W[Y] !== z[Y])
            return !1;
    return !0
}
function isBytesEqual(W, z) {
    return equalBytes(isHex(W) ? toBytes$1(W) : W, isHex(z) ? toBytes$1(z) : z)
}
async function verifyHash(W, {address: z, hash: Y, signature: ne, ...le}) {
    const ue = isHex(ne) ? ne : toHex(ne);
    try {
        const {data: de} = await getAction(W, call, "call")({
            data: encodeDeployData({
                abi: universalSignatureValidatorAbi,
                args: [z, Y, ue],
                bytecode: universalSignatureValidatorByteCode
            }),
            ...le
        });
        return isBytesEqual(de ?? "0x0", "0x1")
    } catch (de) {
        if (de instanceof CallExecutionError)
            return !1;
        throw de
    }
}
async function verifyMessage(W, {address: z, message: Y, signature: ne, ...le}) {
    return verifyHash(W, {
        address: z,
        hash: hashMessage(Y),
        signature: ne,
        ...le
    })
}
async function verifyTypedData(W, {address: z, signature: Y, message: ne, primaryType: le, types: ue, domain: de, ...he}) {
    return verifyHash(W, {
        address: z,
        hash: hashTypedData({
            message: ne,
            primaryType: le,
            types: ue,
            domain: de
        }),
        signature: Y,
        ...he
    })
}
function watchBlockNumber(W, {emitOnBegin: z=!1, emitMissed: Y=!1, onBlockNumber: ne, onError: le, poll: ue, pollingInterval: de=W.pollingInterval}) {
    let he;
    return (ue !== void 0 ? ue : W.transport.type !== "webSocket") ? observe(stringify(["watchBlockNumber", W.uid, z, Y, de]), {
        onBlockNumber: ne,
        onError: le
    }, fe=>poll(async()=>{
        try {
            const ge = await getAction(W, getBlockNumber, "getBlockNumber")({
                cacheTime: 0
            });
            if (he) {
                if (ge === he)
                    return;
                if (ge - he > 1 && Y)
                    for (let xe = he + 1n; xe < ge; xe++)
                        fe.onBlockNumber(xe, he),
                        he = xe
            }
            (!he || ge > he) && (fe.onBlockNumber(ge, he),
            he = ge)
        } catch (ge) {
            fe.onError?.(ge)
        }
    }
    , {
        emitOnBegin: z,
        interval: de
    })) : (()=>{
        let fe = !0
          , ge = ()=>fe = !1;
        return (async()=>{
            try {
                const {unsubscribe: xe} = await W.transport.subscribe({
                    params: ["newHeads"],
                    onData($e) {
                        if (!fe)
                            return;
                        const Ee = hexToBigInt($e.result?.number);
                        ne(Ee, he),
                        he = Ee
                    },
                    onError($e) {
                        le?.($e)
                    }
                });
                ge = xe,
                fe || ge()
            } catch (xe) {
                le?.(xe)
            }
        }
        )(),
        ge
    }
    )()
}
async function waitForTransactionReceipt(W, {confirmations: z=1, hash: Y, onReplaced: ne, pollingInterval: le=W.pollingInterval, timeout: ue}) {
    const de = stringify(["waitForTransactionReceipt", W.uid, Y]);
    let he, fe, ge, xe = !1;
    return new Promise(($e,Ee)=>{
        ue && setTimeout(()=>Ee(new WaitForTransactionReceiptTimeoutError({
            hash: Y
        })), ue);
        const Se = observe(de, {
            onReplaced: ne,
            resolve: $e,
            reject: Ee
        }, Ne=>{
            const tt = getAction(W, watchBlockNumber, "watchBlockNumber")({
                emitMissed: !0,
                emitOnBegin: !0,
                poll: !0,
                pollingInterval: le,
                async onBlockNumber(rr) {
                    if (xe)
                        return;
                    let tr = rr;
                    const we = Ut=>{
                        tt(),
                        Ut(),
                        Se()
                    }
                    ;
                    try {
                        if (ge)
                            return z > 1 && (!ge.blockNumber || tr - ge.blockNumber + 1n < z) ? void 0 : void we(()=>Ne.resolve(ge));
                        if (he || (xe = !0,
                        await withRetry(async()=>{
                            he = await getAction(W, getTransaction, "getTransaction")({
                                hash: Y
                            }),
                            he.blockNumber && (tr = he.blockNumber)
                        }
                        , {
                            delay: ({count: Ut})=>200 * ~~(1 << Ut),
                            retryCount: 6
                        }),
                        xe = !1),
                        ge = await getAction(W, getTransactionReceipt, "getTransactionReceipt")({
                            hash: Y
                        }),
                        z > 1 && (!ge.blockNumber || tr - ge.blockNumber + 1n < z))
                            return;
                        we(()=>Ne.resolve(ge))
                    } catch (Ut) {
                        if (he && (Ut instanceof TransactionNotFoundError || Ut instanceof TransactionReceiptNotFoundError))
                            try {
                                fe = he,
                                xe = !0;
                                const lr = await withRetry(()=>getAction(W, getBlock, "getBlock")({
                                    blockNumber: tr,
                                    includeTransactions: !0
                                }), {
                                    delay: ({count: mr})=>200 * ~~(1 << mr),
                                    retryCount: 6,
                                    shouldRetry: ({error: mr})=>mr instanceof BlockNotFoundError
                                });
                                xe = !1;
                                const cr = lr.transactions.find(({from: mr, nonce: fr})=>mr === fe.from && fr === fe.nonce);
                                if (!cr || (ge = await getAction(W, getTransactionReceipt, "getTransactionReceipt")({
                                    hash: cr.hash
                                }),
                                z > 1 && (!ge.blockNumber || tr - ge.blockNumber + 1n < z)))
                                    return;
                                let be = "replaced";
                                cr.to === fe.to && cr.value === fe.value ? be = "repriced" : cr.from === cr.to && cr.value === 0n && (be = "cancelled"),
                                we(()=>{
                                    Ne.onReplaced?.({
                                        reason: be,
                                        replacedTransaction: fe,
                                        transaction: cr,
                                        transactionReceipt: ge
                                    }),
                                    Ne.resolve(ge)
                                }
                                )
                            } catch (lr) {
                                we(()=>Ne.reject(lr))
                            }
                        else
                            we(()=>Ne.reject(Ut))
                    }
                }
            })
        }
        )
    }
    )
}
function watchBlocks(W, {blockTag: z="latest", emitMissed: Y=!1, emitOnBegin: ne=!1, onBlock: le, onError: ue, includeTransactions: de, poll: he, pollingInterval: fe=W.pollingInterval}) {
    const ge = he !== void 0 ? he : W.transport.type !== "webSocket"
      , xe = de ?? !1;
    let $e;
    return ge ? observe(stringify(["watchBlocks", W.uid, Y, ne, xe, fe]), {
        onBlock: le,
        onError: ue
    }, Ee=>poll(async()=>{
        try {
            const Se = await getAction(W, getBlock, "getBlock")({
                blockTag: z,
                includeTransactions: xe
            });
            if (Se.number && $e?.number) {
                if (Se.number === $e.number)
                    return;
                if (Se.number - $e.number > 1 && Y)
                    for (let Ne = $e?.number + 1n; Ne < Se.number; Ne++) {
                        const tt = await getAction(W, getBlock, "getBlock")({
                            blockNumber: Ne,
                            includeTransactions: xe
                        });
                        Ee.onBlock(tt, $e),
                        $e = tt
                    }
            }
            (!$e?.number || z === "pending" && !Se?.number || Se.number && Se.number > $e.number) && (Ee.onBlock(Se, $e),
            $e = Se)
        } catch (Se) {
            Ee.onError?.(Se)
        }
    }
    , {
        emitOnBegin: ne,
        interval: fe
    })) : (()=>{
        let Ee = !0
          , Se = ()=>Ee = !1;
        return (async()=>{
            try {
                const {unsubscribe: Ne} = await W.transport.subscribe({
                    params: ["newHeads"],
                    onData(tt) {
                        if (!Ee)
                            return;
                        const rr = (W.chain?.formatters?.block?.format || formatBlock)(tt.result);
                        le(rr, $e),
                        $e = rr
                    },
                    onError(tt) {
                        ue?.(tt)
                    }
                });
                Se = Ne,
                Ee || Se()
            } catch (Ne) {
                ue?.(Ne)
            }
        }
        )(),
        Se
    }
    )()
}
function watchEvent(W, {address: z, args: Y, batch: ne=!0, event: le, events: ue, onError: de, onLogs: he, poll: fe, pollingInterval: ge=W.pollingInterval, strict: xe}) {
    const $e = fe !== void 0 ? fe : W.transport.type !== "webSocket"
      , Ee = xe ?? !1;
    return $e ? observe(stringify(["watchEvent", z, Y, ne, W.uid, le, ge]), {
        onLogs: he,
        onError: de
    }, Se=>{
        let Ne, tt, rr = !1;
        const tr = poll(async()=>{
            if (rr)
                try {
                    let we;
                    if (tt)
                        we = await getAction(W, getFilterChanges, "getFilterChanges")({
                            filter: tt
                        });
                    else {
                        const Ut = await getAction(W, getBlockNumber, "getBlockNumber")({});
                        we = Ne && Ne !== Ut ? await getAction(W, getLogs, "getLogs")({
                            address: z,
                            args: Y,
                            event: le,
                            events: ue,
                            fromBlock: Ne + 1n,
                            toBlock: Ut
                        }) : [],
                        Ne = Ut
                    }
                    if (we.length === 0)
                        return;
                    if (ne)
                        Se.onLogs(we);
                    else
                        for (const Ut of we)
                            Se.onLogs([Ut])
                } catch (we) {
                    tt && we instanceof InvalidInputRpcError && (rr = !1),
                    Se.onError?.(we)
                }
            else {
                try {
                    tt = await getAction(W, createEventFilter, "createEventFilter")({
                        address: z,
                        args: Y,
                        event: le,
                        events: ue,
                        strict: Ee
                    })
                } catch {}
                rr = !0
            }
        }
        , {
            emitOnBegin: !0,
            interval: ge
        });
        return async()=>{
            tt && await getAction(W, uninstallFilter, "uninstallFilter")({
                filter: tt
            }),
            tr()
        }
    }
    ) : (()=>{
        let Se = !0
          , Ne = ()=>Se = !1;
        return (async()=>{
            try {
                const tt = ue ?? (le ? [le] : void 0);
                let rr = [];
                tt && (rr = [tt.flatMap(we=>encodeEventTopics({
                    abi: [we],
                    eventName: we.name,
                    args: Y
                }))],
                le && (rr = rr[0]));
                const {unsubscribe: tr} = await W.transport.subscribe({
                    params: ["logs", {
                        address: z,
                        topics: rr
                    }],
                    onData(we) {
                        if (!Se)
                            return;
                        const Ut = we.result;
                        try {
                            const {eventName: lr, args: cr} = decodeEventLog({
                                abi: tt,
                                data: Ut.data,
                                topics: Ut.topics,
                                strict: Ee
                            })
                              , be = formatLog(Ut, {
                                args: cr,
                                eventName: lr
                            });
                            he([be])
                        } catch (lr) {
                            let cr, be;
                            if (lr instanceof DecodeLogDataMismatch || lr instanceof DecodeLogTopicsMismatch) {
                                if (xe)
                                    return;
                                cr = lr.abiItem.name,
                                be = lr.abiItem.inputs?.some(fr=>!("name"in fr && fr.name))
                            }
                            const mr = formatLog(Ut, {
                                args: be ? [] : {},
                                eventName: cr
                            });
                            he([mr])
                        }
                    },
                    onError(we) {
                        de?.(we)
                    }
                });
                Ne = tr,
                Se || Ne()
            } catch (tt) {
                de?.(tt)
            }
        }
        )(),
        Ne
    }
    )()
}
function watchPendingTransactions(W, {batch: z=!0, onError: Y, onTransactions: ne, poll: le, pollingInterval: ue=W.pollingInterval}) {
    return (le !== void 0 ? le : W.transport.type !== "webSocket") ? observe(stringify(["watchPendingTransactions", W.uid, z, ue]), {
        onTransactions: ne,
        onError: Y
    }, de=>{
        let he;
        const fe = poll(async()=>{
            try {
                if (!he)
                    try {
                        return void (he = await getAction(W, createPendingTransactionFilter, "createPendingTransactionFilter")({}))
                    } catch (xe) {
                        throw fe(),
                        xe
                    }
                const ge = await getAction(W, getFilterChanges, "getFilterChanges")({
                    filter: he
                });
                if (ge.length === 0)
                    return;
                if (z)
                    de.onTransactions(ge);
                else
                    for (const xe of ge)
                        de.onTransactions([xe])
            } catch (ge) {
                de.onError?.(ge)
            }
        }
        , {
            emitOnBegin: !0,
            interval: ue
        });
        return async()=>{
            he && await getAction(W, uninstallFilter, "uninstallFilter")({
                filter: he
            }),
            fe()
        }
    }
    ) : (()=>{
        let de = !0
          , he = ()=>de = !1;
        return (async()=>{
            try {
                const {unsubscribe: fe} = await W.transport.subscribe({
                    params: ["newPendingTransactions"],
                    onData(ge) {
                        if (!de)
                            return;
                        const xe = ge.result;
                        ne([xe])
                    },
                    onError(ge) {
                        Y?.(ge)
                    }
                });
                he = fe,
                de || he()
            } catch (fe) {
                Y?.(fe)
            }
        }
        )(),
        he
    }
    )()
}
function publicActions(W) {
    return {
        call: z=>call(W, z),
        createBlockFilter: ()=>createBlockFilter(W),
        createContractEventFilter: z=>createContractEventFilter(W, z),
        createEventFilter: z=>createEventFilter(W, z),
        createPendingTransactionFilter: ()=>createPendingTransactionFilter(W),
        estimateContractGas: z=>estimateContractGas(W, z),
        estimateGas: z=>estimateGas(W, z),
        getBalance: z=>getBalance(W, z),
        getBlock: z=>getBlock(W, z),
        getBlockNumber: z=>getBlockNumber(W, z),
        getBlockTransactionCount: z=>getBlockTransactionCount(W, z),
        getBytecode: z=>getBytecode(W, z),
        getChainId: ()=>getChainId(W),
        getContractEvents: z=>getContractEvents(W, z),
        getEnsAddress: z=>getEnsAddress(W, z),
        getEnsAvatar: z=>getEnsAvatar(W, z),
        getEnsName: z=>getEnsName(W, z),
        getEnsResolver: z=>getEnsResolver(W, z),
        getEnsText: z=>getEnsText(W, z),
        getFeeHistory: z=>getFeeHistory(W, z),
        estimateFeesPerGas: z=>estimateFeesPerGas(W, z),
        getFilterChanges: z=>getFilterChanges(W, z),
        getFilterLogs: z=>getFilterLogs(W, z),
        getGasPrice: ()=>getGasPrice(W),
        getLogs: z=>getLogs(W, z),
        getProof: z=>getProof(W, z),
        estimateMaxPriorityFeePerGas: z=>estimateMaxPriorityFeePerGas(W, z),
        getStorageAt: z=>getStorageAt(W, z),
        getTransaction: z=>getTransaction(W, z),
        getTransactionConfirmations: z=>getTransactionConfirmations(W, z),
        getTransactionCount: z=>getTransactionCount(W, z),
        getTransactionReceipt: z=>getTransactionReceipt(W, z),
        multicall: z=>multicall$1(W, z),
        prepareTransactionRequest: z=>prepareTransactionRequest(W, z),
        readContract: z=>readContract$1(W, z),
        sendRawTransaction: z=>sendRawTransaction(W, z),
        simulateContract: z=>simulateContract(W, z),
        verifyMessage: z=>verifyMessage(W, z),
        verifyTypedData: z=>verifyTypedData(W, z),
        uninstallFilter: z=>uninstallFilter(W, z),
        waitForTransactionReceipt: z=>waitForTransactionReceipt(W, z),
        watchBlocks: z=>watchBlocks(W, z),
        watchBlockNumber: z=>watchBlockNumber(W, z),
        watchContractEvent: z=>watchContractEvent(W, z),
        watchEvent: z=>watchEvent(W, z),
        watchPendingTransactions: z=>watchPendingTransactions(W, z)
    }
}
function createPublicClient(W) {
    const {key: z="public", name: Y="Public Client"} = W;
    return createClient({
        ...W,
        key: z,
        name: Y,
        type: "publicClient"
    }).extend(publicActions)
}
function deployContract(W, {abi: z, args: Y, bytecode: ne, ...le}) {
    return sendTransaction(W, {
        ...le,
        data: encodeDeployData({
            abi: z,
            args: Y,
            bytecode: ne
        })
    })
}
async function getAddresses(W) {
    return W.account?.type === "local" ? [W.account.address] : (await W.request({
        method: "eth_accounts"
    })).map(z=>checksumAddress(z))
}
async function getPermissions(W) {
    return await W.request({
        method: "wallet_getPermissions"
    })
}
async function requestAddresses(W) {
    return (await W.request({
        method: "eth_requestAccounts"
    })).map(z=>getAddress(z))
}
async function requestPermissions(W, z) {
    return W.request({
        method: "wallet_requestPermissions",
        params: [z]
    })
}
async function signMessage(W, {account: z=W.account, message: Y}) {
    if (!z)
        throw new AccountNotFoundError({
            docsPath: "/docs/actions/wallet/signMessage"
        });
    const ne = parseAccount(z);
    if (ne.type === "local")
        return ne.signMessage({
            message: Y
        });
    const le = typeof Y == "string" ? stringToHex(Y) : Y.raw instanceof Uint8Array ? toHex(Y.raw) : Y.raw;
    return W.request({
        method: "personal_sign",
        params: [le, ne.address]
    })
}
async function signTransaction(W, z) {
    const {account: Y=W.account, chain: ne=W.chain, ...le} = z;
    if (!Y)
        throw new AccountNotFoundError({
            docsPath: "/docs/actions/wallet/signTransaction"
        });
    const ue = parseAccount(Y);
    assertRequest({
        account: ue,
        ...z
    });
    const de = await getAction(W, getChainId, "getChainId")({});
    ne !== null && assertCurrentChain({
        currentChainId: de,
        chain: ne
    });
    const he = ne?.formatters || W.chain?.formatters
      , fe = he?.transactionRequest?.format || formatTransactionRequest;
    return ue.type === "local" ? ue.signTransaction({
        ...le,
        chainId: de
    }, {
        serializer: W.chain?.serializers?.transaction
    }) : await W.request({
        method: "eth_signTransaction",
        params: [{
            ...fe(le),
            chainId: numberToHex(de),
            from: ue.address
        }]
    })
}
async function signTypedData(W, {account: z=W.account, domain: Y, message: ne, primaryType: le, types: ue}) {
    if (!z)
        throw new AccountNotFoundError({
            docsPath: "/docs/actions/wallet/signTypedData"
        });
    const de = parseAccount(z)
      , he = {
        EIP712Domain: getTypesForEIP712Domain({
            domain: Y
        }),
        ...ue
    };
    if (validateTypedData({
        domain: Y,
        message: ne,
        primaryType: le,
        types: he
    }),
    de.type === "local")
        return de.signTypedData({
            domain: Y,
            primaryType: le,
            types: he,
            message: ne
        });
    const fe = stringify({
        domain: Y ?? {},
        primaryType: le,
        types: he,
        message: ne
    }, (ge,xe)=>isHex(xe) ? xe.toLowerCase() : xe);
    return W.request({
        method: "eth_signTypedData_v4",
        params: [de.address, fe]
    })
}
async function switchChain(W, {id: z}) {
    await W.request({
        method: "wallet_switchEthereumChain",
        params: [{
            chainId: numberToHex(z)
        }]
    })
}
async function watchAsset(W, z) {
    return await W.request({
        method: "wallet_watchAsset",
        params: z
    })
}
function walletActions(W) {
    return {
        addChain: z=>addChain(W, z),
        deployContract: z=>deployContract(W, z),
        getAddresses: ()=>getAddresses(W),
        getChainId: ()=>getChainId(W),
        getPermissions: ()=>getPermissions(W),
        prepareTransactionRequest: z=>prepareTransactionRequest(W, z),
        requestAddresses: ()=>requestAddresses(W),
        requestPermissions: z=>requestPermissions(W, z),
        sendRawTransaction: z=>sendRawTransaction(W, z),
        sendTransaction: z=>sendTransaction(W, z),
        signMessage: z=>signMessage(W, z),
        signTransaction: z=>signTransaction(W, z),
        signTypedData: z=>signTypedData(W, z),
        switchChain: z=>switchChain(W, z),
        watchAsset: z=>watchAsset(W, z),
        writeContract: z=>writeContract$1(W, z)
    }
}
function createWalletClient(W) {
    const {key: z="wallet", name: Y="Wallet Client", transport: ne} = W;
    return createClient({
        ...W,
        key: z,
        name: Y,
        transport: le=>ne({
            ...le,
            retryCount: 0
        }),
        type: "walletClient"
    }).extend(walletActions)
}
function webSocket(W, z={}) {
    const {key: Y="webSocket", name: ne="WebSocket JSON-RPC", retryDelay: le} = z;
    return ({chain: ue, retryCount: de, timeout: he})=>{
        const fe = z.retryCount ?? de
          , ge = he ?? z.timeout ?? 1e4
          , xe = W || ue?.rpcUrls.default.webSocket?.[0];
        if (!xe)
            throw new UrlRequiredError;
        return createTransport({
            key: Y,
            name: ne,
            async request({method: $e, params: Ee}) {
                const Se = {
                    method: $e,
                    params: Ee
                }
                  , Ne = await getSocket(xe)
                  , {error: tt, result: rr} = await rpc.webSocketAsync(Ne, {
                    body: Se,
                    timeout: ge
                });
                if (tt)
                    throw new RpcRequestError({
                        body: Se,
                        error: tt,
                        url: xe
                    });
                return rr
            },
            retryCount: fe,
            retryDelay: le,
            timeout: ge,
            type: "webSocket"
        }, {
            getSocket: ()=>getSocket(xe),
            async subscribe({params: $e, onData: Ee, onError: Se}) {
                const Ne = await getSocket(xe)
                  , {result: tt} = await new Promise((rr,tr)=>rpc.webSocket(Ne, {
                    body: {
                        method: "eth_subscribe",
                        params: $e
                    },
                    onResponse(we) {
                        if (we.error)
                            return tr(we.error),
                            void Se?.(we.error);
                        typeof we.id != "number" ? we.method === "eth_subscription" && Ee(we.params) : rr(we)
                    }
                }));
                return {
                    subscriptionId: tt,
                    unsubscribe: async()=>new Promise(rr=>rpc.webSocket(Ne, {
                        body: {
                            method: "eth_unsubscribe",
                            params: [tt]
                        },
                        onResponse: rr
                    }))
                }
            }
        })
    }
}
let support, deviceCached, browser$2;
function calcSupport() {
    const W = getWindow()
      , z = getDocument$1();
    return {
        smoothScroll: z.documentElement && z.documentElement.style && "scrollBehavior"in z.documentElement.style,
        touch: !!("ontouchstart"in W || W.DocumentTouch && z instanceof W.DocumentTouch)
    }
}
function getSupport() {
    return support || (support = calcSupport()),
    support
}
function calcDevice(W) {
    let {userAgent: z} = W === void 0 ? {} : W;
    const Y = getSupport()
      , ne = getWindow()
      , le = ne.navigator.platform
      , ue = z || ne.navigator.userAgent
      , de = {
        ios: !1,
        android: !1
    }
      , he = ne.screen.width
      , fe = ne.screen.height
      , ge = ue.match(/(Android);?[\s\/]+([\d.]+)?/);
    let xe = ue.match(/(iPad).*OS\s([\d_]+)/);
    const $e = ue.match(/(iPod)(.*OS\s([\d_]+))?/)
      , Ee = !xe && ue.match(/(iPhone\sOS|iOS)\s([\d_]+)/)
      , Se = le === "Win32";
    let Ne = le === "MacIntel";
    return !xe && Ne && Y.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${he}x${fe}`) >= 0 && (xe = ue.match(/(Version)\/([\d.]+)/),
    xe || (xe = [0, 1, "13_0_0"]),
    Ne = !1),
    ge && !Se && (de.os = "android",
    de.android = !0),
    (xe || Ee || $e) && (de.os = "ios",
    de.ios = !0),
    de
}
function getDevice(W) {
    return W === void 0 && (W = {}),
    deviceCached || (deviceCached = calcDevice(W)),
    deviceCached
}
function calcBrowser() {
    const W = getWindow();
    let z = !1;
    function Y() {
        const ne = W.navigator.userAgent.toLowerCase();
        return ne.indexOf("safari") >= 0 && ne.indexOf("chrome") < 0 && ne.indexOf("android") < 0
    }
    if (Y()) {
        const ne = String(W.navigator.userAgent);
        if (ne.includes("Version/")) {
            const [le,ue] = ne.split("Version/")[1].split(" ")[0].split(".").map(de=>Number(de));
            z = le < 16 || le === 16 && ue < 2
        }
    }
    return {
        isSafari: z || Y(),
        needPerspectiveFix: z,
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(W.navigator.userAgent)
    }
}
function getBrowser() {
    return browser$2 || (browser$2 = calcBrowser()),
    browser$2
}
function Resize(W) {
    let {swiper: z, on: Y, emit: ne} = W;
    const le = getWindow();
    let ue = null
      , de = null;
    const he = ()=>{
        z && !z.destroyed && z.initialized && (ne("beforeResize"),
        ne("resize"))
    }
      , fe = ()=>{
        z && !z.destroyed && z.initialized && ne("orientationchange")
    }
    ;
    Y("init", ()=>{
        z.params.resizeObserver && le.ResizeObserver !== void 0 ? z && !z.destroyed && z.initialized && (ue = new ResizeObserver(ge=>{
            de = le.requestAnimationFrame(()=>{
                const {width: xe, height: $e} = z;
                let Ee = xe
                  , Se = $e;
                ge.forEach(Ne=>{
                    let {contentBoxSize: tt, contentRect: rr, target: tr} = Ne;
                    tr && tr !== z.el || (Ee = rr ? rr.width : (tt[0] || tt).inlineSize,
                    Se = rr ? rr.height : (tt[0] || tt).blockSize)
                }
                ),
                Ee === xe && Se === $e || he()
            }
            )
        }
        ),
        ue.observe(z.el)) : (le.addEventListener("resize", he),
        le.addEventListener("orientationchange", fe))
    }
    ),
    Y("destroy", ()=>{
        de && le.cancelAnimationFrame(de),
        ue && ue.unobserve && z.el && (ue.unobserve(z.el),
        ue = null),
        le.removeEventListener("resize", he),
        le.removeEventListener("orientationchange", fe)
    }
    )
}
function Observer(W) {
    let {swiper: z, extendParams: Y, on: ne, emit: le} = W;
    const ue = []
      , de = getWindow()
      , he = function(fe, ge) {
        ge === void 0 && (ge = {});
        const xe = new (de.MutationObserver || de.WebkitMutationObserver)($e=>{
            if (z.__preventObserver__)
                return;
            if ($e.length === 1)
                return void le("observerUpdate", $e[0]);
            const Ee = function() {
                le("observerUpdate", $e[0])
            };
            de.requestAnimationFrame ? de.requestAnimationFrame(Ee) : de.setTimeout(Ee, 0)
        }
        );
        xe.observe(fe, {
            attributes: ge.attributes === void 0 || ge.attributes,
            childList: ge.childList === void 0 || ge.childList,
            characterData: ge.characterData === void 0 || ge.characterData
        }),
        ue.push(xe)
    };
    Y({
        observer: !1,
        observeParents: !1,
        observeSlideChildren: !1
    }),
    ne("init", ()=>{
        if (z.params.observer) {
            if (z.params.observeParents) {
                const fe = elementParents(z.hostEl);
                for (let ge = 0; ge < fe.length; ge += 1)
                    he(fe[ge])
            }
            he(z.hostEl, {
                childList: z.params.observeSlideChildren
            }),
            he(z.wrapperEl, {
                attributes: !1
            })
        }
    }
    ),
    ne("destroy", ()=>{
        ue.forEach(fe=>{
            fe.disconnect()
        }
        ),
        ue.splice(0, ue.length)
    }
    )
}
BigInt(0),
BigInt(1),
BigInt(2);
var eventsEmitter = {
    on(W, z, Y) {
        const ne = this;
        if (!ne.eventsListeners || ne.destroyed || typeof z != "function")
            return ne;
        const le = Y ? "unshift" : "push";
        return W.split(" ").forEach(ue=>{
            ne.eventsListeners[ue] || (ne.eventsListeners[ue] = []),
            ne.eventsListeners[ue][le](z)
        }
        ),
        ne
    },
    once(W, z, Y) {
        const ne = this;
        if (!ne.eventsListeners || ne.destroyed || typeof z != "function")
            return ne;
        function le() {
            ne.off(W, le),
            le.__emitterProxy && delete le.__emitterProxy;
            for (var ue = arguments.length, de = new Array(ue), he = 0; he < ue; he++)
                de[he] = arguments[he];
            z.apply(ne, de)
        }
        return le.__emitterProxy = z,
        ne.on(W, le, Y)
    },
    onAny(W, z) {
        const Y = this;
        if (!Y.eventsListeners || Y.destroyed || typeof W != "function")
            return Y;
        const ne = z ? "unshift" : "push";
        return Y.eventsAnyListeners.indexOf(W) < 0 && Y.eventsAnyListeners[ne](W),
        Y
    },
    offAny(W) {
        const z = this;
        if (!z.eventsListeners || z.destroyed || !z.eventsAnyListeners)
            return z;
        const Y = z.eventsAnyListeners.indexOf(W);
        return Y >= 0 && z.eventsAnyListeners.splice(Y, 1),
        z
    },
    off(W, z) {
        const Y = this;
        return !Y.eventsListeners || Y.destroyed || Y.eventsListeners && W.split(" ").forEach(ne=>{
            z === void 0 ? Y.eventsListeners[ne] = [] : Y.eventsListeners[ne] && Y.eventsListeners[ne].forEach((le,ue)=>{
                (le === z || le.__emitterProxy && le.__emitterProxy === z) && Y.eventsListeners[ne].splice(ue, 1)
            }
            )
        }
        ),
        Y
    },
    emit() {
        const W = this;
        if (!W.eventsListeners || W.destroyed || !W.eventsListeners)
            return W;
        let z, Y, ne;
        for (var le = arguments.length, ue = new Array(le), de = 0; de < le; de++)
            ue[de] = arguments[de];
        return typeof ue[0] == "string" || Array.isArray(ue[0]) ? (z = ue[0],
        Y = ue.slice(1, ue.length),
        ne = W) : (z = ue[0].events,
        Y = ue[0].data,
        ne = ue[0].context || W),
        Y.unshift(ne),
        (Array.isArray(z) ? z : z.split(" ")).forEach(he=>{
            W.eventsAnyListeners && W.eventsAnyListeners.length && W.eventsAnyListeners.forEach(fe=>{
                fe.apply(ne, [he, ...Y])
            }
            ),
            W.eventsListeners && W.eventsListeners[he] && W.eventsListeners[he].forEach(fe=>{
                fe.apply(ne, Y)
            }
            )
        }
        ),
        W
    }
};
function updateSize() {
    const W = this;
    let z, Y;
    const ne = W.el;
    z = W.params.width !== void 0 && W.params.width !== null ? W.params.width : ne.clientWidth,
    Y = W.params.height !== void 0 && W.params.height !== null ? W.params.height : ne.clientHeight,
    z === 0 && W.isHorizontal() || Y === 0 && W.isVertical() || (z = z - parseInt(elementStyle(ne, "padding-left") || 0, 10) - parseInt(elementStyle(ne, "padding-right") || 0, 10),
    Y = Y - parseInt(elementStyle(ne, "padding-top") || 0, 10) - parseInt(elementStyle(ne, "padding-bottom") || 0, 10),
    Number.isNaN(z) && (z = 0),
    Number.isNaN(Y) && (Y = 0),
    Object.assign(W, {
        width: z,
        height: Y,
        size: W.isHorizontal() ? z : Y
    }))
}
function updateSlides() {
    const W = this;
    function z(Pr, Fr) {
        return parseFloat(Pr.getPropertyValue(W.getDirectionLabel(Fr)) || 0)
    }
    const Y = W.params
      , {wrapperEl: ne, slidesEl: le, size: ue, rtlTranslate: de, wrongRTL: he} = W
      , fe = W.virtual && Y.virtual.enabled
      , ge = fe ? W.virtual.slides.length : W.slides.length
      , xe = elementChildren(le, `.${W.params.slideClass}, swiper-slide`)
      , $e = fe ? W.virtual.slides.length : xe.length;
    let Ee = [];
    const Se = []
      , Ne = [];
    let tt = Y.slidesOffsetBefore;
    typeof tt == "function" && (tt = Y.slidesOffsetBefore.call(W));
    let rr = Y.slidesOffsetAfter;
    typeof rr == "function" && (rr = Y.slidesOffsetAfter.call(W));
    const tr = W.snapGrid.length
      , we = W.slidesGrid.length;
    let Ut = Y.spaceBetween
      , lr = -tt
      , cr = 0
      , be = 0;
    if (ue === void 0)
        return;
    typeof Ut == "string" && Ut.indexOf("%") >= 0 ? Ut = parseFloat(Ut.replace("%", "")) / 100 * ue : typeof Ut == "string" && (Ut = parseFloat(Ut)),
    W.virtualSize = -Ut,
    xe.forEach(Pr=>{
        de ? Pr.style.marginLeft = "" : Pr.style.marginRight = "",
        Pr.style.marginBottom = "",
        Pr.style.marginTop = ""
    }
    ),
    Y.centeredSlides && Y.cssMode && (setCSSProperty(ne, "--swiper-centered-offset-before", ""),
    setCSSProperty(ne, "--swiper-centered-offset-after", ""));
    const mr = Y.grid && Y.grid.rows > 1 && W.grid;
    let fr;
    mr ? W.grid.initSlides(xe) : W.grid && W.grid.unsetSlides();
    const Rr = Y.slidesPerView === "auto" && Y.breakpoints && Object.keys(Y.breakpoints).filter(Pr=>Y.breakpoints[Pr].slidesPerView !== void 0).length > 0;
    for (let Pr = 0; Pr < $e; Pr += 1) {
        let Fr;
        if (fr = 0,
        xe[Pr] && (Fr = xe[Pr]),
        mr && W.grid.updateSlide(Pr, Fr, xe),
        !xe[Pr] || elementStyle(Fr, "display") !== "none") {
            if (Y.slidesPerView === "auto") {
                Rr && (xe[Pr].style[W.getDirectionLabel("width")] = "");
                const br = getComputedStyle(Fr)
                  , xr = Fr.style.transform
                  , _r = Fr.style.webkitTransform;
                if (xr && (Fr.style.transform = "none"),
                _r && (Fr.style.webkitTransform = "none"),
                Y.roundLengths)
                    fr = W.isHorizontal() ? elementOuterSize(Fr, "width", !0) : elementOuterSize(Fr, "height", !0);
                else {
                    const Ir = z(br, "width")
                      , Nr = z(br, "padding-left")
                      , gn = z(br, "padding-right")
                      , Zr = z(br, "margin-left")
                      , Tn = z(br, "margin-right")
                      , Zn = br.getPropertyValue("box-sizing");
                    if (Zn && Zn === "border-box")
                        fr = Ir + Zr + Tn;
                    else {
                        const {clientWidth: Cn, offsetWidth: Gn} = Fr;
                        fr = Ir + Nr + gn + Zr + Tn + (Gn - Cn)
                    }
                }
                xr && (Fr.style.transform = xr),
                _r && (Fr.style.webkitTransform = _r),
                Y.roundLengths && (fr = Math.floor(fr))
            } else
                fr = (ue - (Y.slidesPerView - 1) * Ut) / Y.slidesPerView,
                Y.roundLengths && (fr = Math.floor(fr)),
                xe[Pr] && (xe[Pr].style[W.getDirectionLabel("width")] = `${fr}px`);
            xe[Pr] && (xe[Pr].swiperSlideSize = fr),
            Ne.push(fr),
            Y.centeredSlides ? (lr = lr + fr / 2 + cr / 2 + Ut,
            cr === 0 && Pr !== 0 && (lr = lr - ue / 2 - Ut),
            Pr === 0 && (lr = lr - ue / 2 - Ut),
            Math.abs(lr) < .001 && (lr = 0),
            Y.roundLengths && (lr = Math.floor(lr)),
            be % Y.slidesPerGroup == 0 && Ee.push(lr),
            Se.push(lr)) : (Y.roundLengths && (lr = Math.floor(lr)),
            (be - Math.min(W.params.slidesPerGroupSkip, be)) % W.params.slidesPerGroup == 0 && Ee.push(lr),
            Se.push(lr),
            lr = lr + fr + Ut),
            W.virtualSize += fr + Ut,
            cr = fr,
            be += 1
        }
    }
    if (W.virtualSize = Math.max(W.virtualSize, ue) + rr,
    de && he && (Y.effect === "slide" || Y.effect === "coverflow") && (ne.style.width = `${W.virtualSize + Ut}px`),
    Y.setWrapperSize && (ne.style[W.getDirectionLabel("width")] = `${W.virtualSize + Ut}px`),
    mr && W.grid.updateWrapperSize(fr, Ee),
    !Y.centeredSlides) {
        const Pr = [];
        for (let Fr = 0; Fr < Ee.length; Fr += 1) {
            let br = Ee[Fr];
            Y.roundLengths && (br = Math.floor(br)),
            Ee[Fr] <= W.virtualSize - ue && Pr.push(br)
        }
        Ee = Pr,
        Math.floor(W.virtualSize - ue) - Math.floor(Ee[Ee.length - 1]) > 1 && Ee.push(W.virtualSize - ue)
    }
    if (fe && Y.loop) {
        const Pr = Ne[0] + Ut;
        if (Y.slidesPerGroup > 1) {
            const Fr = Math.ceil((W.virtual.slidesBefore + W.virtual.slidesAfter) / Y.slidesPerGroup)
              , br = Pr * Y.slidesPerGroup;
            for (let xr = 0; xr < Fr; xr += 1)
                Ee.push(Ee[Ee.length - 1] + br)
        }
        for (let Fr = 0; Fr < W.virtual.slidesBefore + W.virtual.slidesAfter; Fr += 1)
            Y.slidesPerGroup === 1 && Ee.push(Ee[Ee.length - 1] + Pr),
            Se.push(Se[Se.length - 1] + Pr),
            W.virtualSize += Pr
    }
    if (Ee.length === 0 && (Ee = [0]),
    Ut !== 0) {
        const Pr = W.isHorizontal() && de ? "marginLeft" : W.getDirectionLabel("marginRight");
        xe.filter((Fr,br)=>!(Y.cssMode && !Y.loop) || br !== xe.length - 1).forEach(Fr=>{
            Fr.style[Pr] = `${Ut}px`
        }
        )
    }
    if (Y.centeredSlides && Y.centeredSlidesBounds) {
        let Pr = 0;
        Ne.forEach(br=>{
            Pr += br + (Ut || 0)
        }
        ),
        Pr -= Ut;
        const Fr = Pr - ue;
        Ee = Ee.map(br=>br <= 0 ? -tt : br > Fr ? Fr + rr : br)
    }
    if (Y.centerInsufficientSlides) {
        let Pr = 0;
        if (Ne.forEach(Fr=>{
            Pr += Fr + (Ut || 0)
        }
        ),
        Pr -= Ut,
        Pr < ue) {
            const Fr = (ue - Pr) / 2;
            Ee.forEach((br,xr)=>{
                Ee[xr] = br - Fr
            }
            ),
            Se.forEach((br,xr)=>{
                Se[xr] = br + Fr
            }
            )
        }
    }
    if (Object.assign(W, {
        slides: xe,
        snapGrid: Ee,
        slidesGrid: Se,
        slidesSizesGrid: Ne
    }),
    Y.centeredSlides && Y.cssMode && !Y.centeredSlidesBounds) {
        setCSSProperty(ne, "--swiper-centered-offset-before", -Ee[0] + "px"),
        setCSSProperty(ne, "--swiper-centered-offset-after", W.size / 2 - Ne[Ne.length - 1] / 2 + "px");
        const Pr = -W.snapGrid[0]
          , Fr = -W.slidesGrid[0];
        W.snapGrid = W.snapGrid.map(br=>br + Pr),
        W.slidesGrid = W.slidesGrid.map(br=>br + Fr)
    }
    if ($e !== ge && W.emit("slidesLengthChange"),
    Ee.length !== tr && (W.params.watchOverflow && W.checkOverflow(),
    W.emit("snapGridLengthChange")),
    Se.length !== we && W.emit("slidesGridLengthChange"),
    Y.watchSlidesProgress && W.updateSlidesOffset(),
    W.emit("slidesUpdated"),
    !(fe || Y.cssMode || Y.effect !== "slide" && Y.effect !== "fade")) {
        const Pr = `${Y.containerModifierClass}backface-hidden`
          , Fr = W.el.classList.contains(Pr);
        $e <= Y.maxBackfaceHiddenSlides ? Fr || W.el.classList.add(Pr) : Fr && W.el.classList.remove(Pr)
    }
}
function updateAutoHeight(W) {
    const z = this
      , Y = []
      , ne = z.virtual && z.params.virtual.enabled;
    let le, ue = 0;
    typeof W == "number" ? z.setTransition(W) : W === !0 && z.setTransition(z.params.speed);
    const de = he=>ne ? z.slides[z.getSlideIndexByData(he)] : z.slides[he];
    if (z.params.slidesPerView !== "auto" && z.params.slidesPerView > 1)
        if (z.params.centeredSlides)
            (z.visibleSlides || []).forEach(he=>{
                Y.push(he)
            }
            );
        else
            for (le = 0; le < Math.ceil(z.params.slidesPerView); le += 1) {
                const he = z.activeIndex + le;
                if (he > z.slides.length && !ne)
                    break;
                Y.push(de(he))
            }
    else
        Y.push(de(z.activeIndex));
    for (le = 0; le < Y.length; le += 1)
        if (Y[le] !== void 0) {
            const he = Y[le].offsetHeight;
            ue = he > ue ? he : ue
        }
    (ue || ue === 0) && (z.wrapperEl.style.height = `${ue}px`)
}
function updateSlidesOffset() {
    const W = this
      , z = W.slides
      , Y = W.isElement ? W.isHorizontal() ? W.wrapperEl.offsetLeft : W.wrapperEl.offsetTop : 0;
    for (let ne = 0; ne < z.length; ne += 1)
        z[ne].swiperSlideOffset = (W.isHorizontal() ? z[ne].offsetLeft : z[ne].offsetTop) - Y - W.cssOverflowAdjustment()
}
function updateSlidesProgress(W) {
    W === void 0 && (W = this && this.translate || 0);
    const z = this
      , Y = z.params
      , {slides: ne, rtlTranslate: le, snapGrid: ue} = z;
    if (ne.length === 0)
        return;
    ne[0].swiperSlideOffset === void 0 && z.updateSlidesOffset();
    let de = -W;
    le && (de = W),
    ne.forEach(fe=>{
        fe.classList.remove(Y.slideVisibleClass, Y.slideFullyVisibleClass)
    }
    ),
    z.visibleSlidesIndexes = [],
    z.visibleSlides = [];
    let he = Y.spaceBetween;
    typeof he == "string" && he.indexOf("%") >= 0 ? he = parseFloat(he.replace("%", "")) / 100 * z.size : typeof he == "string" && (he = parseFloat(he));
    for (let fe = 0; fe < ne.length; fe += 1) {
        const ge = ne[fe];
        let xe = ge.swiperSlideOffset;
        Y.cssMode && Y.centeredSlides && (xe -= ne[0].swiperSlideOffset);
        const $e = (de + (Y.centeredSlides ? z.minTranslate() : 0) - xe) / (ge.swiperSlideSize + he)
          , Ee = (de - ue[0] + (Y.centeredSlides ? z.minTranslate() : 0) - xe) / (ge.swiperSlideSize + he)
          , Se = -(de - xe)
          , Ne = Se + z.slidesSizesGrid[fe]
          , tt = Se >= 0 && Se <= z.size - z.slidesSizesGrid[fe];
        (Se >= 0 && Se < z.size - 1 || Ne > 1 && Ne <= z.size || Se <= 0 && Ne >= z.size) && (z.visibleSlides.push(ge),
        z.visibleSlidesIndexes.push(fe),
        ne[fe].classList.add(Y.slideVisibleClass)),
        tt && ne[fe].classList.add(Y.slideFullyVisibleClass),
        ge.progress = le ? -$e : $e,
        ge.originalProgress = le ? -Ee : Ee
    }
}
function updateProgress(W) {
    const z = this;
    if (W === void 0) {
        const xe = z.rtlTranslate ? -1 : 1;
        W = z && z.translate && z.translate * xe || 0
    }
    const Y = z.params
      , ne = z.maxTranslate() - z.minTranslate();
    let {progress: le, isBeginning: ue, isEnd: de, progressLoop: he} = z;
    const fe = ue
      , ge = de;
    if (ne === 0)
        le = 0,
        ue = !0,
        de = !0;
    else {
        le = (W - z.minTranslate()) / ne;
        const xe = Math.abs(W - z.minTranslate()) < 1
          , $e = Math.abs(W - z.maxTranslate()) < 1;
        ue = xe || le <= 0,
        de = $e || le >= 1,
        xe && (le = 0),
        $e && (le = 1)
    }
    if (Y.loop) {
        const xe = z.getSlideIndexByData(0)
          , $e = z.getSlideIndexByData(z.slides.length - 1)
          , Ee = z.slidesGrid[xe]
          , Se = z.slidesGrid[$e]
          , Ne = z.slidesGrid[z.slidesGrid.length - 1]
          , tt = Math.abs(W);
        he = tt >= Ee ? (tt - Ee) / Ne : (tt + Ne - Se) / Ne,
        he > 1 && (he -= 1)
    }
    Object.assign(z, {
        progress: le,
        progressLoop: he,
        isBeginning: ue,
        isEnd: de
    }),
    (Y.watchSlidesProgress || Y.centeredSlides && Y.autoHeight) && z.updateSlidesProgress(W),
    ue && !fe && z.emit("reachBeginning toEdge"),
    de && !ge && z.emit("reachEnd toEdge"),
    (fe && !ue || ge && !de) && z.emit("fromEdge"),
    z.emit("progress", le)
}
function updateSlidesClasses() {
    const W = this
      , {slides: z, params: Y, slidesEl: ne, activeIndex: le} = W
      , ue = W.virtual && Y.virtual.enabled
      , de = W.grid && Y.grid && Y.grid.rows > 1
      , he = $e=>elementChildren(ne, `.${Y.slideClass}${$e}, swiper-slide${$e}`)[0];
    let fe, ge, xe;
    if (z.forEach($e=>{
        $e.classList.remove(Y.slideActiveClass, Y.slideNextClass, Y.slidePrevClass)
    }
    ),
    ue)
        if (Y.loop) {
            let $e = le - W.virtual.slidesBefore;
            $e < 0 && ($e = W.virtual.slides.length + $e),
            $e >= W.virtual.slides.length && ($e -= W.virtual.slides.length),
            fe = he(`[data-swiper-slide-index="${$e}"]`)
        } else
            fe = he(`[data-swiper-slide-index="${le}"]`);
    else
        de ? (fe = z.filter($e=>$e.column === le)[0],
        xe = z.filter($e=>$e.column === le + 1)[0],
        ge = z.filter($e=>$e.column === le - 1)[0]) : fe = z[le];
    fe && (fe.classList.add(Y.slideActiveClass),
    de ? (xe && xe.classList.add(Y.slideNextClass),
    ge && ge.classList.add(Y.slidePrevClass)) : (xe = elementNextAll(fe, `.${Y.slideClass}, swiper-slide`)[0],
    Y.loop && !xe && (xe = z[0]),
    xe && xe.classList.add(Y.slideNextClass),
    ge = elementPrevAll(fe, `.${Y.slideClass}, swiper-slide`)[0],
    Y.loop && !ge === 0 && (ge = z[z.length - 1]),
    ge && ge.classList.add(Y.slidePrevClass))),
    W.emitSlidesClasses()
}
const processLazyPreloader = (W,z)=>{
    if (!W || W.destroyed || !W.params)
        return;
    const Y = z.closest(W.isElement ? "swiper-slide" : `.${W.params.slideClass}`);
    if (Y) {
        let ne = Y.querySelector(`.${W.params.lazyPreloaderClass}`);
        !ne && W.isElement && (Y.shadowRoot ? ne = Y.shadowRoot.querySelector(`.${W.params.lazyPreloaderClass}`) : requestAnimationFrame(()=>{
            Y.shadowRoot && (ne = Y.shadowRoot.querySelector(`.${W.params.lazyPreloaderClass}`),
            ne && ne.remove())
        }
        )),
        ne && ne.remove()
    }
}
  , unlazy = (W,z)=>{
    if (!W.slides[z])
        return;
    const Y = W.slides[z].querySelector('[loading="lazy"]');
    Y && Y.removeAttribute("loading")
}
  , preload = W=>{
    if (!W || W.destroyed || !W.params)
        return;
    let z = W.params.lazyPreloadPrevNext;
    const Y = W.slides.length;
    if (!Y || !z || z < 0)
        return;
    z = Math.min(z, Y);
    const ne = W.params.slidesPerView === "auto" ? W.slidesPerViewDynamic() : Math.ceil(W.params.slidesPerView)
      , le = W.activeIndex;
    if (W.params.grid && W.params.grid.rows > 1) {
        const de = le
          , he = [de - z];
        return he.push(...Array.from({
            length: z
        }).map((fe,ge)=>de + ne + ge)),
        void W.slides.forEach((fe,ge)=>{
            he.includes(fe.column) && unlazy(W, ge)
        }
        )
    }
    const ue = le + ne - 1;
    if (W.params.rewind || W.params.loop)
        for (let de = le - z; de <= ue + z; de += 1) {
            const he = (de % Y + Y) % Y;
            (he < le || he > ue) && unlazy(W, he)
        }
    else
        for (let de = Math.max(le - z, 0); de <= Math.min(ue + z, Y - 1); de += 1)
            de !== le && (de > ue || de < le) && unlazy(W, de)
}
;
function getActiveIndexByTranslate(W) {
    const {slidesGrid: z, params: Y} = W
      , ne = W.rtlTranslate ? W.translate : -W.translate;
    let le;
    for (let ue = 0; ue < z.length; ue += 1)
        z[ue + 1] !== void 0 ? ne >= z[ue] && ne < z[ue + 1] - (z[ue + 1] - z[ue]) / 2 ? le = ue : ne >= z[ue] && ne < z[ue + 1] && (le = ue + 1) : ne >= z[ue] && (le = ue);
    return Y.normalizeSlideIndex && (le < 0 || le === void 0) && (le = 0),
    le
}
function updateActiveIndex(W) {
    const z = this
      , Y = z.rtlTranslate ? z.translate : -z.translate
      , {snapGrid: ne, params: le, activeIndex: ue, realIndex: de, snapIndex: he} = z;
    let fe, ge = W;
    const xe = Se=>{
        let Ne = Se - z.virtual.slidesBefore;
        return Ne < 0 && (Ne = z.virtual.slides.length + Ne),
        Ne >= z.virtual.slides.length && (Ne -= z.virtual.slides.length),
        Ne
    }
    ;
    if (ge === void 0 && (ge = getActiveIndexByTranslate(z)),
    ne.indexOf(Y) >= 0)
        fe = ne.indexOf(Y);
    else {
        const Se = Math.min(le.slidesPerGroupSkip, ge);
        fe = Se + Math.floor((ge - Se) / le.slidesPerGroup)
    }
    if (fe >= ne.length && (fe = ne.length - 1),
    ge === ue && !z.params.loop)
        return void (fe !== he && (z.snapIndex = fe,
        z.emit("snapIndexChange")));
    if (ge === ue && z.params.loop && z.virtual && z.params.virtual.enabled)
        return void (z.realIndex = xe(ge));
    const $e = z.grid && le.grid && le.grid.rows > 1;
    let Ee;
    if (z.virtual && le.virtual.enabled && le.loop)
        Ee = xe(ge);
    else if ($e) {
        const Se = z.slides.filter(tt=>tt.column === ge)[0];
        let Ne = parseInt(Se.getAttribute("data-swiper-slide-index"), 10);
        Number.isNaN(Ne) && (Ne = Math.max(z.slides.indexOf(Se), 0)),
        Ee = Math.floor(Ne / le.grid.rows)
    } else if (z.slides[ge]) {
        const Se = z.slides[ge].getAttribute("data-swiper-slide-index");
        Ee = Se ? parseInt(Se, 10) : ge
    } else
        Ee = ge;
    Object.assign(z, {
        previousSnapIndex: he,
        snapIndex: fe,
        previousRealIndex: de,
        realIndex: Ee,
        previousIndex: ue,
        activeIndex: ge
    }),
    z.initialized && preload(z),
    z.emit("activeIndexChange"),
    z.emit("snapIndexChange"),
    (z.initialized || z.params.runCallbacksOnInit) && (de !== Ee && z.emit("realIndexChange"),
    z.emit("slideChange"))
}
function updateClickedSlide(W, z) {
    const Y = this
      , ne = Y.params;
    let le = W.closest(`.${ne.slideClass}, swiper-slide`);
    !le && Y.isElement && z && z.length > 1 && z.includes(W) && [...z.slice(z.indexOf(W) + 1, z.length)].forEach(he=>{
        !le && he.matches && he.matches(`.${ne.slideClass}, swiper-slide`) && (le = he)
    }
    );
    let ue, de = !1;
    if (le) {
        for (let he = 0; he < Y.slides.length; he += 1)
            if (Y.slides[he] === le) {
                de = !0,
                ue = he;
                break
            }
    }
    if (!le || !de)
        return Y.clickedSlide = void 0,
        void (Y.clickedIndex = void 0);
    Y.clickedSlide = le,
    Y.virtual && Y.params.virtual.enabled ? Y.clickedIndex = parseInt(le.getAttribute("data-swiper-slide-index"), 10) : Y.clickedIndex = ue,
    ne.slideToClickedSlide && Y.clickedIndex !== void 0 && Y.clickedIndex !== Y.activeIndex && Y.slideToClickedSlide()
}
var update = {
    updateSize,
    updateSlides,
    updateAutoHeight,
    updateSlidesOffset,
    updateSlidesProgress,
    updateProgress,
    updateSlidesClasses,
    updateActiveIndex,
    updateClickedSlide
};
function getSwiperTranslate(W) {
    W === void 0 && (W = this.isHorizontal() ? "x" : "y");
    const {params: z, rtlTranslate: Y, translate: ne, wrapperEl: le} = this;
    if (z.virtualTranslate)
        return Y ? -ne : ne;
    if (z.cssMode)
        return ne;
    let ue = getTranslate(le, W);
    return ue += this.cssOverflowAdjustment(),
    Y && (ue = -ue),
    ue || 0
}
function setTranslate(W, z) {
    const Y = this
      , {rtlTranslate: ne, params: le, wrapperEl: ue, progress: de} = Y;
    let he = 0, fe = 0, ge;
    Y.isHorizontal() ? he = ne ? -W : W : fe = W,
    le.roundLengths && (he = Math.floor(he),
    fe = Math.floor(fe)),
    Y.previousTranslate = Y.translate,
    Y.translate = Y.isHorizontal() ? he : fe,
    le.cssMode ? ue[Y.isHorizontal() ? "scrollLeft" : "scrollTop"] = Y.isHorizontal() ? -he : -fe : le.virtualTranslate || (Y.isHorizontal() ? he -= Y.cssOverflowAdjustment() : fe -= Y.cssOverflowAdjustment(),
    ue.style.transform = `translate3d(${he}px, ${fe}px, 0px)`);
    const xe = Y.maxTranslate() - Y.minTranslate();
    ge = xe === 0 ? 0 : (W - Y.minTranslate()) / xe,
    ge !== de && Y.updateProgress(W),
    Y.emit("setTranslate", Y.translate, z)
}
function minTranslate() {
    return -this.snapGrid[0]
}
function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1]
}
function translateTo(W, z, Y, ne, le) {
    W === void 0 && (W = 0),
    z === void 0 && (z = this.params.speed),
    Y === void 0 && (Y = !0),
    ne === void 0 && (ne = !0);
    const ue = this
      , {params: de, wrapperEl: he} = ue;
    if (ue.animating && de.preventInteractionOnTransition)
        return !1;
    const fe = ue.minTranslate()
      , ge = ue.maxTranslate();
    let xe;
    if (xe = ne && W > fe ? fe : ne && W < ge ? ge : W,
    ue.updateProgress(xe),
    de.cssMode) {
        const $e = ue.isHorizontal();
        if (z === 0)
            he[$e ? "scrollLeft" : "scrollTop"] = -xe;
        else {
            if (!ue.support.smoothScroll)
                return animateCSSModeScroll({
                    swiper: ue,
                    targetPosition: -xe,
                    side: $e ? "left" : "top"
                }),
                !0;
            he.scrollTo({
                [$e ? "left" : "top"]: -xe,
                behavior: "smooth"
            })
        }
        return !0
    }
    return z === 0 ? (ue.setTransition(0),
    ue.setTranslate(xe),
    Y && (ue.emit("beforeTransitionStart", z, le),
    ue.emit("transitionEnd"))) : (ue.setTransition(z),
    ue.setTranslate(xe),
    Y && (ue.emit("beforeTransitionStart", z, le),
    ue.emit("transitionStart")),
    ue.animating || (ue.animating = !0,
    ue.onTranslateToWrapperTransitionEnd || (ue.onTranslateToWrapperTransitionEnd = function($e) {
        ue && !ue.destroyed && $e.target === this && (ue.wrapperEl.removeEventListener("transitionend", ue.onTranslateToWrapperTransitionEnd),
        ue.onTranslateToWrapperTransitionEnd = null,
        delete ue.onTranslateToWrapperTransitionEnd,
        Y && ue.emit("transitionEnd"))
    }
    ),
    ue.wrapperEl.addEventListener("transitionend", ue.onTranslateToWrapperTransitionEnd))),
    !0
}
var translate = {
    getTranslate: getSwiperTranslate,
    setTranslate,
    minTranslate,
    maxTranslate,
    translateTo
};
function setTransition(W, z) {
    const Y = this;
    Y.params.cssMode || (Y.wrapperEl.style.transitionDuration = `${W}ms`,
    Y.wrapperEl.style.transitionDelay = W === 0 ? "0ms" : ""),
    Y.emit("setTransition", W, z)
}
function transitionEmit(W) {
    let {swiper: z, runCallbacks: Y, direction: ne, step: le} = W;
    const {activeIndex: ue, previousIndex: de} = z;
    let he = ne;
    if (he || (he = ue > de ? "next" : ue < de ? "prev" : "reset"),
    z.emit(`transition${le}`),
    Y && ue !== de) {
        if (he === "reset")
            return void z.emit(`slideResetTransition${le}`);
        z.emit(`slideChangeTransition${le}`),
        he === "next" ? z.emit(`slideNextTransition${le}`) : z.emit(`slidePrevTransition${le}`)
    }
}
function transitionStart(W, z) {
    W === void 0 && (W = !0);
    const Y = this
      , {params: ne} = Y;
    ne.cssMode || (ne.autoHeight && Y.updateAutoHeight(),
    transitionEmit({
        swiper: Y,
        runCallbacks: W,
        direction: z,
        step: "Start"
    }))
}
function transitionEnd(W, z) {
    W === void 0 && (W = !0);
    const Y = this
      , {params: ne} = Y;
    Y.animating = !1,
    ne.cssMode || (Y.setTransition(0),
    transitionEmit({
        swiper: Y,
        runCallbacks: W,
        direction: z,
        step: "End"
    }))
}
var transition = {
    setTransition,
    transitionStart,
    transitionEnd
};
function slideTo(W, z, Y, ne, le) {
    W === void 0 && (W = 0),
    z === void 0 && (z = this.params.speed),
    Y === void 0 && (Y = !0),
    typeof W == "string" && (W = parseInt(W, 10));
    const ue = this;
    let de = W;
    de < 0 && (de = 0);
    const {params: he, snapGrid: fe, slidesGrid: ge, previousIndex: xe, activeIndex: $e, rtlTranslate: Ee, wrapperEl: Se, enabled: Ne} = ue;
    if (ue.animating && he.preventInteractionOnTransition || !Ne && !ne && !le)
        return !1;
    const tt = Math.min(ue.params.slidesPerGroupSkip, de);
    let rr = tt + Math.floor((de - tt) / ue.params.slidesPerGroup);
    rr >= fe.length && (rr = fe.length - 1);
    const tr = -fe[rr];
    if (he.normalizeSlideIndex)
        for (let Ut = 0; Ut < ge.length; Ut += 1) {
            const lr = -Math.floor(100 * tr)
              , cr = Math.floor(100 * ge[Ut])
              , be = Math.floor(100 * ge[Ut + 1]);
            ge[Ut + 1] !== void 0 ? lr >= cr && lr < be - (be - cr) / 2 ? de = Ut : lr >= cr && lr < be && (de = Ut + 1) : lr >= cr && (de = Ut)
        }
    if (ue.initialized && de !== $e && (!ue.allowSlideNext && (Ee ? tr > ue.translate && tr > ue.minTranslate() : tr < ue.translate && tr < ue.minTranslate()) || !ue.allowSlidePrev && tr > ue.translate && tr > ue.maxTranslate() && ($e || 0) !== de))
        return !1;
    let we;
    if (de !== (xe || 0) && Y && ue.emit("beforeSlideChangeStart"),
    ue.updateProgress(tr),
    we = de > $e ? "next" : de < $e ? "prev" : "reset",
    Ee && -tr === ue.translate || !Ee && tr === ue.translate)
        return ue.updateActiveIndex(de),
        he.autoHeight && ue.updateAutoHeight(),
        ue.updateSlidesClasses(),
        he.effect !== "slide" && ue.setTranslate(tr),
        we !== "reset" && (ue.transitionStart(Y, we),
        ue.transitionEnd(Y, we)),
        !1;
    if (he.cssMode) {
        const Ut = ue.isHorizontal()
          , lr = Ee ? tr : -tr;
        if (z === 0) {
            const cr = ue.virtual && ue.params.virtual.enabled;
            cr && (ue.wrapperEl.style.scrollSnapType = "none",
            ue._immediateVirtual = !0),
            cr && !ue._cssModeVirtualInitialSet && ue.params.initialSlide > 0 ? (ue._cssModeVirtualInitialSet = !0,
            requestAnimationFrame(()=>{
                Se[Ut ? "scrollLeft" : "scrollTop"] = lr
            }
            )) : Se[Ut ? "scrollLeft" : "scrollTop"] = lr,
            cr && requestAnimationFrame(()=>{
                ue.wrapperEl.style.scrollSnapType = "",
                ue._immediateVirtual = !1
            }
            )
        } else {
            if (!ue.support.smoothScroll)
                return animateCSSModeScroll({
                    swiper: ue,
                    targetPosition: lr,
                    side: Ut ? "left" : "top"
                }),
                !0;
            Se.scrollTo({
                [Ut ? "left" : "top"]: lr,
                behavior: "smooth"
            })
        }
        return !0
    }
    return ue.setTransition(z),
    ue.setTranslate(tr),
    ue.updateActiveIndex(de),
    ue.updateSlidesClasses(),
    ue.emit("beforeTransitionStart", z, ne),
    ue.transitionStart(Y, we),
    z === 0 ? ue.transitionEnd(Y, we) : ue.animating || (ue.animating = !0,
    ue.onSlideToWrapperTransitionEnd || (ue.onSlideToWrapperTransitionEnd = function(Ut) {
        ue && !ue.destroyed && Ut.target === this && (ue.wrapperEl.removeEventListener("transitionend", ue.onSlideToWrapperTransitionEnd),
        ue.onSlideToWrapperTransitionEnd = null,
        delete ue.onSlideToWrapperTransitionEnd,
        ue.transitionEnd(Y, we))
    }
    ),
    ue.wrapperEl.addEventListener("transitionend", ue.onSlideToWrapperTransitionEnd)),
    !0
}
function slideToLoop(W, z, Y, ne) {
    W === void 0 && (W = 0),
    z === void 0 && (z = this.params.speed),
    Y === void 0 && (Y = !0),
    typeof W == "string" && (W = parseInt(W, 10));
    const le = this
      , ue = le.grid && le.params.grid && le.params.grid.rows > 1;
    let de = W;
    if (le.params.loop)
        if (le.virtual && le.params.virtual.enabled)
            de += le.virtual.slidesBefore;
        else {
            let he;
            if (ue) {
                const Ee = de * le.params.grid.rows;
                he = le.slides.filter(Se=>1 * Se.getAttribute("data-swiper-slide-index") === Ee)[0].column
            } else
                he = le.getSlideIndexByData(de);
            const fe = ue ? Math.ceil(le.slides.length / le.params.grid.rows) : le.slides.length
              , {centeredSlides: ge} = le.params;
            let xe = le.params.slidesPerView;
            xe === "auto" ? xe = le.slidesPerViewDynamic() : (xe = Math.ceil(parseFloat(le.params.slidesPerView, 10)),
            ge && xe % 2 == 0 && (xe += 1));
            let $e = fe - he < xe;
            if (ge && ($e = $e || he < Math.ceil(xe / 2)),
            $e) {
                const Ee = ge ? he < le.activeIndex ? "prev" : "next" : he - le.activeIndex - 1 < le.params.slidesPerView ? "next" : "prev";
                le.loopFix({
                    direction: Ee,
                    slideTo: !0,
                    activeSlideIndex: Ee === "next" ? he + 1 : he - fe + 1,
                    slideRealIndex: Ee === "next" ? le.realIndex : void 0
                })
            }
            if (ue) {
                const Ee = de * le.params.grid.rows;
                de = le.slides.filter(Se=>1 * Se.getAttribute("data-swiper-slide-index") === Ee)[0].column
            } else
                de = le.getSlideIndexByData(de)
        }
    return requestAnimationFrame(()=>{
        le.slideTo(de, z, Y, ne)
    }
    ),
    le
}
function slideNext(W, z, Y) {
    W === void 0 && (W = this.params.speed),
    z === void 0 && (z = !0);
    const ne = this
      , {enabled: le, params: ue, animating: de} = ne;
    if (!le)
        return ne;
    let he = ue.slidesPerGroup;
    ue.slidesPerView === "auto" && ue.slidesPerGroup === 1 && ue.slidesPerGroupAuto && (he = Math.max(ne.slidesPerViewDynamic("current", !0), 1));
    const fe = ne.activeIndex < ue.slidesPerGroupSkip ? 1 : he
      , ge = ne.virtual && ue.virtual.enabled;
    if (ue.loop) {
        if (de && !ge && ue.loopPreventsSliding)
            return !1;
        if (ne.loopFix({
            direction: "next"
        }),
        ne._clientLeft = ne.wrapperEl.clientLeft,
        ne.activeIndex === ne.slides.length - 1 && ue.cssMode)
            return requestAnimationFrame(()=>{
                ne.slideTo(ne.activeIndex + fe, W, z, Y)
            }
            ),
            !0
    }
    return ue.rewind && ne.isEnd ? ne.slideTo(0, W, z, Y) : ne.slideTo(ne.activeIndex + fe, W, z, Y)
}
function slidePrev(W, z, Y) {
    W === void 0 && (W = this.params.speed),
    z === void 0 && (z = !0);
    const ne = this
      , {params: le, snapGrid: ue, slidesGrid: de, rtlTranslate: he, enabled: fe, animating: ge} = ne;
    if (!fe)
        return ne;
    const xe = ne.virtual && le.virtual.enabled;
    if (le.loop) {
        if (ge && !xe && le.loopPreventsSliding)
            return !1;
        ne.loopFix({
            direction: "prev"
        }),
        ne._clientLeft = ne.wrapperEl.clientLeft
    }
    function $e(rr) {
        return rr < 0 ? -Math.floor(Math.abs(rr)) : Math.floor(rr)
    }
    const Ee = $e(he ? ne.translate : -ne.translate)
      , Se = ue.map(rr=>$e(rr));
    let Ne = ue[Se.indexOf(Ee) - 1];
    if (Ne === void 0 && le.cssMode) {
        let rr;
        ue.forEach((tr,we)=>{
            Ee >= tr && (rr = we)
        }
        ),
        rr !== void 0 && (Ne = ue[rr > 0 ? rr - 1 : rr])
    }
    let tt = 0;
    if (Ne !== void 0 && (tt = de.indexOf(Ne),
    tt < 0 && (tt = ne.activeIndex - 1),
    le.slidesPerView === "auto" && le.slidesPerGroup === 1 && le.slidesPerGroupAuto && (tt = tt - ne.slidesPerViewDynamic("previous", !0) + 1,
    tt = Math.max(tt, 0))),
    le.rewind && ne.isBeginning) {
        const rr = ne.params.virtual && ne.params.virtual.enabled && ne.virtual ? ne.virtual.slides.length - 1 : ne.slides.length - 1;
        return ne.slideTo(rr, W, z, Y)
    }
    return le.loop && ne.activeIndex === 0 && le.cssMode ? (requestAnimationFrame(()=>{
        ne.slideTo(tt, W, z, Y)
    }
    ),
    !0) : ne.slideTo(tt, W, z, Y)
}
function slideReset(W, z, Y) {
    return W === void 0 && (W = this.params.speed),
    z === void 0 && (z = !0),
    this.slideTo(this.activeIndex, W, z, Y)
}
function slideToClosest(W, z, Y, ne) {
    W === void 0 && (W = this.params.speed),
    z === void 0 && (z = !0),
    ne === void 0 && (ne = .5);
    const le = this;
    let ue = le.activeIndex;
    const de = Math.min(le.params.slidesPerGroupSkip, ue)
      , he = de + Math.floor((ue - de) / le.params.slidesPerGroup)
      , fe = le.rtlTranslate ? le.translate : -le.translate;
    if (fe >= le.snapGrid[he]) {
        const ge = le.snapGrid[he];
        fe - ge > (le.snapGrid[he + 1] - ge) * ne && (ue += le.params.slidesPerGroup)
    } else {
        const ge = le.snapGrid[he - 1];
        fe - ge <= (le.snapGrid[he] - ge) * ne && (ue -= le.params.slidesPerGroup)
    }
    return ue = Math.max(ue, 0),
    ue = Math.min(ue, le.slidesGrid.length - 1),
    le.slideTo(ue, W, z, Y)
}
function slideToClickedSlide() {
    const W = this
      , {params: z, slidesEl: Y} = W
      , ne = z.slidesPerView === "auto" ? W.slidesPerViewDynamic() : z.slidesPerView;
    let le, ue = W.clickedIndex;
    const de = W.isElement ? "swiper-slide" : `.${z.slideClass}`;
    if (z.loop) {
        if (W.animating)
            return;
        le = parseInt(W.clickedSlide.getAttribute("data-swiper-slide-index"), 10),
        z.centeredSlides ? ue < W.loopedSlides - ne / 2 || ue > W.slides.length - W.loopedSlides + ne / 2 ? (W.loopFix(),
        ue = W.getSlideIndex(elementChildren(Y, `${de}[data-swiper-slide-index="${le}"]`)[0]),
        nextTick(()=>{
            W.slideTo(ue)
        }
        )) : W.slideTo(ue) : ue > W.slides.length - ne ? (W.loopFix(),
        ue = W.getSlideIndex(elementChildren(Y, `${de}[data-swiper-slide-index="${le}"]`)[0]),
        nextTick(()=>{
            W.slideTo(ue)
        }
        )) : W.slideTo(ue)
    } else
        W.slideTo(ue)
}
var slide = {
    slideTo,
    slideToLoop,
    slideNext,
    slidePrev,
    slideReset,
    slideToClosest,
    slideToClickedSlide
};
function loopCreate(W) {
    const z = this
      , {params: Y, slidesEl: ne} = z;
    if (!Y.loop || z.virtual && z.params.virtual.enabled)
        return;
    const le = ()=>{
        elementChildren(ne, `.${Y.slideClass}, swiper-slide`).forEach((xe,$e)=>{
            xe.setAttribute("data-swiper-slide-index", $e)
        }
        )
    }
      , ue = z.grid && Y.grid && Y.grid.rows > 1
      , de = Y.slidesPerGroup * (ue ? Y.grid.rows : 1)
      , he = z.slides.length % de != 0
      , fe = ue && z.slides.length % Y.grid.rows != 0
      , ge = xe=>{
        for (let $e = 0; $e < xe; $e += 1) {
            const Ee = z.isElement ? createElement("swiper-slide", [Y.slideBlankClass]) : createElement("div", [Y.slideClass, Y.slideBlankClass]);
            z.slidesEl.append(Ee)
        }
    }
    ;
    he ? (Y.loopAddBlankSlides ? (ge(de - z.slides.length % de),
    z.recalcSlides(),
    z.updateSlides()) : showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"),
    le()) : (fe && (Y.loopAddBlankSlides ? (ge(Y.grid.rows - z.slides.length % Y.grid.rows),
    z.recalcSlides(),
    z.updateSlides()) : showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)")),
    le()),
    z.loopFix({
        slideRealIndex: W,
        direction: Y.centeredSlides ? void 0 : "next"
    })
}
function loopFix(W) {
    let {slideRealIndex: z, slideTo: Y=!0, direction: ne, setTranslate: le, activeSlideIndex: ue, byController: de, byMousewheel: he} = W === void 0 ? {} : W;
    const fe = this;
    if (!fe.params.loop)
        return;
    fe.emit("beforeLoopFix");
    const {slides: ge, allowSlidePrev: xe, allowSlideNext: $e, slidesEl: Ee, params: Se} = fe
      , {centeredSlides: Ne} = Se;
    if (fe.allowSlidePrev = !0,
    fe.allowSlideNext = !0,
    fe.virtual && Se.virtual.enabled)
        return Y && (Se.centeredSlides || fe.snapIndex !== 0 ? Se.centeredSlides && fe.snapIndex < Se.slidesPerView ? fe.slideTo(fe.virtual.slides.length + fe.snapIndex, 0, !1, !0) : fe.snapIndex === fe.snapGrid.length - 1 && fe.slideTo(fe.virtual.slidesBefore, 0, !1, !0) : fe.slideTo(fe.virtual.slides.length, 0, !1, !0)),
        fe.allowSlidePrev = xe,
        fe.allowSlideNext = $e,
        void fe.emit("loopFix");
    let tt = Se.slidesPerView;
    tt === "auto" ? tt = fe.slidesPerViewDynamic() : (tt = Math.ceil(parseFloat(Se.slidesPerView, 10)),
    Ne && tt % 2 == 0 && (tt += 1));
    const rr = Se.slidesPerGroupAuto ? tt : Se.slidesPerGroup;
    let tr = rr;
    tr % rr != 0 && (tr += rr - tr % rr),
    tr += Se.loopAdditionalSlides,
    fe.loopedSlides = tr;
    const we = fe.grid && Se.grid && Se.grid.rows > 1;
    ge.length < tt + tr ? showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : we && Se.grid.fill === "row" && showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
    const Ut = []
      , lr = [];
    let cr = fe.activeIndex;
    ue === void 0 ? ue = fe.getSlideIndex(ge.filter(br=>br.classList.contains(Se.slideActiveClass))[0]) : cr = ue;
    const be = ne === "next" || !ne
      , mr = ne === "prev" || !ne;
    let fr = 0
      , Rr = 0;
    const Pr = we ? Math.ceil(ge.length / Se.grid.rows) : ge.length
      , Fr = (we ? ge[ue].column : ue) + (Ne && le === void 0 ? -tt / 2 + .5 : 0);
    if (Fr < tr) {
        fr = Math.max(tr - Fr, rr);
        for (let br = 0; br < tr - Fr; br += 1) {
            const xr = br - Math.floor(br / Pr) * Pr;
            if (we) {
                const _r = Pr - xr - 1;
                for (let Ir = ge.length - 1; Ir >= 0; Ir -= 1)
                    ge[Ir].column === _r && Ut.push(Ir)
            } else
                Ut.push(Pr - xr - 1)
        }
    } else if (Fr + tt > Pr - tr) {
        Rr = Math.max(Fr - (Pr - 2 * tr), rr);
        for (let br = 0; br < Rr; br += 1) {
            const xr = br - Math.floor(br / Pr) * Pr;
            we ? ge.forEach((_r,Ir)=>{
                _r.column === xr && lr.push(Ir)
            }
            ) : lr.push(xr)
        }
    }
    if (fe.__preventObserver__ = !0,
    requestAnimationFrame(()=>{
        fe.__preventObserver__ = !1
    }
    ),
    mr && Ut.forEach(br=>{
        ge[br].swiperLoopMoveDOM = !0,
        Ee.prepend(ge[br]),
        ge[br].swiperLoopMoveDOM = !1
    }
    ),
    be && lr.forEach(br=>{
        ge[br].swiperLoopMoveDOM = !0,
        Ee.append(ge[br]),
        ge[br].swiperLoopMoveDOM = !1
    }
    ),
    fe.recalcSlides(),
    Se.slidesPerView === "auto" ? fe.updateSlides() : we && (Ut.length > 0 && mr || lr.length > 0 && be) && fe.slides.forEach((br,xr)=>{
        fe.grid.updateSlide(xr, br, fe.slides)
    }
    ),
    Se.watchSlidesProgress && fe.updateSlidesOffset(),
    Y) {
        if (Ut.length > 0 && mr) {
            if (z === void 0) {
                const br = fe.slidesGrid[cr]
                  , xr = fe.slidesGrid[cr + fr] - br;
                he ? fe.setTranslate(fe.translate - xr) : (fe.slideTo(cr + fr, 0, !1, !0),
                le && (fe.touchEventsData.startTranslate = fe.touchEventsData.startTranslate - xr,
                fe.touchEventsData.currentTranslate = fe.touchEventsData.currentTranslate - xr))
            } else if (le) {
                const br = we ? Ut.length / Se.grid.rows : Ut.length;
                fe.slideTo(fe.activeIndex + br, 0, !1, !0),
                fe.touchEventsData.currentTranslate = fe.translate
            }
        } else if (lr.length > 0 && be)
            if (z === void 0) {
                const br = fe.slidesGrid[cr]
                  , xr = fe.slidesGrid[cr - Rr] - br;
                he ? fe.setTranslate(fe.translate - xr) : (fe.slideTo(cr - Rr, 0, !1, !0),
                le && (fe.touchEventsData.startTranslate = fe.touchEventsData.startTranslate - xr,
                fe.touchEventsData.currentTranslate = fe.touchEventsData.currentTranslate - xr))
            } else {
                const br = we ? lr.length / Se.grid.rows : lr.length;
                fe.slideTo(fe.activeIndex - br, 0, !1, !0)
            }
    }
    if (fe.allowSlidePrev = xe,
    fe.allowSlideNext = $e,
    fe.controller && fe.controller.control && !de) {
        const br = {
            slideRealIndex: z,
            direction: ne,
            setTranslate: le,
            activeSlideIndex: ue,
            byController: !0
        };
        Array.isArray(fe.controller.control) ? fe.controller.control.forEach(xr=>{
            !xr.destroyed && xr.params.loop && xr.loopFix({
                ...br,
                slideTo: xr.params.slidesPerView === Se.slidesPerView && Y
            })
        }
        ) : fe.controller.control instanceof fe.constructor && fe.controller.control.params.loop && fe.controller.control.loopFix({
            ...br,
            slideTo: fe.controller.control.params.slidesPerView === Se.slidesPerView && Y
        })
    }
    fe.emit("loopFix")
}
function loopDestroy() {
    const W = this
      , {params: z, slidesEl: Y} = W;
    if (!z.loop || W.virtual && W.params.virtual.enabled)
        return;
    W.recalcSlides();
    const ne = [];
    W.slides.forEach(le=>{
        const ue = le.swiperSlideIndex === void 0 ? 1 * le.getAttribute("data-swiper-slide-index") : le.swiperSlideIndex;
        ne[ue] = le
    }
    ),
    W.slides.forEach(le=>{
        le.removeAttribute("data-swiper-slide-index")
    }
    ),
    ne.forEach(le=>{
        Y.append(le)
    }
    ),
    W.recalcSlides(),
    W.slideTo(W.realIndex, 0)
}
var loop = {
    loopCreate,
    loopFix,
    loopDestroy
};
function setGrabCursor(W) {
    const z = this;
    if (!z.params.simulateTouch || z.params.watchOverflow && z.isLocked || z.params.cssMode)
        return;
    const Y = z.params.touchEventsTarget === "container" ? z.el : z.wrapperEl;
    z.isElement && (z.__preventObserver__ = !0),
    Y.style.cursor = "move",
    Y.style.cursor = W ? "grabbing" : "grab",
    z.isElement && requestAnimationFrame(()=>{
        z.__preventObserver__ = !1
    }
    )
}
function unsetGrabCursor() {
    const W = this;
    W.params.watchOverflow && W.isLocked || W.params.cssMode || (W.isElement && (W.__preventObserver__ = !0),
    W[W.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "",
    W.isElement && requestAnimationFrame(()=>{
        W.__preventObserver__ = !1
    }
    ))
}
var grabCursor = {
    setGrabCursor,
    unsetGrabCursor
};
function closestElement(W, z) {
    return z === void 0 && (z = this),
    function Y(ne) {
        if (!ne || ne === getDocument$1() || ne === getWindow())
            return null;
        ne.assignedSlot && (ne = ne.assignedSlot);
        const le = ne.closest(W);
        return le || ne.getRootNode ? le || Y(ne.getRootNode().host) : null
    }(z)
}
function preventEdgeSwipe(W, z, Y) {
    const ne = getWindow()
      , {params: le} = W
      , ue = le.edgeSwipeDetection
      , de = le.edgeSwipeThreshold;
    return !ue || !(Y <= de || Y >= ne.innerWidth - de) || ue === "prevent" && (z.preventDefault(),
    !0)
}
function onTouchStart(W) {
    const z = this
      , Y = getDocument$1();
    let ne = W;
    ne.originalEvent && (ne = ne.originalEvent);
    const le = z.touchEventsData;
    if (ne.type === "pointerdown") {
        if (le.pointerId !== null && le.pointerId !== ne.pointerId)
            return;
        le.pointerId = ne.pointerId
    } else
        ne.type === "touchstart" && ne.targetTouches.length === 1 && (le.touchId = ne.targetTouches[0].identifier);
    if (ne.type === "touchstart")
        return void preventEdgeSwipe(z, ne, ne.targetTouches[0].pageX);
    const {params: ue, touches: de, enabled: he} = z;
    if (!he || !ue.simulateTouch && ne.pointerType === "mouse" || z.animating && ue.preventInteractionOnTransition)
        return;
    !z.animating && ue.cssMode && ue.loop && z.loopFix();
    let fe = ne.target;
    if (ue.touchEventsTarget === "wrapper" && !z.wrapperEl.contains(fe) || "which"in ne && ne.which === 3 || "button"in ne && ne.button > 0 || le.isTouched && le.isMoved)
        return;
    const ge = !!ue.noSwipingClass && ue.noSwipingClass !== ""
      , xe = ne.composedPath ? ne.composedPath() : ne.path;
    ge && ne.target && ne.target.shadowRoot && xe && (fe = xe[0]);
    const $e = ue.noSwipingSelector ? ue.noSwipingSelector : `.${ue.noSwipingClass}`
      , Ee = !(!ne.target || !ne.target.shadowRoot);
    if (ue.noSwiping && (Ee ? closestElement($e, fe) : fe.closest($e)))
        return void (z.allowClick = !0);
    if (ue.swipeHandler && !fe.closest(ue.swipeHandler))
        return;
    de.currentX = ne.pageX,
    de.currentY = ne.pageY;
    const Se = de.currentX
      , Ne = de.currentY;
    if (!preventEdgeSwipe(z, ne, Se))
        return;
    Object.assign(le, {
        isTouched: !0,
        isMoved: !1,
        allowTouchCallbacks: !0,
        isScrolling: void 0,
        startMoving: void 0
    }),
    de.startX = Se,
    de.startY = Ne,
    le.touchStartTime = now$1(),
    z.allowClick = !0,
    z.updateSize(),
    z.swipeDirection = void 0,
    ue.threshold > 0 && (le.allowThresholdMove = !1);
    let tt = !0;
    fe.matches(le.focusableElements) && (tt = !1,
    fe.nodeName === "SELECT" && (le.isTouched = !1)),
    Y.activeElement && Y.activeElement.matches(le.focusableElements) && Y.activeElement !== fe && Y.activeElement.blur();
    const rr = tt && z.allowTouchMove && ue.touchStartPreventDefault;
    !ue.touchStartForcePreventDefault && !rr || fe.isContentEditable || ne.preventDefault(),
    ue.freeMode && ue.freeMode.enabled && z.freeMode && z.animating && !ue.cssMode && z.freeMode.onTouchStart(),
    z.emit("touchStart", ne)
}
function onTouchMove(W) {
    const z = getDocument$1()
      , Y = this
      , ne = Y.touchEventsData
      , {params: le, touches: ue, rtlTranslate: de, enabled: he} = Y;
    if (!he || !le.simulateTouch && W.pointerType === "mouse")
        return;
    let fe, ge = W;
    if (ge.originalEvent && (ge = ge.originalEvent),
    ge.type === "pointermove" && (ne.touchId !== null || ge.pointerId !== ne.pointerId))
        return;
    if (ge.type === "touchmove") {
        if (fe = [...ge.changedTouches].filter(cr=>cr.identifier === ne.touchId)[0],
        !fe || fe.identifier !== ne.touchId)
            return
    } else
        fe = ge;
    if (!ne.isTouched)
        return void (ne.startMoving && ne.isScrolling && Y.emit("touchMoveOpposite", ge));
    const xe = fe.pageX
      , $e = fe.pageY;
    if (ge.preventedByNestedSwiper)
        return ue.startX = xe,
        void (ue.startY = $e);
    if (!Y.allowTouchMove)
        return ge.target.matches(ne.focusableElements) || (Y.allowClick = !1),
        void (ne.isTouched && (Object.assign(ue, {
            startX: xe,
            startY: $e,
            currentX: xe,
            currentY: $e
        }),
        ne.touchStartTime = now$1()));
    if (le.touchReleaseOnEdges && !le.loop) {
        if (Y.isVertical()) {
            if ($e < ue.startY && Y.translate <= Y.maxTranslate() || $e > ue.startY && Y.translate >= Y.minTranslate())
                return ne.isTouched = !1,
                void (ne.isMoved = !1)
        } else if (xe < ue.startX && Y.translate <= Y.maxTranslate() || xe > ue.startX && Y.translate >= Y.minTranslate())
            return
    }
    if (z.activeElement && ge.target === z.activeElement && ge.target.matches(ne.focusableElements))
        return ne.isMoved = !0,
        void (Y.allowClick = !1);
    ne.allowTouchCallbacks && Y.emit("touchMove", ge),
    ue.previousX = ue.currentX,
    ue.previousY = ue.currentY,
    ue.currentX = xe,
    ue.currentY = $e;
    const Ee = ue.currentX - ue.startX
      , Se = ue.currentY - ue.startY;
    if (Y.params.threshold && Math.sqrt(Ee ** 2 + Se ** 2) < Y.params.threshold)
        return;
    if (ne.isScrolling === void 0) {
        let cr;
        Y.isHorizontal() && ue.currentY === ue.startY || Y.isVertical() && ue.currentX === ue.startX ? ne.isScrolling = !1 : Ee * Ee + Se * Se >= 25 && (cr = 180 * Math.atan2(Math.abs(Se), Math.abs(Ee)) / Math.PI,
        ne.isScrolling = Y.isHorizontal() ? cr > le.touchAngle : 90 - cr > le.touchAngle)
    }
    if (ne.isScrolling && Y.emit("touchMoveOpposite", ge),
    ne.startMoving === void 0 && (ue.currentX === ue.startX && ue.currentY === ue.startY || (ne.startMoving = !0)),
    ne.isScrolling)
        return void (ne.isTouched = !1);
    if (!ne.startMoving)
        return;
    Y.allowClick = !1,
    !le.cssMode && ge.cancelable && ge.preventDefault(),
    le.touchMoveStopPropagation && !le.nested && ge.stopPropagation();
    let Ne = Y.isHorizontal() ? Ee : Se
      , tt = Y.isHorizontal() ? ue.currentX - ue.previousX : ue.currentY - ue.previousY;
    le.oneWayMovement && (Ne = Math.abs(Ne) * (de ? 1 : -1),
    tt = Math.abs(tt) * (de ? 1 : -1)),
    ue.diff = Ne,
    Ne *= le.touchRatio,
    de && (Ne = -Ne,
    tt = -tt);
    const rr = Y.touchesDirection;
    Y.swipeDirection = Ne > 0 ? "prev" : "next",
    Y.touchesDirection = tt > 0 ? "prev" : "next";
    const tr = Y.params.loop && !le.cssMode
      , we = Y.touchesDirection === "next" && Y.allowSlideNext || Y.touchesDirection === "prev" && Y.allowSlidePrev;
    if (!ne.isMoved) {
        if (tr && we && Y.loopFix({
            direction: Y.swipeDirection
        }),
        ne.startTranslate = Y.getTranslate(),
        Y.setTransition(0),
        Y.animating) {
            const cr = new window.CustomEvent("transitionend",{
                bubbles: !0,
                cancelable: !0
            });
            Y.wrapperEl.dispatchEvent(cr)
        }
        ne.allowMomentumBounce = !1,
        !le.grabCursor || Y.allowSlideNext !== !0 && Y.allowSlidePrev !== !0 || Y.setGrabCursor(!0),
        Y.emit("sliderFirstMove", ge)
    }
    if (new Date().getTime(),
    ne.isMoved && ne.allowThresholdMove && rr !== Y.touchesDirection && tr && we && Math.abs(Ne) >= 1)
        return Object.assign(ue, {
            startX: xe,
            startY: $e,
            currentX: xe,
            currentY: $e,
            startTranslate: ne.currentTranslate
        }),
        ne.loopSwapReset = !0,
        void (ne.startTranslate = ne.currentTranslate);
    Y.emit("sliderMove", ge),
    ne.isMoved = !0,
    ne.currentTranslate = Ne + ne.startTranslate;
    let Ut = !0
      , lr = le.resistanceRatio;
    if (le.touchReleaseOnEdges && (lr = 0),
    Ne > 0 ? (tr && we && ne.allowThresholdMove && ne.currentTranslate > (le.centeredSlides ? Y.minTranslate() - Y.slidesSizesGrid[Y.activeIndex + 1] : Y.minTranslate()) && Y.loopFix({
        direction: "prev",
        setTranslate: !0,
        activeSlideIndex: 0
    }),
    ne.currentTranslate > Y.minTranslate() && (Ut = !1,
    le.resistance && (ne.currentTranslate = Y.minTranslate() - 1 + (-Y.minTranslate() + ne.startTranslate + Ne) ** lr))) : Ne < 0 && (tr && we && ne.allowThresholdMove && ne.currentTranslate < (le.centeredSlides ? Y.maxTranslate() + Y.slidesSizesGrid[Y.slidesSizesGrid.length - 1] : Y.maxTranslate()) && Y.loopFix({
        direction: "next",
        setTranslate: !0,
        activeSlideIndex: Y.slides.length - (le.slidesPerView === "auto" ? Y.slidesPerViewDynamic() : Math.ceil(parseFloat(le.slidesPerView, 10)))
    }),
    ne.currentTranslate < Y.maxTranslate() && (Ut = !1,
    le.resistance && (ne.currentTranslate = Y.maxTranslate() + 1 - (Y.maxTranslate() - ne.startTranslate - Ne) ** lr))),
    Ut && (ge.preventedByNestedSwiper = !0),
    !Y.allowSlideNext && Y.swipeDirection === "next" && ne.currentTranslate < ne.startTranslate && (ne.currentTranslate = ne.startTranslate),
    !Y.allowSlidePrev && Y.swipeDirection === "prev" && ne.currentTranslate > ne.startTranslate && (ne.currentTranslate = ne.startTranslate),
    Y.allowSlidePrev || Y.allowSlideNext || (ne.currentTranslate = ne.startTranslate),
    le.threshold > 0) {
        if (!(Math.abs(Ne) > le.threshold || ne.allowThresholdMove))
            return void (ne.currentTranslate = ne.startTranslate);
        if (!ne.allowThresholdMove)
            return ne.allowThresholdMove = !0,
            ue.startX = ue.currentX,
            ue.startY = ue.currentY,
            ne.currentTranslate = ne.startTranslate,
            void (ue.diff = Y.isHorizontal() ? ue.currentX - ue.startX : ue.currentY - ue.startY)
    }
    le.followFinger && !le.cssMode && ((le.freeMode && le.freeMode.enabled && Y.freeMode || le.watchSlidesProgress) && (Y.updateActiveIndex(),
    Y.updateSlidesClasses()),
    le.freeMode && le.freeMode.enabled && Y.freeMode && Y.freeMode.onTouchMove(),
    Y.updateProgress(ne.currentTranslate),
    Y.setTranslate(ne.currentTranslate))
}
function onTouchEnd(W) {
    const z = this
      , Y = z.touchEventsData;
    let ne, le = W;
    if (le.originalEvent && (le = le.originalEvent),
    le.type === "touchend" || le.type === "touchcancel") {
        if (ne = [...le.changedTouches].filter(lr=>lr.identifier === Y.touchId)[0],
        !ne || ne.identifier !== Y.touchId)
            return
    } else {
        if (Y.touchId !== null || le.pointerId !== Y.pointerId)
            return;
        ne = le
    }
    if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(le.type) && !(["pointercancel", "contextmenu"].includes(le.type) && (z.browser.isSafari || z.browser.isWebView)))
        return;
    Y.pointerId = null,
    Y.touchId = null;
    const {params: ue, touches: de, rtlTranslate: he, slidesGrid: fe, enabled: ge} = z;
    if (!ge || !ue.simulateTouch && le.pointerType === "mouse")
        return;
    if (Y.allowTouchCallbacks && z.emit("touchEnd", le),
    Y.allowTouchCallbacks = !1,
    !Y.isTouched)
        return Y.isMoved && ue.grabCursor && z.setGrabCursor(!1),
        Y.isMoved = !1,
        void (Y.startMoving = !1);
    ue.grabCursor && Y.isMoved && Y.isTouched && (z.allowSlideNext === !0 || z.allowSlidePrev === !0) && z.setGrabCursor(!1);
    const xe = now$1()
      , $e = xe - Y.touchStartTime;
    if (z.allowClick) {
        const lr = le.path || le.composedPath && le.composedPath();
        z.updateClickedSlide(lr && lr[0] || le.target, lr),
        z.emit("tap click", le),
        $e < 300 && xe - Y.lastClickTime < 300 && z.emit("doubleTap doubleClick", le)
    }
    if (Y.lastClickTime = now$1(),
    nextTick(()=>{
        z.destroyed || (z.allowClick = !0)
    }
    ),
    !Y.isTouched || !Y.isMoved || !z.swipeDirection || de.diff === 0 && !Y.loopSwapReset || Y.currentTranslate === Y.startTranslate && !Y.loopSwapReset)
        return Y.isTouched = !1,
        Y.isMoved = !1,
        void (Y.startMoving = !1);
    let Ee;
    if (Y.isTouched = !1,
    Y.isMoved = !1,
    Y.startMoving = !1,
    Ee = ue.followFinger ? he ? z.translate : -z.translate : -Y.currentTranslate,
    ue.cssMode)
        return;
    if (ue.freeMode && ue.freeMode.enabled)
        return void z.freeMode.onTouchEnd({
            currentPos: Ee
        });
    const Se = Ee >= -z.maxTranslate() && !z.params.loop;
    let Ne = 0
      , tt = z.slidesSizesGrid[0];
    for (let lr = 0; lr < fe.length; lr += lr < ue.slidesPerGroupSkip ? 1 : ue.slidesPerGroup) {
        const cr = lr < ue.slidesPerGroupSkip - 1 ? 1 : ue.slidesPerGroup;
        fe[lr + cr] !== void 0 ? (Se || Ee >= fe[lr] && Ee < fe[lr + cr]) && (Ne = lr,
        tt = fe[lr + cr] - fe[lr]) : (Se || Ee >= fe[lr]) && (Ne = lr,
        tt = fe[fe.length - 1] - fe[fe.length - 2])
    }
    let rr = null
      , tr = null;
    ue.rewind && (z.isBeginning ? tr = ue.virtual && ue.virtual.enabled && z.virtual ? z.virtual.slides.length - 1 : z.slides.length - 1 : z.isEnd && (rr = 0));
    const we = (Ee - fe[Ne]) / tt
      , Ut = Ne < ue.slidesPerGroupSkip - 1 ? 1 : ue.slidesPerGroup;
    if ($e > ue.longSwipesMs) {
        if (!ue.longSwipes)
            return void z.slideTo(z.activeIndex);
        z.swipeDirection === "next" && (we >= ue.longSwipesRatio ? z.slideTo(ue.rewind && z.isEnd ? rr : Ne + Ut) : z.slideTo(Ne)),
        z.swipeDirection === "prev" && (we > 1 - ue.longSwipesRatio ? z.slideTo(Ne + Ut) : tr !== null && we < 0 && Math.abs(we) > ue.longSwipesRatio ? z.slideTo(tr) : z.slideTo(Ne))
    } else {
        if (!ue.shortSwipes)
            return void z.slideTo(z.activeIndex);
        z.navigation && (le.target === z.navigation.nextEl || le.target === z.navigation.prevEl) ? le.target === z.navigation.nextEl ? z.slideTo(Ne + Ut) : z.slideTo(Ne) : (z.swipeDirection === "next" && z.slideTo(rr !== null ? rr : Ne + Ut),
        z.swipeDirection === "prev" && z.slideTo(tr !== null ? tr : Ne))
    }
}
function onResize() {
    const W = this
      , {params: z, el: Y} = W;
    if (Y && Y.offsetWidth === 0)
        return;
    z.breakpoints && W.setBreakpoint();
    const {allowSlideNext: ne, allowSlidePrev: le, snapGrid: ue} = W
      , de = W.virtual && W.params.virtual.enabled;
    W.allowSlideNext = !0,
    W.allowSlidePrev = !0,
    W.updateSize(),
    W.updateSlides(),
    W.updateSlidesClasses();
    const he = de && z.loop;
    !(z.slidesPerView === "auto" || z.slidesPerView > 1) || !W.isEnd || W.isBeginning || W.params.centeredSlides || he ? W.params.loop && !de ? W.slideToLoop(W.realIndex, 0, !1, !0) : W.slideTo(W.activeIndex, 0, !1, !0) : W.slideTo(W.slides.length - 1, 0, !1, !0),
    W.autoplay && W.autoplay.running && W.autoplay.paused && (clearTimeout(W.autoplay.resizeTimeout),
    W.autoplay.resizeTimeout = setTimeout(()=>{
        W.autoplay && W.autoplay.running && W.autoplay.paused && W.autoplay.resume()
    }
    , 500)),
    W.allowSlidePrev = le,
    W.allowSlideNext = ne,
    W.params.watchOverflow && ue !== W.snapGrid && W.checkOverflow()
}
function onClick(W) {
    const z = this;
    z.enabled && (z.allowClick || (z.params.preventClicks && W.preventDefault(),
    z.params.preventClicksPropagation && z.animating && (W.stopPropagation(),
    W.stopImmediatePropagation())))
}
function onScroll() {
    const W = this
      , {wrapperEl: z, rtlTranslate: Y, enabled: ne} = W;
    if (!ne)
        return;
    let le;
    W.previousTranslate = W.translate,
    W.isHorizontal() ? W.translate = -z.scrollLeft : W.translate = -z.scrollTop,
    W.translate === 0 && (W.translate = 0),
    W.updateActiveIndex(),
    W.updateSlidesClasses();
    const ue = W.maxTranslate() - W.minTranslate();
    le = ue === 0 ? 0 : (W.translate - W.minTranslate()) / ue,
    le !== W.progress && W.updateProgress(Y ? -W.translate : W.translate),
    W.emit("setTranslate", W.translate, !1)
}
function onLoad(W) {
    const z = this;
    processLazyPreloader(z, W.target),
    z.params.cssMode || z.params.slidesPerView !== "auto" && !z.params.autoHeight || z.update()
}
function onDocumentTouchStart() {
    const W = this;
    W.documentTouchHandlerProceeded || (W.documentTouchHandlerProceeded = !0,
    W.params.touchReleaseOnEdges && (W.el.style.touchAction = "auto"))
}
const events = (W,z)=>{
    const Y = getDocument$1()
      , {params: ne, el: le, wrapperEl: ue, device: de} = W
      , he = !!ne.nested
      , fe = z === "on" ? "addEventListener" : "removeEventListener"
      , ge = z;
    Y[fe]("touchstart", W.onDocumentTouchStart, {
        passive: !1,
        capture: he
    }),
    le[fe]("touchstart", W.onTouchStart, {
        passive: !1
    }),
    le[fe]("pointerdown", W.onTouchStart, {
        passive: !1
    }),
    Y[fe]("touchmove", W.onTouchMove, {
        passive: !1,
        capture: he
    }),
    Y[fe]("pointermove", W.onTouchMove, {
        passive: !1,
        capture: he
    }),
    Y[fe]("touchend", W.onTouchEnd, {
        passive: !0
    }),
    Y[fe]("pointerup", W.onTouchEnd, {
        passive: !0
    }),
    Y[fe]("pointercancel", W.onTouchEnd, {
        passive: !0
    }),
    Y[fe]("touchcancel", W.onTouchEnd, {
        passive: !0
    }),
    Y[fe]("pointerout", W.onTouchEnd, {
        passive: !0
    }),
    Y[fe]("pointerleave", W.onTouchEnd, {
        passive: !0
    }),
    Y[fe]("contextmenu", W.onTouchEnd, {
        passive: !0
    }),
    (ne.preventClicks || ne.preventClicksPropagation) && le[fe]("click", W.onClick, !0),
    ne.cssMode && ue[fe]("scroll", W.onScroll),
    ne.updateOnWindowResize ? W[ge](de.ios || de.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, !0) : W[ge]("observerUpdate", onResize, !0),
    le[fe]("load", W.onLoad, {
        capture: !0
    })
}
;
function attachEvents() {
    const W = this
      , {params: z} = W;
    W.onTouchStart = onTouchStart.bind(W),
    W.onTouchMove = onTouchMove.bind(W),
    W.onTouchEnd = onTouchEnd.bind(W),
    W.onDocumentTouchStart = onDocumentTouchStart.bind(W),
    z.cssMode && (W.onScroll = onScroll.bind(W)),
    W.onClick = onClick.bind(W),
    W.onLoad = onLoad.bind(W),
    events(W, "on")
}
function detachEvents() {
    events(this, "off")
}
var events$1 = {
    attachEvents,
    detachEvents
};
const isGridEnabled = (W,z)=>W.grid && z.grid && z.grid.rows > 1;
function setBreakpoint() {
    const W = this
      , {realIndex: z, initialized: Y, params: ne, el: le} = W
      , ue = ne.breakpoints;
    if (!ue || ue && Object.keys(ue).length === 0)
        return;
    const de = W.getBreakpoint(ue, W.params.breakpointsBase, W.el);
    if (!de || W.currentBreakpoint === de)
        return;
    const he = (de in ue ? ue[de] : void 0) || W.originalParams
      , fe = isGridEnabled(W, ne)
      , ge = isGridEnabled(W, he)
      , xe = ne.enabled;
    fe && !ge ? (le.classList.remove(`${ne.containerModifierClass}grid`, `${ne.containerModifierClass}grid-column`),
    W.emitContainerClasses()) : !fe && ge && (le.classList.add(`${ne.containerModifierClass}grid`),
    (he.grid.fill && he.grid.fill === "column" || !he.grid.fill && ne.grid.fill === "column") && le.classList.add(`${ne.containerModifierClass}grid-column`),
    W.emitContainerClasses()),
    ["navigation", "pagination", "scrollbar"].forEach(rr=>{
        if (he[rr] === void 0)
            return;
        const tr = ne[rr] && ne[rr].enabled
          , we = he[rr] && he[rr].enabled;
        tr && !we && W[rr].disable(),
        !tr && we && W[rr].enable()
    }
    );
    const $e = he.direction && he.direction !== ne.direction
      , Ee = ne.loop && (he.slidesPerView !== ne.slidesPerView || $e)
      , Se = ne.loop;
    $e && Y && W.changeDirection(),
    extend(W.params, he);
    const Ne = W.params.enabled
      , tt = W.params.loop;
    Object.assign(W, {
        allowTouchMove: W.params.allowTouchMove,
        allowSlideNext: W.params.allowSlideNext,
        allowSlidePrev: W.params.allowSlidePrev
    }),
    xe && !Ne ? W.disable() : !xe && Ne && W.enable(),
    W.currentBreakpoint = de,
    W.emit("_beforeBreakpoint", he),
    Y && (Ee ? (W.loopDestroy(),
    W.loopCreate(z),
    W.updateSlides()) : !Se && tt ? (W.loopCreate(z),
    W.updateSlides()) : Se && !tt && W.loopDestroy()),
    W.emit("breakpoint", he)
}
function getBreakpoint(W, z, Y) {
    if (z === void 0 && (z = "window"),
    !W || z === "container" && !Y)
        return;
    let ne = !1;
    const le = getWindow()
      , ue = z === "window" ? le.innerHeight : Y.clientHeight
      , de = Object.keys(W).map(he=>{
        if (typeof he == "string" && he.indexOf("@") === 0) {
            const fe = parseFloat(he.substr(1));
            return {
                value: ue * fe,
                point: he
            }
        }
        return {
            value: he,
            point: he
        }
    }
    );
    de.sort((he,fe)=>parseInt(he.value, 10) - parseInt(fe.value, 10));
    for (let he = 0; he < de.length; he += 1) {
        const {point: fe, value: ge} = de[he];
        z === "window" ? le.matchMedia(`(min-width: ${ge}px)`).matches && (ne = fe) : ge <= Y.clientWidth && (ne = fe)
    }
    return ne || "max"
}
var breakpoints = {
    setBreakpoint,
    getBreakpoint
};
function prepareClasses(W, z) {
    const Y = [];
    return W.forEach(ne=>{
        typeof ne == "object" ? Object.keys(ne).forEach(le=>{
            ne[le] && Y.push(z + le)
        }
        ) : typeof ne == "string" && Y.push(z + ne)
    }
    ),
    Y
}
function addClasses() {
    const W = this
      , {classNames: z, params: Y, rtl: ne, el: le, device: ue} = W
      , de = prepareClasses(["initialized", Y.direction, {
        "free-mode": W.params.freeMode && Y.freeMode.enabled
    }, {
        autoheight: Y.autoHeight
    }, {
        rtl: ne
    }, {
        grid: Y.grid && Y.grid.rows > 1
    }, {
        "grid-column": Y.grid && Y.grid.rows > 1 && Y.grid.fill === "column"
    }, {
        android: ue.android
    }, {
        ios: ue.ios
    }, {
        "css-mode": Y.cssMode
    }, {
        centered: Y.cssMode && Y.centeredSlides
    }, {
        "watch-progress": Y.watchSlidesProgress
    }], Y.containerModifierClass);
    z.push(...de),
    le.classList.add(...z),
    W.emitContainerClasses()
}
function removeClasses() {
    const {el: W, classNames: z} = this;
    W.classList.remove(...z),
    this.emitContainerClasses()
}
var classes = {
    addClasses,
    removeClasses
};
function checkOverflow() {
    const W = this
      , {isLocked: z, params: Y} = W
      , {slidesOffsetBefore: ne} = Y;
    if (ne) {
        const le = W.slides.length - 1
          , ue = W.slidesGrid[le] + W.slidesSizesGrid[le] + 2 * ne;
        W.isLocked = W.size > ue
    } else
        W.isLocked = W.snapGrid.length === 1;
    Y.allowSlideNext === !0 && (W.allowSlideNext = !W.isLocked),
    Y.allowSlidePrev === !0 && (W.allowSlidePrev = !W.isLocked),
    z && z !== W.isLocked && (W.isEnd = !1),
    z !== W.isLocked && W.emit(W.isLocked ? "lock" : "unlock")
}
var checkOverflow$1 = {
    checkOverflow
}
  , defaults = {
    init: !0,
    direction: "horizontal",
    oneWayMovement: !1,
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: !1,
    updateOnWindowResize: !0,
    resizeObserver: !0,
    nested: !1,
    createElements: !1,
    eventsPrefix: "swiper",
    enabled: !0,
    focusableElements: "input, select, option, textarea, button, video, label",
    width: null,
    height: null,
    preventInteractionOnTransition: !1,
    userAgent: null,
    url: null,
    edgeSwipeDetection: !1,
    edgeSwipeThreshold: 20,
    autoHeight: !1,
    setWrapperSize: !1,
    virtualTranslate: !1,
    effect: "slide",
    breakpoints: void 0,
    breakpointsBase: "window",
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: !1,
    centeredSlides: !1,
    centeredSlidesBounds: !1,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    normalizeSlideIndex: !0,
    centerInsufficientSlides: !1,
    watchOverflow: !0,
    roundLengths: !1,
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: !0,
    shortSwipes: !0,
    longSwipes: !0,
    longSwipesRatio: .5,
    longSwipesMs: 300,
    followFinger: !0,
    allowTouchMove: !0,
    threshold: 5,
    touchMoveStopPropagation: !1,
    touchStartPreventDefault: !0,
    touchStartForcePreventDefault: !1,
    touchReleaseOnEdges: !1,
    uniqueNavElements: !0,
    resistance: !0,
    resistanceRatio: .85,
    watchSlidesProgress: !1,
    grabCursor: !1,
    preventClicks: !0,
    preventClicksPropagation: !0,
    slideToClickedSlide: !1,
    loop: !1,
    loopAddBlankSlides: !0,
    loopAdditionalSlides: 0,
    loopPreventsSliding: !0,
    rewind: !1,
    allowSlidePrev: !0,
    allowSlideNext: !0,
    swipeHandler: null,
    noSwiping: !0,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    passiveListeners: !0,
    maxBackfaceHiddenSlides: 10,
    containerModifierClass: "swiper-",
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-blank",
    slideActiveClass: "swiper-slide-active",
    slideVisibleClass: "swiper-slide-visible",
    slideFullyVisibleClass: "swiper-slide-fully-visible",
    slideNextClass: "swiper-slide-next",
    slidePrevClass: "swiper-slide-prev",
    wrapperClass: "swiper-wrapper",
    lazyPreloaderClass: "swiper-lazy-preloader",
    lazyPreloadPrevNext: 0,
    runCallbacksOnInit: !0,
    _emitClasses: !1
};
function moduleExtendParams(W, z) {
    return function(Y) {
        Y === void 0 && (Y = {});
        const ne = Object.keys(Y)[0]
          , le = Y[ne];
        typeof le == "object" && le !== null ? (W[ne] === !0 && (W[ne] = {
            enabled: !0
        }),
        ne === "navigation" && W[ne] && W[ne].enabled && !W[ne].prevEl && !W[ne].nextEl && (W[ne].auto = !0),
        ["pagination", "scrollbar"].indexOf(ne) >= 0 && W[ne] && W[ne].enabled && !W[ne].el && (W[ne].auto = !0),
        ne in W && "enabled"in le && (typeof W[ne] != "object" || "enabled"in W[ne] || (W[ne].enabled = !0),
        W[ne] || (W[ne] = {
            enabled: !1
        })),
        extend(z, Y)) : extend(z, Y)
    }
}
const prototypes = {
    eventsEmitter,
    update,
    translate,
    transition,
    slide,
    loop,
    grabCursor,
    events: events$1,
    breakpoints,
    checkOverflow: checkOverflow$1,
    classes
}
  , extendedDefaults = {};
class Swiper {
    constructor() {
        let z, Y;
        for (var ne = arguments.length, le = new Array(ne), ue = 0; ue < ne; ue++)
            le[ue] = arguments[ue];
        le.length === 1 && le[0].constructor && Object.prototype.toString.call(le[0]).slice(8, -1) === "Object" ? Y = le[0] : [z,Y] = le,
        Y || (Y = {}),
        Y = extend({}, Y),
        z && !Y.el && (Y.el = z);
        const de = getDocument$1();
        if (Y.el && typeof Y.el == "string" && de.querySelectorAll(Y.el).length > 1) {
            const xe = [];
            return de.querySelectorAll(Y.el).forEach($e=>{
                const Ee = extend({}, Y, {
                    el: $e
                });
                xe.push(new Swiper(Ee))
            }
            ),
            xe
        }
        const he = this;
        he.__swiper__ = !0,
        he.support = getSupport(),
        he.device = getDevice({
            userAgent: Y.userAgent
        }),
        he.browser = getBrowser(),
        he.eventsListeners = {},
        he.eventsAnyListeners = [],
        he.modules = [...he.__modules__],
        Y.modules && Array.isArray(Y.modules) && he.modules.push(...Y.modules);
        const fe = {};
        he.modules.forEach(xe=>{
            xe({
                params: Y,
                swiper: he,
                extendParams: moduleExtendParams(Y, fe),
                on: he.on.bind(he),
                once: he.once.bind(he),
                off: he.off.bind(he),
                emit: he.emit.bind(he)
            })
        }
        );
        const ge = extend({}, defaults, fe);
        return he.params = extend({}, ge, extendedDefaults, Y),
        he.originalParams = extend({}, he.params),
        he.passedParams = extend({}, Y),
        he.params && he.params.on && Object.keys(he.params.on).forEach(xe=>{
            he.on(xe, he.params.on[xe])
        }
        ),
        he.params && he.params.onAny && he.onAny(he.params.onAny),
        Object.assign(he, {
            enabled: he.params.enabled,
            el: z,
            classNames: [],
            slides: [],
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            isHorizontal: ()=>he.params.direction === "horizontal",
            isVertical: ()=>he.params.direction === "vertical",
            activeIndex: 0,
            realIndex: 0,
            isBeginning: !0,
            isEnd: !1,
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: !1,
            cssOverflowAdjustment() {
                return Math.trunc(this.translate / 2 ** 23) * 2 ** 23
            },
            allowSlideNext: he.params.allowSlideNext,
            allowSlidePrev: he.params.allowSlidePrev,
            touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                focusableElements: he.params.focusableElements,
                lastClickTime: 0,
                clickTimeout: void 0,
                velocities: [],
                allowMomentumBounce: void 0,
                startMoving: void 0,
                pointerId: null,
                touchId: null
            },
            allowClick: !0,
            allowTouchMove: he.params.allowTouchMove,
            touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0
            },
            imagesToLoad: [],
            imagesLoaded: 0
        }),
        he.emit("_swiper"),
        he.params.init && he.init(),
        he
    }
    getDirectionLabel(z) {
        return this.isHorizontal() ? z : {
            width: "height",
            "margin-top": "margin-left",
            "margin-bottom ": "margin-right",
            "margin-left": "margin-top",
            "margin-right": "margin-bottom",
            "padding-left": "padding-top",
            "padding-right": "padding-bottom",
            marginRight: "marginBottom"
        }[z]
    }
    getSlideIndex(z) {
        const {slidesEl: Y, params: ne} = this
          , le = elementIndex(elementChildren(Y, `.${ne.slideClass}, swiper-slide`)[0]);
        return elementIndex(z) - le
    }
    getSlideIndexByData(z) {
        return this.getSlideIndex(this.slides.filter(Y=>1 * Y.getAttribute("data-swiper-slide-index") === z)[0])
    }
    recalcSlides() {
        const {slidesEl: z, params: Y} = this;
        this.slides = elementChildren(z, `.${Y.slideClass}, swiper-slide`)
    }
    enable() {
        const z = this;
        z.enabled || (z.enabled = !0,
        z.params.grabCursor && z.setGrabCursor(),
        z.emit("enable"))
    }
    disable() {
        const z = this;
        z.enabled && (z.enabled = !1,
        z.params.grabCursor && z.unsetGrabCursor(),
        z.emit("disable"))
    }
    setProgress(z, Y) {
        const ne = this;
        z = Math.min(Math.max(z, 0), 1);
        const le = ne.minTranslate()
          , ue = (ne.maxTranslate() - le) * z + le;
        ne.translateTo(ue, Y === void 0 ? 0 : Y),
        ne.updateActiveIndex(),
        ne.updateSlidesClasses()
    }
    emitContainerClasses() {
        const z = this;
        if (!z.params._emitClasses || !z.el)
            return;
        const Y = z.el.className.split(" ").filter(ne=>ne.indexOf("swiper") === 0 || ne.indexOf(z.params.containerModifierClass) === 0);
        z.emit("_containerClasses", Y.join(" "))
    }
    getSlideClasses(z) {
        const Y = this;
        return Y.destroyed ? "" : z.className.split(" ").filter(ne=>ne.indexOf("swiper-slide") === 0 || ne.indexOf(Y.params.slideClass) === 0).join(" ")
    }
    emitSlidesClasses() {
        const z = this;
        if (!z.params._emitClasses || !z.el)
            return;
        const Y = [];
        z.slides.forEach(ne=>{
            const le = z.getSlideClasses(ne);
            Y.push({
                slideEl: ne,
                classNames: le
            }),
            z.emit("_slideClass", ne, le)
        }
        ),
        z.emit("_slideClasses", Y)
    }
    slidesPerViewDynamic(z, Y) {
        z === void 0 && (z = "current"),
        Y === void 0 && (Y = !1);
        const {params: ne, slides: le, slidesGrid: ue, slidesSizesGrid: de, size: he, activeIndex: fe} = this;
        let ge = 1;
        if (typeof ne.slidesPerView == "number")
            return ne.slidesPerView;
        if (ne.centeredSlides) {
            let xe, $e = le[fe] ? le[fe].swiperSlideSize : 0;
            for (let Ee = fe + 1; Ee < le.length; Ee += 1)
                le[Ee] && !xe && ($e += le[Ee].swiperSlideSize,
                ge += 1,
                $e > he && (xe = !0));
            for (let Ee = fe - 1; Ee >= 0; Ee -= 1)
                le[Ee] && !xe && ($e += le[Ee].swiperSlideSize,
                ge += 1,
                $e > he && (xe = !0))
        } else if (z === "current")
            for (let xe = fe + 1; xe < le.length; xe += 1)
                (Y ? ue[xe] + de[xe] - ue[fe] < he : ue[xe] - ue[fe] < he) && (ge += 1);
        else
            for (let xe = fe - 1; xe >= 0; xe -= 1)
                ue[fe] - ue[xe] < he && (ge += 1);
        return ge
    }
    update() {
        const z = this;
        if (!z || z.destroyed)
            return;
        const {snapGrid: Y, params: ne} = z;
        function le() {
            const de = z.rtlTranslate ? -1 * z.translate : z.translate
              , he = Math.min(Math.max(de, z.maxTranslate()), z.minTranslate());
            z.setTranslate(he),
            z.updateActiveIndex(),
            z.updateSlidesClasses()
        }
        let ue;
        if (ne.breakpoints && z.setBreakpoint(),
        [...z.el.querySelectorAll('[loading="lazy"]')].forEach(de=>{
            de.complete && processLazyPreloader(z, de)
        }
        ),
        z.updateSize(),
        z.updateSlides(),
        z.updateProgress(),
        z.updateSlidesClasses(),
        ne.freeMode && ne.freeMode.enabled && !ne.cssMode)
            le(),
            ne.autoHeight && z.updateAutoHeight();
        else {
            if ((ne.slidesPerView === "auto" || ne.slidesPerView > 1) && z.isEnd && !ne.centeredSlides) {
                const de = z.virtual && ne.virtual.enabled ? z.virtual.slides : z.slides;
                ue = z.slideTo(de.length - 1, 0, !1, !0)
            } else
                ue = z.slideTo(z.activeIndex, 0, !1, !0);
            ue || le()
        }
        ne.watchOverflow && Y !== z.snapGrid && z.checkOverflow(),
        z.emit("update")
    }
    changeDirection(z, Y) {
        Y === void 0 && (Y = !0);
        const ne = this
          , le = ne.params.direction;
        return z || (z = le === "horizontal" ? "vertical" : "horizontal"),
        z === le || z !== "horizontal" && z !== "vertical" || (ne.el.classList.remove(`${ne.params.containerModifierClass}${le}`),
        ne.el.classList.add(`${ne.params.containerModifierClass}${z}`),
        ne.emitContainerClasses(),
        ne.params.direction = z,
        ne.slides.forEach(ue=>{
            z === "vertical" ? ue.style.width = "" : ue.style.height = ""
        }
        ),
        ne.emit("changeDirection"),
        Y && ne.update()),
        ne
    }
    changeLanguageDirection(z) {
        const Y = this;
        Y.rtl && z === "rtl" || !Y.rtl && z === "ltr" || (Y.rtl = z === "rtl",
        Y.rtlTranslate = Y.params.direction === "horizontal" && Y.rtl,
        Y.rtl ? (Y.el.classList.add(`${Y.params.containerModifierClass}rtl`),
        Y.el.dir = "rtl") : (Y.el.classList.remove(`${Y.params.containerModifierClass}rtl`),
        Y.el.dir = "ltr"),
        Y.update())
    }
    mount(z) {
        const Y = this;
        if (Y.mounted)
            return !0;
        let ne = z || Y.params.el;
        if (typeof ne == "string" && (ne = document.querySelector(ne)),
        !ne)
            return !1;
        ne.swiper = Y,
        ne.parentNode && ne.parentNode.host && ne.parentNode.host.nodeName === "SWIPER-CONTAINER" && (Y.isElement = !0);
        const le = ()=>`.${(Y.params.wrapperClass || "").trim().split(" ").join(".")}`;
        let ue = (()=>ne && ne.shadowRoot && ne.shadowRoot.querySelector ? ne.shadowRoot.querySelector(le()) : elementChildren(ne, le())[0])();
        return !ue && Y.params.createElements && (ue = createElement("div", Y.params.wrapperClass),
        ne.append(ue),
        elementChildren(ne, `.${Y.params.slideClass}`).forEach(de=>{
            ue.append(de)
        }
        )),
        Object.assign(Y, {
            el: ne,
            wrapperEl: ue,
            slidesEl: Y.isElement && !ne.parentNode.host.slideSlots ? ne.parentNode.host : ue,
            hostEl: Y.isElement ? ne.parentNode.host : ne,
            mounted: !0,
            rtl: ne.dir.toLowerCase() === "rtl" || elementStyle(ne, "direction") === "rtl",
            rtlTranslate: Y.params.direction === "horizontal" && (ne.dir.toLowerCase() === "rtl" || elementStyle(ne, "direction") === "rtl"),
            wrongRTL: elementStyle(ue, "display") === "-webkit-box"
        }),
        !0
    }
    init(z) {
        const Y = this;
        if (Y.initialized || Y.mount(z) === !1)
            return Y;
        Y.emit("beforeInit"),
        Y.params.breakpoints && Y.setBreakpoint(),
        Y.addClasses(),
        Y.updateSize(),
        Y.updateSlides(),
        Y.params.watchOverflow && Y.checkOverflow(),
        Y.params.grabCursor && Y.enabled && Y.setGrabCursor(),
        Y.params.loop && Y.virtual && Y.params.virtual.enabled ? Y.slideTo(Y.params.initialSlide + Y.virtual.slidesBefore, 0, Y.params.runCallbacksOnInit, !1, !0) : Y.slideTo(Y.params.initialSlide, 0, Y.params.runCallbacksOnInit, !1, !0),
        Y.params.loop && Y.loopCreate(),
        Y.attachEvents();
        const ne = [...Y.el.querySelectorAll('[loading="lazy"]')];
        return Y.isElement && ne.push(...Y.hostEl.querySelectorAll('[loading="lazy"]')),
        ne.forEach(le=>{
            le.complete ? processLazyPreloader(Y, le) : le.addEventListener("load", ue=>{
                processLazyPreloader(Y, ue.target)
            }
            )
        }
        ),
        preload(Y),
        Y.initialized = !0,
        preload(Y),
        Y.emit("init"),
        Y.emit("afterInit"),
        Y
    }
    destroy(z, Y) {
        z === void 0 && (z = !0),
        Y === void 0 && (Y = !0);
        const ne = this
          , {params: le, el: ue, wrapperEl: de, slides: he} = ne;
        return ne.params === void 0 || ne.destroyed || (ne.emit("beforeDestroy"),
        ne.initialized = !1,
        ne.detachEvents(),
        le.loop && ne.loopDestroy(),
        Y && (ne.removeClasses(),
        ue.removeAttribute("style"),
        de.removeAttribute("style"),
        he && he.length && he.forEach(fe=>{
            fe.classList.remove(le.slideVisibleClass, le.slideFullyVisibleClass, le.slideActiveClass, le.slideNextClass, le.slidePrevClass),
            fe.removeAttribute("style"),
            fe.removeAttribute("data-swiper-slide-index")
        }
        )),
        ne.emit("destroy"),
        Object.keys(ne.eventsListeners).forEach(fe=>{
            ne.off(fe)
        }
        ),
        z !== !1 && (ne.el.swiper = null,
        deleteProps(ne)),
        ne.destroyed = !0),
        null
    }
    static extendDefaults(z) {
        extend(extendedDefaults, z)
    }
    static get extendedDefaults() {
        return extendedDefaults
    }
    static get defaults() {
        return defaults
    }
    static installModule(z) {
        Swiper.prototype.__modules__ || (Swiper.prototype.__modules__ = []);
        const Y = Swiper.prototype.__modules__;
        typeof z == "function" && Y.indexOf(z) < 0 && Y.push(z)
    }
    static use(z) {
        return Array.isArray(z) ? (z.forEach(Y=>Swiper.installModule(Y)),
        Swiper) : (Swiper.installModule(z),
        Swiper)
    }
}
Object.keys(prototypes).forEach(W=>{
    Object.keys(prototypes[W]).forEach(z=>{
        Swiper.prototype[z] = prototypes[W][z]
    }
    )
}
),
Swiper.use([Resize, Observer]);
const bsc = defineChain({
    id: 56,
    name: "BNB Smart Chain",
    network: "bsc",
    nativeCurrency: {
        decimals: 18,
        name: "BNB",
        symbol: "BNB"
    },
    rpcUrls: {
        default: {
            http: ["https://rpc.ankr.com/bsc"]
        },
        public: {
            http: ["https://rpc.ankr.com/bsc"]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "BscScan",
            url: "https://bscscan.com"
        },
        default: {
            name: "BscScan",
            url: "https://bscscan.com"
        }
    },
    contracts: {
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 15921452
        }
    }
})
  , goerli = defineChain({
    id: 5,
    network: "goerli",
    name: "Goerli",
    nativeCurrency: {
        name: "Goerli Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        alchemy: {
            http: ["https://eth-goerli.g.alchemy.com/v2"],
            webSocket: ["wss://eth-goerli.g.alchemy.com/v2"]
        },
        infura: {
            http: ["https://goerli.infura.io/v3"],
            webSocket: ["wss://goerli.infura.io/ws/v3"]
        },
        default: {
            http: ["https://rpc.ankr.com/eth_goerli"]
        },
        public: {
            http: ["https://rpc.ankr.com/eth_goerli"]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Etherscan",
            url: "https://goerli.etherscan.io"
        },
        default: {
            name: "Etherscan",
            url: "https://goerli.etherscan.io"
        }
    },
    contracts: {
        ensRegistry: {
            address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        ensUniversalResolver: {
            address: "0x56522D00C410a43BFfDF00a9A569489297385790",
            blockCreated: 8765204
        },
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 6507670
        }
    },
    testnet: !0
})
  , mainnet = defineChain({
    id: 1,
    network: "homestead",
    name: "Ethereum",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        alchemy: {
            http: ["https://eth-mainnet.g.alchemy.com/v2"],
            webSocket: ["wss://eth-mainnet.g.alchemy.com/v2"]
        },
        infura: {
            http: ["https://mainnet.infura.io/v3"],
            webSocket: ["wss://mainnet.infura.io/ws/v3"]
        },
        default: {
            http: ["https://cloudflare-eth.com"]
        },
        public: {
            http: ["https://cloudflare-eth.com"]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Etherscan",
            url: "https://etherscan.io"
        },
        default: {
            name: "Etherscan",
            url: "https://etherscan.io"
        }
    },
    contracts: {
        ensRegistry: {
            address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        ensUniversalResolver: {
            address: "0xc0497E381f536Be9ce14B0dD3817cBcAe57d2F62",
            blockCreated: 16966585
        },
        multicall3: {
            address: "0xca11bde05977b3631167028862be2a173976ca11",
            blockCreated: 14353601
        }
    }
});
var ChainNotConfiguredForConnectorError = class extends Error {
    constructor({chainId: W, connectorId: z}) {
        super(`Chain "${W}" not configured for connector "${z}".`),
        this.name = "ChainNotConfiguredForConnectorError"
    }
}
  , ConnectorNotFoundError = class extends Error {
    constructor() {
        super(...arguments),
        this.name = "ConnectorNotFoundError",
        this.message = "Connector not found"
    }
}
;
function normalizeChainId(W) {
    return typeof W == "string" ? Number.parseInt(W, W.trim().substring(0, 2) === "0x" ? 16 : 10) : typeof W == "bigint" ? Number(W) : W
}
var eventemitter3 = {
    exports: {}
};
(function(W) {
    var z = Object.prototype.hasOwnProperty
      , Y = "~";
    function ne() {}
    function le(fe, ge, xe) {
        this.fn = fe,
        this.context = ge,
        this.once = xe || !1
    }
    function ue(fe, ge, xe, $e, Ee) {
        if (typeof xe != "function")
            throw new TypeError("The listener must be a function");
        var Se = new le(xe,$e || fe,Ee)
          , Ne = Y ? Y + ge : ge;
        return fe._events[Ne] ? fe._events[Ne].fn ? fe._events[Ne] = [fe._events[Ne], Se] : fe._events[Ne].push(Se) : (fe._events[Ne] = Se,
        fe._eventsCount++),
        fe
    }
    function de(fe, ge) {
        --fe._eventsCount == 0 ? fe._events = new ne : delete fe._events[ge]
    }
    function he() {
        this._events = new ne,
        this._eventsCount = 0
    }
    Object.create && (ne.prototype = Object.create(null),
    new ne().__proto__ || (Y = !1)),
    he.prototype.eventNames = function() {
        var fe, ge, xe = [];
        if (this._eventsCount === 0)
            return xe;
        for (ge in fe = this._events)
            z.call(fe, ge) && xe.push(Y ? ge.slice(1) : ge);
        return Object.getOwnPropertySymbols ? xe.concat(Object.getOwnPropertySymbols(fe)) : xe
    }
    ,
    he.prototype.listeners = function(fe) {
        var ge = Y ? Y + fe : fe
          , xe = this._events[ge];
        if (!xe)
            return [];
        if (xe.fn)
            return [xe.fn];
        for (var $e = 0, Ee = xe.length, Se = new Array(Ee); $e < Ee; $e++)
            Se[$e] = xe[$e].fn;
        return Se
    }
    ,
    he.prototype.listenerCount = function(fe) {
        var ge = Y ? Y + fe : fe
          , xe = this._events[ge];
        return xe ? xe.fn ? 1 : xe.length : 0
    }
    ,
    he.prototype.emit = function(fe, ge, xe, $e, Ee, Se) {
        var Ne = Y ? Y + fe : fe;
        if (!this._events[Ne])
            return !1;
        var tt, rr, tr = this._events[Ne], we = arguments.length;
        if (tr.fn) {
            switch (tr.once && this.removeListener(fe, tr.fn, void 0, !0),
            we) {
            case 1:
                return tr.fn.call(tr.context),
                !0;
            case 2:
                return tr.fn.call(tr.context, ge),
                !0;
            case 3:
                return tr.fn.call(tr.context, ge, xe),
                !0;
            case 4:
                return tr.fn.call(tr.context, ge, xe, $e),
                !0;
            case 5:
                return tr.fn.call(tr.context, ge, xe, $e, Ee),
                !0;
            case 6:
                return tr.fn.call(tr.context, ge, xe, $e, Ee, Se),
                !0
            }
            for (rr = 1,
            tt = new Array(we - 1); rr < we; rr++)
                tt[rr - 1] = arguments[rr];
            tr.fn.apply(tr.context, tt)
        } else {
            var Ut, lr = tr.length;
            for (rr = 0; rr < lr; rr++)
                switch (tr[rr].once && this.removeListener(fe, tr[rr].fn, void 0, !0),
                we) {
                case 1:
                    tr[rr].fn.call(tr[rr].context);
                    break;
                case 2:
                    tr[rr].fn.call(tr[rr].context, ge);
                    break;
                case 3:
                    tr[rr].fn.call(tr[rr].context, ge, xe);
                    break;
                case 4:
                    tr[rr].fn.call(tr[rr].context, ge, xe, $e);
                    break;
                default:
                    if (!tt)
                        for (Ut = 1,
                        tt = new Array(we - 1); Ut < we; Ut++)
                            tt[Ut - 1] = arguments[Ut];
                    tr[rr].fn.apply(tr[rr].context, tt)
                }
        }
        return !0
    }
    ,
    he.prototype.on = function(fe, ge, xe) {
        return ue(this, fe, ge, xe, !1)
    }
    ,
    he.prototype.once = function(fe, ge, xe) {
        return ue(this, fe, ge, xe, !0)
    }
    ,
    he.prototype.removeListener = function(fe, ge, xe, $e) {
        var Ee = Y ? Y + fe : fe;
        if (!this._events[Ee])
            return this;
        if (!ge)
            return de(this, Ee),
            this;
        var Se = this._events[Ee];
        if (Se.fn)
            Se.fn !== ge || $e && !Se.once || xe && Se.context !== xe || de(this, Ee);
        else {
            for (var Ne = 0, tt = [], rr = Se.length; Ne < rr; Ne++)
                (Se[Ne].fn !== ge || $e && !Se[Ne].once || xe && Se[Ne].context !== xe) && tt.push(Se[Ne]);
            tt.length ? this._events[Ee] = tt.length === 1 ? tt[0] : tt : de(this, Ee)
        }
        return this
    }
    ,
    he.prototype.removeAllListeners = function(fe) {
        var ge;
        return fe ? (ge = Y ? Y + fe : fe,
        this._events[ge] && de(this, ge)) : (this._events = new ne,
        this._eventsCount = 0),
        this
    }
    ,
    he.prototype.off = he.prototype.removeListener,
    he.prototype.addListener = he.prototype.on,
    he.prefixed = Y,
    he.EventEmitter = he,
    W.exports = he
}
)(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter = getDefaultExportFromCjs(eventemitter3Exports);
var __accessCheck$1 = (W,z,Y)=>{
    if (!z.has(W))
        throw TypeError("Cannot " + Y)
}
, __privateGet$1 = (W,z,Y)=>(__accessCheck$1(W, z, "read from private field"),
Y ? Y.call(W) : z.get(W)), __privateAdd$1 = (W,z,Y)=>{
    if (z.has(W))
        throw TypeError("Cannot add the same private member more than once");
    z instanceof WeakSet ? z.add(W) : z.set(W, Y)
}
, __privateSet$1 = (W,z,Y,ne)=>(__accessCheck$1(W, z, "write to private field"),
ne ? ne.call(W, Y) : z.set(W, Y),
Y), __privateMethod$1 = (W,z,Y)=>(__accessCheck$1(W, z, "access private method"),
Y), Connector = class extends EventEmitter {
    constructor({chains: W=[mainnet, goerli], options: z}) {
        super(),
        this.chains = W,
        this.options = z
    }
    getBlockExplorerUrls(W) {
        const {default: z, ...Y} = W.blockExplorers ?? {};
        if (z)
            return [z.url, ...Object.values(Y).map(ne=>ne.url)]
    }
    isChainUnsupported(W) {
        return !this.chains.some(z=>z.id === W)
    }
    setStorage(W) {
        this.storage = W
    }
}
, _provider$2;
function getInjectedName(W) {
    if (!W)
        return "Injected";
    const z = Y=>Y.isApexWallet ? "Apex Wallet" : Y.isAvalanche ? "Core Wallet" : Y.isBackpack ? "Backpack" : Y.isBifrost ? "Bifrost Wallet" : Y.isBitKeep ? "BitKeep" : Y.isBitski ? "Bitski" : Y.isBlockWallet ? "BlockWallet" : Y.isBraveWallet ? "Brave Wallet" : Y.isCoin98 ? "Coin98 Wallet" : Y.isCoinbaseWallet ? "Coinbase Wallet" : Y.isDawn ? "Dawn Wallet" : Y.isDefiant ? "Defiant" : Y.isDesig ? "Desig Wallet" : Y.isEnkrypt ? "Enkrypt" : Y.isExodus ? "Exodus" : Y.isFordefi ? "Fordefi" : Y.isFrame ? "Frame" : Y.isFrontier ? "Frontier Wallet" : Y.isGamestop ? "GameStop Wallet" : Y.isHaqqWallet ? "HAQQ Wallet" : Y.isHyperPay ? "HyperPay Wallet" : Y.isImToken ? "ImToken" : Y.isHaloWallet ? "Halo Wallet" : Y.isKuCoinWallet ? "KuCoin Wallet" : Y.isMathWallet ? "MathWallet" : Y.isNovaWallet ? "Nova Wallet" : Y.isOkxWallet || Y.isOKExWallet ? "OKX Wallet" : Y.isOneInchIOSWallet || Y.isOneInchAndroidWallet ? "1inch Wallet" : Y.isOpera ? "Opera" : Y.isPhantom ? "Phantom" : Y.isPortal ? "Ripio Portal" : Y.isRabby ? "Rabby Wallet" : Y.isRainbow ? "Rainbow" : Y.isSafePal ? "SafePal Wallet" : Y.isStatus ? "Status" : Y.isSubWallet ? "SubWallet" : Y.isTalisman ? "Talisman" : Y.isTally ? "Taho" : Y.isTokenPocket ? "TokenPocket" : Y.isTokenary ? "Tokenary" : Y.isTrust || Y.isTrustWallet ? "Trust Wallet" : Y.isTTWallet ? "TTWallet" : Y.isXDEFI ? "XDEFI Wallet" : Y.isZeal ? "Zeal" : Y.isZerion ? "Zerion" : Y.isMetaMask ? "MetaMask" : void 0;
    if (W.providers?.length) {
        const Y = new Set;
        let ne = 1;
        for (const ue of W.providers) {
            let de = z(ue);
            de || (de = `Unknown Wallet #${ne}`,
            ne += 1),
            Y.add(de)
        }
        const le = [...Y];
        return le.length ? le : le[0] ?? "Injected"
    }
    return z(W) ?? "Injected"
}
var InjectedConnector = class extends Connector {
    constructor({chains: W, options: z}={}) {
        const Y = {
            shimDisconnect: !0,
            getProvider() {
                if (typeof window > "u")
                    return;
                const le = window.ethereum;
                return le?.providers && le.providers.length > 0 ? le.providers[0] : le
            },
            ...z
        };
        super({
            chains: W,
            options: Y
        }),
        this.id = "injected",
        __privateAdd$1(this, _provider$2, void 0),
        this.shimDisconnectKey = `${this.id}.shimDisconnect`,
        this.onAccountsChanged = le=>{
            le.length === 0 ? this.emit("disconnect") : this.emit("change", {
                account: getAddress(le[0])
            })
        }
        ,
        this.onChainChanged = le=>{
            const ue = normalizeChainId(le)
              , de = this.isChainUnsupported(ue);
            this.emit("change", {
                chain: {
                    id: ue,
                    unsupported: de
                }
            })
        }
        ,
        this.onDisconnect = async le=>{
            le.code === 1013 && await this.getProvider() && await this.getAccount() || (this.emit("disconnect"),
            this.options.shimDisconnect && this.storage?.removeItem(this.shimDisconnectKey))
        }
        ;
        const ne = Y.getProvider();
        if (typeof Y.name == "string")
            this.name = Y.name;
        else if (ne) {
            const le = getInjectedName(ne);
            Y.name ? this.name = Y.name(le) : this.name = typeof le == "string" ? le : le[0]
        } else
            this.name = "Injected";
        this.ready = !!ne
    }
    async connect({chainId: W}={}) {
        try {
            const z = await this.getProvider();
            if (!z)
                throw new ConnectorNotFoundError;
            z.on && (z.on("accountsChanged", this.onAccountsChanged),
            z.on("chainChanged", this.onChainChanged),
            z.on("disconnect", this.onDisconnect)),
            this.emit("message", {
                type: "connecting"
            });
            const Y = getAddress((await z.request({
                method: "eth_requestAccounts"
            }))[0]);
            let ne = await this.getChainId()
              , le = this.isChainUnsupported(ne);
            return W && ne !== W && (ne = (await this.switchChain(W)).id,
            le = this.isChainUnsupported(ne)),
            this.options.shimDisconnect && this.storage?.setItem(this.shimDisconnectKey, !0),
            {
                account: Y,
                chain: {
                    id: ne,
                    unsupported: le
                }
            }
        } catch (z) {
            throw this.isUserRejectedRequestError(z) ? new UserRejectedRequestError(z) : z.code === -32002 ? new ResourceUnavailableRpcError(z) : z
        }
    }
    async disconnect() {
        const W = await this.getProvider();
        W?.removeListener && (W.removeListener("accountsChanged", this.onAccountsChanged),
        W.removeListener("chainChanged", this.onChainChanged),
        W.removeListener("disconnect", this.onDisconnect),
        this.options.shimDisconnect && this.storage?.removeItem(this.shimDisconnectKey))
    }
    async getAccount() {
        const W = await this.getProvider();
        if (!W)
            throw new ConnectorNotFoundError;
        return getAddress((await W.request({
            method: "eth_accounts"
        }))[0])
    }
    async getChainId() {
        const W = await this.getProvider();
        if (!W)
            throw new ConnectorNotFoundError;
        return W.request({
            method: "eth_chainId"
        }).then(normalizeChainId)
    }
    async getProvider() {
        const W = this.options.getProvider();
        return W && __privateSet$1(this, _provider$2, W),
        __privateGet$1(this, _provider$2)
    }
    async getWalletClient({chainId: W}={}) {
        const [z,Y] = await Promise.all([this.getProvider(), this.getAccount()])
          , ne = this.chains.find(le=>le.id === W);
        if (!z)
            throw new Error("provider is required.");
        return createWalletClient({
            account: Y,
            chain: ne,
            transport: custom(z)
        })
    }
    async isAuthorized() {
        try {
            if (this.options.shimDisconnect && !this.storage?.getItem(this.shimDisconnectKey))
                return !1;
            if (!await this.getProvider())
                throw new ConnectorNotFoundError;
            return !!await this.getAccount()
        } catch {
            return !1
        }
    }
    async switchChain(W) {
        const z = await this.getProvider();
        if (!z)
            throw new ConnectorNotFoundError;
        const Y = numberToHex(W);
        try {
            return await Promise.all([z.request({
                method: "wallet_switchEthereumChain",
                params: [{
                    chainId: Y
                }]
            }), new Promise(ne=>this.on("change", ({chain: le})=>{
                le?.id === W && ne()
            }
            ))]),
            this.chains.find(ne=>ne.id === W) ?? {
                id: W,
                name: `Chain ${Y}`,
                network: `${Y}`,
                nativeCurrency: {
                    name: "Ether",
                    decimals: 18,
                    symbol: "ETH"
                },
                rpcUrls: {
                    default: {
                        http: [""]
                    },
                    public: {
                        http: [""]
                    }
                }
            }
        } catch (ne) {
            const le = this.chains.find(ue=>ue.id === W);
            if (!le)
                throw new ChainNotConfiguredForConnectorError({
                    chainId: W,
                    connectorId: this.id
                });
            if (ne.code === 4902 || ne?.data?.originalError?.code === 4902)
                try {
                    if (await z.request({
                        method: "wallet_addEthereumChain",
                        params: [{
                            chainId: Y,
                            chainName: le.name,
                            nativeCurrency: le.nativeCurrency,
                            rpcUrls: [le.rpcUrls.public?.http[0] ?? ""],
                            blockExplorerUrls: this.getBlockExplorerUrls(le)
                        }]
                    }),
                    await this.getChainId() !== W)
                        throw new UserRejectedRequestError(new Error("User rejected switch after adding network."));
                    return le
                } catch (ue) {
                    throw new UserRejectedRequestError(ue)
                }
            throw this.isUserRejectedRequestError(ne) ? new UserRejectedRequestError(ne) : new SwitchChainError(ne)
        }
    }
    async watchAsset({address: W, decimals: z=18, image: Y, symbol: ne}) {
        const le = await this.getProvider();
        if (!le)
            throw new ConnectorNotFoundError;
        return le.request({
            method: "wallet_watchAsset",
            params: {
                type: "ERC20",
                options: {
                    address: W,
                    decimals: z,
                    image: Y,
                    symbol: ne
                }
            }
        })
    }
    isUserRejectedRequestError(W) {
        return W.code === 4001
    }
}
;
_provider$2 = new WeakMap;
var __accessCheck = (W,z,Y)=>{
    if (!z.has(W))
        throw TypeError("Cannot " + Y)
}
  , __privateGet = (W,z,Y)=>(__accessCheck(W, z, "read from private field"),
Y ? Y.call(W) : z.get(W))
  , __privateAdd = (W,z,Y)=>{
    if (z.has(W))
        throw TypeError("Cannot add the same private member more than once");
    z instanceof WeakSet ? z.add(W) : z.set(W, Y)
}
  , __privateSet = (W,z,Y,ne)=>(__accessCheck(W, z, "write to private field"),
ne ? ne.call(W, Y) : z.set(W, Y),
Y)
  , __privateMethod = (W,z,Y)=>(__accessCheck(W, z, "access private method"),
Y);
const subscribeWithSelectorImpl = W=>(z,Y,ne)=>{
    const le = ne.subscribe;
    return ne.subscribe = (ue,de,he)=>{
        let fe = ue;
        if (de) {
            const ge = he?.equalityFn || Object.is;
            let xe = ue(ne.getState());
            fe = $e=>{
                const Ee = ue($e);
                if (!ge(xe, Ee)) {
                    const Se = xe;
                    de(xe = Ee, Se)
                }
            }
            ,
            he?.fireImmediately && de(xe, xe)
        }
        return le(fe)
    }
    ,
    W(z, Y, ne)
}
  , subscribeWithSelector = subscribeWithSelectorImpl;
function createJSONStorage(W, z) {
    let Y;
    try {
        Y = W()
    } catch {
        return
    }
    return {
        getItem: ne=>{
            var le;
            const ue = he=>he === null ? null : JSON.parse(he, z?.reviver)
              , de = (le = Y.getItem(ne)) != null ? le : null;
            return de instanceof Promise ? de.then(ue) : ue(de)
        }
        ,
        setItem: (ne,le)=>Y.setItem(ne, JSON.stringify(le, z?.replacer)),
        removeItem: ne=>Y.removeItem(ne)
    }
}
const toThenable = W=>z=>{
    try {
        const Y = W(z);
        return Y instanceof Promise ? Y : {
            then: ne=>toThenable(ne)(Y),
            catch(ne) {
                return this
            }
        }
    } catch (Y) {
        return {
            then(ne) {
                return this
            },
            catch: ne=>toThenable(ne)(Y)
        }
    }
}
  , oldImpl = (W,z)=>(Y,ne,le)=>{
    let ue = {
        getStorage: ()=>localStorage,
        serialize: JSON.stringify,
        deserialize: JSON.parse,
        partialize: rr=>rr,
        version: 0,
        merge: (rr,tr)=>({
            ...tr,
            ...rr
        }),
        ...z
    }
      , de = !1;
    const he = new Set
      , fe = new Set;
    let ge;
    try {
        ge = ue.getStorage()
    } catch {}
    if (!ge)
        return W((...rr)=>{
            console.warn(`[zustand persist middleware] Unable to update item '${ue.name}', the given storage is currently unavailable.`),
            Y(...rr)
        }
        , ne, le);
    const xe = toThenable(ue.serialize)
      , $e = ()=>{
        const rr = ue.partialize({
            ...ne()
        });
        let tr;
        const we = xe({
            state: rr,
            version: ue.version
        }).then(Ut=>ge.setItem(ue.name, Ut)).catch(Ut=>{
            tr = Ut
        }
        );
        if (tr)
            throw tr;
        return we
    }
      , Ee = le.setState;
    le.setState = (rr,tr)=>{
        Ee(rr, tr),
        $e()
    }
    ;
    const Se = W((...rr)=>{
        Y(...rr),
        $e()
    }
    , ne, le);
    let Ne;
    const tt = ()=>{
        var rr;
        if (!ge)
            return;
        de = !1,
        he.forEach(we=>we(ne()));
        const tr = ((rr = ue.onRehydrateStorage) == null ? void 0 : rr.call(ue, ne())) || void 0;
        return toThenable(ge.getItem.bind(ge))(ue.name).then(we=>{
            if (we)
                return ue.deserialize(we)
        }
        ).then(we=>{
            if (we) {
                if (typeof we.version != "number" || we.version === ue.version)
                    return we.state;
                if (ue.migrate)
                    return ue.migrate(we.state, we.version);
                console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
            }
        }
        ).then(we=>{
            var Ut;
            return Ne = ue.merge(we, (Ut = ne()) != null ? Ut : Se),
            Y(Ne, !0),
            $e()
        }
        ).then(()=>{
            tr?.(Ne, void 0),
            de = !0,
            fe.forEach(we=>we(Ne))
        }
        ).catch(we=>{
            tr?.(void 0, we)
        }
        )
    }
    ;
    return le.persist = {
        setOptions: rr=>{
            ue = {
                ...ue,
                ...rr
            },
            rr.getStorage && (ge = rr.getStorage())
        }
        ,
        clearStorage: ()=>{
            ge?.removeItem(ue.name)
        }
        ,
        getOptions: ()=>ue,
        rehydrate: ()=>tt(),
        hasHydrated: ()=>de,
        onHydrate: rr=>(he.add(rr),
        ()=>{
            he.delete(rr)
        }
        ),
        onFinishHydration: rr=>(fe.add(rr),
        ()=>{
            fe.delete(rr)
        }
        )
    },
    tt(),
    Ne || Se
}
  , newImpl = (W,z)=>(Y,ne,le)=>{
    let ue = {
        storage: createJSONStorage(()=>localStorage),
        partialize: tt=>tt,
        version: 0,
        merge: (tt,rr)=>({
            ...rr,
            ...tt
        }),
        ...z
    }
      , de = !1;
    const he = new Set
      , fe = new Set;
    let ge = ue.storage;
    if (!ge)
        return W((...tt)=>{
            console.warn(`[zustand persist middleware] Unable to update item '${ue.name}', the given storage is currently unavailable.`),
            Y(...tt)
        }
        , ne, le);
    const xe = ()=>{
        const tt = ue.partialize({
            ...ne()
        });
        return ge.setItem(ue.name, {
            state: tt,
            version: ue.version
        })
    }
      , $e = le.setState;
    le.setState = (tt,rr)=>{
        $e(tt, rr),
        xe()
    }
    ;
    const Ee = W((...tt)=>{
        Y(...tt),
        xe()
    }
    , ne, le);
    let Se;
    const Ne = ()=>{
        var tt, rr;
        if (!ge)
            return;
        de = !1,
        he.forEach(we=>{
            var Ut;
            return we((Ut = ne()) != null ? Ut : Ee)
        }
        );
        const tr = ((rr = ue.onRehydrateStorage) == null ? void 0 : rr.call(ue, (tt = ne()) != null ? tt : Ee)) || void 0;
        return toThenable(ge.getItem.bind(ge))(ue.name).then(we=>{
            if (we) {
                if (typeof we.version != "number" || we.version === ue.version)
                    return we.state;
                if (ue.migrate)
                    return ue.migrate(we.state, we.version);
                console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
            }
        }
        ).then(we=>{
            var Ut;
            return Se = ue.merge(we, (Ut = ne()) != null ? Ut : Ee),
            Y(Se, !0),
            xe()
        }
        ).then(()=>{
            tr?.(Se, void 0),
            Se = ne(),
            de = !0,
            fe.forEach(we=>we(Se))
        }
        ).catch(we=>{
            tr?.(void 0, we)
        }
        )
    }
    ;
    return le.persist = {
        setOptions: tt=>{
            ue = {
                ...ue,
                ...tt
            },
            tt.storage && (ge = tt.storage)
        }
        ,
        clearStorage: ()=>{
            ge?.removeItem(ue.name)
        }
        ,
        getOptions: ()=>ue,
        rehydrate: ()=>Ne(),
        hasHydrated: ()=>de,
        onHydrate: tt=>(he.add(tt),
        ()=>{
            he.delete(tt)
        }
        ),
        onFinishHydration: tt=>(fe.add(tt),
        ()=>{
            fe.delete(tt)
        }
        )
    },
    ue.skipHydration || Ne(),
    Se || Ee
}
  , persistImpl = (W,z)=>"getStorage"in z || "serialize"in z || "deserialize"in z ? oldImpl(W, z) : newImpl(W, z)
  , persist = persistImpl
  , createStoreImpl = W=>{
    let z;
    const Y = new Set
      , ne = (de,he)=>{
        const fe = typeof de == "function" ? de(z) : de;
        if (!Object.is(fe, z)) {
            const ge = z;
            z = he ?? (typeof fe != "object" || fe === null) ? fe : Object.assign({}, z, fe),
            Y.forEach(xe=>xe(z, ge))
        }
    }
      , le = ()=>z
      , ue = {
        setState: ne,
        getState: le,
        subscribe: de=>(Y.add(de),
        ()=>Y.delete(de)),
        destroy: ()=>{
            Y.clear()
        }
    };
    return z = W(ne, le, ue),
    ue
}
  , createStore = W=>W ? createStoreImpl(W) : createStoreImpl;
function shallow$1(W, z) {
    if (Object.is(W, z))
        return !0;
    if (typeof W != "object" || W === null || typeof z != "object" || z === null)
        return !1;
    if (W instanceof Map && z instanceof Map) {
        if (W.size !== z.size)
            return !1;
        for (const [ne,le] of W)
            if (!Object.is(le, z.get(ne)))
                return !1;
        return !0
    }
    if (W instanceof Set && z instanceof Set) {
        if (W.size !== z.size)
            return !1;
        for (const ne of W)
            if (!z.has(ne))
                return !1;
        return !0
    }
    const Y = Object.keys(W);
    if (Y.length !== Object.keys(z).length)
        return !1;
    for (let ne = 0; ne < Y.length; ne++)
        if (!Object.prototype.hasOwnProperty.call(z, Y[ne]) || !Object.is(W[Y[ne]], z[Y[ne]]))
            return !1;
    return !0
}
function configureChains(W, z, {batch: Y={
    multicall: {
        wait: 32
    }
}, pollingInterval: ne=4e3, rank: le, retryCount: ue, retryDelay: de, stallTimeout: he}={}) {
    if (!W.length)
        throw new Error("must have at least one chain");
    let fe = [];
    const ge = {}
      , xe = {};
    for (const $e of W) {
        let Ee = !1;
        for (const Se of z) {
            const Ne = Se($e);
            Ne && (Ee = !0,
            fe.some(({id: tt})=>tt === $e.id) || (fe = [...fe, Ne.chain]),
            ge[$e.id] = [...ge[$e.id] || [], ...Ne.rpcUrls.http],
            Ne.rpcUrls.webSocket && (xe[$e.id] = [...xe[$e.id] || [], ...Ne.rpcUrls.webSocket]))
        }
        if (!Ee)
            throw new Error([`Could not find valid provider configuration for chain "${$e.name}".
`, "You may need to add `jsonRpcProvider` to `configureChains` with the chain's RPC URLs.", "Read more: https://wagmi.sh/core/providers/jsonRpc"].join(`
`))
    }
    return {
        chains: fe,
        publicClient: ({chainId: $e})=>{
            const Ee = fe.find(tt=>tt.id === $e) ?? W[0]
              , Se = ge[Ee.id];
            if (!Se || !Se[0])
                throw new Error(`No providers configured for chain "${Ee.id}"`);
            const Ne = createPublicClient({
                batch: Y,
                chain: Ee,
                transport: fallback(Se.map(tt=>http(tt, {
                    timeout: he
                })), {
                    rank: le,
                    retryCount: ue,
                    retryDelay: de
                }),
                pollingInterval: ne
            });
            return Object.assign(Ne, {
                chains: fe
            })
        }
        ,
        webSocketPublicClient: ({chainId: $e})=>{
            const Ee = fe.find(tt=>tt.id === $e) ?? W[0]
              , Se = xe[Ee.id];
            if (!Se || !Se[0])
                return;
            const Ne = createPublicClient({
                batch: Y,
                chain: Ee,
                transport: fallback(Se.map(tt=>webSocket(tt, {
                    timeout: he
                })), {
                    rank: le,
                    retryCount: ue,
                    retryDelay: de
                }),
                pollingInterval: ne
            });
            return Object.assign(Ne, {
                chains: fe
            })
        }
    }
}
var ChainMismatchError = class extends Error {
    constructor({activeChain: W, targetChain: z}) {
        super(`Chain mismatch: Expected "${z}", received "${W}".`),
        this.name = "ChainMismatchError"
    }
}
  , ChainNotConfiguredError = class extends Error {
    constructor({chainId: W, connectorId: z}) {
        super(`Chain "${W}" not configured${z ? ` for connector "${z}"` : ""}.`),
        this.name = "ChainNotConfigured"
    }
}
  , ConnectorAlreadyConnectedError = class extends Error {
    constructor() {
        super(...arguments),
        this.name = "ConnectorAlreadyConnectedError",
        this.message = "Connector already connected"
    }
}
  , ConfigChainsNotFound = class extends Error {
    constructor() {
        super(...arguments),
        this.name = "ConfigChainsNotFound",
        this.message = "No chains were found on the wagmi config. Some functions that require a chain may not work."
    }
}
  , SwitchChainNotSupportedError = class extends Error {
    constructor({connector: W}) {
        super(`"${W.name}" does not support programmatic chain switching.`),
        this.name = "SwitchChainNotSupportedError"
    }
}
  , findAndReplace = (W,{find: z, replace: Y})=>W && z(W) ? Y(W) : typeof W != "object" ? W : Array.isArray(W) ? W.map(ne=>findAndReplace(ne, {
    find: z,
    replace: Y
})) : W instanceof Object ? Object.entries(W).reduce((ne,[le,ue])=>({
    ...ne,
    [le]: findAndReplace(ue, {
        find: z,
        replace: Y
    })
}), {}) : W;
function deserialize(W) {
    const z = JSON.parse(W);
    return findAndReplace(z, {
        find: ne=>typeof ne == "string" && ne.startsWith("#bigint."),
        replace: ne=>BigInt(ne.replace("#bigint.", ""))
    })
}
function getCallParameters(W) {
    return {
        accessList: W.accessList,
        account: W.account,
        blockNumber: W.blockNumber,
        blockTag: W.blockTag,
        data: W.data,
        gas: W.gas,
        gasPrice: W.gasPrice,
        maxFeePerGas: W.maxFeePerGas,
        maxPriorityFeePerGas: W.maxPriorityFeePerGas,
        nonce: W.nonce,
        to: W.to,
        value: W.value
    }
}
function getUnit(W) {
    return typeof W == "number" ? W : W === "wei" ? 0 : Math.abs(weiUnits[W])
}
function getReferenceKey(W, z) {
    return W.slice(0, z).join(".") || "."
}
function getCutoff(W, z) {
    const {length: Y} = W;
    for (let ne = 0; ne < Y; ++ne)
        if (W[ne] === z)
            return ne + 1;
    return 0
}
function createReplacer(W, z) {
    const Y = typeof W == "function"
      , ne = typeof z == "function"
      , le = []
      , ue = [];
    return function(de, he) {
        if (typeof he == "object")
            if (le.length) {
                const fe = getCutoff(le, this);
                fe === 0 ? le[le.length] = this : (le.splice(fe),
                ue.splice(fe)),
                ue[ue.length] = de;
                const ge = getCutoff(le, he);
                if (ge !== 0)
                    return ne ? z.call(this, de, he, getReferenceKey(ue, ge)) : `[ref=${getReferenceKey(ue, ge)}]`
            } else
                le[0] = he,
                ue[0] = de;
        return Y ? W.call(this, de, he) : he
    }
}
function serialize(W, z, Y, ne) {
    return JSON.stringify(W, createReplacer((le,ue)=>{
        const de = typeof ue == "bigint" ? `#bigint.${ue.toString()}` : ue;
        return z?.(le, de) || de
    }
    , ne), Y ?? void 0)
}
var noopStorage = {
    getItem: W=>"",
    setItem: (W,z)=>null,
    removeItem: W=>null
};
function createStorage({deserialize: W=deserialize, key: z="wagmi", serialize: Y=serialize, storage: ne}) {
    return {
        ...ne,
        getItem: (le,ue=null)=>{
            const de = ne.getItem(`${z}.${le}`);
            try {
                return de ? W(de) : ue
            } catch (he) {
                return console.warn(he),
                ue
            }
        }
        ,
        setItem: (le,ue)=>{
            if (ue === null)
                ne.removeItem(`${z}.${le}`);
            else
                try {
                    ne.setItem(`${z}.${le}`, Y(ue))
                } catch (de) {
                    console.error(de)
                }
        }
        ,
        removeItem: le=>ne.removeItem(`${z}.${le}`)
    }
}
var storeKey = "store", _isAutoConnecting, _lastUsedConnector, _addEffects, addEffects_fn, Config = class {
    constructor({autoConnect: W=!1, connectors: z=[new InjectedConnector], publicClient: Y, storage: ne=createStorage({
        storage: typeof window < "u" ? window.localStorage : noopStorage
    }), logger: le={
        warn: console.warn
    }, webSocketPublicClient: ue}) {
        __privateAdd(this, _addEffects),
        this.publicClients = new Map,
        this.webSocketPublicClients = new Map,
        __privateAdd(this, _isAutoConnecting, void 0),
        __privateAdd(this, _lastUsedConnector, void 0),
        this.args = {
            autoConnect: W,
            connectors: z,
            logger: le,
            publicClient: Y,
            storage: ne,
            webSocketPublicClient: ue
        };
        let de, he = "disconnected";
        if (W)
            try {
                const ge = ne.getItem(storeKey)
                  , xe = ge?.state?.data;
                he = xe?.account ? "reconnecting" : "connecting",
                de = xe?.chain?.id
            } catch {}
        const fe = typeof z == "function" ? z() : z;
        fe.forEach(ge=>ge.setStorage(ne)),
        this.store = createStore(subscribeWithSelector(persist(()=>({
            connectors: fe,
            publicClient: this.getPublicClient({
                chainId: de
            }),
            status: he,
            webSocketPublicClient: this.getWebSocketPublicClient({
                chainId: de
            })
        }), {
            name: storeKey,
            storage: ne,
            partialize: ge=>({
                ...W && {
                    data: {
                        account: ge?.data?.account,
                        chain: ge?.data?.chain
                    }
                },
                chains: ge?.chains
            }),
            version: 2
        }))),
        this.storage = ne,
        __privateSet(this, _lastUsedConnector, ne?.getItem("wallet")),
        __privateMethod(this, _addEffects, addEffects_fn).call(this),
        W && typeof window < "u" && setTimeout(async()=>await this.autoConnect(), 0)
    }
    get chains() {
        return this.store.getState().chains
    }
    get connectors() {
        return this.store.getState().connectors
    }
    get connector() {
        return this.store.getState().connector
    }
    get data() {
        return this.store.getState().data
    }
    get error() {
        return this.store.getState().error
    }
    get lastUsedChainId() {
        return this.data?.chain?.id
    }
    get publicClient() {
        return this.store.getState().publicClient
    }
    get status() {
        return this.store.getState().status
    }
    get subscribe() {
        return this.store.subscribe
    }
    get webSocketPublicClient() {
        return this.store.getState().webSocketPublicClient
    }
    setState(W) {
        const z = typeof W == "function" ? W(this.store.getState()) : W;
        this.store.setState(z, !0)
    }
    clearState() {
        this.setState(W=>({
            ...W,
            chains: void 0,
            connector: void 0,
            data: void 0,
            error: void 0,
            status: "disconnected"
        }))
    }
    async destroy() {
        this.connector && await this.connector.disconnect?.(),
        __privateSet(this, _isAutoConnecting, !1),
        this.clearState(),
        this.store.destroy()
    }
    async autoConnect() {
        if (__privateGet(this, _isAutoConnecting))
            return;
        __privateSet(this, _isAutoConnecting, !0),
        this.setState(Y=>({
            ...Y,
            status: Y.data?.account ? "reconnecting" : "connecting"
        }));
        const W = __privateGet(this, _lastUsedConnector) ? [...this.connectors].sort(Y=>Y.id === __privateGet(this, _lastUsedConnector) ? -1 : 1) : this.connectors;
        let z = !1;
        for (const Y of W) {
            if (!Y.ready || !Y.isAuthorized || !await Y.isAuthorized())
                continue;
            const ne = await Y.connect();
            this.setState(le=>({
                ...le,
                connector: Y,
                chains: Y?.chains,
                data: ne,
                status: "connected"
            })),
            z = !0;
            break
        }
        return z || this.setState(Y=>({
            ...Y,
            data: void 0,
            status: "disconnected"
        })),
        __privateSet(this, _isAutoConnecting, !1),
        this.data
    }
    setConnectors(W) {
        this.args = {
            ...this.args,
            connectors: W
        };
        const z = typeof W == "function" ? W() : W;
        z.forEach(Y=>Y.setStorage(this.args.storage)),
        this.setState(Y=>({
            ...Y,
            connectors: z
        }))
    }
    getPublicClient({chainId: W}={}) {
        let z = this.publicClients.get(-1);
        if (z && z?.chain.id === W || (z = this.publicClients.get(W ?? -1),
        z))
            return z;
        const {publicClient: Y} = this.args;
        return z = typeof Y == "function" ? Y({
            chainId: W
        }) : Y,
        this.publicClients.set(W ?? -1, z),
        z
    }
    setPublicClient(W) {
        const z = this.data?.chain?.id;
        this.args = {
            ...this.args,
            publicClient: W
        },
        this.publicClients.clear(),
        this.setState(Y=>({
            ...Y,
            publicClient: this.getPublicClient({
                chainId: z
            })
        }))
    }
    getWebSocketPublicClient({chainId: W}={}) {
        let z = this.webSocketPublicClients.get(-1);
        if (z && z?.chain.id === W || (z = this.webSocketPublicClients.get(W ?? -1),
        z))
            return z;
        const {webSocketPublicClient: Y} = this.args;
        return z = typeof Y == "function" ? Y({
            chainId: W
        }) : Y,
        z && this.webSocketPublicClients.set(W ?? -1, z),
        z
    }
    setWebSocketPublicClient(W) {
        const z = this.data?.chain?.id;
        this.args = {
            ...this.args,
            webSocketPublicClient: W
        },
        this.webSocketPublicClients.clear(),
        this.setState(Y=>({
            ...Y,
            webSocketPublicClient: this.getWebSocketPublicClient({
                chainId: z
            })
        }))
    }
    setLastUsedConnector(W=null) {
        this.storage?.setItem("wallet", W)
    }
}
, config;
function createConfig(W) {
    const z = new Config(W);
    return config = z,
    z
}
function getConfig() {
    if (!config)
        throw new Error("No wagmi config found. Ensure you have set up a config: https://wagmi.sh/react/config");
    return config
}
async function connect({chainId: W, connector: z}) {
    const Y = getConfig()
      , ne = Y.connector;
    if (ne && z.id === ne.id)
        throw new ConnectorAlreadyConnectedError;
    try {
        Y.setState(ue=>({
            ...ue,
            status: "connecting"
        }));
        const le = await z.connect({
            chainId: W
        });
        return Y.setLastUsedConnector(z.id),
        Y.setState(ue=>({
            ...ue,
            connector: z,
            chains: z?.chains,
            data: le,
            status: "connected"
        })),
        Y.storage.setItem("connected", !0),
        {
            ...le,
            connector: z
        }
    } catch (le) {
        throw Y.setState(ue=>({
            ...ue,
            status: ue.connector ? "connected" : "disconnected"
        })),
        le
    }
}
async function disconnect() {
    const W = getConfig();
    W.connector && await W.connector.disconnect(),
    W.clearState(),
    W.storage.removeItem("connected")
}
_isAutoConnecting = new WeakMap,
_lastUsedConnector = new WeakMap,
_addEffects = new WeakSet,
addEffects_fn = function() {
    const W = ue=>{
        this.setState(de=>({
            ...de,
            data: {
                ...de.data,
                ...ue
            }
        }))
    }
      , z = ()=>{
        this.clearState()
    }
      , Y = ue=>{
        this.setState(de=>({
            ...de,
            error: ue
        }))
    }
    ;
    this.store.subscribe(({connector: ue})=>ue, (ue,de)=>{
        de?.off?.("change", W),
        de?.off?.("disconnect", z),
        de?.off?.("error", Y),
        ue && (ue.on?.("change", W),
        ue.on?.("disconnect", z),
        ue.on?.("error", Y))
    }
    );
    const {publicClient: ne, webSocketPublicClient: le} = this.args;
    (typeof ne == "function" || typeof le == "function") && this.store.subscribe(({data: ue})=>ue?.chain?.id, ue=>{
        this.setState(de=>({
            ...de,
            publicClient: this.getPublicClient({
                chainId: ue
            }),
            webSocketPublicClient: this.getWebSocketPublicClient({
                chainId: ue
            })
        }))
    }
    )
}
;
var erc20ABI = [{
    type: "event",
    name: "Approval",
    inputs: [{
        indexed: !0,
        name: "owner",
        type: "address"
    }, {
        indexed: !0,
        name: "spender",
        type: "address"
    }, {
        indexed: !1,
        name: "value",
        type: "uint256"
    }]
}, {
    type: "event",
    name: "Transfer",
    inputs: [{
        indexed: !0,
        name: "from",
        type: "address"
    }, {
        indexed: !0,
        name: "to",
        type: "address"
    }, {
        indexed: !1,
        name: "value",
        type: "uint256"
    }]
}, {
    type: "function",
    name: "allowance",
    stateMutability: "view",
    inputs: [{
        name: "owner",
        type: "address"
    }, {
        name: "spender",
        type: "address"
    }],
    outputs: [{
        name: "",
        type: "uint256"
    }]
}, {
    type: "function",
    name: "approve",
    stateMutability: "nonpayable",
    inputs: [{
        name: "spender",
        type: "address"
    }, {
        name: "amount",
        type: "uint256"
    }],
    outputs: [{
        name: "",
        type: "bool"
    }]
}, {
    type: "function",
    name: "balanceOf",
    stateMutability: "view",
    inputs: [{
        name: "account",
        type: "address"
    }],
    outputs: [{
        name: "",
        type: "uint256"
    }]
}, {
    type: "function",
    name: "decimals",
    stateMutability: "view",
    inputs: [],
    outputs: [{
        name: "",
        type: "uint8"
    }]
}, {
    type: "function",
    name: "name",
    stateMutability: "view",
    inputs: [],
    outputs: [{
        name: "",
        type: "string"
    }]
}, {
    type: "function",
    name: "symbol",
    stateMutability: "view",
    inputs: [],
    outputs: [{
        name: "",
        type: "string"
    }]
}, {
    type: "function",
    name: "totalSupply",
    stateMutability: "view",
    inputs: [],
    outputs: [{
        name: "",
        type: "uint256"
    }]
}, {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [{
        name: "recipient",
        type: "address"
    }, {
        name: "amount",
        type: "uint256"
    }],
    outputs: [{
        name: "",
        type: "bool"
    }]
}, {
    type: "function",
    name: "transferFrom",
    stateMutability: "nonpayable",
    inputs: [{
        name: "sender",
        type: "address"
    }, {
        name: "recipient",
        type: "address"
    }, {
        name: "amount",
        type: "uint256"
    }],
    outputs: [{
        name: "",
        type: "bool"
    }]
}]
  , erc20ABI_bytes32 = [{
    type: "event",
    name: "Approval",
    inputs: [{
        indexed: !0,
        name: "owner",
        type: "address"
    }, {
        indexed: !0,
        name: "spender",
        type: "address"
    }, {
        indexed: !1,
        name: "value",
        type: "uint256"
    }]
}, {
    type: "event",
    name: "Transfer",
    inputs: [{
        indexed: !0,
        name: "from",
        type: "address"
    }, {
        indexed: !0,
        name: "to",
        type: "address"
    }, {
        indexed: !1,
        name: "value",
        type: "uint256"
    }]
}, {
    type: "function",
    name: "allowance",
    stateMutability: "view",
    inputs: [{
        name: "owner",
        type: "address"
    }, {
        name: "spender",
        type: "address"
    }],
    outputs: [{
        name: "",
        type: "uint256"
    }]
}, {
    type: "function",
    name: "approve",
    stateMutability: "nonpayable",
    inputs: [{
        name: "spender",
        type: "address"
    }, {
        name: "amount",
        type: "uint256"
    }],
    outputs: [{
        name: "",
        type: "bool"
    }]
}, {
    type: "function",
    name: "balanceOf",
    stateMutability: "view",
    inputs: [{
        name: "account",
        type: "address"
    }],
    outputs: [{
        name: "",
        type: "uint256"
    }]
}, {
    type: "function",
    name: "decimals",
    stateMutability: "view",
    inputs: [],
    outputs: [{
        name: "",
        type: "uint8"
    }]
}, {
    type: "function",
    name: "name",
    stateMutability: "view",
    inputs: [],
    outputs: [{
        name: "",
        type: "bytes32"
    }]
}, {
    type: "function",
    name: "symbol",
    stateMutability: "view",
    inputs: [],
    outputs: [{
        name: "",
        type: "bytes32"
    }]
}, {
    type: "function",
    name: "totalSupply",
    stateMutability: "view",
    inputs: [],
    outputs: [{
        name: "",
        type: "uint256"
    }]
}, {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [{
        name: "recipient",
        type: "address"
    }, {
        name: "amount",
        type: "uint256"
    }],
    outputs: [{
        name: "",
        type: "bool"
    }]
}, {
    type: "function",
    name: "transferFrom",
    stateMutability: "nonpayable",
    inputs: [{
        name: "sender",
        type: "address"
    }, {
        name: "recipient",
        type: "address"
    }, {
        name: "amount",
        type: "uint256"
    }],
    outputs: [{
        name: "",
        type: "bool"
    }]
}];
function getPublicClient({chainId: W}={}) {
    const z = getConfig();
    return W && z.getPublicClient({
        chainId: W
    }) || z.publicClient
}
async function getWalletClient({chainId: W}={}) {
    return await getConfig().connector?.getWalletClient?.({
        chainId: W
    }) || null
}
async function prepareWriteContract({abi: W, address: z, args: Y, chainId: ne, dataSuffix: le, functionName: ue, walletClient: de, ...he}) {
    const fe = getPublicClient({
        chainId: ne
    })
      , ge = de ?? await getWalletClient({
        chainId: ne
    });
    if (!ge)
        throw new ConnectorNotFoundError;
    ne && assertActiveChain({
        chainId: ne
    });
    const {account: xe, accessList: $e, blockNumber: Ee, blockTag: Se, gas: Ne, gasPrice: tt, maxFeePerGas: rr, maxPriorityFeePerGas: tr, nonce: we, value: Ut} = getCallParameters(he)
      , {result: lr, request: cr} = await fe.simulateContract({
        abi: W,
        address: z,
        functionName: ue,
        args: Y,
        account: xe || ge.account,
        accessList: $e,
        blockNumber: Ee,
        blockTag: Se,
        dataSuffix: le,
        gas: Ne,
        gasPrice: tt,
        maxFeePerGas: rr,
        maxPriorityFeePerGas: tr,
        nonce: we,
        value: Ut
    });
    return {
        mode: "prepared",
        request: {
            ...cr,
            abi: W.filter(be=>"name"in be && be.name === ue),
            chainId: ne
        },
        result: lr
    }
}
async function multicall({chainId: W, contracts: z, blockNumber: Y, blockTag: ne, ...le}) {
    const ue = getPublicClient({
        chainId: W
    });
    if (!ue.chains)
        throw new ConfigChainsNotFound;
    if (W && ue.chain.id !== W)
        throw new ChainNotConfiguredError({
            chainId: W
        });
    return ue.multicall({
        allowFailure: le.allowFailure ?? !0,
        blockNumber: Y,
        blockTag: ne,
        contracts: z
    })
}
async function readContract({address: W, account: z, chainId: Y, abi: ne, args: le, functionName: ue, blockNumber: de, blockTag: he}) {
    return getPublicClient({
        chainId: Y
    }).readContract({
        abi: ne,
        address: W,
        account: z,
        functionName: ue,
        args: le,
        blockNumber: de,
        blockTag: he
    })
}
async function readContracts({contracts: W, blockNumber: z, blockTag: Y, ...ne}) {
    const {allowFailure: le=!0} = ne;
    try {
        const ue = getPublicClient()
          , de = W.reduce((xe,$e,Ee)=>{
            const Se = $e.chainId ?? ue.chain.id;
            return {
                ...xe,
                [Se]: [...xe[Se] || [], {
                    contract: $e,
                    index: Ee
                }]
            }
        }
        , {})
          , he = ()=>Object.entries(de).map(([xe,$e])=>multicall({
            allowFailure: le,
            chainId: parseInt(xe),
            contracts: $e.map(({contract: Ee})=>Ee),
            blockNumber: z,
            blockTag: Y
        }))
          , fe = (await Promise.all(he())).flat()
          , ge = Object.values(de).flatMap(xe=>xe.map(({index: $e})=>$e));
        return fe.reduce((xe,$e,Ee)=>(xe && (xe[ge[Ee]] = $e),
        xe), [])
    } catch (ue) {
        if (ue instanceof ContractFunctionExecutionError)
            throw ue;
        const de = ()=>W.map(he=>readContract({
            ...he,
            blockNumber: z,
            blockTag: Y
        }));
        return le ? (await Promise.allSettled(de())).map(he=>he.status === "fulfilled" ? {
            result: he.value,
            status: "success"
        } : {
            error: he.reason,
            result: void 0,
            status: "failure"
        }) : await Promise.all(de())
    }
}
async function writeContract(W) {
    const z = await getWalletClient({
        chainId: W.chainId
    });
    if (!z)
        throw new ConnectorNotFoundError;
    let Y;
    if (W.chainId && assertActiveChain({
        chainId: W.chainId
    }),
    W.mode === "prepared")
        Y = W.request;
    else {
        const {chainId: ne, mode: le, ...ue} = W;
        Y = (await prepareWriteContract(ue)).request
    }
    return {
        hash: await z.writeContract({
            ...Y,
            chain: W.chainId ? {
                id: W.chainId
            } : null
        })
    }
}
async function fetchBalance({address: W, chainId: z, formatUnits: Y, token: ne}) {
    const le = getConfig()
      , ue = getPublicClient({
        chainId: z
    });
    if (ne) {
        const ge = async({abi: xe})=>{
            const $e = {
                abi: xe,
                address: ne,
                chainId: z
            }
              , [Ee,Se,Ne] = await readContracts({
                allowFailure: !1,
                contracts: [{
                    ...$e,
                    functionName: "balanceOf",
                    args: [W]
                }, {
                    ...$e,
                    functionName: "decimals"
                }, {
                    ...$e,
                    functionName: "symbol"
                }]
            });
            return {
                decimals: Se,
                formatted: formatUnits(Ee ?? "0", getUnit(Y ?? Se)),
                symbol: Ne,
                value: Ee
            }
        }
        ;
        try {
            return await ge({
                abi: erc20ABI
            })
        } catch (xe) {
            if (xe instanceof ContractFunctionExecutionError) {
                const {symbol: $e, ...Ee} = await ge({
                    abi: erc20ABI_bytes32
                });
                return {
                    symbol: hexToString(trim($e, {
                        dir: "right"
                    })),
                    ...Ee
                }
            }
            throw xe
        }
    }
    const de = [...le.publicClient.chains || [], ...le.chains ?? []]
      , he = await ue.getBalance({
        address: W
    })
      , fe = de.find(ge=>ge.id === ue.chain.id);
    return {
        decimals: fe?.nativeCurrency.decimals ?? 18,
        formatted: formatUnits(he ?? "0", getUnit(Y ?? 18)),
        symbol: fe?.nativeCurrency.symbol ?? "ETH",
        value: he
    }
}
function getAccount() {
    const {data: W, connector: z, status: Y} = getConfig();
    switch (Y) {
    case "connected":
        return {
            address: W?.account,
            connector: z,
            isConnected: !0,
            isConnecting: !1,
            isDisconnected: !1,
            isReconnecting: !1,
            status: Y
        };
    case "reconnecting":
        return {
            address: W?.account,
            connector: z,
            isConnected: !!W?.account,
            isConnecting: !1,
            isDisconnected: !1,
            isReconnecting: !0,
            status: Y
        };
    case "connecting":
        return {
            address: W?.account,
            connector: z,
            isConnected: !1,
            isConnecting: !0,
            isDisconnected: !1,
            isReconnecting: !1,
            status: Y
        };
    case "disconnected":
        return {
            address: void 0,
            connector: void 0,
            isConnected: !1,
            isConnecting: !1,
            isDisconnected: !0,
            isReconnecting: !1,
            status: Y
        }
    }
}
function getNetwork() {
    const W = getConfig()
      , z = W.data?.chain?.id
      , Y = W.chains ?? []
      , ne = [...W.publicClient?.chains || [], ...Y].find(le=>le.id === z) ?? {
        id: z,
        name: `Chain ${z}`,
        network: `${z}`,
        nativeCurrency: {
            name: "Ether",
            decimals: 18,
            symbol: "ETH"
        },
        rpcUrls: {
            default: {
                http: [""]
            },
            public: {
                http: [""]
            }
        }
    };
    return {
        chain: z ? {
            ...ne,
            ...W.data?.chain,
            id: z
        } : void 0,
        chains: Y
    }
}
async function switchNetwork({chainId: W}) {
    const {connector: z} = getConfig();
    if (!z)
        throw new ConnectorNotFoundError;
    if (!z.switchChain)
        throw new SwitchChainNotSupportedError({
            connector: z
        });
    return z.switchChain(W)
}
function watchAccount(W, {selector: z=Y=>Y}={}) {
    return getConfig().subscribe(({data: ne, connector: le, status: ue})=>z({
        address: ne?.account,
        connector: le,
        status: ue
    }), ()=>W(getAccount()), {
        equalityFn: shallow$1
    })
}
function watchNetwork(W, {selector: z=Y=>Y}={}) {
    return getConfig().subscribe(({data: ne, chains: le})=>z({
        chainId: ne?.chain?.id,
        chains: le
    }), ()=>W(getNetwork()), {
        equalityFn: shallow$1
    })
}
async function fetchEnsAvatar({name: W, chainId: z}) {
    /*const {normalize: Y} = await __vitePreload(()=>import("./index.09e182b1.js"), []);
    return await getPublicClient({
        chainId: z
    }).getEnsAvatar({
        name: Y(W)
    })*/
}
async function fetchEnsName({address: W, chainId: z}) {
    return getPublicClient({
        chainId: z
    }).getEnsName({
        address: getAddress(W)
    })
}
function assertActiveChain({chainId: W}) {
    const {chain: z, chains: Y} = getNetwork()
      , ne = z?.id;
    if (ne && W !== ne)
        throw new ChainMismatchError({
            activeChain: Y.find(le=>le.id === ne)?.name ?? `Chain ${ne}`,
            targetChain: Y.find(le=>le.id === W)?.name ?? `Chain ${W}`
        })
}
const t$6 = Symbol()
  , s$6 = Object.getPrototypeOf
  , c$7 = new WeakMap
  , l$4 = W=>W && (c$7.has(W) ? c$7.get(W) : s$6(W) === Object.prototype || s$6(W) === Array.prototype)
  , y$3 = W=>l$4(W) && W[t$6] || null
  , h$7 = (W,z=!0)=>{
    c$7.set(W, z)
}
  , isObject = W=>typeof W == "object" && W !== null
  , proxyStateMap = new WeakMap
  , refSet = new WeakSet
  , buildProxyFunction = (W=Object.is,z=(ge,xe)=>new Proxy(ge,xe),Y=ge=>isObject(ge) && !refSet.has(ge) && (Array.isArray(ge) || !(Symbol.iterator in ge)) && !(ge instanceof WeakMap) && !(ge instanceof WeakSet) && !(ge instanceof Error) && !(ge instanceof Number) && !(ge instanceof Date) && !(ge instanceof String) && !(ge instanceof RegExp) && !(ge instanceof ArrayBuffer),ne=ge=>{
    switch (ge.status) {
    case "fulfilled":
        return ge.value;
    case "rejected":
        throw ge.reason;
    default:
        throw ge
    }
}
,le=new WeakMap,ue=(ge,xe,$e=ne)=>{
    const Ee = le.get(ge);
    if (Ee?.[0] === xe)
        return Ee[1];
    const Se = Array.isArray(ge) ? [] : Object.create(Object.getPrototypeOf(ge));
    return h$7(Se, !0),
    le.set(ge, [xe, Se]),
    Reflect.ownKeys(ge).forEach(Ne=>{
        if (Object.getOwnPropertyDescriptor(Se, Ne))
            return;
        const tt = Reflect.get(ge, Ne)
          , rr = {
            value: tt,
            enumerable: !0,
            configurable: !0
        };
        if (refSet.has(tt))
            h$7(tt, !1);
        else if (tt instanceof Promise)
            delete rr.value,
            rr.get = ()=>$e(tt);
        else if (proxyStateMap.has(tt)) {
            const [tr,we] = proxyStateMap.get(tt);
            rr.value = ue(tr, we(), $e)
        }
        Object.defineProperty(Se, Ne, rr)
    }
    ),
    Object.preventExtensions(Se)
}
,de=new WeakMap,he=[1, 1],fe=ge=>{
    if (!isObject(ge))
        throw new Error("object required");
    const xe = de.get(ge);
    if (xe)
        return xe;
    let $e = he[0];
    const Ee = new Set
      , Se = (be,mr=++he[0])=>{
        $e !== mr && ($e = mr,
        Ee.forEach(fr=>fr(be, mr)))
    }
    ;
    let Ne = he[1];
    const tt = be=>(mr,fr)=>{
        const Rr = [...mr];
        Rr[1] = [be, ...Rr[1]],
        Se(Rr, fr)
    }
      , rr = new Map
      , tr = be=>{
        var mr;
        const fr = rr.get(be);
        fr && (rr.delete(be),
        (mr = fr[1]) == null || mr.call(fr))
    }
      , we = Array.isArray(ge) ? [] : Object.create(Object.getPrototypeOf(ge))
      , Ut = {
        deleteProperty(be, mr) {
            const fr = Reflect.get(be, mr);
            tr(mr);
            const Rr = Reflect.deleteProperty(be, mr);
            return Rr && Se(["delete", [mr], fr]),
            Rr
        },
        set(be, mr, fr, Rr) {
            const Pr = Reflect.has(be, mr)
              , Fr = Reflect.get(be, mr, Rr);
            if (Pr && (W(Fr, fr) || de.has(fr) && W(Fr, de.get(fr))))
                return !0;
            tr(mr),
            isObject(fr) && (fr = y$3(fr) || fr);
            let br = fr;
            if (fr instanceof Promise)
                fr.then(xr=>{
                    fr.status = "fulfilled",
                    fr.value = xr,
                    Se(["resolve", [mr], xr])
                }
                ).catch(xr=>{
                    fr.status = "rejected",
                    fr.reason = xr,
                    Se(["reject", [mr], xr])
                }
                );
            else {
                !proxyStateMap.has(fr) && Y(fr) && (br = fe(fr));
                const xr = !refSet.has(br) && proxyStateMap.get(br);
                xr && ((_r,Ir)=>{
                    if (Ee.size) {
                        const Nr = Ir[3](tt(_r));
                        rr.set(_r, [Ir, Nr])
                    } else
                        rr.set(_r, [Ir])
                }
                )(mr, xr)
            }
            return Reflect.set(be, mr, br, Rr),
            Se(["set", [mr], fr, Fr]),
            !0
        }
    }
      , lr = z(we, Ut);
    de.set(ge, lr);
    const cr = [we, (be=++he[1])=>(Ne === be || Ee.size || (Ne = be,
    rr.forEach(([mr])=>{
        const fr = mr[1](be);
        fr > $e && ($e = fr)
    }
    )),
    $e), ue, be=>(Ee.add(be),
    Ee.size === 1 && rr.forEach(([mr,fr],Rr)=>{
        const Pr = mr[3](tt(Rr));
        rr.set(Rr, [mr, Pr])
    }
    ),
    ()=>{
        Ee.delete(be),
        Ee.size === 0 && rr.forEach(([mr,fr],Rr)=>{
            fr && (fr(),
            rr.set(Rr, [mr]))
        }
        )
    }
    )];
    return proxyStateMap.set(lr, cr),
    Reflect.ownKeys(ge).forEach(be=>{
        const mr = Object.getOwnPropertyDescriptor(ge, be);
        "value"in mr && (lr[be] = ge[be],
        delete mr.value,
        delete mr.writable),
        Object.defineProperty(we, be, mr)
    }
    ),
    lr
}
)=>[fe, proxyStateMap, refSet, W, z, Y, ne, le, ue, de, he]
  , [defaultProxyFunction] = buildProxyFunction();
function proxy$1(W={}) {
    return defaultProxyFunction(W)
}
function subscribe(W, z, Y) {
    const ne = proxyStateMap.get(W);
    let le;
    const ue = []
      , de = ne[3];
    let he = !1;
    const fe = de(ge=>{
        ue.push(ge),
        Y ? z(ue.splice(0)) : le || (le = Promise.resolve().then(()=>{
            le = void 0,
            he && z(ue.splice(0))
        }
        ))
    }
    );
    return he = !0,
    ()=>{
        he = !1,
        fe()
    }
}
function snapshot(W, z) {
    const Y = proxyStateMap.get(W)
      , [ne,le,ue] = Y;
    return ue(ne, le(), z)
}
function ref(W) {
    return refSet.add(W),
    W
}
function subscribeKey(W, z, Y, ne) {
    let le = W[z];
    return subscribe(W, ()=>{
        const ue = W[z];
        Object.is(le, ue) || Y(le = ue)
    }
    , ne)
}
const ConstantsUtil$1 = {
    FOUR_MINUTES_MS: 24e4,
    TEN_SEC_MS: 1e4,
    ONE_SEC_MS: 1e3,
    RESTRICTED_TIMEZONES: ["ASIA/SHANGHAI", "ASIA/URUMQI", "ASIA/CHONGQING", "ASIA/HARBIN", "ASIA/KASHGAR", "ASIA/MACAU", "ASIA/HONG_KONG", "ASIA/MACAO", "ASIA/BEIJING", "ASIA/HARBIN"]
}
  , CoreHelperUtil = {
    isMobile: ()=>typeof window < "u" && !!(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)),
    isAndroid() {
        const W = navigator.userAgent.toLowerCase();
        return CoreHelperUtil.isMobile() && W.includes("android")
    },
    isIos() {
        const W = navigator.userAgent.toLowerCase();
        return CoreHelperUtil.isMobile() && (W.includes("iphone") || W.includes("ipad"))
    },
    isClient: ()=>typeof window < "u",
    isPairingExpired: W=>!W || W - Date.now() <= ConstantsUtil$1.TEN_SEC_MS,
    isAllowedRetry: W=>Date.now() - W >= ConstantsUtil$1.ONE_SEC_MS,
    copyToClopboard(W) {
        navigator.clipboard.writeText(W)
    },
    getPairingExpiry: ()=>Date.now() + ConstantsUtil$1.FOUR_MINUTES_MS,
    getPlainAddress: W=>W.split(":")[2],
    wait: async W=>new Promise(z=>{
        setTimeout(z, W)
    }
    ),
    debounce(W, z=500) {
        let Y;
        return (...ne)=>{
            Y && clearTimeout(Y),
            Y = setTimeout(function() {
                W(...ne)
            }, z)
        }
    },
    isHttpUrl: W=>W.startsWith("http://") || W.startsWith("https://"),
    formatNativeUrl(W, z) {
        if (CoreHelperUtil.isHttpUrl(W))
            return this.formatUniversalUrl(W, z);
        let Y = W;
        return Y.includes("://") || (Y = W.replaceAll("/", "").replaceAll(":", ""),
        Y = `${Y}://`),
        Y.endsWith("/") || (Y = `${Y}/`),
        {
            redirect: `${Y}wc?uri=${encodeURIComponent(z)}`,
            href: Y
        }
    },
    formatUniversalUrl(W, z) {
        if (!CoreHelperUtil.isHttpUrl(W))
            return this.formatNativeUrl(W, z);
        let Y = W;
        return Y.endsWith("/") || (Y = `${Y}/`),
        {
            redirect: `${Y}wc?uri=${encodeURIComponent(z)}`,
            href: Y
        }
    },
    openHref(W, z) {
        window.open(W, z, "noreferrer noopener")
    },
    async preloadImage(W) {
        const z = new Promise((Y,ne)=>{
            const le = new Image;
            le.onload = Y,
            le.onerror = ne,
            le.crossOrigin = "anonymous",
            le.src = W
        }
        );
        return Promise.race([z, CoreHelperUtil.wait(2e3)])
    },
    formatBalance(W, z) {
        let Y;
        if (W === "0")
            Y = "0.000";
        else if (typeof W == "string") {
            const ne = Number(W);
            ne && (Y = ne.toString().match(/^-?\d+(?:\.\d{0,3})?/u)?.[0])
        }
        return Y ? `${Y} ${z}` : "0.000"
    },
    isRestrictedRegion() {
        try {
            const {timeZone: W} = new Intl.DateTimeFormat().resolvedOptions()
              , z = W.toUpperCase();
            return ConstantsUtil$1.RESTRICTED_TIMEZONES.includes(z)
        } catch {
            return !1
        }
    },
    getApiUrl: ()=>CoreHelperUtil.isRestrictedRegion() ? "https://api.web3modal.org" : "https://api.web3modal.com",
    getBlockchainApiUrl: ()=>CoreHelperUtil.isRestrictedRegion() ? "https://rpc.walletconnect.org" : "https://rpc.walletconnect.com",
    getAnalyticsUrl: ()=>CoreHelperUtil.isRestrictedRegion() ? "https://pulse.walletconnect.org" : "https://pulse.walletconnect.com",
    getUUID: ()=>crypto?.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, W=>{
        const z = 16 * Math.random() | 0;
        return (W === "x" ? z : 3 & z | 8).toString(16)
    }
    )
}
  , state$e = proxy$1({
    isConnected: !1
})
  , AccountController = {
    state: state$e,
    subscribe: W=>subscribe(state$e, ()=>W(state$e)),
    subscribeKey: (W,z)=>subscribeKey(state$e, W, z),
    setIsConnected(W) {
        state$e.isConnected = W
    },
    setCaipAddress(W) {
        state$e.caipAddress = W,
        state$e.address = W ? CoreHelperUtil.getPlainAddress(W) : void 0
    },
    setBalance(W, z) {
        state$e.balance = W,
        state$e.balanceSymbol = z
    },
    setProfileName(W) {
        state$e.profileName = W
    },
    setProfileImage(W) {
        state$e.profileImage = W
    },
    setAddressExplorerUrl(W) {
        state$e.addressExplorerUrl = W
    },
    resetAccount() {
        state$e.isConnected = !1,
        state$e.caipAddress = void 0,
        state$e.address = void 0,
        state$e.balance = void 0,
        state$e.balanceSymbol = void 0,
        state$e.profileName = void 0,
        state$e.profileImage = void 0,
        state$e.addressExplorerUrl = void 0
    }
};
class FetchUtil {
    constructor({baseUrl: z}) {
        this.baseUrl = z
    }
    async get({headers: z, ...Y}) {
        const ne = this.createUrl(Y);
        return (await fetch(ne, {
            method: "GET",
            headers: z
        })).json()
    }
    async getBlob({headers: z, ...Y}) {
        const ne = this.createUrl(Y);
        return (await fetch(ne, {
            method: "GET",
            headers: z
        })).blob()
    }
    async post({body: z, headers: Y, ...ne}) {
        const le = this.createUrl(ne);
        return (await fetch(le, {
            method: "POST",
            headers: Y,
            body: z ? JSON.stringify(z) : void 0
        })).json()
    }
    async put({body: z, headers: Y, ...ne}) {
        const le = this.createUrl(ne);
        return (await fetch(le, {
            method: "PUT",
            headers: Y,
            body: z ? JSON.stringify(z) : void 0
        })).json()
    }
    async delete({body: z, headers: Y, ...ne}) {
        const le = this.createUrl(ne);
        return (await fetch(le, {
            method: "DELETE",
            headers: Y,
            body: z ? JSON.stringify(z) : void 0
        })).json()
    }
    createUrl({path: z, params: Y}) {
        const ne = new URL(z,this.baseUrl);
        return Y && Object.entries(Y).forEach(([le,ue])=>{
            ue && ne.searchParams.append(le, ue)
        }
        ),
        ne
    }
}
const WC_DEEPLINK = "WALLETCONNECT_DEEPLINK_CHOICE"
  , W3M_RECENT = "@w3m/recent"
  , W3M_CONNECTED_WALLET_IMAGE_URL = "@w3m/connected_wallet_image_url"
  , StorageUtil = {
    setWalletConnectDeepLink({href: W, name: z}) {
        try {
            localStorage.setItem(WC_DEEPLINK, JSON.stringify({
                href: W,
                name: z
            }))
        } catch {
            console.info("Unable to set WalletConnect deep link")
        }
    },
    getWalletConnectDeepLink() {
        try {
            const W = localStorage.getItem(WC_DEEPLINK);
            if (W)
                return JSON.parse(W)
        } catch {
            console.info("Unable to get WalletConnect deep link")
        }
    },
    deleteWalletConnectDeepLink() {
        try {
            localStorage.removeItem(WC_DEEPLINK)
        } catch {
            console.info("Unable to delete WalletConnect deep link")
        }
    },
    setWeb3ModalRecent(W) {
        try {
            const z = StorageUtil.getRecentWallets();
            z.find(ne=>ne.id === W.id) || (z.unshift(W),
            z.length > 2 && z.pop(),
            localStorage.setItem(W3M_RECENT, JSON.stringify(z)))
        } catch {
            console.info("Unable to set Web3Modal recent")
        }
    },
    getRecentWallets() {
        try {
            const W = localStorage.getItem(W3M_RECENT);
            return W ? JSON.parse(W) : []
        } catch {
            console.info("Unable to get Web3Modal recent")
        }
        return []
    },
    setConnectedWalletImageUrl(W) {
        try {
            localStorage.setItem(W3M_CONNECTED_WALLET_IMAGE_URL, W)
        } catch {
            console.info("Unable to set Connected Wallet Image Url")
        }
    },
    getConnectedWalletImageUrl() {
        try {
            return localStorage.getItem(W3M_CONNECTED_WALLET_IMAGE_URL)
        } catch {
            console.info("Unable to set Connected Wallet Image Url")
        }
    }
}
  , state$d = proxy$1({
    walletImages: {},
    networkImages: {},
    connectorImages: {},
    tokenImages: {}
})
  , AssetController = {
    state: state$d,
    subscribeNetworkImages: W=>subscribe(state$d.networkImages, ()=>W(state$d.networkImages)),
    subscribeKey: (W,z)=>subscribeKey(state$d, W, z),
    setWalletImage(W, z) {
        state$d.walletImages[W] = z
    },
    setNetworkImage(W, z) {
        state$d.networkImages[W] = z
    },
    setConnectorImage(W, z) {
        state$d.connectorImages[W] = z
    },
    setTokenImage(W, z) {
        state$d.tokenImages[W] = z
    }
}
  , state$c = proxy$1({
    connectors: []
})
  , ConnectorController = {
    state: state$c,
    subscribeKey: (W,z)=>subscribeKey(state$c, W, z),
    setConnectors(W) {
        state$c.connectors = W.map(z=>ref(z))
    },
    addConnector(W) {
        state$c.connectors.push(ref(W))
    },
    getConnectors: ()=>state$c.connectors
}
  , state$b = proxy$1({
    open: !1,
    selectedNetworkId: void 0
})
  , PublicStateController = {
    state: state$b,
    subscribe: W=>subscribe(state$b, ()=>W(state$b)),
    set(W) {
        Object.assign(state$b, {
            ...state$b,
            ...W
        })
    }
}
  , state$a = proxy$1({
    supportsAllNetworks: !0,
    isDefaultCaipNetwork: !1
})
  , NetworkController = {
    state: state$a,
    subscribeKey: (W,z)=>subscribeKey(state$a, W, z),
    _getClient() {
        if (!state$a._client)
            throw new Error("NetworkController client not set");
        return state$a._client
    },
    setClient(W) {
        state$a._client = ref(W)
    },
    setCaipNetwork(W) {
        state$a.caipNetwork = W,
        PublicStateController.set({
            selectedNetworkId: W?.id
        })
    },
    setDefaultCaipNetwork(W) {
        state$a.caipNetwork = W,
        PublicStateController.set({
            selectedNetworkId: W?.id
        }),
        state$a.isDefaultCaipNetwork = !0
    },
    setRequestedCaipNetworks(W) {
        state$a.requestedCaipNetworks = W
    },
    async getApprovedCaipNetworksData() {
        const W = await this._getClient().getApprovedCaipNetworksData();
        state$a.supportsAllNetworks = W.supportsAllNetworks,
        state$a.approvedCaipNetworkIds = W.approvedCaipNetworkIds
    },
    async switchActiveNetwork(W) {
        await this._getClient().switchCaipNetwork(W),
        state$a.caipNetwork = W
    },
    resetNetwork() {
        state$a.isDefaultCaipNetwork || (state$a.caipNetwork = void 0),
        state$a.approvedCaipNetworkIds = void 0,
        state$a.supportsAllNetworks = !0
    }
}
  , state$9 = proxy$1({
    projectId: "",
    sdkType: "w3m",
    sdkVersion: "html-wagmi-undefined"
})
  , OptionsController = {
    state: state$9,
    subscribeKey: (W,z)=>subscribeKey(state$9, W, z),
    setProjectId(W) {
        state$9.projectId = W
    },
    setIncludeWalletIds(W) {
        state$9.includeWalletIds = W
    },
    setExcludeWalletIds(W) {
        state$9.excludeWalletIds = W
    },
    setFeaturedWalletIds(W) {
        state$9.featuredWalletIds = W
    },
    setTokens(W) {
        state$9.tokens = W
    },
    setTermsConditionsUrl(W) {
        state$9.termsConditionsUrl = W
    },
    setPrivacyPolicyUrl(W) {
        state$9.privacyPolicyUrl = W
    },
    setCustomWallets(W) {
        state$9.customWallets = W
    },
    setEnableAnalytics(W) {
        state$9.enableAnalytics = W
    },
    setSdkVersion(W) {
        state$9.sdkVersion = W
    },
    setMetadata(W) {
        state$9.metadata = W
    }
}
  , baseUrl$2 = CoreHelperUtil.getApiUrl()
  , api$2 = new FetchUtil({
    baseUrl: baseUrl$2
})
  , entries = "40"
  , recommendedEntries = "4"
  , state$8 = proxy$1({
    page: 1,
    count: 0,
    featured: [],
    recommended: [],
    wallets: [],
    search: []
})
  , ApiController = {
    state: state$8,
    subscribeKey: (W,z)=>subscribeKey(state$8, W, z),
    _getApiHeaders() {
        const {projectId: W, sdkType: z, sdkVersion: Y} = OptionsController.state;
        return {
            "x-project-id": W,
            "x-sdk-type": z,
            "x-sdk-version": Y
        }
    },
    async _fetchWalletImage(W) {
        const z = `${api$2.baseUrl}/getWalletImage/${W}`
          , Y = await api$2.getBlob({
            path: z,
            headers: ApiController._getApiHeaders()
        });
        AssetController.setWalletImage(W, URL.createObjectURL(Y))
    },
    async _fetchNetworkImage(W) {
        const z = `${api$2.baseUrl}/public/getAssetImage/${W}`
          , Y = await api$2.getBlob({
            path: z,
            headers: ApiController._getApiHeaders()
        });
        AssetController.setNetworkImage(W, URL.createObjectURL(Y))
    },
    async _fetchConnectorImage(W) {
        const z = `${api$2.baseUrl}/public/getAssetImage/${W}`
          , Y = await api$2.getBlob({
            path: z,
            headers: ApiController._getApiHeaders()
        });
        AssetController.setConnectorImage(W, URL.createObjectURL(Y))
    },
    async fetchNetworkImages() {
        const {requestedCaipNetworks: W} = NetworkController.state
          , z = W?.map(({imageId: Y})=>Y).filter(Boolean);
        z && await Promise.allSettled(z.map(Y=>ApiController._fetchNetworkImage(Y)))
    },
    async fetchConnectorImages() {
        const {connectors: W} = ConnectorController.state
          , z = W.map(({imageId: Y})=>Y).filter(Boolean);
        await Promise.allSettled(z.map(Y=>ApiController._fetchConnectorImage(Y)))
    },
    async fetchFeaturedWallets() {
        const {featuredWalletIds: W} = OptionsController.state;
        if (W?.length) {
            const {data: z} = await api$2.get({
                path: "/getWallets",
                headers: ApiController._getApiHeaders(),
                params: {
                    page: "1",
                    entries: W?.length ? String(W.length) : recommendedEntries,
                    include: W?.join(",")
                }
            });
            z.sort((ne,le)=>W.indexOf(ne.id) - W.indexOf(le.id));
            const Y = z.map(ne=>ne.image_id).filter(Boolean);
            await Promise.allSettled(Y.map(ne=>ApiController._fetchWalletImage(ne))),
            state$8.featured = z
        }
    },
    async fetchRecommendedWallets() {
        const {includeWalletIds: W, excludeWalletIds: z, featuredWalletIds: Y} = OptionsController.state
          , ne = [...z ?? [], ...Y ?? []].filter(Boolean)
          , {data: le, count: ue} = await api$2.get({
            path: "/getWallets",
            headers: ApiController._getApiHeaders(),
            params: {
                page: "1",
                entries: recommendedEntries,
                include: W?.join(","),
                exclude: ne?.join(",")
            }
        })
          , de = StorageUtil.getRecentWallets()
          , he = le.map(ge=>ge.image_id).filter(Boolean)
          , fe = de.map(ge=>ge.image_id).filter(Boolean);
        await Promise.allSettled([...he, ...fe].map(ge=>ApiController._fetchWalletImage(ge))),
        state$8.recommended = le,
        state$8.count = ue ?? 0
    },
    async fetchWallets({page: W}) {
        const {includeWalletIds: z, excludeWalletIds: Y, featuredWalletIds: ne} = OptionsController.state
          , le = [...state$8.recommended.map(({id: fe})=>fe), ...Y ?? [], ...ne ?? []].filter(Boolean)
          , {data: ue, count: de} = await api$2.get({
            path: "/getWallets",
            headers: ApiController._getApiHeaders(),
            params: {
                page: String(W),
                entries,
                include: z?.join(","),
                exclude: le.join(",")
            }
        })
          , he = ue.map(fe=>fe.image_id).filter(Boolean);
        await Promise.allSettled([...he.map(fe=>ApiController._fetchWalletImage(fe)), CoreHelperUtil.wait(300)]),
        state$8.wallets = [...state$8.wallets, ...ue],
        state$8.count = de > state$8.count ? de : state$8.count,
        state$8.page = W
    },
    async searchWallet({search: W}) {
        const {includeWalletIds: z, excludeWalletIds: Y} = OptionsController.state;
        state$8.search = [];
        const {data: ne} = await api$2.get({
            path: "/getWallets",
            headers: ApiController._getApiHeaders(),
            params: {
                page: "1",
                entries: "100",
                search: W,
                include: z?.join(","),
                exclude: Y?.join(",")
            }
        })
          , le = ne.map(ue=>ue.image_id).filter(Boolean);
        await Promise.allSettled([...le.map(ue=>ApiController._fetchWalletImage(ue)), CoreHelperUtil.wait(300)]),
        state$8.search = ne
    },
    prefetch() {
        state$8.prefetchPromise = Promise.race([Promise.allSettled([ApiController.fetchFeaturedWallets(), ApiController.fetchRecommendedWallets(), ApiController.fetchNetworkImages(), ApiController.fetchConnectorImages()]), CoreHelperUtil.wait(3e3)])
    }
}
  , baseUrl$1 = CoreHelperUtil.getAnalyticsUrl()
  , api$1 = new FetchUtil({
    baseUrl: baseUrl$1
})
  , excluded = ["MODAL_CREATED"]
  , state$7 = proxy$1({
    timestamp: Date.now(),
    data: {
        type: "track",
        event: "MODAL_CREATED"
    }
})
  , EventsController = {
    state: state$7,
    subscribe: W=>subscribe(state$7, ()=>W(state$7)),
    _getApiHeaders() {
        const {projectId: W, sdkType: z, sdkVersion: Y} = OptionsController.state;
        return {
            "x-project-id": W,
            "x-sdk-type": z,
            "x-sdk-version": Y
        }
    },
    async _sendAnalyticsEvent(W) {
        try {
            if (excluded.includes(W.data.event) || typeof window > "u")
                return;
            await api$1.post({
                path: "/e",
                headers: EventsController._getApiHeaders(),
                body: {
                    eventId: CoreHelperUtil.getUUID(),
                    url: window.location.href,
                    domain: window.location.hostname,
                    timestamp: W.timestamp,
                    props: W.data
                }
            })
        } catch {}
    },
    sendEvent(W) {
        state$7.timestamp = Date.now(),
        state$7.data = W,
        OptionsController.state.enableAnalytics && EventsController._sendAnalyticsEvent(state$7)
    }
}
  , state$6 = proxy$1({
    view: "Connect",
    history: ["Connect"]
})
  , RouterController = {
    state: state$6,
    subscribeKey: (W,z)=>subscribeKey(state$6, W, z),
    push(W, z) {
        W !== state$6.view && (state$6.view = W,
        state$6.history.push(W),
        state$6.data = z)
    },
    reset(W) {
        state$6.view = W,
        state$6.history = [W]
    },
    replace(W) {
        state$6.history.length > 1 && state$6.history.at(-1) !== W && (state$6.view = W,
        state$6.history[state$6.history.length - 1] = W)
    },
    goBack() {
        if (state$6.history.length > 1) {
            state$6.history.pop();
            const [W] = state$6.history.slice(-1);
            W && (state$6.view = W)
        }
    }
}
  , state$5 = proxy$1({
    open: !1
})
  , ModalController = {
    state: state$5,
    subscribeKey: (W,z)=>subscribeKey(state$5, W, z),
    async open(W) {
        await ApiController.state.prefetchPromise,
        W?.view ? RouterController.reset(W.view) : AccountController.state.isConnected ? RouterController.reset("Account") : RouterController.reset("Connect"),
        state$5.open = !0,
        PublicStateController.set({
            open: !0
        }),
        EventsController.sendEvent({
            type: "track",
            event: "MODAL_OPEN"
        })
    },
    close() {
        state$5.open = !1,
        PublicStateController.set({
            open: !1
        }),
        EventsController.sendEvent({
            type: "track",
            event: "MODAL_CLOSE"
        })
    }
}
  , baseUrl = CoreHelperUtil.getBlockchainApiUrl()
  , api = new FetchUtil({
    baseUrl
})
  , BlockchainApiController = {
    fetchIdentity: ({caipChainId: W, address: z})=>api.get({
        path: `/v1/identity/${z}`,
        params: {
            chainId: W,
            projectId: OptionsController.state.projectId
        }
    }),
    fetchTransactions({account: W, projectId: z, cursor: Y}) {
        const ne = Y ? {
            cursor: Y
        } : {};
        return api.get({
            path: `/v1/account/${W}/history?projectId=${z}`,
            params: ne
        })
    }
}
  , state$4 = proxy$1({
    message: "",
    variant: "success",
    open: !1
})
  , SnackController = {
    state: state$4,
    subscribeKey: (W,z)=>subscribeKey(state$4, W, z),
    showSuccess(W) {
        state$4.message = W,
        state$4.variant = "success",
        state$4.open = !0
    },
    showError(W) {
        state$4.message = W,
        state$4.variant = "error",
        state$4.open = !0
    },
    hide() {
        state$4.open = !1
    }
}
  , state$3 = proxy$1({
    transactions: [],
    transactionsByYear: {},
    loading: !1,
    empty: !1,
    next: void 0
})
  , TransactionsController = {
    state: state$3,
    subscribe: W=>subscribe(state$3, ()=>W(state$3)),
    async fetchTransactions(W) {
        const {projectId: z} = OptionsController.state;
        if (!z || !W)
            throw new Error("Transactions can't be fetched without a projectId and an accountAddress");
        state$3.loading = !0;
        try {
            const Y = await BlockchainApiController.fetchTransactions({
                account: W,
                projectId: z,
                cursor: state$3.next
            })
              , ne = this.filterSpamTransactions(Y.data)
              , le = [...state$3.transactions, ...ne];
            state$3.loading = !1,
            state$3.transactions = le,
            state$3.transactionsByYear = this.groupTransactionsByYear(state$3.transactionsByYear, ne),
            state$3.empty = le.length === 0,
            state$3.next = Y.next ? Y.next : void 0
        } catch {
            EventsController.sendEvent({
                type: "track",
                event: "ERROR_FETCH_TRANSACTIONS",
                properties: {
                    address: W,
                    projectId: z,
                    cursor: state$3.next
                }
            }),
            SnackController.showError("Failed to fetch transactions"),
            state$3.loading = !1,
            state$3.empty = !0
        }
    },
    groupTransactionsByYear(W={}, z=[]) {
        const Y = W;
        return z.forEach(ne=>{
            const le = new Date(ne.metadata.minedAt).getFullYear();
            Y[le] || (Y[le] = []),
            Y[le]?.push(ne)
        }
        ),
        Y
    },
    filterSpamTransactions: W=>W.filter(z=>!z.transfers.every(Y=>Y.nft_info?.flags.is_spam === !0)),
    resetTransactions() {
        state$3.transactions = [],
        state$3.transactionsByYear = {},
        state$3.loading = !1,
        state$3.empty = !1,
        state$3.next = void 0
    }
}
  , state$2 = proxy$1({
    wcError: !1,
    buffering: !1
})
  , ConnectionController = {
    state: state$2,
    subscribeKey: (W,z)=>subscribeKey(state$2, W, z),
    _getClient() {
        if (!state$2._client)
            throw new Error("ConnectionController client not set");
        return state$2._client
    },
    setClient(W) {
        state$2._client = ref(W)
    },
    connectWalletConnect() {
        state$2.wcPromise = this._getClient().connectWalletConnect(W=>{
            state$2.wcUri = W,
            state$2.wcPairingExpiry = CoreHelperUtil.getPairingExpiry()
        }
        )
    },
    async connectExternal(W) {
        await this._getClient().connectExternal?.(W)
    },
    checkInstalled(W) {
        return this._getClient().checkInstalled?.(W)
    },
    resetWcConnection() {
        state$2.wcUri = void 0,
        state$2.wcPairingExpiry = void 0,
        state$2.wcPromise = void 0,
        state$2.wcLinking = void 0,
        state$2.recentWallet = void 0,
        TransactionsController.resetTransactions(),
        StorageUtil.deleteWalletConnectDeepLink()
    },
    setWcLinking(W) {
        state$2.wcLinking = W
    },
    setWcError(W) {
        state$2.wcError = W,
        state$2.buffering = !1
    },
    setRecentWallet(W) {
        state$2.recentWallet = W
    },
    setBuffering(W) {
        state$2.buffering = W
    },
    async disconnect() {
        await this._getClient().disconnect(),
        this.resetWcConnection()
    }
}
  , state$1 = proxy$1({
    status: "uninitialized"
})
  , SIWEController = {
    state: state$1,
    subscribeKey: (W,z)=>subscribeKey(state$1, W, z),
    subscribe: W=>subscribe(state$1, ()=>W(state$1)),
    _getClient() {
        if (!state$1._client)
            throw new Error("SIWEController client not set");
        return state$1._client
    },
    setSIWEClient(W) {
        state$1._client = ref(W),
        state$1.status = "ready"
    },
    setNonce(W) {
        state$1.nonce = W
    },
    setStatus(W) {
        state$1.status = W
    },
    setMessage(W) {
        state$1.message = W
    },
    setSession(W) {
        state$1.session = W
    }
}
  , state = proxy$1({
    themeMode: "dark",
    themeVariables: {}
})
  , ThemeController = {
    state,
    subscribe: W=>subscribe(state, ()=>W(state)),
    setThemeMode(W) {
        state.themeMode = W
    },
    setThemeVariables(W) {
        state.themeVariables = {
            ...state.themeVariables,
            ...W
        }
    }
}
  , AssetUtil = {
    getWalletImage: W=>W?.image_url ? W?.image_url : W?.image_id ? AssetController.state.walletImages[W.image_id] : void 0,
    getNetworkImage: W=>W?.imageUrl ? W?.imageUrl : W?.imageId ? AssetController.state.networkImages[W.imageId] : void 0,
    getConnectorImage: W=>W?.imageUrl ? W.imageUrl : W?.imageId ? AssetController.state.connectorImages[W.imageId] : void 0
}
  , t$5 = globalThis
  , e$8 = t$5.ShadowRoot && (t$5.ShadyCSS === void 0 || t$5.ShadyCSS.nativeShadow) && "adoptedStyleSheets"in Document.prototype && "replace"in CSSStyleSheet.prototype
  , s$5 = Symbol()
  , o$9 = new WeakMap;
let n$8 = class {
    constructor(W, z, Y) {
        if (this._$cssResult$ = !0,
        Y !== s$5)
            throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = W,
        this.t = z
    }
    get styleSheet() {
        let W = this.o;
        const z = this.t;
        if (e$8 && W === void 0) {
            const Y = z !== void 0 && z.length === 1;
            Y && (W = o$9.get(z)),
            W === void 0 && ((this.o = W = new CSSStyleSheet).replaceSync(this.cssText),
            Y && o$9.set(z, W))
        }
        return W
    }
    toString() {
        return this.cssText
    }
}
;
const r$9 = W=>new n$8(typeof W == "string" ? W : W + "",void 0,s$5)
  , S$4 = (W,z)=>{
    if (e$8)
        W.adoptedStyleSheets = z.map(Y=>Y instanceof CSSStyleSheet ? Y : Y.styleSheet);
    else
        for (const Y of z) {
            const ne = document.createElement("style")
              , le = t$5.litNonce;
            le !== void 0 && ne.setAttribute("nonce", le),
            ne.textContent = Y.cssText,
            W.appendChild(ne)
        }
}
  , c$6 = e$8 ? W=>W : W=>W instanceof CSSStyleSheet ? (z=>{
    let Y = "";
    for (const ne of z.cssRules)
        Y += ne.cssText;
    return r$9(Y)
}
)(W) : W
  , {is: i$6, defineProperty: e$7, getOwnPropertyDescriptor: r$8, getOwnPropertyNames: h$6, getOwnPropertySymbols: o$8, getPrototypeOf: n$7} = Object
  , a$3 = globalThis
  , c$5 = a$3.trustedTypes
  , l$3 = c$5 ? c$5.emptyScript : ""
  , p$4 = a$3.reactiveElementPolyfillSupport
  , d$3 = (W,z)=>W
  , u$3 = {
    toAttribute(W, z) {
        switch (z) {
        case Boolean:
            W = W ? l$3 : null;
            break;
        case Object:
        case Array:
            W = W == null ? W : JSON.stringify(W)
        }
        return W
    },
    fromAttribute(W, z) {
        let Y = W;
        switch (z) {
        case Boolean:
            Y = W !== null;
            break;
        case Number:
            Y = W === null ? null : Number(W);
            break;
        case Object:
        case Array:
            try {
                Y = JSON.parse(W)
            } catch {
                Y = null
            }
        }
        return Y
    }
}
  , f$5 = (W,z)=>!i$6(W, z)
  , y$2 = {
    attribute: !0,
    type: String,
    converter: u$3,
    reflect: !1,
    hasChanged: f$5
};
Symbol.metadata ??= Symbol("metadata"),
a$3.litPropertyMetadata ??= new WeakMap;
let b$2 = class extends HTMLElement {
    static addInitializer(W) {
        this._$Ei(),
        (this.l ??= []).push(W)
    }
    static get observedAttributes() {
        return this.finalize(),
        this._$Eh && [...this._$Eh.keys()]
    }
    static createProperty(W, z=y$2) {
        if (z.state && (z.attribute = !1),
        this._$Ei(),
        this.elementProperties.set(W, z),
        !z.noAccessor) {
            const Y = Symbol()
              , ne = this.getPropertyDescriptor(W, Y, z);
            ne !== void 0 && e$7(this.prototype, W, ne)
        }
    }
    static getPropertyDescriptor(W, z, Y) {
        const {get: ne, set: le} = r$8(this.prototype, W) ?? {
            get() {
                return this[z]
            },
            set(ue) {
                this[z] = ue
            }
        };
        return {
            get() {
                return ne?.call(this)
            },
            set(ue) {
                const de = ne?.call(this);
                le.call(this, ue),
                this.requestUpdate(W, de, Y)
            },
            configurable: !0,
            enumerable: !0
        }
    }
    static getPropertyOptions(W) {
        return this.elementProperties.get(W) ?? y$2
    }
    static _$Ei() {
        if (this.hasOwnProperty(d$3("elementProperties")))
            return;
        const W = n$7(this);
        W.finalize(),
        W.l !== void 0 && (this.l = [...W.l]),
        this.elementProperties = new Map(W.elementProperties)
    }
    static finalize() {
        if (this.hasOwnProperty(d$3("finalized")))
            return;
        if (this.finalized = !0,
        this._$Ei(),
        this.hasOwnProperty(d$3("properties"))) {
            const z = this.properties
              , Y = [...h$6(z), ...o$8(z)];
            for (const ne of Y)
                this.createProperty(ne, z[ne])
        }
        const W = this[Symbol.metadata];
        if (W !== null) {
            const z = litPropertyMetadata.get(W);
            if (z !== void 0)
                for (const [Y,ne] of z)
                    this.elementProperties.set(Y, ne)
        }
        this._$Eh = new Map;
        for (const [z,Y] of this.elementProperties) {
            const ne = this._$Eu(z, Y);
            ne !== void 0 && this._$Eh.set(ne, z)
        }
        this.elementStyles = this.finalizeStyles(this.styles)
    }
    static finalizeStyles(W) {
        const z = [];
        if (Array.isArray(W)) {
            const Y = new Set(W.flat(1 / 0).reverse());
            for (const ne of Y)
                z.unshift(c$6(ne))
        } else
            W !== void 0 && z.push(c$6(W));
        return z
    }
    static _$Eu(W, z) {
        const Y = z.attribute;
        return Y === !1 ? void 0 : typeof Y == "string" ? Y : typeof W == "string" ? W.toLowerCase() : void 0
    }
    constructor() {
        super(),
        this._$Ep = void 0,
        this.isUpdatePending = !1,
        this.hasUpdated = !1,
        this._$Em = null,
        this._$Ev()
    }
    _$Ev() {
        this._$Eg = new Promise(W=>this.enableUpdating = W),
        this._$AL = new Map,
        this._$ES(),
        this.requestUpdate(),
        this.constructor.l?.forEach(W=>W(this))
    }
    addController(W) {
        (this._$E_ ??= new Set).add(W),
        this.renderRoot !== void 0 && this.isConnected && W.hostConnected?.()
    }
    removeController(W) {
        this._$E_?.delete(W)
    }
    _$ES() {
        const W = new Map
          , z = this.constructor.elementProperties;
        for (const Y of z.keys())
            this.hasOwnProperty(Y) && (W.set(Y, this[Y]),
            delete this[Y]);
        W.size > 0 && (this._$Ep = W)
    }
    createRenderRoot() {
        const W = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
        return S$4(W, this.constructor.elementStyles),
        W
    }
    connectedCallback() {
        this.renderRoot ??= this.createRenderRoot(),
        this.enableUpdating(!0),
        this._$E_?.forEach(W=>W.hostConnected?.())
    }
    enableUpdating(W) {}
    disconnectedCallback() {
        this._$E_?.forEach(W=>W.hostDisconnected?.())
    }
    attributeChangedCallback(W, z, Y) {
        this._$AK(W, Y)
    }
    _$EO(W, z) {
        const Y = this.constructor.elementProperties.get(W)
          , ne = this.constructor._$Eu(W, Y);
        if (ne !== void 0 && Y.reflect === !0) {
            const le = (Y.converter?.toAttribute !== void 0 ? Y.converter : u$3).toAttribute(z, Y.type);
            this._$Em = W,
            le == null ? this.removeAttribute(ne) : this.setAttribute(ne, le),
            this._$Em = null
        }
    }
    _$AK(W, z) {
        const Y = this.constructor
          , ne = Y._$Eh.get(W);
        if (ne !== void 0 && this._$Em !== ne) {
            const le = Y.getPropertyOptions(ne)
              , ue = typeof le.converter == "function" ? {
                fromAttribute: le.converter
            } : le.converter?.fromAttribute !== void 0 ? le.converter : u$3;
            this._$Em = ne,
            this[ne] = ue.fromAttribute(z, le.type),
            this._$Em = null
        }
    }
    requestUpdate(W, z, Y, ne=!1, le) {
        if (W !== void 0) {
            if (Y ??= this.constructor.getPropertyOptions(W),
            !(Y.hasChanged ?? f$5)(ne ? le : this[W], z))
                return;
            this.C(W, z, Y)
        }
        this.isUpdatePending === !1 && (this._$Eg = this._$EP())
    }
    C(W, z, Y) {
        this._$AL.has(W) || this._$AL.set(W, z),
        Y.reflect === !0 && this._$Em !== W && (this._$Ej ??= new Set).add(W)
    }
    async _$EP() {
        this.isUpdatePending = !0;
        try {
            await this._$Eg
        } catch (z) {
            Promise.reject(z)
        }
        const W = this.scheduleUpdate();
        return W != null && await W,
        !this.isUpdatePending
    }
    scheduleUpdate() {
        return this.performUpdate()
    }
    performUpdate() {
        if (!this.isUpdatePending)
            return;
        if (!this.hasUpdated) {
            if (this.renderRoot ??= this.createRenderRoot(),
            this._$Ep) {
                for (const [ne,le] of this._$Ep)
                    this[ne] = le;
                this._$Ep = void 0
            }
            const Y = this.constructor.elementProperties;
            if (Y.size > 0)
                for (const [ne,le] of Y)
                    le.wrapped !== !0 || this._$AL.has(ne) || this[ne] === void 0 || this.C(ne, this[ne], le)
        }
        let W = !1;
        const z = this._$AL;
        try {
            W = this.shouldUpdate(z),
            W ? (this.willUpdate(z),
            this._$E_?.forEach(Y=>Y.hostUpdate?.()),
            this.update(z)) : this._$ET()
        } catch (Y) {
            throw W = !1,
            this._$ET(),
            Y
        }
        W && this._$AE(z)
    }
    willUpdate(W) {}
    _$AE(W) {
        this._$E_?.forEach(z=>z.hostUpdated?.()),
        this.hasUpdated || (this.hasUpdated = !0,
        this.firstUpdated(W)),
        this.updated(W)
    }
    _$ET() {
        this._$AL = new Map,
        this.isUpdatePending = !1
    }
    get updateComplete() {
        return this.getUpdateComplete()
    }
    getUpdateComplete() {
        return this._$Eg
    }
    shouldUpdate(W) {
        return !0
    }
    update(W) {
        this._$Ej &&= this._$Ej.forEach(z=>this._$EO(z, this[z])),
        this._$ET()
    }
    updated(W) {}
    firstUpdated(W) {}
}
;
b$2.elementStyles = [],
b$2.shadowRootOptions = {
    mode: "open"
},
b$2[d$3("elementProperties")] = new Map,
b$2[d$3("finalized")] = new Map,
p$4?.({
    ReactiveElement: b$2
}),
(a$3.reactiveElementVersions ??= []).push("2.0.2");
const t$4 = globalThis
  , i$5 = t$4.trustedTypes
  , s$4 = i$5 ? i$5.createPolicy("lit-html", {
    createHTML: W=>W
}) : void 0
  , e$6 = "$lit$"
  , h$5 = `lit$${(Math.random() + "").slice(9)}$`
  , o$7 = "?" + h$5
  , n$6 = `<${o$7}>`
  , r$7 = document
  , l$2 = ()=>r$7.createComment("")
  , c$4 = W=>W === null || typeof W != "object" && typeof W != "function"
  , a$2 = Array.isArray
  , u$2 = W=>a$2(W) || typeof W?.[Symbol.iterator] == "function"
  , d$2 = `[ 	
\f\r]`
  , f$4 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g
  , v$1 = /-->/g
  , _$2 = />/g
  , m$2 = RegExp(`>|${d$2}(?:([^\\s"'>=/]+)(${d$2}*=${d$2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g")
  , p$3 = /'/g
  , g$1 = /"/g
  , $$2 = /^(?:script|style|textarea|title)$/i
  , w$2 = Symbol.for("lit-noChange")
  , T$1 = Symbol.for("lit-nothing")
  , A$2 = new WeakMap
  , E$1 = r$7.createTreeWalker(r$7, 129);
function C$1(W, z) {
    if (!Array.isArray(W) || !W.hasOwnProperty("raw"))
        throw Error("invalid template strings array");
    return s$4 !== void 0 ? s$4.createHTML(z) : z
}
const P$1 = (W,z)=>{
    const Y = W.length - 1
      , ne = [];
    let le, ue = z === 2 ? "<svg>" : "", de = f$4;
    for (let he = 0; he < Y; he++) {
        const fe = W[he];
        let ge, xe, $e = -1, Ee = 0;
        for (; Ee < fe.length && (de.lastIndex = Ee,
        xe = de.exec(fe),
        xe !== null); )
            Ee = de.lastIndex,
            de === f$4 ? xe[1] === "!--" ? de = v$1 : xe[1] !== void 0 ? de = _$2 : xe[2] !== void 0 ? ($$2.test(xe[2]) && (le = RegExp("</" + xe[2], "g")),
            de = m$2) : xe[3] !== void 0 && (de = m$2) : de === m$2 ? xe[0] === ">" ? (de = le ?? f$4,
            $e = -1) : xe[1] === void 0 ? $e = -2 : ($e = de.lastIndex - xe[2].length,
            ge = xe[1],
            de = xe[3] === void 0 ? m$2 : xe[3] === '"' ? g$1 : p$3) : de === g$1 || de === p$3 ? de = m$2 : de === v$1 || de === _$2 ? de = f$4 : (de = m$2,
            le = void 0);
        const Se = de === m$2 && W[he + 1].startsWith("/>") ? " " : "";
        ue += de === f$4 ? fe + n$6 : $e >= 0 ? (ne.push(ge),
        fe.slice(0, $e) + e$6 + fe.slice($e) + h$5 + Se) : fe + h$5 + ($e === -2 ? he : Se)
    }
    return [C$1(W, ue + (W[Y] || "<?>") + (z === 2 ? "</svg>" : "")), ne]
}
;
let V$1 = class Hh {
    constructor({strings: z, _$litType$: Y}, ne) {
        let le;
        this.parts = [];
        let ue = 0
          , de = 0;
        const he = z.length - 1
          , fe = this.parts
          , [ge,xe] = P$1(z, Y);
        if (this.el = Hh.createElement(ge, ne),
        E$1.currentNode = this.el.content,
        Y === 2) {
            const $e = this.el.content.firstChild;
            $e.replaceWith(...$e.childNodes)
        }
        for (; (le = E$1.nextNode()) !== null && fe.length < he; ) {
            if (le.nodeType === 1) {
                if (le.hasAttributes())
                    for (const $e of le.getAttributeNames())
                        if ($e.endsWith(e$6)) {
                            const Ee = xe[de++]
                              , Se = le.getAttribute($e).split(h$5)
                              , Ne = /([.?@])?(.*)/.exec(Ee);
                            fe.push({
                                type: 1,
                                index: ue,
                                name: Ne[2],
                                strings: Se,
                                ctor: Ne[1] === "." ? k$2 : Ne[1] === "?" ? H$1 : Ne[1] === "@" ? I$1 : R$2
                            }),
                            le.removeAttribute($e)
                        } else
                            $e.startsWith(h$5) && (fe.push({
                                type: 6,
                                index: ue
                            }),
                            le.removeAttribute($e));
                if ($$2.test(le.tagName)) {
                    const $e = le.textContent.split(h$5)
                      , Ee = $e.length - 1;
                    if (Ee > 0) {
                        le.textContent = i$5 ? i$5.emptyScript : "";
                        for (let Se = 0; Se < Ee; Se++)
                            le.append($e[Se], l$2()),
                            E$1.nextNode(),
                            fe.push({
                                type: 2,
                                index: ++ue
                            });
                        le.append($e[Ee], l$2())
                    }
                }
            } else if (le.nodeType === 8)
                if (le.data === o$7)
                    fe.push({
                        type: 2,
                        index: ue
                    });
                else {
                    let $e = -1;
                    for (; ($e = le.data.indexOf(h$5, $e + 1)) !== -1; )
                        fe.push({
                            type: 7,
                            index: ue
                        }),
                        $e += h$5.length - 1
                }
            ue++
        }
    }
    static createElement(z, Y) {
        const ne = r$7.createElement("template");
        return ne.innerHTML = z,
        ne
    }
}
;
function N$2(W, z, Y=W, ne) {
    if (z === w$2)
        return z;
    let le = ne !== void 0 ? Y._$Co?.[ne] : Y._$Cl;
    const ue = c$4(z) ? void 0 : z._$litDirective$;
    return le?.constructor !== ue && (le?._$AO?.(!1),
    ue === void 0 ? le = void 0 : (le = new ue(W),
    le._$AT(W, Y, ne)),
    ne !== void 0 ? (Y._$Co ??= [])[ne] = le : Y._$Cl = le),
    le !== void 0 && (z = N$2(W, le._$AS(W, z.values), le, ne)),
    z
}
let S$3 = class {
    constructor(W, z) {
        this._$AV = [],
        this._$AN = void 0,
        this._$AD = W,
        this._$AM = z
    }
    get parentNode() {
        return this._$AM.parentNode
    }
    get _$AU() {
        return this._$AM._$AU
    }
    u(W) {
        const {el: {content: z}, parts: Y} = this._$AD
          , ne = (W?.creationScope ?? r$7).importNode(z, !0);
        E$1.currentNode = ne;
        let le = E$1.nextNode()
          , ue = 0
          , de = 0
          , he = Y[0];
        for (; he !== void 0; ) {
            if (ue === he.index) {
                let fe;
                he.type === 2 ? fe = new M$2(le,le.nextSibling,this,W) : he.type === 1 ? fe = new he.ctor(le,he.name,he.strings,this,W) : he.type === 6 && (fe = new L$1(le,this,W)),
                this._$AV.push(fe),
                he = Y[++de]
            }
            ue !== he?.index && (le = E$1.nextNode(),
            ue++)
        }
        return E$1.currentNode = r$7,
        ne
    }
    p(W) {
        let z = 0;
        for (const Y of this._$AV)
            Y !== void 0 && (Y.strings !== void 0 ? (Y._$AI(W, Y, z),
            z += Y.strings.length - 2) : Y._$AI(W[z])),
            z++
    }
}
  , M$2 = class Fh {
    get _$AU() {
        return this._$AM?._$AU ?? this._$Cv
    }
    constructor(z, Y, ne, le) {
        this.type = 2,
        this._$AH = T$1,
        this._$AN = void 0,
        this._$AA = z,
        this._$AB = Y,
        this._$AM = ne,
        this.options = le,
        this._$Cv = le?.isConnected ?? !0
    }
    get parentNode() {
        let z = this._$AA.parentNode;
        const Y = this._$AM;
        return Y !== void 0 && z?.nodeType === 11 && (z = Y.parentNode),
        z
    }
    get startNode() {
        return this._$AA
    }
    get endNode() {
        return this._$AB
    }
    _$AI(z, Y=this) {
        z = N$2(this, z, Y),
        c$4(z) ? z === T$1 || z == null || z === "" ? (this._$AH !== T$1 && this._$AR(),
        this._$AH = T$1) : z !== this._$AH && z !== w$2 && this._(z) : z._$litType$ !== void 0 ? this.g(z) : z.nodeType !== void 0 ? this.$(z) : u$2(z) ? this.T(z) : this._(z)
    }
    k(z) {
        return this._$AA.parentNode.insertBefore(z, this._$AB)
    }
    $(z) {
        this._$AH !== z && (this._$AR(),
        this._$AH = this.k(z))
    }
    _(z) {
        this._$AH !== T$1 && c$4(this._$AH) ? this._$AA.nextSibling.data = z : this.$(r$7.createTextNode(z)),
        this._$AH = z
    }
    g(z) {
        const {values: Y, _$litType$: ne} = z
          , le = typeof ne == "number" ? this._$AC(z) : (ne.el === void 0 && (ne.el = V$1.createElement(C$1(ne.h, ne.h[0]), this.options)),
        ne);
        if (this._$AH?._$AD === le)
            this._$AH.p(Y);
        else {
            const ue = new S$3(le,this)
              , de = ue.u(this.options);
            ue.p(Y),
            this.$(de),
            this._$AH = ue
        }
    }
    _$AC(z) {
        let Y = A$2.get(z.strings);
        return Y === void 0 && A$2.set(z.strings, Y = new V$1(z)),
        Y
    }
    T(z) {
        a$2(this._$AH) || (this._$AH = [],
        this._$AR());
        const Y = this._$AH;
        let ne, le = 0;
        for (const ue of z)
            le === Y.length ? Y.push(ne = new Fh(this.k(l$2()),this.k(l$2()),this,this.options)) : ne = Y[le],
            ne._$AI(ue),
            le++;
        le < Y.length && (this._$AR(ne && ne._$AB.nextSibling, le),
        Y.length = le)
    }
    _$AR(z=this._$AA.nextSibling, Y) {
        for (this._$AP?.(!1, !0, Y); z && z !== this._$AB; ) {
            const ne = z.nextSibling;
            z.remove(),
            z = ne
        }
    }
    setConnected(z) {
        this._$AM === void 0 && (this._$Cv = z,
        this._$AP?.(z))
    }
}
  , R$2 = class {
    get tagName() {
        return this.element.tagName
    }
    get _$AU() {
        return this._$AM._$AU
    }
    constructor(W, z, Y, ne, le) {
        this.type = 1,
        this._$AH = T$1,
        this._$AN = void 0,
        this.element = W,
        this.name = z,
        this._$AM = ne,
        this.options = le,
        Y.length > 2 || Y[0] !== "" || Y[1] !== "" ? (this._$AH = Array(Y.length - 1).fill(new String),
        this.strings = Y) : this._$AH = T$1
    }
    _$AI(W, z=this, Y, ne) {
        const le = this.strings;
        let ue = !1;
        if (le === void 0)
            W = N$2(this, W, z, 0),
            ue = !c$4(W) || W !== this._$AH && W !== w$2,
            ue && (this._$AH = W);
        else {
            const de = W;
            let he, fe;
            for (W = le[0],
            he = 0; he < le.length - 1; he++)
                fe = N$2(this, de[Y + he], z, he),
                fe === w$2 && (fe = this._$AH[he]),
                ue ||= !c$4(fe) || fe !== this._$AH[he],
                fe === T$1 ? W = T$1 : W !== T$1 && (W += (fe ?? "") + le[he + 1]),
                this._$AH[he] = fe
        }
        ue && !ne && this.O(W)
    }
    O(W) {
        W === T$1 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, W ?? "")
    }
}
  , k$2 = class extends R$2 {
    constructor() {
        super(...arguments),
        this.type = 3
    }
    O(W) {
        this.element[this.name] = W === T$1 ? void 0 : W
    }
}
  , H$1 = class extends R$2 {
    constructor() {
        super(...arguments),
        this.type = 4
    }
    O(W) {
        this.element.toggleAttribute(this.name, !!W && W !== T$1)
    }
}
  , I$1 = class extends R$2 {
    constructor(W, z, Y, ne, le) {
        super(W, z, Y, ne, le),
        this.type = 5
    }
    _$AI(W, z=this) {
        if ((W = N$2(this, W, z, 0) ?? T$1) === w$2)
            return;
        const Y = this._$AH
          , ne = W === T$1 && Y !== T$1 || W.capture !== Y.capture || W.once !== Y.once || W.passive !== Y.passive
          , le = W !== T$1 && (Y === T$1 || ne);
        ne && this.element.removeEventListener(this.name, this, Y),
        le && this.element.addEventListener(this.name, this, W),
        this._$AH = W
    }
    handleEvent(W) {
        typeof this._$AH == "function" ? this._$AH.call(this.options?.host ?? this.element, W) : this._$AH.handleEvent(W)
    }
}
  , L$1 = class {
    constructor(W, z, Y) {
        this.element = W,
        this.type = 6,
        this._$AN = void 0,
        this._$AM = z,
        this.options = Y
    }
    get _$AU() {
        return this._$AM._$AU
    }
    _$AI(W) {
        N$2(this, W)
    }
}
;
const Z$2 = t$4.litHtmlPolyfillSupport;
Z$2?.(V$1, M$2),
(t$4.litHtmlVersions ??= []).push("3.1.0");
const t$3 = globalThis
  , e$5 = t$3.ShadowRoot && (t$3.ShadyCSS === void 0 || t$3.ShadyCSS.nativeShadow) && "adoptedStyleSheets"in Document.prototype && "replace"in CSSStyleSheet.prototype
  , s$3 = Symbol()
  , o$6 = new WeakMap;
let n$5 = class {
    constructor(W, z, Y) {
        if (this._$cssResult$ = !0,
        Y !== s$3)
            throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = W,
        this.t = z
    }
    get styleSheet() {
        let W = this.o;
        const z = this.t;
        if (e$5 && W === void 0) {
            const Y = z !== void 0 && z.length === 1;
            Y && (W = o$6.get(z)),
            W === void 0 && ((this.o = W = new CSSStyleSheet).replaceSync(this.cssText),
            Y && o$6.set(z, W))
        }
        return W
    }
    toString() {
        return this.cssText
    }
}
;
const r$6 = W=>new n$5(typeof W == "string" ? W : W + "",void 0,s$3)
  , i$4 = (W,...z)=>{
    const Y = W.length === 1 ? W[0] : z.reduce((ne,le,ue)=>ne + (de=>{
        if (de._$cssResult$ === !0)
            return de.cssText;
        if (typeof de == "number")
            return de;
        throw Error("Value passed to 'css' function must be a 'css' function result: " + de + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")
    }
    )(le) + W[ue + 1], W[0]);
    return new n$5(Y,W,s$3)
}
  , S$2 = (W,z)=>{
    if (e$5)
        W.adoptedStyleSheets = z.map(Y=>Y instanceof CSSStyleSheet ? Y : Y.styleSheet);
    else
        for (const Y of z) {
            const ne = document.createElement("style")
              , le = t$3.litNonce;
            le !== void 0 && ne.setAttribute("nonce", le),
            ne.textContent = Y.cssText,
            W.appendChild(ne)
        }
}
  , c$3 = e$5 ? W=>W : W=>W instanceof CSSStyleSheet ? (z=>{
    let Y = "";
    for (const ne of z.cssRules)
        Y += ne.cssText;
    return r$6(Y)
}
)(W) : W
  , {is: i$3, defineProperty: e$4, getOwnPropertyDescriptor: r$5, getOwnPropertyNames: h$4, getOwnPropertySymbols: o$5, getPrototypeOf: n$4} = Object
  , a$1 = globalThis
  , c$2 = a$1.trustedTypes
  , l$1 = c$2 ? c$2.emptyScript : ""
  , p$2 = a$1.reactiveElementPolyfillSupport
  , d$1 = (W,z)=>W
  , u$1 = {
    toAttribute(W, z) {
        switch (z) {
        case Boolean:
            W = W ? l$1 : null;
            break;
        case Object:
        case Array:
            W = W == null ? W : JSON.stringify(W)
        }
        return W
    },
    fromAttribute(W, z) {
        let Y = W;
        switch (z) {
        case Boolean:
            Y = W !== null;
            break;
        case Number:
            Y = W === null ? null : Number(W);
            break;
        case Object:
        case Array:
            try {
                Y = JSON.parse(W)
            } catch {
                Y = null
            }
        }
        return Y
    }
}
  , f$3 = (W,z)=>!i$3(W, z)
  , y$1 = {
    attribute: !0,
    type: String,
    converter: u$1,
    reflect: !1,
    hasChanged: f$3
};
Symbol.metadata ??= Symbol("metadata"),
a$1.litPropertyMetadata ??= new WeakMap;
let b$1 = class extends HTMLElement {
    static addInitializer(W) {
        this._$Ei(),
        (this.l ??= []).push(W)
    }
    static get observedAttributes() {
        return this.finalize(),
        this._$Eh && [...this._$Eh.keys()]
    }
    static createProperty(W, z=y$1) {
        if (z.state && (z.attribute = !1),
        this._$Ei(),
        this.elementProperties.set(W, z),
        !z.noAccessor) {
            const Y = Symbol()
              , ne = this.getPropertyDescriptor(W, Y, z);
            ne !== void 0 && e$4(this.prototype, W, ne)
        }
    }
    static getPropertyDescriptor(W, z, Y) {
        const {get: ne, set: le} = r$5(this.prototype, W) ?? {
            get() {
                return this[z]
            },
            set(ue) {
                this[z] = ue
            }
        };
        return {
            get() {
                return ne?.call(this)
            },
            set(ue) {
                const de = ne?.call(this);
                le.call(this, ue),
                this.requestUpdate(W, de, Y)
            },
            configurable: !0,
            enumerable: !0
        }
    }
    static getPropertyOptions(W) {
        return this.elementProperties.get(W) ?? y$1
    }
    static _$Ei() {
        if (this.hasOwnProperty(d$1("elementProperties")))
            return;
        const W = n$4(this);
        W.finalize(),
        W.l !== void 0 && (this.l = [...W.l]),
        this.elementProperties = new Map(W.elementProperties)
    }
    static finalize() {
        if (this.hasOwnProperty(d$1("finalized")))
            return;
        if (this.finalized = !0,
        this._$Ei(),
        this.hasOwnProperty(d$1("properties"))) {
            const z = this.properties
              , Y = [...h$4(z), ...o$5(z)];
            for (const ne of Y)
                this.createProperty(ne, z[ne])
        }
        const W = this[Symbol.metadata];
        if (W !== null) {
            const z = litPropertyMetadata.get(W);
            if (z !== void 0)
                for (const [Y,ne] of z)
                    this.elementProperties.set(Y, ne)
        }
        this._$Eh = new Map;
        for (const [z,Y] of this.elementProperties) {
            const ne = this._$Eu(z, Y);
            ne !== void 0 && this._$Eh.set(ne, z)
        }
        this.elementStyles = this.finalizeStyles(this.styles)
    }
    static finalizeStyles(W) {
        const z = [];
        if (Array.isArray(W)) {
            const Y = new Set(W.flat(1 / 0).reverse());
            for (const ne of Y)
                z.unshift(c$3(ne))
        } else
            W !== void 0 && z.push(c$3(W));
        return z
    }
    static _$Eu(W, z) {
        const Y = z.attribute;
        return Y === !1 ? void 0 : typeof Y == "string" ? Y : typeof W == "string" ? W.toLowerCase() : void 0
    }
    constructor() {
        super(),
        this._$Ep = void 0,
        this.isUpdatePending = !1,
        this.hasUpdated = !1,
        this._$Em = null,
        this._$Ev()
    }
    _$Ev() {
        this._$Eg = new Promise(W=>this.enableUpdating = W),
        this._$AL = new Map,
        this._$ES(),
        this.requestUpdate(),
        this.constructor.l?.forEach(W=>W(this))
    }
    addController(W) {
        (this._$E_ ??= new Set).add(W),
        this.renderRoot !== void 0 && this.isConnected && W.hostConnected?.()
    }
    removeController(W) {
        this._$E_?.delete(W)
    }
    _$ES() {
        const W = new Map
          , z = this.constructor.elementProperties;
        for (const Y of z.keys())
            this.hasOwnProperty(Y) && (W.set(Y, this[Y]),
            delete this[Y]);
        W.size > 0 && (this._$Ep = W)
    }
    createRenderRoot() {
        const W = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
        return S$2(W, this.constructor.elementStyles),
        W
    }
    connectedCallback() {
        this.renderRoot ??= this.createRenderRoot(),
        this.enableUpdating(!0),
        this._$E_?.forEach(W=>W.hostConnected?.())
    }
    enableUpdating(W) {}
    disconnectedCallback() {
        this._$E_?.forEach(W=>W.hostDisconnected?.())
    }
    attributeChangedCallback(W, z, Y) {
        this._$AK(W, Y)
    }
    _$EO(W, z) {
        const Y = this.constructor.elementProperties.get(W)
          , ne = this.constructor._$Eu(W, Y);
        if (ne !== void 0 && Y.reflect === !0) {
            const le = (Y.converter?.toAttribute !== void 0 ? Y.converter : u$1).toAttribute(z, Y.type);
            this._$Em = W,
            le == null ? this.removeAttribute(ne) : this.setAttribute(ne, le),
            this._$Em = null
        }
    }
    _$AK(W, z) {
        const Y = this.constructor
          , ne = Y._$Eh.get(W);
        if (ne !== void 0 && this._$Em !== ne) {
            const le = Y.getPropertyOptions(ne)
              , ue = typeof le.converter == "function" ? {
                fromAttribute: le.converter
            } : le.converter?.fromAttribute !== void 0 ? le.converter : u$1;
            this._$Em = ne,
            this[ne] = ue.fromAttribute(z, le.type),
            this._$Em = null
        }
    }
    requestUpdate(W, z, Y, ne=!1, le) {
        if (W !== void 0) {
            if (Y ??= this.constructor.getPropertyOptions(W),
            !(Y.hasChanged ?? f$3)(ne ? le : this[W], z))
                return;
            this.C(W, z, Y)
        }
        this.isUpdatePending === !1 && (this._$Eg = this._$EP())
    }
    C(W, z, Y) {
        this._$AL.has(W) || this._$AL.set(W, z),
        Y.reflect === !0 && this._$Em !== W && (this._$Ej ??= new Set).add(W)
    }
    async _$EP() {
        this.isUpdatePending = !0;
        try {
            await this._$Eg
        } catch (z) {
            Promise.reject(z)
        }
        const W = this.scheduleUpdate();
        return W != null && await W,
        !this.isUpdatePending
    }
    scheduleUpdate() {
        return this.performUpdate()
    }
    performUpdate() {
        if (!this.isUpdatePending)
            return;
        if (!this.hasUpdated) {
            if (this.renderRoot ??= this.createRenderRoot(),
            this._$Ep) {
                for (const [ne,le] of this._$Ep)
                    this[ne] = le;
                this._$Ep = void 0
            }
            const Y = this.constructor.elementProperties;
            if (Y.size > 0)
                for (const [ne,le] of Y)
                    le.wrapped !== !0 || this._$AL.has(ne) || this[ne] === void 0 || this.C(ne, this[ne], le)
        }
        let W = !1;
        const z = this._$AL;
        try {
            W = this.shouldUpdate(z),
            W ? (this.willUpdate(z),
            this._$E_?.forEach(Y=>Y.hostUpdate?.()),
            this.update(z)) : this._$ET()
        } catch (Y) {
            throw W = !1,
            this._$ET(),
            Y
        }
        W && this._$AE(z)
    }
    willUpdate(W) {}
    _$AE(W) {
        this._$E_?.forEach(z=>z.hostUpdated?.()),
        this.hasUpdated || (this.hasUpdated = !0,
        this.firstUpdated(W)),
        this.updated(W)
    }
    _$ET() {
        this._$AL = new Map,
        this.isUpdatePending = !1
    }
    get updateComplete() {
        return this.getUpdateComplete()
    }
    getUpdateComplete() {
        return this._$Eg
    }
    shouldUpdate(W) {
        return !0
    }
    update(W) {
        this._$Ej &&= this._$Ej.forEach(z=>this._$EO(z, this[z])),
        this._$ET()
    }
    updated(W) {}
    firstUpdated(W) {}
}
;
b$1.elementStyles = [],
b$1.shadowRootOptions = {
    mode: "open"
},
b$1[d$1("elementProperties")] = new Map,
b$1[d$1("finalized")] = new Map,
p$2?.({
    ReactiveElement: b$1
}),
(a$1.reactiveElementVersions ??= []).push("2.0.2");
const t$2 = globalThis
  , i$2 = t$2.trustedTypes
  , s$2 = i$2 ? i$2.createPolicy("lit-html", {
    createHTML: W=>W
}) : void 0
  , e$3 = "$lit$"
  , h$3 = `lit$${(Math.random() + "").slice(9)}$`
  , o$4 = "?" + h$3
  , n$3 = `<${o$4}>`
  , r$4 = document
  , l = ()=>r$4.createComment("")
  , c$1 = W=>W === null || typeof W != "object" && typeof W != "function"
  , a = Array.isArray
  , u = W=>a(W) || typeof W?.[Symbol.iterator] == "function"
  , d = `[ 	
\f\r]`
  , f$2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g
  , v = /-->/g
  , _$1 = />/g
  , m$1 = RegExp(`>|${d}(?:([^\\s"'>=/]+)(${d}*=${d}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g")
  , p$1 = /'/g
  , g = /"/g
  , $$1 = /^(?:script|style|textarea|title)$/i
  , y = W=>(z,...Y)=>({
    _$litType$: W,
    strings: z,
    values: Y
})
  , x$1 = y(1)
  , b = y(2)
  , w$1 = Symbol.for("lit-noChange")
  , T = Symbol.for("lit-nothing")
  , A$1 = new WeakMap
  , E = r$4.createTreeWalker(r$4, 129);
function C(W, z) {
    if (!Array.isArray(W) || !W.hasOwnProperty("raw"))
        throw Error("invalid template strings array");
    return s$2 !== void 0 ? s$2.createHTML(z) : z
}
const P = (W,z)=>{
    const Y = W.length - 1
      , ne = [];
    let le, ue = z === 2 ? "<svg>" : "", de = f$2;
    for (let he = 0; he < Y; he++) {
        const fe = W[he];
        let ge, xe, $e = -1, Ee = 0;
        for (; Ee < fe.length && (de.lastIndex = Ee,
        xe = de.exec(fe),
        xe !== null); )
            Ee = de.lastIndex,
            de === f$2 ? xe[1] === "!--" ? de = v : xe[1] !== void 0 ? de = _$1 : xe[2] !== void 0 ? ($$1.test(xe[2]) && (le = RegExp("</" + xe[2], "g")),
            de = m$1) : xe[3] !== void 0 && (de = m$1) : de === m$1 ? xe[0] === ">" ? (de = le ?? f$2,
            $e = -1) : xe[1] === void 0 ? $e = -2 : ($e = de.lastIndex - xe[2].length,
            ge = xe[1],
            de = xe[3] === void 0 ? m$1 : xe[3] === '"' ? g : p$1) : de === g || de === p$1 ? de = m$1 : de === v || de === _$1 ? de = f$2 : (de = m$1,
            le = void 0);
        const Se = de === m$1 && W[he + 1].startsWith("/>") ? " " : "";
        ue += de === f$2 ? fe + n$3 : $e >= 0 ? (ne.push(ge),
        fe.slice(0, $e) + e$3 + fe.slice($e) + h$3 + Se) : fe + h$3 + ($e === -2 ? he : Se)
    }
    return [C(W, ue + (W[Y] || "<?>") + (z === 2 ? "</svg>" : "")), ne]
}
;
class V {
    constructor({strings: z, _$litType$: Y}, ne) {
        let le;
        this.parts = [];
        let ue = 0
          , de = 0;
        const he = z.length - 1
          , fe = this.parts
          , [ge,xe] = P(z, Y);
        if (this.el = V.createElement(ge, ne),
        E.currentNode = this.el.content,
        Y === 2) {
            const $e = this.el.content.firstChild;
            $e.replaceWith(...$e.childNodes)
        }
        for (; (le = E.nextNode()) !== null && fe.length < he; ) {
            if (le.nodeType === 1) {
                if (le.hasAttributes())
                    for (const $e of le.getAttributeNames())
                        if ($e.endsWith(e$3)) {
                            const Ee = xe[de++]
                              , Se = le.getAttribute($e).split(h$3)
                              , Ne = /([.?@])?(.*)/.exec(Ee);
                            fe.push({
                                type: 1,
                                index: ue,
                                name: Ne[2],
                                strings: Se,
                                ctor: Ne[1] === "." ? k$1 : Ne[1] === "?" ? H : Ne[1] === "@" ? I : R$1
                            }),
                            le.removeAttribute($e)
                        } else
                            $e.startsWith(h$3) && (fe.push({
                                type: 6,
                                index: ue
                            }),
                            le.removeAttribute($e));
                if ($$1.test(le.tagName)) {
                    const $e = le.textContent.split(h$3)
                      , Ee = $e.length - 1;
                    if (Ee > 0) {
                        le.textContent = i$2 ? i$2.emptyScript : "";
                        for (let Se = 0; Se < Ee; Se++)
                            le.append($e[Se], l()),
                            E.nextNode(),
                            fe.push({
                                type: 2,
                                index: ++ue
                            });
                        le.append($e[Ee], l())
                    }
                }
            } else if (le.nodeType === 8)
                if (le.data === o$4)
                    fe.push({
                        type: 2,
                        index: ue
                    });
                else {
                    let $e = -1;
                    for (; ($e = le.data.indexOf(h$3, $e + 1)) !== -1; )
                        fe.push({
                            type: 7,
                            index: ue
                        }),
                        $e += h$3.length - 1
                }
            ue++
        }
    }
    static createElement(z, Y) {
        const ne = r$4.createElement("template");
        return ne.innerHTML = z,
        ne
    }
}
function N$1(W, z, Y=W, ne) {
    if (z === w$1)
        return z;
    let le = ne !== void 0 ? Y._$Co?.[ne] : Y._$Cl;
    const ue = c$1(z) ? void 0 : z._$litDirective$;
    return le?.constructor !== ue && (le?._$AO?.(!1),
    ue === void 0 ? le = void 0 : (le = new ue(W),
    le._$AT(W, Y, ne)),
    ne !== void 0 ? (Y._$Co ??= [])[ne] = le : Y._$Cl = le),
    le !== void 0 && (z = N$1(W, le._$AS(W, z.values), le, ne)),
    z
}
let S$1 = class {
    constructor(W, z) {
        this._$AV = [],
        this._$AN = void 0,
        this._$AD = W,
        this._$AM = z
    }
    get parentNode() {
        return this._$AM.parentNode
    }
    get _$AU() {
        return this._$AM._$AU
    }
    u(W) {
        const {el: {content: z}, parts: Y} = this._$AD
          , ne = (W?.creationScope ?? r$4).importNode(z, !0);
        E.currentNode = ne;
        let le = E.nextNode()
          , ue = 0
          , de = 0
          , he = Y[0];
        for (; he !== void 0; ) {
            if (ue === he.index) {
                let fe;
                he.type === 2 ? fe = new M$1(le,le.nextSibling,this,W) : he.type === 1 ? fe = new he.ctor(le,he.name,he.strings,this,W) : he.type === 6 && (fe = new L(le,this,W)),
                this._$AV.push(fe),
                he = Y[++de]
            }
            ue !== he?.index && (le = E.nextNode(),
            ue++)
        }
        return E.currentNode = r$4,
        ne
    }
    p(W) {
        let z = 0;
        for (const Y of this._$AV)
            Y !== void 0 && (Y.strings !== void 0 ? (Y._$AI(W, Y, z),
            z += Y.strings.length - 2) : Y._$AI(W[z])),
            z++
    }
}
  , M$1 = class zh {
    get _$AU() {
        return this._$AM?._$AU ?? this._$Cv
    }
    constructor(z, Y, ne, le) {
        this.type = 2,
        this._$AH = T,
        this._$AN = void 0,
        this._$AA = z,
        this._$AB = Y,
        this._$AM = ne,
        this.options = le,
        this._$Cv = le?.isConnected ?? !0
    }
    get parentNode() {
        let z = this._$AA.parentNode;
        const Y = this._$AM;
        return Y !== void 0 && z?.nodeType === 11 && (z = Y.parentNode),
        z
    }
    get startNode() {
        return this._$AA
    }
    get endNode() {
        return this._$AB
    }
    _$AI(z, Y=this) {
        z = N$1(this, z, Y),
        c$1(z) ? z === T || z == null || z === "" ? (this._$AH !== T && this._$AR(),
        this._$AH = T) : z !== this._$AH && z !== w$1 && this._(z) : z._$litType$ !== void 0 ? this.g(z) : z.nodeType !== void 0 ? this.$(z) : u(z) ? this.T(z) : this._(z)
    }
    k(z) {
        return this._$AA.parentNode.insertBefore(z, this._$AB)
    }
    $(z) {
        this._$AH !== z && (this._$AR(),
        this._$AH = this.k(z))
    }
    _(z) {
        this._$AH !== T && c$1(this._$AH) ? this._$AA.nextSibling.data = z : this.$(r$4.createTextNode(z)),
        this._$AH = z
    }
    g(z) {
        const {values: Y, _$litType$: ne} = z
          , le = typeof ne == "number" ? this._$AC(z) : (ne.el === void 0 && (ne.el = V.createElement(C(ne.h, ne.h[0]), this.options)),
        ne);
        if (this._$AH?._$AD === le)
            this._$AH.p(Y);
        else {
            const ue = new S$1(le,this)
              , de = ue.u(this.options);
            ue.p(Y),
            this.$(de),
            this._$AH = ue
        }
    }
    _$AC(z) {
        let Y = A$1.get(z.strings);
        return Y === void 0 && A$1.set(z.strings, Y = new V(z)),
        Y
    }
    T(z) {
        a(this._$AH) || (this._$AH = [],
        this._$AR());
        const Y = this._$AH;
        let ne, le = 0;
        for (const ue of z)
            le === Y.length ? Y.push(ne = new zh(this.k(l()),this.k(l()),this,this.options)) : ne = Y[le],
            ne._$AI(ue),
            le++;
        le < Y.length && (this._$AR(ne && ne._$AB.nextSibling, le),
        Y.length = le)
    }
    _$AR(z=this._$AA.nextSibling, Y) {
        for (this._$AP?.(!1, !0, Y); z && z !== this._$AB; ) {
            const ne = z.nextSibling;
            z.remove(),
            z = ne
        }
    }
    setConnected(z) {
        this._$AM === void 0 && (this._$Cv = z,
        this._$AP?.(z))
    }
}
  , R$1 = class {
    get tagName() {
        return this.element.tagName
    }
    get _$AU() {
        return this._$AM._$AU
    }
    constructor(W, z, Y, ne, le) {
        this.type = 1,
        this._$AH = T,
        this._$AN = void 0,
        this.element = W,
        this.name = z,
        this._$AM = ne,
        this.options = le,
        Y.length > 2 || Y[0] !== "" || Y[1] !== "" ? (this._$AH = Array(Y.length - 1).fill(new String),
        this.strings = Y) : this._$AH = T
    }
    _$AI(W, z=this, Y, ne) {
        const le = this.strings;
        let ue = !1;
        if (le === void 0)
            W = N$1(this, W, z, 0),
            ue = !c$1(W) || W !== this._$AH && W !== w$1,
            ue && (this._$AH = W);
        else {
            const de = W;
            let he, fe;
            for (W = le[0],
            he = 0; he < le.length - 1; he++)
                fe = N$1(this, de[Y + he], z, he),
                fe === w$1 && (fe = this._$AH[he]),
                ue ||= !c$1(fe) || fe !== this._$AH[he],
                fe === T ? W = T : W !== T && (W += (fe ?? "") + le[he + 1]),
                this._$AH[he] = fe
        }
        ue && !ne && this.O(W)
    }
    O(W) {
        W === T ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, W ?? "")
    }
}
  , k$1 = class extends R$1 {
    constructor() {
        super(...arguments),
        this.type = 3
    }
    O(W) {
        this.element[this.name] = W === T ? void 0 : W
    }
}
;
class H extends R$1 {
    constructor() {
        super(...arguments),
        this.type = 4
    }
    O(z) {
        this.element.toggleAttribute(this.name, !!z && z !== T)
    }
}
class I extends R$1 {
    constructor(z, Y, ne, le, ue) {
        super(z, Y, ne, le, ue),
        this.type = 5
    }
    _$AI(z, Y=this) {
        if ((z = N$1(this, z, Y, 0) ?? T) === w$1)
            return;
        const ne = this._$AH
          , le = z === T && ne !== T || z.capture !== ne.capture || z.once !== ne.once || z.passive !== ne.passive
          , ue = z !== T && (ne === T || le);
        le && this.element.removeEventListener(this.name, this, ne),
        ue && this.element.addEventListener(this.name, this, z),
        this._$AH = z
    }
    handleEvent(z) {
        typeof this._$AH == "function" ? this._$AH.call(this.options?.host ?? this.element, z) : this._$AH.handleEvent(z)
    }
}
class L {
    constructor(z, Y, ne) {
        this.element = z,
        this.type = 6,
        this._$AN = void 0,
        this._$AM = Y,
        this.options = ne
    }
    get _$AU() {
        return this._$AM._$AU
    }
    _$AI(z) {
        N$1(this, z)
    }
}
const Z$1 = t$2.litHtmlPolyfillSupport;
Z$1?.(V, M$1),
(t$2.litHtmlVersions ??= []).push("3.1.0");
const j$1 = (W,z,Y)=>{
    const ne = Y?.renderBefore ?? z;
    let le = ne._$litPart$;
    if (le === void 0) {
        const ue = Y?.renderBefore ?? null;
        ne._$litPart$ = le = new M$1(z.insertBefore(l(), ue),ue,void 0,Y ?? {})
    }
    return le._$AI(W),
    le
}
;
let s$1 = class extends b$1 {
    constructor() {
        super(...arguments),
        this.renderOptions = {
            host: this
        },
        this._$Do = void 0
    }
    createRenderRoot() {
        const W = super.createRenderRoot();
        return this.renderOptions.renderBefore ??= W.firstChild,
        W
    }
    update(W) {
        const z = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected),
        super.update(W),
        this._$Do = j$1(z, this.renderRoot, this.renderOptions)
    }
    connectedCallback() {
        super.connectedCallback(),
        this._$Do?.setConnected(!0)
    }
    disconnectedCallback() {
        super.disconnectedCallback(),
        this._$Do?.setConnected(!1)
    }
    render() {
        return w$1
    }
}
;
s$1._$litElement$ = !0,
s$1.finalized = !0,
globalThis.litElementHydrateSupport?.({
    LitElement: s$1
});
const r$3 = globalThis.litElementPolyfillSupport;
let themeTag, darkModeTag, lightModeTag;
function initializeTheming(W, z) {
    themeTag = document.createElement("style"),
    darkModeTag = document.createElement("style"),
    lightModeTag = document.createElement("style"),
    themeTag.textContent = createRootStyles(W).core.cssText,
    darkModeTag.textContent = createRootStyles(W).dark.cssText,
    lightModeTag.textContent = createRootStyles(W).light.cssText,
    document.head.appendChild(themeTag),
    document.head.appendChild(darkModeTag),
    document.head.appendChild(lightModeTag),
    setColorTheme(z)
}
function setColorTheme(W) {
    darkModeTag && lightModeTag && (W === "light" ? (darkModeTag.removeAttribute("media"),
    lightModeTag.media = "enabled") : (lightModeTag.removeAttribute("media"),
    darkModeTag.media = "enabled"))
}
function setThemeVariables(W) {
    themeTag && darkModeTag && lightModeTag && (themeTag.textContent = createRootStyles(W).core.cssText,
    darkModeTag.textContent = createRootStyles(W).dark.cssText,
    lightModeTag.textContent = createRootStyles(W).light.cssText)
}
function createRootStyles(W) {
    return {
        core: i$4`
      :root {
        --w3m-color-mix-strength: ${r$6(W?.["--w3m-color-mix-strength"] ? `${W["--w3m-color-mix-strength"]}%` : "0%")};
        --w3m-font-family: ${r$6(W?.["--w3m-font-family"] || "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif")};
        --w3m-font-size-master: ${r$6(W?.["--w3m-font-size-master"] || "10px")};
        --w3m-border-radius-master: ${r$6(W?.["--w3m-border-radius-master"] || "4px")};
        --w3m-z-index: ${r$6(W?.["--w3m-z-index"] || 100)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-lg: 40px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(0, 0, 0, 0.3);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-blue-100: var(--wui-color-blue-base-100);
        --wui-color-blue-015: var(--wui-color-accent-base-015);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-accent-glass-090: var(--wui-accent-glass-base-090);
        --wui-accent-glass-080: var(--wui-accent-glass-base-080);
        --wui-accent-glass-020: var(--wui-accent-glass-base-020);
        --wui-accent-glass-015: var(--wui-accent-glass-base-015);
        --wui-accent-glass-010: var(--wui-accent-glass-base-010);
        --wui-accent-glass-005: var(--wui-accent-glass-base-005);
        --wui-accent-glass-002: var(--wui-accent-glass-base-002);

        --wui-color-fg-100: var(--wui-color-fg-base-100);
        --wui-color-fg-125: var(--wui-color-fg-base-125);
        --wui-color-fg-150: var(--wui-color-fg-base-150);
        --wui-color-fg-175: var(--wui-color-fg-base-175);
        --wui-color-fg-200: var(--wui-color-fg-base-200);
        --wui-color-fg-225: var(--wui-color-fg-base-225);
        --wui-color-fg-250: var(--wui-color-fg-base-250);
        --wui-color-fg-275: var(--wui-color-fg-base-275);
        --wui-color-fg-300: var(--wui-color-fg-base-300);

        --wui-color-bg-100: var(--wui-color-bg-base-100);
        --wui-color-bg-125: var(--wui-color-bg-base-125);
        --wui-color-bg-150: var(--wui-color-bg-base-150);
        --wui-color-bg-175: var(--wui-color-bg-base-175);
        --wui-color-bg-200: var(--wui-color-bg-base-200);
        --wui-color-bg-225: var(--wui-color-bg-base-225);
        --wui-color-bg-250: var(--wui-color-bg-base-250);
        --wui-color-bg-275: var(--wui-color-bg-base-275);
        --wui-color-bg-300: var(--wui-color-bg-base-300);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-error-100: var(--wui-color-error-base-100);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-base-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-box-shadow-blue: rgba(71, 161, 255, 0.16);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 16%, transparent);

          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            var(--w3m-default)
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            var(--w3m-default)
          );

          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );

          --wui-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-300)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-300)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-base-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );
        }
      }
    `,
        light: i$4`
      :root {
        --w3m-color-mix: ${r$6(W?.["--w3m-color-mix"] || "#fff")};
        --w3m-accent: ${r$6(W?.["--w3m-accent"] || "#47a1ff")};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: #191a1a;

        --wui-color-blue-base-100: #47a1ff;

        --wui-color-accent-base-100: var(--w3m-accent);
        --wui-color-accent-base-090: #59aaff;
        --wui-color-accent-base-080: #6cb4ff;

        --wui-accent-glass-base-090: rgba(71, 161, 255, 0.9);
        --wui-accent-glass-base-080: rgba(71, 161, 255, 0.8);
        --wui-accent-glass-base-020: rgba(71, 161, 255, 0.2);
        --wui-accent-glass-base-015: rgba(71, 161, 255, 0.15);
        --wui-accent-glass-base-010: rgba(71, 161, 255, 0.1);
        --wui-accent-glass-base-005: rgba(71, 161, 255, 0.05);
        --wui-accent-glass-base-002: rgba(71, 161, 255, 0.02);

        --wui-color-fg-base-100: #e4e7e7;
        --wui-color-fg-base-125: #d0d5d5;
        --wui-color-fg-base-150: #a8b1b1;
        --wui-color-fg-base-175: #a8b0b0;
        --wui-color-fg-base-200: #949e9e;
        --wui-color-fg-base-225: #868f8f;
        --wui-color-fg-base-250: #788080;
        --wui-color-fg-base-275: #788181;
        --wui-color-fg-base-300: #6e7777;

        --wui-color-bg-base-100: #141414;
        --wui-color-bg-base-125: #191a1a;
        --wui-color-bg-base-150: #1e1f1f;
        --wui-color-bg-base-175: #222525;
        --wui-color-bg-base-200: #272a2a;
        --wui-color-bg-base-225: #2c3030;
        --wui-color-bg-base-250: #313535;
        --wui-color-bg-base-275: #363b3b;
        --wui-color-bg-base-300: #3b4040;

        --wui-color-success-base-100: #26d962;
        --wui-color-error-base-100: #f25a67;

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: #1f3a28;
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-base-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-gray-glass-080: rgba(255, 255, 255, 0.8);
      }
    `,
        dark: i$4`
      :root {
        --w3m-color-mix: ${r$6(W?.["--w3m-color-mix"] || "#000")};
        --w3m-accent: ${r$6(W?.["--w3m-accent"] || "#3396ff")};
        --w3m-default: #000;

        --wui-color-modal-bg-base: #fff;

        --wui-color-blue-base-100: #3396ff;

        --wui-color-accent-base-100: var(--w3m-accent);
        --wui-color-accent-base-090: #2d7dd2;
        --wui-color-accent-base-080: #2978cc;

        --wui-accent-glass-base-090: rgba(51, 150, 255, 0.9);
        --wui-accent-glass-base-080: rgba(51, 150, 255, 0.8);
        --wui-accent-glass-base-020: rgba(51, 150, 255, 0.2);
        --wui-accent-glass-base-015: rgba(51, 150, 255, 0.15);
        --wui-accent-glass-base-010: rgba(51, 150, 255, 0.1);
        --wui-accent-glass-base-005: rgba(51, 150, 255, 0.05);
        --wui-accent-glass-base-002: rgba(51, 150, 255, 0.02);

        --wui-color-fg-base-100: #141414;
        --wui-color-fg-base-125: #2d3131;
        --wui-color-fg-base-150: #474d4d;
        --wui-color-fg-base-175: #636d6d;
        --wui-color-fg-base-200: #798686;
        --wui-color-fg-base-225: #828f8f;
        --wui-color-fg-base-250: #8b9797;
        --wui-color-fg-base-275: #95a0a0;
        --wui-color-fg-base-300: #9ea9a9;

        --wui-color-bg-base-100: #ffffff;
        --wui-color-bg-base-125: #f5fafa;
        --wui-color-bg-base-150: #f3f8f8;
        --wui-color-bg-base-175: #eef4f4;
        --wui-color-bg-base-200: #eaf1f1;
        --wui-color-bg-base-225: #e5eded;
        --wui-color-bg-base-250: #e1e9e9;
        --wui-color-bg-base-275: #dce7e7;
        --wui-color-bg-base-300: #d8e3e3;

        --wui-color-success-base-100: #26b562;
        --wui-color-error-base-100: #f05142;

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-base-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-gray-glass-080: rgba(0, 0, 0, 0.8);
      }
    `
    }
}
r$3?.({
    LitElement: s$1
}),
(globalThis.litElementVersions ??= []).push("4.0.2");
const resetStyles = i$4`
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`
  , elementStyles = i$4`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
    outline: none;
    border: 1px solid transparent;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-gray-glass-005);
    }

    button:active:enabled {
      transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
      background-color: var(--wui-gray-glass-010);
    }

    button[data-variant='fill']:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='accentBg']:hover:enabled {
      background: var(--wui-accent-glass-015);
    }

    button[data-variant='accentBg']:active:enabled {
      background: var(--wui-accent-glass-020);
    }
  }

  button:disabled {
    cursor: not-allowed;
    background-color: var(--wui-gray-glass-005);
  }

  button[data-variant='shade']:disabled,
  button[data-variant='accent']:disabled,
  button[data-variant='accentBg']:disabled {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-gray-glass-015);
    filter: grayscale(1);
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-icon-box,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  button:focus-visible,
  a:focus-visible {
    border: 1px solid var(--wui-color-accent-100);
    background-color: var(--wui-gray-glass-005);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  button[data-variant='fill']:focus-visible {
    background-color: var(--wui-color-accent-090);
  }

  button[data-variant='fill'] {
    color: var(--wui-color-inverse-100);
    background-color: var(--wui-color-accent-100);
  }

  button[data-variant='fill']:disabled {
    color: var(--wui-gray-glass-015);
    background-color: var(--wui-gray-glass-015);
  }

  button[data-variant='fill']:disabled > wui-icon {
    color: var(--wui-gray-glass-015);
  }

  button[data-variant='shade'] {
    color: var(--wui-color-fg-200);
  }

  button[data-variant='accent'],
  button[data-variant='accentBg'] {
    color: var(--wui-color-accent-100);
  }

  button[data-variant='accentBg'] {
    background: var(--wui-accent-glass-010);
    border: 1px solid var(--wui-accent-glass-010);
  }

  button[data-variant='fullWidth'] {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    height: 56px;
    border: none;
    background-color: var(--wui-gray-glass-002);
    color: var(--wui-color-fg-200);
    gap: var(--wui-spacing-xs);
  }

  button:active:enabled {
    background-color: var(--wui-gray-glass-010);
  }

  button[data-variant='fill']:active:enabled {
    background-color: var(--wui-color-accent-080);
    border: 1px solid var(--wui-gray-glass-010);
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`
  , colorStyles = i$4`
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }
`;
function standardCustomElement(W, z) {
    const {kind: Y, elements: ne} = z;
    return {
        kind: Y,
        elements: ne,
        finisher(le) {
            customElements.get(W) || customElements.define(W, le)
        }
    }
}
function legacyCustomElement(W, z) {
    return customElements.get(W) || customElements.define(W, z),
    z
}
function customElement(W) {
    return function(z) {
        return typeof z == "function" ? legacyCustomElement(W, z) : standardCustomElement(W, z)
    }
}
const styles$Y = i$4`
  :host {
    display: block;
    border-radius: clamp(0px, var(--wui-border-radius-l), 44px);
    border: 1px solid var(--wui-gray-glass-005);
    background-color: var(--wui-color-modal-bg);
    overflow: hidden;
  }
`;
var __decorate$1h = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiCard = class extends s$1 {
    render() {
        return x$1`<slot></slot>`
    }
}
;
WuiCard.styles = [resetStyles, styles$Y],
WuiCard = __decorate$1h([customElement("wui-card")], WuiCard);
const o$3 = {
    attribute: !0,
    type: String,
    converter: u$3,
    reflect: !1,
    hasChanged: f$5
}
  , r$2 = (W=o$3,z,Y)=>{
    const {kind: ne, metadata: le} = Y;
    let ue = globalThis.litPropertyMetadata.get(le);
    if (ue === void 0 && globalThis.litPropertyMetadata.set(le, ue = new Map),
    ue.set(Y.name, W),
    ne === "accessor") {
        const {name: de} = Y;
        return {
            set(he) {
                const fe = z.get.call(this);
                z.set.call(this, he),
                this.requestUpdate(de, fe, W)
            },
            init(he) {
                return he !== void 0 && this.C(de, void 0, W),
                he
            }
        }
    }
    if (ne === "setter") {
        const {name: de} = Y;
        return function(he) {
            const fe = this[de];
            z.call(this, he),
            this.requestUpdate(de, fe, W)
        }
    }
    throw Error("Unsupported decorator location: " + ne)
}
;
function n$2(W) {
    return (z,Y)=>typeof Y == "object" ? r$2(W, z, Y) : ((ne,le,ue)=>{
        const de = le.hasOwnProperty(ue);
        return le.constructor.createProperty(ue, de ? {
            ...ne,
            wrapped: !0
        } : ne),
        de ? Object.getOwnPropertyDescriptor(le, ue) : void 0
    }
    )(W, z, Y)
}
function r$1(W) {
    return n$2({
        ...W,
        state: !0,
        attribute: !1
    })
}
const styles$X = i$4`
  :host {
    display: flex;
    aspect-ratio: 1 / 1;
    color: var(--local-color);
    width: var(--local-width);
  }

  svg {
    width: inherit;
    height: inherit;
    object-fit: contain;
    object-position: center;
  }
`
  , allWalletsSvg = b`<svg fill="none" viewBox="0 0 24 24">
  <path
    style="fill: var(--wui-color-accent-100);"
    d="M10.2 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM10.2 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0Z"
  />
</svg>`
  , appStoreSvg = b`
<svg width="36" height="36">
  <path
    d="M28.724 0H7.271A7.269 7.269 0 0 0 0 7.272v21.46A7.268 7.268 0 0 0 7.271 36H28.73A7.272 7.272 0 0 0 36 28.728V7.272A7.275 7.275 0 0 0 28.724 0Z"
    fill="url(#a)"
  />
  <path
    d="m17.845 8.271.729-1.26a1.64 1.64 0 1 1 2.843 1.638l-7.023 12.159h5.08c1.646 0 2.569 1.935 1.853 3.276H6.434a1.632 1.632 0 0 1-1.638-1.638c0-.909.73-1.638 1.638-1.638h4.176l5.345-9.265-1.67-2.898a1.642 1.642 0 0 1 2.844-1.638l.716 1.264Zm-6.317 17.5-1.575 2.732a1.64 1.64 0 1 1-2.844-1.638l1.17-2.025c1.323-.41 2.398-.095 3.249.931Zm13.56-4.954h4.262c.909 0 1.638.729 1.638 1.638 0 .909-.73 1.638-1.638 1.638h-2.367l1.597 2.772c.45.788.185 1.782-.602 2.241a1.642 1.642 0 0 1-2.241-.603c-2.69-4.666-4.711-8.159-6.052-10.485-1.372-2.367-.391-4.743.576-5.549 1.075 1.846 2.682 4.631 4.828 8.348Z"
    fill="#fff"
  />
  <defs>
    <linearGradient id="a" x1="18" y1="0" x2="18" y2="36" gradientUnits="userSpaceOnUse">
      <stop stop-color="#18BFFB" />
      <stop offset="1" stop-color="#2072F3" />
    </linearGradient>
  </defs>
</svg>`
  , appleSvg = b`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#000" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M28.77 23.3c-.69 1.99-2.75 5.52-4.87 5.56-1.4.03-1.86-.84-3.46-.84-1.61 0-2.12.81-3.45.86-2.25.1-5.72-5.1-5.72-9.62 0-4.15 2.9-6.2 5.42-6.25 1.36-.02 2.64.92 3.47.92.83 0 2.38-1.13 4.02-.97.68.03 2.6.28 3.84 2.08-3.27 2.14-2.76 6.61.75 8.25ZM24.2 7.88c-2.47.1-4.49 2.69-4.2 4.84 2.28.17 4.47-2.39 4.2-4.84Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`
  , arrowBottomSvg = b`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 1.99a1 1 0 0 1 1 1v7.58l2.46-2.46a1 1 0 0 1 1.41 1.42L7.7 13.69a1 1 0 0 1-1.41 0L2.12 9.53A1 1 0 0 1 3.54 8.1L6 10.57V3a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`
  , arrowLeftSvg = b`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13 7.99a1 1 0 0 1-1 1H4.4l2.46 2.46a1 1 0 1 1-1.41 1.41L1.29 8.7a1 1 0 0 1 0-1.41L5.46 3.1a1 1 0 0 1 1.41 1.42L4.41 6.99H12a1 1 0 0 1 1 1Z"
    clip-rule="evenodd"
  />
</svg>`
  , arrowRightSvg = b`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1 7.99a1 1 0 0 1 1-1h7.58L7.12 4.53A1 1 0 1 1 8.54 3.1l4.16 4.17a1 1 0 0 1 0 1.41l-4.16 4.17a1 1 0 1 1-1.42-1.41l2.46-2.46H2a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`
  , arrowTopSvg = b`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 13.99a1 1 0 0 1-1-1V5.4L3.54 7.86a1 1 0 0 1-1.42-1.41L6.3 2.28a1 1 0 0 1 1.41 0l4.17 4.17a1 1 0 1 1-1.41 1.41L8 5.4v7.59a1 1 0 0 1-1 1Z"
    clip-rule="evenodd"
  />
</svg>`
  , browserSvg$1 = b`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4 6.4a1 1 0 0 1-.46.89 6.98 6.98 0 0 0 .38 6.18A7 7 0 0 0 16.46 7.3a1 1 0 0 1-.47-.92 7 7 0 0 0-12 .03Zm-2.02-.5a9 9 0 1 1 16.03 8.2A9 9 0 0 1 1.98 5.9Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.03 8.63c-1.46-.3-2.72-.75-3.6-1.35l-.02-.01-.14-.11a1 1 0 0 1 1.2-1.6l.1.08c.6.4 1.52.74 2.69 1 .16-.99.39-1.88.67-2.65.3-.79.68-1.5 1.15-2.02A2.58 2.58 0 0 1 9.99 1c.8 0 1.45.44 1.92.97.47.52.84 1.23 1.14 2.02.29.77.52 1.66.68 2.64a8 8 0 0 0 2.7-1l.26-.18h.48a1 1 0 0 1 .12 2c-.86.51-2.01.91-3.34 1.18a22.24 22.24 0 0 1-.03 3.19c1.45.29 2.7.73 3.58 1.31a1 1 0 0 1-1.1 1.68c-.6-.4-1.56-.76-2.75-1-.15.8-.36 1.55-.6 2.2-.3.79-.67 1.5-1.14 2.02-.47.53-1.12.97-1.92.97-.8 0-1.45-.44-1.91-.97a6.51 6.51 0 0 1-1.15-2.02c-.24-.65-.44-1.4-.6-2.2-1.18.24-2.13.6-2.73.99a1 1 0 1 1-1.1-1.67c.88-.58 2.12-1.03 3.57-1.31a22.03 22.03 0 0 1-.04-3.2Zm2.2-1.7c.15-.86.34-1.61.58-2.24.24-.65.51-1.12.76-1.4.25-.28.4-.29.42-.29.03 0 .17.01.42.3.25.27.52.74.77 1.4.23.62.43 1.37.57 2.22a19.96 19.96 0 0 1-3.52 0Zm-.18 4.6a20.1 20.1 0 0 1-.03-2.62 21.95 21.95 0 0 0 3.94 0 20.4 20.4 0 0 1-.03 2.63 21.97 21.97 0 0 0-3.88 0Zm.27 2c.13.66.3 1.26.49 1.78.24.65.51 1.12.76 1.4.25.28.4.29.42.29.03 0 .17-.01.42-.3.25-.27.52-.74.77-1.4.19-.5.36-1.1.49-1.78a20.03 20.03 0 0 0-3.35 0Z"
    clip-rule="evenodd"
  />
</svg>`
  , checkmarkSvg = b`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M12.04 2.65c.47.3.6.91.3 1.38l-5.78 9a1 1 0 0 1-1.61.1L1.73 9.27A1 1 0 1 1 3.27 8L5.6 10.8l5.05-7.85a1 1 0 0 1 1.38-.3Z"
    clip-rule="evenodd"
  />
</svg>`
  , chevronBottomSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1.46 4.96a1 1 0 0 1 1.41 0L8 10.09l5.13-5.13a1 1 0 1 1 1.41 1.41l-5.83 5.84a1 1 0 0 1-1.42 0L1.46 6.37a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`
  , chevronLeftSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M11.04 1.46a1 1 0 0 1 0 1.41L5.91 8l5.13 5.13a1 1 0 1 1-1.41 1.41L3.79 8.71a1 1 0 0 1 0-1.42l5.84-5.83a1 1 0 0 1 1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`
  , chevronRightSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.96 14.54a1 1 0 0 1 0-1.41L10.09 8 4.96 2.87a1 1 0 0 1 1.41-1.41l5.84 5.83a1 1 0 0 1 0 1.42l-5.84 5.83a1 1 0 0 1-1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`
  , chevronTopSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M14.54 11.04a1 1 0 0 1-1.41 0L8 5.92l-5.13 5.12a1 1 0 1 1-1.41-1.41l5.83-5.84a1 1 0 0 1 1.42 0l5.83 5.84a1 1 0 0 1 0 1.41Z"
    clip-rule="evenodd"
  />
</svg>`
  , chromeStoreSvg = b`<svg width="36" height="36" fill="none">
  <path
    fill="#fff"
    fill-opacity=".05"
    d="M0 14.94c0-5.55 0-8.326 1.182-10.4a9 9 0 0 1 3.359-3.358C6.614 0 9.389 0 14.94 0h6.12c5.55 0 8.326 0 10.4 1.182a9 9 0 0 1 3.358 3.359C36 6.614 36 9.389 36 14.94v6.12c0 5.55 0 8.326-1.182 10.4a9 9 0 0 1-3.359 3.358C29.386 36 26.611 36 21.06 36h-6.12c-5.55 0-8.326 0-10.4-1.182a9 9 0 0 1-3.358-3.359C0 29.386 0 26.611 0 21.06v-6.12Z"
  />
  <path
    stroke="#fff"
    stroke-opacity=".05"
    d="M14.94.5h6.12c2.785 0 4.84 0 6.46.146 1.612.144 2.743.43 3.691.97a8.5 8.5 0 0 1 3.172 3.173c.541.948.826 2.08.971 3.692.145 1.62.146 3.675.146 6.459v6.12c0 2.785 0 4.84-.146 6.46-.145 1.612-.43 2.743-.97 3.691a8.5 8.5 0 0 1-3.173 3.172c-.948.541-2.08.826-3.692.971-1.62.145-3.674.146-6.459.146h-6.12c-2.784 0-4.84 0-6.46-.146-1.612-.145-2.743-.43-3.691-.97a8.5 8.5 0 0 1-3.172-3.173c-.541-.948-.827-2.08-.971-3.692C.5 25.9.5 23.845.5 21.06v-6.12c0-2.784 0-4.84.146-6.46.144-1.612.43-2.743.97-3.691A8.5 8.5 0 0 1 4.79 1.617C5.737 1.076 6.869.79 8.48.646 10.1.5 12.156.5 14.94.5Z"
  />
  <path
    fill="url(#a)"
    d="M17.998 10.8h12.469a14.397 14.397 0 0 0-24.938.001l6.234 10.798.006-.001a7.19 7.19 0 0 1 6.23-10.799Z"
  />
  <path
    fill="url(#b)"
    d="m24.237 21.598-6.234 10.798A14.397 14.397 0 0 0 30.47 10.798H18.002l-.002.006a7.191 7.191 0 0 1 6.237 10.794Z"
  />
  <path
    fill="url(#c)"
    d="M11.765 21.601 5.531 10.803A14.396 14.396 0 0 0 18.001 32.4l6.235-10.798-.004-.004a7.19 7.19 0 0 1-12.466.004Z"
  />
  <path fill="#fff" d="M18 25.2a7.2 7.2 0 1 0 0-14.4 7.2 7.2 0 0 0 0 14.4Z" />
  <path fill="#1A73E8" d="M18 23.7a5.7 5.7 0 1 0 0-11.4 5.7 5.7 0 0 0 0 11.4Z" />
  <defs>
    <linearGradient
      id="a"
      x1="6.294"
      x2="41.1"
      y1="5.995"
      y2="5.995"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#D93025" />
      <stop offset="1" stop-color="#EA4335" />
    </linearGradient>
    <linearGradient
      id="b"
      x1="20.953"
      x2="37.194"
      y1="32.143"
      y2="2.701"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#FCC934" />
      <stop offset="1" stop-color="#FBBC04" />
    </linearGradient>
    <linearGradient
      id="c"
      x1="25.873"
      x2="9.632"
      y1="31.2"
      y2="1.759"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#1E8E3E" />
      <stop offset="1" stop-color="#34A853" />
    </linearGradient>
  </defs>
</svg>`
  , clockSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 2.99a5 5 0 1 0 0 10 5 5 0 0 0 0-10Zm-7 5a7 7 0 1 1 14 0 7 7 0 0 1-14 0Zm7-4a1 1 0 0 1 1 1v2.58l1.85 1.85a1 1 0 0 1-1.41 1.42L6.29 8.69A1 1 0 0 1 6 8v-3a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`
  , closeSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M2.54 2.54a1 1 0 0 1 1.42 0L8 6.6l4.04-4.05a1 1 0 1 1 1.42 1.42L9.4 8l4.05 4.04a1 1 0 0 1-1.42 1.42L8 9.4l-4.04 4.05a1 1 0 0 1-1.42-1.42L6.6 8 2.54 3.96a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`
  , coinPlaceholderSvg = b`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 3a7 7 0 0 0-6.85 8.44l8.29-8.3C10.97 3.06 10.49 3 10 3Zm3.49.93-9.56 9.56c.32.55.71 1.06 1.16 1.5L15 5.1a7.03 7.03 0 0 0-1.5-1.16Zm2.7 2.8-9.46 9.46a7 7 0 0 0 9.46-9.46ZM1.99 5.9A9 9 0 1 1 18 14.09 9 9 0 0 1 1.98 5.91Z"
    clip-rule="evenodd"
  />
</svg>`
  , compassSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm10.66-2.65a1 1 0 0 1 .23 1.06L9.83 9.24a1 1 0 0 1-.59.58l-2.83 1.06A1 1 0 0 1 5.13 9.6l1.06-2.82a1 1 0 0 1 .58-.59L9.6 5.12a1 1 0 0 1 1.06.23ZM7.9 7.89l-.13.35.35-.13.12-.35-.34.13Z"
    clip-rule="evenodd"
  />
</svg>`
  , copySvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.5 0h1.67c.68 0 1.26 0 1.73.04.5.05.97.14 1.42.4.52.3.95.72 1.24 1.24.26.45.35.92.4 1.42.04.47.04 1.05.04 1.73V6.5c0 .69 0 1.26-.04 1.74-.05.5-.14.97-.4 1.41-.3.52-.72.95-1.24 1.25-.45.25-.92.35-1.42.4-.43.03-.95.03-1.57.03 0 .62 0 1.14-.04 1.57-.04.5-.14.97-.4 1.42-.29.52-.72.95-1.24 1.24-.44.26-.92.35-1.41.4-.48.04-1.05.04-1.74.04H4.83c-.68 0-1.26 0-1.73-.04-.5-.05-.97-.14-1.42-.4-.52-.3-.95-.72-1.24-1.24a3.39 3.39 0 0 1-.4-1.42A20.9 20.9 0 0 1 0 11.17V9.5c0-.69 0-1.26.04-1.74.05-.5.14-.97.4-1.41.3-.52.72-.95 1.24-1.25.45-.25.92-.35 1.42-.4.43-.03.95-.03 1.57-.03 0-.62 0-1.14.04-1.57.04-.5.14-.97.4-1.42.29-.52.72-.95 1.24-1.24.44-.26.92-.35 1.41-.4A20.9 20.9 0 0 1 9.5 0ZM4.67 6.67c-.63 0-1.06 0-1.4.03-.35.03-.5.09-.6.14-.2.12-.38.3-.5.5-.05.1-.1.24-.14.6C2 8.32 2 8.8 2 9.54v1.59c0 .73 0 1.22.03 1.6.04.35.1.5.15.6.11.2.29.38.5.5.09.05.24.1.6.14.37.03.86.03 1.6.03h1.58c.74 0 1.22 0 1.6-.03.36-.04.5-.1.6-.15.2-.11.38-.29.5-.5.05-.09.1-.24.14-.6.03-.33.03-.76.03-1.39-.6 0-1.13 0-1.57-.04-.5-.04-.97-.14-1.41-.4-.52-.29-.95-.72-1.25-1.24a3.39 3.39 0 0 1-.4-1.41c-.03-.44-.03-.96-.03-1.57Zm3.27-4.64c-.36.04-.5.1-.6.15-.2.11-.38.29-.5.5-.05.09-.1.24-.14.6-.03.37-.03.86-.03 1.6v1.58c0 .74 0 1.22.03 1.6.03.36.09.5.14.6.12.2.3.38.5.5.1.05.24.1.6.14.38.03.86.03 1.6.03h1.59c.73 0 1.22 0 1.6-.03.35-.03.5-.09.6-.14.2-.12.38-.3.5-.5.05-.1.1-.24.14-.6.03-.38.03-.86.03-1.6V4.87c0-.73 0-1.22-.03-1.6a1.46 1.46 0 0 0-.15-.6c-.11-.2-.29-.38-.5-.5-.09-.05-.24-.1-.6-.14-.37-.03-.86-.03-1.6-.03H9.55c-.74 0-1.22 0-1.6.03Z"
    clip-rule="evenodd"
  />
</svg>`
  , cursorSvg = b` <svg fill="none" viewBox="0 0 13 4">
  <path fill="currentColor" d="M.5 0h12L8.9 3.13a3.76 3.76 0 0 1-4.8 0L.5 0Z" />
</svg>`
  , desktopSvg = b`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13.66 2H6.34c-1.07 0-1.96 0-2.68.08-.74.08-1.42.25-2.01.68a4 4 0 0 0-.89.89c-.43.6-.6 1.27-.68 2.01C0 6.38 0 7.26 0 8.34v.89c0 1.07 0 1.96.08 2.68.08.74.25 1.42.68 2.01a4 4 0 0 0 .89.89c.6.43 1.27.6 2.01.68a27 27 0 0 0 2.68.08h7.32a27 27 0 0 0 2.68-.08 4.03 4.03 0 0 0 2.01-.68 4 4 0 0 0 .89-.89c.43-.6.6-1.27.68-2.01.08-.72.08-1.6.08-2.68v-.89c0-1.07 0-1.96-.08-2.68a4.04 4.04 0 0 0-.68-2.01 4 4 0 0 0-.89-.89c-.6-.43-1.27-.6-2.01-.68C15.62 2 14.74 2 13.66 2ZM2.82 4.38c.2-.14.48-.25 1.06-.31C4.48 4 5.25 4 6.4 4h7.2c1.15 0 1.93 0 2.52.07.58.06.86.17 1.06.31a2 2 0 0 1 .44.44c.14.2.25.48.31 1.06.07.6.07 1.37.07 2.52v.77c0 1.15 0 1.93-.07 2.52-.06.58-.17.86-.31 1.06a2 2 0 0 1-.44.44c-.2.14-.48.25-1.06.32-.6.06-1.37.06-2.52.06H6.4c-1.15 0-1.93 0-2.52-.06-.58-.07-.86-.18-1.06-.32a2 2 0 0 1-.44-.44c-.14-.2-.25-.48-.31-1.06C2 11.1 2 10.32 2 9.17V8.4c0-1.15 0-1.93.07-2.52.06-.58.17-.86.31-1.06a2 2 0 0 1 .44-.44Z"
    clip-rule="evenodd"
  />
  <path fill="currentColor" d="M6.14 17.57a1 1 0 1 0 0 2h7.72a1 1 0 1 0 0-2H6.14Z" />
</svg>`
  , disconnectSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.07 1h.57a1 1 0 0 1 0 2h-.52c-.98 0-1.64 0-2.14.06-.48.05-.7.14-.84.24-.13.1-.25.22-.34.35-.1.14-.2.35-.25.83-.05.5-.05 1.16-.05 2.15v2.74c0 .99 0 1.65.05 2.15.05.48.14.7.25.83.1.14.2.25.34.35.14.1.36.2.84.25.5.05 1.16.05 2.14.05h.52a1 1 0 0 1 0 2h-.57c-.92 0-1.69 0-2.3-.07a3.6 3.6 0 0 1-1.8-.61c-.3-.22-.57-.49-.8-.8a3.6 3.6 0 0 1-.6-1.79C.5 11.11.5 10.35.5 9.43V6.58c0-.92 0-1.7.06-2.31a3.6 3.6 0 0 1 .62-1.8c.22-.3.48-.57.79-.79a3.6 3.6 0 0 1 1.8-.61C4.37 1 5.14 1 6.06 1ZM9.5 3a1 1 0 0 1 1.42 0l4.28 4.3a1 1 0 0 1 0 1.4L10.93 13a1 1 0 0 1-1.42-1.42L12.1 9H6.8a1 1 0 1 1 0-2h5.3L9.51 4.42a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`
  , discordSvg = b`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
        clip-rule="evenodd"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg>`
  , etherscanSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M4.25 7a.63.63 0 0 0-.63.63v3.97c0 .28-.2.51-.47.54l-.75.07a.93.93 0 0 1-.9-.47A7.51 7.51 0 0 1 5.54.92a7.5 7.5 0 0 1 9.54 4.62c.12.35.06.72-.16 1-.74.97-1.68 1.78-2.6 2.44V4.44a.64.64 0 0 0-.63-.64h-1.06c-.35 0-.63.3-.63.64v5.5c0 .23-.12.42-.32.5l-.52.23V6.05c0-.36-.3-.64-.64-.64H7.45c-.35 0-.64.3-.64.64v4.97c0 .25-.17.46-.4.52a5.8 5.8 0 0 0-.45.11v-4c0-.36-.3-.65-.64-.65H4.25ZM14.07 12.4A7.49 7.49 0 0 1 3.6 14.08c4.09-.58 9.14-2.5 11.87-6.6v.03a7.56 7.56 0 0 1-1.41 4.91Z"
  />
</svg>`
  , extensionSvg = b`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.71 2.99a.57.57 0 0 0-.57.57 1 1 0 0 1-1 1c-.58 0-.96 0-1.24.03-.27.03-.37.07-.42.1a.97.97 0 0 0-.36.35c-.04.08-.09.21-.11.67a2.57 2.57 0 0 1 0 5.13c.02.45.07.6.11.66.09.15.21.28.36.36.07.04.21.1.67.12a2.57 2.57 0 0 1 5.12 0c.46-.03.6-.08.67-.12a.97.97 0 0 0 .36-.36c.03-.04.07-.14.1-.41.02-.29.03-.66.03-1.24a1 1 0 0 1 1-1 .57.57 0 0 0 0-1.15 1 1 0 0 1-1-1c0-.58 0-.95-.03-1.24a1.04 1.04 0 0 0-.1-.42.97.97 0 0 0-.36-.36 1.04 1.04 0 0 0-.42-.1c-.28-.02-.65-.02-1.24-.02a1 1 0 0 1-1-1 .57.57 0 0 0-.57-.57ZM5.15 13.98a1 1 0 0 0 .99-1v-.78a.57.57 0 0 1 1.14 0v.78a1 1 0 0 0 .99 1H8.36a66.26 66.26 0 0 0 .73 0 3.78 3.78 0 0 0 1.84-.38c.46-.26.85-.64 1.1-1.1.23-.4.32-.8.36-1.22.02-.2.03-.4.03-.63a2.57 2.57 0 0 0 0-4.75c0-.23-.01-.44-.03-.63a2.96 2.96 0 0 0-.35-1.22 2.97 2.97 0 0 0-1.1-1.1c-.4-.22-.8-.31-1.22-.35a8.7 8.7 0 0 0-.64-.04 2.57 2.57 0 0 0-4.74 0c-.23 0-.44.02-.63.04-.42.04-.83.13-1.22.35-.46.26-.84.64-1.1 1.1-.33.57-.37 1.2-.39 1.84a21.39 21.39 0 0 0 0 .72v.1a1 1 0 0 0 1 .99h.78a.57.57 0 0 1 0 1.15h-.77a1 1 0 0 0-1 .98v.1a63.87 63.87 0 0 0 0 .73c0 .64.05 1.27.38 1.83.26.47.64.85 1.1 1.11.56.32 1.2.37 1.84.38a20.93 20.93 0 0 0 .72 0h.1Z"
    clip-rule="evenodd"
  />
</svg>`
  , externalLinkSvg = b`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.74 3.99a1 1 0 0 1 1-1H11a1 1 0 0 1 1 1v6.26a1 1 0 0 1-2 0V6.4l-6.3 6.3a1 1 0 0 1-1.4-1.42l6.29-6.3H4.74a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`
  , facebookSvg = b`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1877F2" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M26 12.38h-2.89c-.92 0-1.61.38-1.61 1.34v1.66H26l-.36 4.5H21.5v12H17v-12h-3v-4.5h3V12.5c0-3.03 1.6-4.62 5.2-4.62H26v4.5Z"
        />
      </g>
    </g>
    <path
      fill="#1877F2"
      d="M40 20a20 20 0 1 0-23.13 19.76V25.78H11.8V20h5.07v-4.4c0-5.02 3-7.79 7.56-7.79 2.19 0 4.48.4 4.48.4v4.91h-2.53c-2.48 0-3.25 1.55-3.25 3.13V20h5.54l-.88 5.78h-4.66v13.98A20 20 0 0 0 40 20Z"
    />
    <path
      fill="#fff"
      d="m27.79 25.78.88-5.78h-5.55v-3.75c0-1.58.78-3.13 3.26-3.13h2.53V8.2s-2.3-.39-4.48-.39c-4.57 0-7.55 2.77-7.55 7.78V20H11.8v5.78h5.07v13.98a20.15 20.15 0 0 0 6.25 0V25.78h4.67Z"
    />
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`
  , filtersSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 3a1 1 0 0 1 1-1h14a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1Zm2.63 5.25a1 1 0 0 1 1-1h8.75a1 1 0 1 1 0 2H3.63a1 1 0 0 1-1-1Zm2.62 5.25a1 1 0 0 1 1-1h3.5a1 1 0 0 1 0 2h-3.5a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`
  , githubSvg = b`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1B1F23" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M8 19.89a12 12 0 1 1 15.8 11.38c-.6.12-.8-.26-.8-.57v-3.3c0-1.12-.4-1.85-.82-2.22 2.67-.3 5.48-1.31 5.48-5.92 0-1.31-.47-2.38-1.24-3.22.13-.3.54-1.52-.12-3.18 0 0-1-.32-3.3 1.23a11.54 11.54 0 0 0-6 0c-2.3-1.55-3.3-1.23-3.3-1.23a4.32 4.32 0 0 0-.12 3.18 4.64 4.64 0 0 0-1.24 3.22c0 4.6 2.8 5.63 5.47 5.93-.34.3-.65.83-.76 1.6-.69.31-2.42.84-3.5-1 0 0-.63-1.15-1.83-1.23 0 0-1.18-.02-.09.73 0 0 .8.37 1.34 1.76 0 0 .7 2.14 4.03 1.41v2.24c0 .31-.2.68-.8.57A12 12 0 0 1 8 19.9Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`
  , googleSvg = b`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#fff" fill-opacity=".05" />
      <g clip-path="url(#c)">
        <path
          fill="#4285F4"
          d="M20 17.7v4.65h6.46a5.53 5.53 0 0 1-2.41 3.61l3.9 3.02c2.26-2.09 3.57-5.17 3.57-8.82 0-.85-.08-1.67-.22-2.46H20Z"
        />
        <path
          fill="#34A853"
          d="m13.27 22.17-.87.67-3.11 2.42A12 12 0 0 0 20 31.9c3.24 0 5.96-1.07 7.94-2.9l-3.9-3.03A7.15 7.15 0 0 1 20 27.12a7.16 7.16 0 0 1-6.72-4.94v-.01Z"
        />
        <path
          fill="#FBBC05"
          d="M9.29 14.5a11.85 11.85 0 0 0 0 10.76l3.99-3.1a7.19 7.19 0 0 1 0-4.55l-4-3.1Z"
        />
        <path
          fill="#EA4335"
          d="M20 12.66c1.77 0 3.34.61 4.6 1.8l3.43-3.44A11.51 11.51 0 0 0 20 7.89c-4.7 0-8.74 2.69-10.71 6.62l3.99 3.1A7.16 7.16 0 0 1 20 12.66Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`
  , helpCircleSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M8.51 5.66a.83.83 0 0 0-.57-.2.83.83 0 0 0-.52.28.8.8 0 0 0-.25.52 1 1 0 0 1-2 0c0-.75.34-1.43.81-1.91a2.75 2.75 0 0 1 4.78 1.92c0 1.24-.8 1.86-1.25 2.2l-.04.03c-.47.36-.5.43-.5.65a1 1 0 1 1-2 0c0-1.25.8-1.86 1.24-2.2l.04-.04c.47-.36.5-.43.5-.65 0-.3-.1-.49-.24-.6ZM9.12 11.87a1.13 1.13 0 1 1-2.25 0 1.13 1.13 0 0 1 2.25 0Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"
    clip-rule="evenodd"
  />
</svg>`
  , infoCircleSvg = b`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    d="M6 10.49a1 1 0 1 0 2 0v-2a1 1 0 0 0-2 0v2ZM7 4.49a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 14.99a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm5-7a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z"
    clip-rule="evenodd"
  />
</svg>`
  , mailSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.83 1.34h6.34c.68 0 1.26 0 1.73.04.5.05.97.15 1.42.4.52.3.95.72 1.24 1.24.26.45.35.92.4 1.42.04.47.04 1.05.04 1.73v3.71c0 .69 0 1.26-.04 1.74-.05.5-.14.97-.4 1.41-.3.52-.72.95-1.24 1.25-.45.25-.92.35-1.42.4-.47.03-1.05.03-1.73.03H4.83c-.68 0-1.26 0-1.73-.04-.5-.04-.97-.14-1.42-.4-.52-.29-.95-.72-1.24-1.24a3.39 3.39 0 0 1-.4-1.41A20.9 20.9 0 0 1 0 9.88v-3.7c0-.7 0-1.27.04-1.74.05-.5.14-.97.4-1.42.3-.52.72-.95 1.24-1.24.45-.25.92-.35 1.42-.4.47-.04 1.05-.04 1.73-.04ZM3.28 3.38c-.36.03-.51.08-.6.14-.21.11-.39.29-.5.5a.8.8 0 0 0-.08.19l5.16 3.44c.45.3 1.03.3 1.48 0L13.9 4.2a.79.79 0 0 0-.08-.2c-.11-.2-.29-.38-.5-.5-.09-.05-.24-.1-.6-.13-.37-.04-.86-.04-1.6-.04H4.88c-.73 0-1.22 0-1.6.04ZM14 6.54 9.85 9.31a3.33 3.33 0 0 1-3.7 0L2 6.54v3.3c0 .74 0 1.22.03 1.6.04.36.1.5.15.6.11.2.29.38.5.5.09.05.24.1.6.14.37.03.86.03 1.6.03h6.25c.73 0 1.22 0 1.6-.03.35-.03.5-.09.6-.14.2-.12.38-.3.5-.5.05-.1.1-.24.14-.6.03-.38.03-.86.03-1.6v-3.3Z"
    clip-rule="evenodd"
  />
</svg>`
  , mobileSvg = b`<svg fill="none" viewBox="0 0 20 20">
  <path fill="currentColor" d="M10.81 5.81a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z" />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3 4.75A4.75 4.75 0 0 1 7.75 0h4.5A4.75 4.75 0 0 1 17 4.75v10.5A4.75 4.75 0 0 1 12.25 20h-4.5A4.75 4.75 0 0 1 3 15.25V4.75ZM7.75 2A2.75 2.75 0 0 0 5 4.75v10.5A2.75 2.75 0 0 0 7.75 18h4.5A2.75 2.75 0 0 0 15 15.25V4.75A2.75 2.75 0 0 0 12.25 2h-4.5Z"
    clip-rule="evenodd"
  />
</svg>`
  , networkPlaceholderSvg = b`<svg fill="none" viewBox="0 0 22 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M16.32 13.62a3.14 3.14 0 1 1-.99 1.72l-1.6-.93a3.83 3.83 0 0 1-3.71 1 3.66 3.66 0 0 1-1.74-1l-1.6.94a3.14 3.14 0 1 1-1-1.73l1.6-.94a3.7 3.7 0 0 1 0-2 3.81 3.81 0 0 1 1.8-2.33c.29-.17.6-.3.92-.38V6.1a3.14 3.14 0 1 1 2 0l-.01.02v1.85H12a3.82 3.82 0 0 1 2.33 1.8 3.7 3.7 0 0 1 .39 2.91l1.6.93ZM2.6 16.54a1.14 1.14 0 0 0 1.98-1.14 1.14 1.14 0 0 0-1.98 1.14ZM11 2.01a1.14 1.14 0 1 0 0 2.28 1.14 1.14 0 0 0 0-2.28Zm1.68 10.45c.08-.19.14-.38.16-.58v-.05l.02-.13v-.13a1.92 1.92 0 0 0-.24-.8l-.11-.15a1.89 1.89 0 0 0-.74-.6 1.86 1.86 0 0 0-.77-.17h-.19a1.97 1.97 0 0 0-.89.34 1.98 1.98 0 0 0-.61.74 1.99 1.99 0 0 0-.16.9v.05a1.87 1.87 0 0 0 .24.74l.1.15c.12.16.26.3.42.42l.16.1.13.07.04.02a1.84 1.84 0 0 0 .76.17h.17a2 2 0 0 0 .91-.35 1.78 1.78 0 0 0 .52-.58l.03-.05a.84.84 0 0 0 .05-.11Zm5.15 4.5a1.14 1.14 0 0 0 1.14-1.97 1.13 1.13 0 0 0-1.55.41c-.32.55-.13 1.25.41 1.56Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.63 9.43a1.5 1.5 0 1 0 1.5-2.6 1.5 1.5 0 0 0-1.5 2.6Zm.32-1.55a.5.5 0 0 1 .68-.19.5.5 0 0 1 .18.68.5.5 0 0 1-.68.19.5.5 0 0 1-.18-.68ZM17.94 8.88a1.5 1.5 0 1 1-2.6-1.5 1.5 1.5 0 1 1 2.6 1.5ZM16.9 7.69a.5.5 0 0 0-.68.19.5.5 0 0 0 .18.68.5.5 0 0 0 .68-.19.5.5 0 0 0-.18-.68ZM9.75 17.75a1.5 1.5 0 1 1 2.6 1.5 1.5 1.5 0 1 1-2.6-1.5Zm1.05 1.18a.5.5 0 0 0 .68-.18.5.5 0 0 0-.18-.68.5.5 0 0 0-.68.18.5.5 0 0 0 .18.68Z"
    clip-rule="evenodd"
  />
</svg>`
  , nftPlaceholderSvg = b`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.13 1h1.71c1.46 0 2.63 0 3.56.1.97.1 1.8.33 2.53.85a5 5 0 0 1 1.1 1.11c.53.73.75 1.56.86 2.53.1.93.1 2.1.1 3.55v1.72c0 1.45 0 2.62-.1 3.55-.1.97-.33 1.8-.86 2.53a5 5 0 0 1-1.1 1.1c-.73.53-1.56.75-2.53.86-.93.1-2.1.1-3.55.1H9.13c-1.45 0-2.62 0-3.56-.1-.96-.1-1.8-.33-2.52-.85a5 5 0 0 1-1.1-1.11 5.05 5.05 0 0 1-.86-2.53c-.1-.93-.1-2.1-.1-3.55V9.14c0-1.45 0-2.62.1-3.55.1-.97.33-1.8.85-2.53a5 5 0 0 1 1.1-1.1 5.05 5.05 0 0 1 2.53-.86C6.51 1 7.67 1 9.13 1ZM5.79 3.09a3.1 3.1 0 0 0-1.57.48 3 3 0 0 0-.66.67c-.24.32-.4.77-.48 1.56-.1.82-.1 1.88-.1 3.4v1.6c0 1.15 0 2.04.05 2.76l.41-.42c.5-.5.93-.92 1.32-1.24.41-.33.86-.6 1.43-.7a3 3 0 0 1 .94 0c.35.06.66.2.95.37a17.11 17.11 0 0 0 .8.45c.1-.08.2-.2.41-.4l.04-.03a27 27 0 0 1 1.95-1.84 4.03 4.03 0 0 1 1.91-.94 4 4 0 0 1 1.25 0c.73.11 1.33.46 1.91.94l.64.55V9.2c0-1.52 0-2.58-.1-3.4a3.1 3.1 0 0 0-.48-1.56 3 3 0 0 0-.66-.67 3.1 3.1 0 0 0-1.56-.48C13.37 3 12.3 3 10.79 3h-1.6c-1.52 0-2.59 0-3.4.09Zm11.18 10-.04-.05a26.24 26.24 0 0 0-1.83-1.74c-.45-.36-.73-.48-.97-.52a2 2 0 0 0-.63 0c-.24.04-.51.16-.97.52-.46.38-1.01.93-1.83 1.74l-.02.02c-.17.18-.34.34-.49.47a2.04 2.04 0 0 1-1.08.5 1.97 1.97 0 0 1-1.25-.27l-.79-.46-.02-.02a.65.65 0 0 0-.24-.1 1 1 0 0 0-.31 0c-.08.02-.21.06-.49.28-.3.24-.65.59-1.2 1.14l-.56.56-.65.66a3 3 0 0 0 .62.6c.33.24.77.4 1.57.49.81.09 1.88.09 3.4.09h1.6c1.52 0 2.58 0 3.4-.09a3.1 3.1 0 0 0 1.56-.48 3 3 0 0 0 .66-.67c.24-.32.4-.77.49-1.56l.07-1.12Zm-8.02-1.03ZM4.99 7a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z"
    clip-rule="evenodd"
  />
</svg>`
  , offSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 0a1 1 0 0 1 1 1v5.38a1 1 0 0 1-2 0V1a1 1 0 0 1 1-1ZM5.26 2.6a1 1 0 0 1-.28 1.39 5.46 5.46 0 1 0 6.04 0 1 1 0 1 1 1.1-1.67 7.46 7.46 0 1 1-8.25 0 1 1 0 0 1 1.4.28Z"
    clip-rule="evenodd"
  />
</svg>`
  , playStoreSvg = b` <svg
  width="36"
  height="36"
  fill="none"
>
  <path
    d="M0 8a8 8 0 0 1 8-8h20a8 8 0 0 1 8 8v20a8 8 0 0 1-8 8H8a8 8 0 0 1-8-8V8Z"
    fill="#fff"
    fill-opacity=".05"
  />
  <path
    d="m18.262 17.513-8.944 9.49v.01a2.417 2.417 0 0 0 3.56 1.452l.026-.017 10.061-5.803-4.703-5.132Z"
    fill="#EA4335"
  />
  <path
    d="m27.307 15.9-.008-.008-4.342-2.52-4.896 4.36 4.913 4.912 4.325-2.494a2.42 2.42 0 0 0 .008-4.25Z"
    fill="#FBBC04"
  />
  <path
    d="M9.318 8.997c-.05.202-.084.403-.084.622V26.39c0 .218.025.42.084.621l9.246-9.247-9.246-8.768Z"
    fill="#4285F4"
  />
  <path
    d="m18.33 18 4.627-4.628-10.053-5.828a2.427 2.427 0 0 0-3.586 1.444L18.329 18Z"
    fill="#34A853"
  />
  <path
    d="M8 .5h20A7.5 7.5 0 0 1 35.5 8v20a7.5 7.5 0 0 1-7.5 7.5H8A7.5 7.5 0 0 1 .5 28V8A7.5 7.5 0 0 1 8 .5Z"
    stroke="#fff"
    stroke-opacity=".05"
  />
</svg>`
  , qrCodeIcon = b`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M3 6a3 3 0 0 1 3-3h1a1 1 0 1 0 0-2H6a5 5 0 0 0-5 5v1a1 1 0 0 0 2 0V6ZM13 1a1 1 0 1 0 0 2h1a3 3 0 0 1 3 3v1a1 1 0 1 0 2 0V6a5 5 0 0 0-5-5h-1ZM3 13a1 1 0 1 0-2 0v1a5 5 0 0 0 5 5h1a1 1 0 1 0 0-2H6a3 3 0 0 1-3-3v-1ZM19 13a1 1 0 1 0-2 0v1a3 3 0 0 1-3 3h-1a1 1 0 1 0 0 2h1.01a5 5 0 0 0 5-5v-1ZM5.3 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05A1.5 1.5 0 0 0 9.2 8.14c.06-.2.06-.43.06-.89s0-.7-.06-.89A1.5 1.5 0 0 0 8.14 5.3c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM10.8 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM5.26 12.75c0-.46 0-.7.05-.89a1.5 1.5 0 0 1 1.06-1.06c.19-.05.42-.05.89-.05.46 0 .7 0 .88.05.52.14.93.54 1.06 1.06.06.2.06.43.06.89s0 .7-.06.89a1.5 1.5 0 0 1-1.06 1.06c-.19.05-.42.05-.88.05-.47 0-.7 0-.9-.05a1.5 1.5 0 0 1-1.05-1.06c-.05-.2-.05-.43-.05-.89ZM10.8 11.86c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06Z"
  />
</svg>`
  , refreshSvg = b`<svg fill="none" viewBox="0 0 14 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.94 1.04a1 1 0 0 1 .7 1.23l-.48 1.68a5.85 5.85 0 0 1 8.53 4.32 5.86 5.86 0 0 1-11.4 2.56 1 1 0 0 1 1.9-.57 3.86 3.86 0 1 0 1.83-4.5l1.87.53a1 1 0 0 1-.55 1.92l-4.1-1.15a1 1 0 0 1-.69-1.23l1.16-4.1a1 1 0 0 1 1.23-.7Z"
    clip-rule="evenodd"
  />
</svg>`
  , searchSvg = b`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.36 4.21a5.14 5.14 0 1 0 0 10.29 5.14 5.14 0 0 0 0-10.29ZM1.64 9.36a7.71 7.71 0 1 1 14 4.47l2.52 2.5a1.29 1.29 0 1 1-1.82 1.83l-2.51-2.51A7.71 7.71 0 0 1 1.65 9.36Z"
    clip-rule="evenodd"
  />
</svg>`
  , swapHorizontalSvg = b`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.76.3a1 1 0 0 1 0 1.4L4.07 4.4h9a1 1 0 1 1 0 2h-9l2.69 2.68a1 1 0 1 1-1.42 1.42L.95 6.09a1 1 0 0 1 0-1.4l4.4-4.4a1 1 0 0 1 1.4 0Zm6.49 9.21a1 1 0 0 1 1.41 0l4.39 4.4a1 1 0 0 1 0 1.4l-4.39 4.4a1 1 0 0 1-1.41-1.42l2.68-2.68h-9a1 1 0 0 1 0-2h9l-2.68-2.68a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`
  , swapHorizontalBoldSvg = b`<svg width="10" height="10" viewBox="0 0 10 10">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.77986 0.566631C4.0589 0.845577 4.0589 1.29784 3.77986 1.57678L3.08261 2.2738H6.34184C6.73647 2.2738 7.05637 2.5936 7.05637 2.98808C7.05637 3.38257 6.73647 3.70237 6.34184 3.70237H3.08261L3.77986 4.39938C4.0589 4.67833 4.0589 5.13059 3.77986 5.40954C3.50082 5.68848 3.04841 5.68848 2.76937 5.40954L0.852346 3.49316C0.573306 3.21421 0.573306 2.76195 0.852346 2.48301L2.76937 0.566631C3.04841 0.287685 3.50082 0.287685 3.77986 0.566631ZM6.22 4.59102C6.49904 4.31208 6.95145 4.31208 7.23049 4.59102L9.14751 6.5074C9.42655 6.78634 9.42655 7.23861 9.14751 7.51755L7.23049 9.43393C6.95145 9.71287 6.49904 9.71287 6.22 9.43393C5.94096 9.15498 5.94096 8.70272 6.22 8.42377L6.91725 7.72676L3.65802 7.72676C3.26339 7.72676 2.94349 7.40696 2.94349 7.01247C2.94349 6.61798 3.26339 6.29819 3.65802 6.29819L6.91725 6.29819L6.22 5.60117C5.94096 5.32223 5.94096 4.86997 6.22 4.59102Z"
    clip-rule="evenodd"
  />
</svg>`
  , swapVerticalSvg = b`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.48 2.18a1 1 0 0 1 1.41 0l2.68 2.68a1 1 0 1 1-1.41 1.42l-.98-.98v4.56a1 1 0 0 1-2 0V5.3l-.97.98A1 1 0 0 1 .79 4.86l2.69-2.68Zm6.34 2.93a1 1 0 0 1 1 1v4.56l.97-.98a1 1 0 1 1 1.42 1.42l-2.69 2.68a1 1 0 0 1-1.41 0l-2.68-2.68a1 1 0 0 1 1.41-1.42l.98.98V6.1a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`
  , telegramSvg = b`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
        clip-rule="evenodd"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg> `
  , twitchSvg = b`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5A3E85" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M18.22 25.7 20 23.91h3.34l2.1-2.1v-6.68H15.4v8.78h2.82v1.77Zm3.87-8.16h1.25v3.66H22.1v-3.66Zm-3.34 0H20v3.66h-1.25v-3.66ZM20 7.9a12 12 0 1 0 0 24 12 12 0 0 0 0-24Zm6.69 14.56-3.66 3.66h-2.72l-1.77 1.78h-1.88V26.1H13.3v-9.82l.94-2.4H26.7v8.56Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`
  , twitterSvg = b`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1D9BF0" />
      <path
        fill="#fff"
        d="M30 13.81c-.74.33-1.53.55-2.36.65.85-.51 1.5-1.32 1.8-2.27-.79.47-1.66.8-2.6 1a4.1 4.1 0 0 0-7 3.73c-3.4-.17-6.42-1.8-8.45-4.28a4.1 4.1 0 0 0 1.27 5.47c-.67-.02-1.3-.2-1.86-.5a4.1 4.1 0 0 0 3.3 4.07c-.58.15-1.21.19-1.86.07a4.1 4.1 0 0 0 3.83 2.85A8.25 8.25 0 0 1 10 26.3a11.62 11.62 0 0 0 6.29 1.84c7.62 0 11.92-6.44 11.66-12.2.8-.59 1.5-1.3 2.05-2.13Z"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg>`
  , twitterIconSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="m14.36 4.74.01.42c0 4.34-3.3 9.34-9.34 9.34A9.3 9.3 0 0 1 0 13.03a6.6 6.6 0 0 0 4.86-1.36 3.29 3.29 0 0 1-3.07-2.28c.5.1 1 .07 1.48-.06A3.28 3.28 0 0 1 .64 6.11v-.04c.46.26.97.4 1.49.41A3.29 3.29 0 0 1 1.11 2.1a9.32 9.32 0 0 0 6.77 3.43 3.28 3.28 0 0 1 5.6-3 6.59 6.59 0 0 0 2.08-.8 3.3 3.3 0 0 1-1.45 1.82A6.53 6.53 0 0 0 16 3.04c-.44.66-1 1.23-1.64 1.7Z"
  />
</svg>`
  , walletPlaceholderSvg = b`
  <svg fill="none" viewBox="0 0 48 44">
    <path
      style="fill: var(--wui-color-bg-300);"
      d="M4.56 8.64c-1.23 1.68-1.23 4.08-1.23 8.88v8.96c0 4.8 0 7.2 1.23 8.88.39.55.87 1.02 1.41 1.42C7.65 38 10.05 38 14.85 38h14.3c4.8 0 7.2 0 8.88-1.22a6.4 6.4 0 0 0 1.41-1.42c.83-1.14 1.1-2.6 1.19-4.92a6.4 6.4 0 0 0 5.16-4.65c.21-.81.21-1.8.21-3.79 0-1.98 0-2.98-.22-3.79a6.4 6.4 0 0 0-5.15-4.65c-.1-2.32-.36-3.78-1.19-4.92a6.4 6.4 0 0 0-1.41-1.42C36.35 6 33.95 6 29.15 6h-14.3c-4.8 0-7.2 0-8.88 1.22a6.4 6.4 0 0 0-1.41 1.42Z"
    />
    <path
      style="fill: var(--wui-color-fg-200);"
      fill-rule="evenodd"
      d="M2.27 11.33a6.4 6.4 0 0 1 6.4-6.4h26.66a6.4 6.4 0 0 1 6.4 6.4v1.7a6.4 6.4 0 0 1 5.34 6.3v5.34a6.4 6.4 0 0 1-5.34 6.3v1.7a6.4 6.4 0 0 1-6.4 6.4H8.67a6.4 6.4 0 0 1-6.4-6.4V11.33ZM39.6 31.07h-6.93a9.07 9.07 0 1 1 0-18.14h6.93v-1.6a4.27 4.27 0 0 0-4.27-4.26H8.67a4.27 4.27 0 0 0-4.27 4.26v21.34a4.27 4.27 0 0 0 4.27 4.26h26.66a4.27 4.27 0 0 0 4.27-4.26v-1.6Zm-6.93-16a6.93 6.93 0 0 0 0 13.86h8a4.27 4.27 0 0 0 4.26-4.26v-5.34a4.27 4.27 0 0 0-4.26-4.26h-8Z"
      clip-rule="evenodd"
    />
  </svg>
`
  , walletSvg = b`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 5.5c0-1.8 1.46-3.25 3.25-3.25H14.5c1.8 0 3.25 1.46 3.25 3.25v.28A3.25 3.25 0 0 1 20 8.88v2.24c0 1.45-.94 2.68-2.25 3.1v.28c0 1.8-1.46 3.25-3.25 3.25H3.25A3.25 3.25 0 0 1 0 14.5v-9Zm15.75 8.88h-2.38a4.38 4.38 0 0 1 0-8.76h2.38V5.5c0-.69-.56-1.25-1.25-1.25H3.25C2.56 4.25 2 4.81 2 5.5v9c0 .69.56 1.25 1.25 1.25H14.5c.69 0 1.25-.56 1.25-1.25v-.13Zm-2.38-6.76a2.37 2.37 0 1 0 0 4.75h3.38c.69 0 1.25-.55 1.25-1.24V8.87c0-.69-.56-1.24-1.25-1.24h-3.38Z"
    clip-rule="evenodd"
  />
</svg>`
  , walletConnectSvg = b`<svg fill="none" viewBox="0 0 96 67">
  <path
    fill="currentColor"
    d="M25.32 18.8a32.56 32.56 0 0 1 45.36 0l1.5 1.47c.63.62.63 1.61 0 2.22l-5.15 5.05c-.31.3-.82.3-1.14 0l-2.07-2.03a22.71 22.71 0 0 0-31.64 0l-2.22 2.18c-.31.3-.82.3-1.14 0l-5.15-5.05a1.55 1.55 0 0 1 0-2.22l1.65-1.62Zm56.02 10.44 4.59 4.5c.63.6.63 1.6 0 2.21l-20.7 20.26c-.62.61-1.63.61-2.26 0L48.28 41.83a.4.4 0 0 0-.56 0L33.03 56.21c-.63.61-1.64.61-2.27 0L10.07 35.95a1.55 1.55 0 0 1 0-2.22l4.59-4.5a1.63 1.63 0 0 1 2.27 0L31.6 43.63a.4.4 0 0 0 .57 0l14.69-14.38a1.63 1.63 0 0 1 2.26 0l14.69 14.38a.4.4 0 0 0 .57 0l14.68-14.38a1.63 1.63 0 0 1 2.27 0Z"
  />
  <path
    stroke="#000"
    stroke-opacity=".1"
    d="M25.67 19.15a32.06 32.06 0 0 1 44.66 0l1.5 1.48c.43.42.43 1.09 0 1.5l-5.15 5.05a.31.31 0 0 1-.44 0l-2.07-2.03a23.21 23.21 0 0 0-32.34 0l-2.22 2.18a.31.31 0 0 1-.44 0l-5.15-5.05a1.05 1.05 0 0 1 0-1.5l1.65-1.63ZM81 29.6l4.6 4.5c.42.41.42 1.09 0 1.5l-20.7 20.26c-.43.43-1.14.43-1.57 0L48.63 41.47a.9.9 0 0 0-1.26 0L32.68 55.85c-.43.43-1.14.43-1.57 0L10.42 35.6a1.05 1.05 0 0 1 0-1.5l4.59-4.5a1.13 1.13 0 0 1 1.57 0l14.68 14.38a.9.9 0 0 0 1.27 0l-.35-.35.35.35L47.22 29.6a1.13 1.13 0 0 1 1.56 0l14.7 14.38a.9.9 0 0 0 1.26 0L79.42 29.6a1.13 1.13 0 0 1 1.57 0Z"
  />
</svg>`
  , warningCircleSvg = b`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M11 6.67a1 1 0 1 0-2 0v2.66a1 1 0 0 0 2 0V6.67ZM10 14.5a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 1a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm-7 9a7 7 0 1 1 14 0 7 7 0 0 1-14 0Z"
    clip-rule="evenodd"
  />
</svg>`;
var __decorate$1g = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
const svgOptions$1 = {
    allWallets: allWalletsSvg,
    appStore: appStoreSvg,
    chromeStore: chromeStoreSvg,
    apple: appleSvg,
    arrowBottom: arrowBottomSvg,
    arrowLeft: arrowLeftSvg,
    arrowRight: arrowRightSvg,
    arrowTop: arrowTopSvg,
    browser: browserSvg$1,
    checkmark: checkmarkSvg,
    chevronBottom: chevronBottomSvg,
    chevronLeft: chevronLeftSvg,
    chevronRight: chevronRightSvg,
    chevronTop: chevronTopSvg,
    clock: clockSvg,
    close: closeSvg,
    compass: compassSvg,
    coinPlaceholder: coinPlaceholderSvg,
    copy: copySvg,
    cursor: cursorSvg,
    desktop: desktopSvg,
    disconnect: disconnectSvg,
    discord: discordSvg,
    etherscan: etherscanSvg,
    extension: extensionSvg,
    externalLink: externalLinkSvg,
    facebook: facebookSvg,
    filters: filtersSvg,
    github: githubSvg,
    google: googleSvg,
    helpCircle: helpCircleSvg,
    infoCircle: infoCircleSvg,
    mail: mailSvg,
    mobile: mobileSvg,
    networkPlaceholder: networkPlaceholderSvg,
    nftPlaceholder: nftPlaceholderSvg,
    off: offSvg,
    playStore: playStoreSvg,
    qrCode: qrCodeIcon,
    refresh: refreshSvg,
    search: searchSvg,
    swapHorizontal: swapHorizontalSvg,
    swapHorizontalBold: swapHorizontalBoldSvg,
    swapVertical: swapVerticalSvg,
    telegram: telegramSvg,
    twitch: twitchSvg,
    twitter: twitterSvg,
    twitterIcon: twitterIconSvg,
    wallet: walletSvg,
    walletConnect: walletConnectSvg,
    walletPlaceholder: walletPlaceholderSvg,
    warningCircle: warningCircleSvg
};
let WuiIcon = class extends s$1 {
    constructor() {
        super(...arguments),
        this.size = "md",
        this.name = "copy",
        this.color = "fg-300"
    }
    render() {
        return this.style.cssText = `
      --local-color: var(--wui-color-${this.color});
      --local-width: var(--wui-icon-size-${this.size});
    `,
        x$1`${svgOptions$1[this.name]}`
    }
}
;
WuiIcon.styles = [resetStyles, colorStyles, styles$X],
__decorate$1g([n$2()], WuiIcon.prototype, "size", void 0),
__decorate$1g([n$2()], WuiIcon.prototype, "name", void 0),
__decorate$1g([n$2()], WuiIcon.prototype, "color", void 0),
WuiIcon = __decorate$1g([customElement("wui-icon")], WuiIcon);
const styles$W = i$4`
  :host {
    display: block;
    width: 100%;
    height: 100%;
  }

  img {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center center;
    border-radius: inherit;
  }
`;
var __decorate$1f = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiImage = class extends s$1 {
    constructor() {
        super(...arguments),
        this.src = "./path/to/image.jpg",
        this.alt = "Image"
    }
    render() {
        return x$1`<img src=${this.src} alt=${this.alt} />`
    }
}
;
WuiImage.styles = [resetStyles, colorStyles, styles$W],
__decorate$1f([n$2()], WuiImage.prototype, "src", void 0),
__decorate$1f([n$2()], WuiImage.prototype, "alt", void 0),
WuiImage = __decorate$1f([customElement("wui-image")], WuiImage);
const styles$V = i$4`
  :host {
    display: block;
    width: var(--wui-box-size-lg);
    height: var(--wui-box-size-lg);
  }

  svg {
    width: var(--wui-box-size-lg);
    height: var(--wui-box-size-lg);
    fill: none;
    stroke: transparent;
    stroke-linecap: round;
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  use {
    stroke: var(--wui-color-accent-100);
    stroke-width: 2px;
    stroke-dasharray: 54, 118;
    stroke-dashoffset: 172;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;
var __decorate$1e = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiLoadingHexagon = class extends s$1 {
    render() {
        return x$1`
      <svg viewBox="0 0 54 59">
        <path
          id="wui-loader-path"
          d="M17.22 5.295c3.877-2.277 5.737-3.363 7.72-3.726a11.44 11.44 0 0 1 4.12 0c1.983.363 3.844 1.45 7.72 3.726l6.065 3.562c3.876 2.276 5.731 3.372 7.032 4.938a11.896 11.896 0 0 1 2.06 3.63c.683 1.928.688 4.11.688 8.663v7.124c0 4.553-.005 6.735-.688 8.664a11.896 11.896 0 0 1-2.06 3.63c-1.3 1.565-3.156 2.66-7.032 4.937l-6.065 3.563c-3.877 2.276-5.737 3.362-7.72 3.725a11.46 11.46 0 0 1-4.12 0c-1.983-.363-3.844-1.449-7.72-3.726l-6.065-3.562c-3.876-2.276-5.731-3.372-7.032-4.938a11.885 11.885 0 0 1-2.06-3.63c-.682-1.928-.688-4.11-.688-8.663v-7.124c0-4.553.006-6.735.688-8.664a11.885 11.885 0 0 1 2.06-3.63c1.3-1.565 3.156-2.66 7.032-4.937l6.065-3.562Z"
        />
        <use xlink:href="#wui-loader-path"></use>
      </svg>
    `
    }
}
;
WuiLoadingHexagon.styles = [resetStyles, styles$V],
WuiLoadingHexagon = __decorate$1e([customElement("wui-loading-hexagon")], WuiLoadingHexagon);
const styles$U = i$4`
  :host {
    display: flex;
  }

  :host([data-size='sm']) > svg {
    width: 12px;
    height: 12px;
  }

  :host([data-size='md']) > svg {
    width: 14px;
    height: 14px;
  }

  :host([data-size='lg']) > svg {
    width: 24px;
    height: 24px;
  }

  svg {
    animation: rotate 2s linear infinite;
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  circle {
    fill: none;
    stroke: var(--local-color);
    stroke-width: 4px;
    stroke-dasharray: 1, 124;
    stroke-dashoffset: 0;
    stroke-linecap: round;
    animation: dash 1.5s ease-in-out infinite;
  }

  :host([data-size='md']) > svg > circle {
    stroke-width: 6px;
  }

  :host([data-size='sm']) > svg > circle {
    stroke-width: 8px;
  }

  @keyframes rotate {
    100% {
      transform: rotate(360deg);
    }
  }

  @keyframes dash {
    0% {
      stroke-dasharray: 1, 124;
      stroke-dashoffset: 0;
    }

    50% {
      stroke-dasharray: 90, 124;
      stroke-dashoffset: -35;
    }

    100% {
      stroke-dashoffset: -125;
    }
  }
`;
var __decorate$1d = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiLoadingSpinner = class extends s$1 {
    constructor() {
        super(...arguments),
        this.color = "accent-100",
        this.size = "lg"
    }
    render() {
        return this.style.cssText = `--local-color: var(--wui-color-${this.color});`,
        this.dataset.size = this.size,
        x$1`<svg viewBox="25 25 50 50">
      <circle r="20" cy="50" cx="50"></circle>
    </svg>`
    }
}
;
WuiLoadingSpinner.styles = [resetStyles, styles$U],
__decorate$1d([n$2()], WuiLoadingSpinner.prototype, "color", void 0),
__decorate$1d([n$2()], WuiLoadingSpinner.prototype, "size", void 0),
WuiLoadingSpinner = __decorate$1d([customElement("wui-loading-spinner")], WuiLoadingSpinner);
const styles$T = i$4`
  :host {
    display: block;
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
  }

  svg {
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  rect {
    fill: none;
    stroke: var(--wui-color-accent-100);
    stroke-width: 4px;
    stroke-linecap: round;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;
var __decorate$1c = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiLoadingThumbnail = class extends s$1 {
    constructor() {
        super(...arguments),
        this.radius = 36
    }
    render() {
        return this.svgLoaderTemplate()
    }
    svgLoaderTemplate() {
        const W = this.radius > 50 ? 50 : this.radius
          , z = 36 - W;
        return x$1`
      <svg viewBox="0 0 110 110" width="110" height="110">
        <rect
          x="2"
          y="2"
          width="106"
          height="106"
          rx=${W}
          stroke-dasharray="${116 + z} ${245 + z}"
          stroke-dashoffset=${360 + 1.75 * z}
        />
      </svg>
    `
    }
}
;
WuiLoadingThumbnail.styles = [resetStyles, styles$T],
__decorate$1c([n$2({
    type: Number
})], WuiLoadingThumbnail.prototype, "radius", void 0),
WuiLoadingThumbnail = __decorate$1c([customElement("wui-loading-thumbnail")], WuiLoadingThumbnail);
const styles$S = i$4`
  :host {
    display: block;
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
    background: linear-gradient(
      120deg,
      var(--wui-color-bg-200) 5%,
      var(--wui-color-bg-200) 48%,
      var(--wui-color-bg-300) 55%,
      var(--wui-color-bg-300) 60%,
      var(--wui-color-bg-300) calc(60% + 10px),
      var(--wui-color-bg-200) calc(60% + 12px),
      var(--wui-color-bg-200) 100%
    );
    background-size: 250%;
    animation: shimmer 3s linear infinite reverse;
  }

  @keyframes shimmer {
    from {
      background-position: -250% 0;
    }
    to {
      background-position: 250% 0;
    }
  }
`;
var __decorate$1b = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiShimmer = class extends s$1 {
    constructor() {
        super(...arguments),
        this.width = "",
        this.height = "",
        this.borderRadius = "m"
    }
    render() {
        return this.style.cssText = `
      width: ${this.width};
      height: ${this.height};
      border-radius: clamp(0px,var(--wui-border-radius-${this.borderRadius}), 40px);
    `,
        x$1`<slot></slot>`
    }
}
;
WuiShimmer.styles = [styles$S],
__decorate$1b([n$2()], WuiShimmer.prototype, "width", void 0),
__decorate$1b([n$2()], WuiShimmer.prototype, "height", void 0),
__decorate$1b([n$2()], WuiShimmer.prototype, "borderRadius", void 0),
WuiShimmer = __decorate$1b([customElement("wui-shimmer")], WuiShimmer);
const t$1 = {
    ATTRIBUTE: 1,
    CHILD: 2,
    PROPERTY: 3,
    BOOLEAN_ATTRIBUTE: 4,
    EVENT: 5,
    ELEMENT: 6
}
  , e$2 = W=>(...z)=>({
    _$litDirective$: W,
    values: z
});
let i$1 = class {
    constructor(W) {}
    get _$AU() {
        return this._$AM._$AU
    }
    _$AT(W, z, Y) {
        this._$Ct = W,
        this._$AM = z,
        this._$Ci = Y
    }
    _$AS(W, z) {
        return this.update(W, z)
    }
    update(W, z) {
        return this.render(...z)
    }
}
;
const e$1 = e$2(class extends i$1 {
    constructor(W) {
        if (super(W),
        W.type !== t$1.ATTRIBUTE || W.name !== "class" || W.strings?.length > 2)
            throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.")
    }
    render(W) {
        return " " + Object.keys(W).filter(z=>W[z]).join(" ") + " "
    }
    update(W, [z]) {
        if (this.it === void 0) {
            this.it = new Set,
            W.strings !== void 0 && (this.st = new Set(W.strings.join(" ").split(/\s/).filter(ne=>ne !== "")));
            for (const ne in z)
                z[ne] && !this.st?.has(ne) && this.it.add(ne);
            return this.render(z)
        }
        const Y = W.element.classList;
        for (const ne of this.it)
            ne in z || (Y.remove(ne),
            this.it.delete(ne));
        for (const ne in z) {
            const le = !!z[ne];
            le === this.it.has(ne) || this.st?.has(ne) || (le ? (Y.add(ne),
            this.it.add(ne)) : (Y.remove(ne),
            this.it.delete(ne)))
        }
        return w$2
    }
}
)
  , styles$R = i$4`
  :host {
    display: flex !important;
  }

  slot {
    display: inline-block;
    font-style: normal;
    font-family: var(--wui-font-family);
    font-feature-settings:
      'tnum' on,
      'lnum' on,
      'case' on;
    line-height: 130%;
    font-weight: var(--wui-font-weight-regular);
    overflow: inherit;
    text-overflow: inherit;
    text-align: var(--local-align);
    color: var(--local-color);
  }

  .wui-font-large-500,
  .wui-font-large-600,
  .wui-font-large-700 {
    font-size: var(--wui-font-size-large);
    letter-spacing: var(--wui-letter-spacing-large);
  }

  .wui-font-paragraph-500,
  .wui-font-paragraph-600,
  .wui-font-paragraph-700 {
    font-size: var(--wui-font-size-paragraph);
    letter-spacing: var(--wui-letter-spacing-paragraph);
  }

  .wui-font-small-400,
  .wui-font-small-500,
  .wui-font-small-600 {
    font-size: var(--wui-font-size-small);
    letter-spacing: var(--wui-letter-spacing-small);
  }

  .wui-font-tiny-500,
  .wui-font-tiny-600 {
    font-size: var(--wui-font-size-tiny);
    letter-spacing: var(--wui-letter-spacing-tiny);
  }

  .wui-font-micro-700,
  .wui-font-micro-600 {
    font-size: var(--wui-font-size-micro);
    letter-spacing: var(--wui-letter-spacing-micro);
    text-transform: uppercase;
  }

  .wui-font-small-400 {
    font-weight: var(--wui-font-weight-light);
  }

  .wui-font-large-700,
  .wui-font-paragraph-700,
  .wui-font-micro-700 {
    font-weight: var(--wui-font-weight-bold);
  }

  .wui-font-large-600,
  .wui-font-paragraph-600,
  .wui-font-small-600,
  .wui-font-tiny-600,
  .wui-font-micro-600 {
    font-weight: var(--wui-font-weight-medium);
  }
`;
var __decorate$1a = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiText = class extends s$1 {
    constructor() {
        super(...arguments),
        this.variant = "paragraph-500",
        this.color = "fg-300",
        this.align = "left"
    }
    render() {
        const W = {
            [`wui-font-${this.variant}`]: !0,
            [`wui-color-${this.color}`]: !0
        };
        return this.style.cssText = `
      --local-align: ${this.align};
      --local-color: var(--wui-color-${this.color});
    `,
        x$1`<slot class=${e$1(W)}></slot>`
    }
}
;
WuiText.styles = [resetStyles, styles$R],
__decorate$1a([n$2()], WuiText.prototype, "variant", void 0),
__decorate$1a([n$2()], WuiText.prototype, "color", void 0),
__decorate$1a([n$2()], WuiText.prototype, "align", void 0),
WuiText = __decorate$1a([customElement("wui-text")], WuiText);
const browserSvg = b`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="30" />
  <circle cx="30" cy="30" r="3" fill="#fff" />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m45.32 17.9-.88-.42.88.42.02-.05c.1-.2.21-.44.26-.7l-.82-.15.82.16a2 2 0 0 0-.24-1.4c-.13-.23-.32-.42-.47-.57a8.42 8.42 0 0 1-.04-.04l-.04-.04a2.9 2.9 0 0 0-.56-.47l-.51.86.5-.86a2 2 0 0 0-1.4-.24c-.26.05-.5.16-.69.26l-.05.02-15.05 7.25-.1.05c-1.14.55-1.85.89-2.46 1.37a7 7 0 0 0-1.13 1.14c-.5.6-.83 1.32-1.38 2.45l-.05.11-7.25 15.05-.02.05c-.1.2-.21.43-.26.69a2 2 0 0 0 .24 1.4l.85-.5-.85.5c.13.23.32.42.47.57l.04.04.04.04c.15.15.34.34.56.47a2 2 0 0 0 1.41.24l-.2-.98.2.98c.25-.05.5-.17.69-.26l.05-.02-.42-.87.42.87 15.05-7.25.1-.05c1.14-.55 1.85-.89 2.46-1.38a7 7 0 0 0 1.13-1.13 12.87 12.87 0 0 0 1.43-2.56l7.25-15.05Z"
  />
  <path
    fill="#1DC956"
    d="M33.38 32.72 30.7 29.3 15.86 44.14l.2.2a1 1 0 0 0 1.14.2l15.1-7.27a3 3 0 0 0 1.08-4.55Z"
  />
  <path
    fill="#86F999"
    d="m26.62 27.28 2.67 3.43 14.85-14.85-.2-.2a1 1 0 0 0-1.14-.2l-15.1 7.27a3 3 0 0 0-1.08 4.55Z"
  />
  <circle cx="30" cy="30" r="3" fill="#fff" transform="rotate(45 30 30)" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
</svg> `
  , daoSvg = b`<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#clip0_7734_50402)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#EB8B47"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M19 52C24.5228 52 29 47.5228 29 42C29 36.4772 24.5228 32 19 32C13.4772 32 9 36.4772 9 42C9 47.5228 13.4772 52 19 52Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.8437 8.3264C42.4507 7.70891 41.5493 7.70891 41.1564 8.32641L28.978 27.4638C28.5544 28.1295 29.0326 29.0007 29.8217 29.0007H54.1783C54.9674 29.0007 55.4456 28.1295 55.022 27.4638L42.8437 8.3264Z"
      fill="white"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.3348 11.6456C42.659 11.7608 42.9061 12.1492 43.4005 12.926L50.7332 24.4488C51.2952 25.332 51.5763 25.7737 51.5254 26.1382C51.4915 26.3808 51.3698 26.6026 51.1833 26.7614C50.9031 27 50.3796 27 49.3327 27H34.6673C33.6204 27 33.0969 27 32.8167 26.7614C32.6302 26.6026 32.5085 26.3808 32.4746 26.1382C32.4237 25.7737 32.7048 25.332 33.2669 24.4488L40.5995 12.926C41.0939 12.1492 41.341 11.7608 41.6652 11.6456C41.8818 11.5687 42.1182 11.5687 42.3348 11.6456ZM35.0001 26.999C38.8661 26.999 42.0001 23.865 42.0001 19.999C42.0001 23.865 45.1341 26.999 49.0001 26.999H35.0001Z"
      fill="#FF974C"
    />
    <path
      d="M10.1061 9.35712C9.9973 9.67775 9.99867 10.0388 9.99978 10.3323C9.99989 10.3611 10 10.3893 10 10.4167V25.5833C10 25.6107 9.99989 25.6389 9.99978 25.6677C9.99867 25.9612 9.9973 26.3222 10.1061 26.6429C10.306 27.2317 10.7683 27.694 11.3571 27.8939C11.6777 28.0027 12.0388 28.0013 12.3323 28.0002C12.3611 28.0001 12.3893 28 12.4167 28H19C24.5228 28 29 23.5228 29 18C29 12.4772 24.5228 8 19 8H12.4167C12.3893 8 12.3611 7.99989 12.3323 7.99978C12.0388 7.99867 11.6778 7.9973 11.3571 8.10614C10.7683 8.306 10.306 8.76834 10.1061 9.35712Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="19" cy="18" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
    <circle cx="19" cy="42" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="clip0_7734_50402">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `
  , defiSvg = b`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#1DC956"
      d="M0 25.01c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02.11 15.65.11 24.9.11h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.13 60 15.76 60 25v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-3.45 1.97-8.08 1.97-17.33 1.97H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 49.1 0 44.46 0 35.21v-10.2Z"
    />
    <path
      fill="#2BEE6C"
      d="M16.1 60c-3.82-.18-6.4-.64-8.53-1.86a15 15 0 0 1-5.6-5.6C.55 50.06.16 46.97.04 41.98L4.2 40.6a4 4 0 0 0 2.48-2.39l4.65-12.4a2 2 0 0 1 2.5-1.2l2.53.84a2 2 0 0 0 2.43-1l2.96-5.94a2 2 0 0 1 3.7.32l3.78 12.58a2 2 0 0 0 3.03 1.09l3.34-2.23a2 2 0 0 0 .65-.7l5.3-9.72a2 2 0 0 1 1.42-1.01l4.14-.69a2 2 0 0 1 1.6.44l3.9 3.24a2 2 0 0 0 2.7-.12l4.62-4.63c.08 2.2.08 4.8.08 7.93v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-2.13 1.22-4.7 1.68-8.54 1.86H16.11Z"
    />
    <path
      fill="#fff"
      d="m.07 43.03-.05-2.1 3.85-1.28a3 3 0 0 0 1.86-1.79l4.66-12.4a3 3 0 0 1 3.75-1.8l2.53.84a1 1 0 0 0 1.21-.5l2.97-5.94a3 3 0 0 1 5.56.48l3.77 12.58a1 1 0 0 0 1.51.55l3.34-2.23a1 1 0 0 0 .33-.35l5.3-9.71a3 3 0 0 1 2.14-1.53l4.13-.69a3 3 0 0 1 2.41.66l3.9 3.24a1 1 0 0 0 1.34-.06l5.28-5.28c.05.85.08 1.75.1 2.73L56 22.41a3 3 0 0 1-4.04.19l-3.9-3.25a1 1 0 0 0-.8-.21l-4.13.69a1 1 0 0 0-.72.5l-5.3 9.72a3 3 0 0 1-.97 1.05l-3.34 2.23a3 3 0 0 1-4.53-1.63l-3.78-12.58a1 1 0 0 0-1.85-.16l-2.97 5.94a3 3 0 0 1-3.63 1.5l-2.53-.84a1 1 0 0 0-1.25.6l-4.65 12.4a5 5 0 0 1-3.1 3L.07 43.02Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M49.5 19a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M45 .28v59.66l-2 .1V.19c.7.02 1.37.05 2 .1Z" />
    <path fill="#2BEE6C" d="M47.5 19a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
    <path
      stroke="#fff"
      stroke-opacity=".1"
      d="M.5 25.01c0-4.63 0-8.08.24-10.8.25-2.7.73-4.64 1.66-6.28a14.5 14.5 0 0 1 5.42-5.41C9.46 1.58 11.39 1.1 14.1.85A133 133 0 0 1 24.9.61h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.67a14.5 14.5 0 0 1 5.42 5.4c.93 1.65 1.41 3.58 1.66 6.3.24 2.71.24 6.16.24 10.79v10.2c0 4.64 0 8.08-.24 10.8-.25 2.7-.73 4.65-1.66 6.28a14.5 14.5 0 0 1-5.42 5.42c-1.63.93-3.57 1.41-6.28 1.66-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.66a14.5 14.5 0 0 1-5.42-5.42C1.47 50.66 1 48.72.74 46.01A133 133 0 0 1 .5 35.2v-10.2Z"
    />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg>`
  , defiAltSvg = b`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="30" />
    <path
      fill="#E87DE8"
      d="M57.98.01v19.5a4.09 4.09 0 0 0-2.63 2.29L50.7 34.2a2 2 0 0 1-2.5 1.2l-2.53-.84a2 2 0 0 0-2.42 1l-2.97 5.94a2 2 0 0 1-3.7-.32L32.8 28.6a2 2 0 0 0-3.02-1.09l-3.35 2.23a2 2 0 0 0-.64.7l-5.3 9.72a2 2 0 0 1-1.43 1.01l-4.13.69a2 2 0 0 1-1.61-.44l-3.9-3.24a2 2 0 0 0-2.69.12L2.1 42.93.02 43V.01h57.96Z"
    />
    <path
      fill="#fff"
      d="m61.95 16.94.05 2.1-3.85 1.28a3 3 0 0 0-1.86 1.79l-4.65 12.4a3 3 0 0 1-3.76 1.8l-2.53-.84a1 1 0 0 0-1.2.5l-2.98 5.94a3 3 0 0 1-5.55-.48l-3.78-12.58a1 1 0 0 0-1.5-.55l-3.35 2.23a1 1 0 0 0-.32.35l-5.3 9.72a3 3 0 0 1-2.14 1.52l-4.14.69a3 3 0 0 1-2.41-.66l-3.9-3.24a1 1 0 0 0-1.34.06l-5.28 5.28c-.05-.84-.08-1.75-.1-2.73l3.97-3.96a3 3 0 0 1 4.04-.19l3.89 3.25a1 1 0 0 0 .8.21l4.14-.68a1 1 0 0 0 .71-.51l5.3-9.71a3 3 0 0 1 .97-1.06l3.34-2.23a3 3 0 0 1 4.54 1.63l3.77 12.58a1 1 0 0 0 1.86.16l2.96-5.93a3 3 0 0 1 3.64-1.5l2.52.83a1 1 0 0 0 1.25-.6l4.66-12.4a5 5 0 0 1 3.1-2.99l4.43-1.48Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M35.5 27a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M31 0v60h-2V0h2Z" />
    <path fill="#E87DE8" d="M33.5 27a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `
  , ethSvg = b`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#987DE8" rx="30" />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="m15.48 28.37 11.97-19.3a3 3 0 0 1 5.1 0l11.97 19.3a6 6 0 0 1 .9 3.14v.03a6 6 0 0 1-1.16 3.56L33.23 50.2a4 4 0 0 1-6.46 0L15.73 35.1a6 6 0 0 1-1.15-3.54v-.03a6 6 0 0 1 .9-3.16Z"
      clip-rule="evenodd"
    />
    <path
      fill="#643CDD"
      d="M30.84 10.11a1 1 0 0 0-.84-.46V24.5l12.6 5.53a2 2 0 0 0-.28-1.4L30.84 10.11Z"
    />
    <path
      fill="#BDADEB"
      d="M30 9.65a1 1 0 0 0-.85.46L17.66 28.64a2 2 0 0 0-.26 1.39L30 24.5V9.65Z"
    />
    <path
      fill="#643CDD"
      d="M30 50.54a1 1 0 0 0 .8-.4l11.24-15.38c.3-.44-.2-1-.66-.73l-9.89 5.68a3 3 0 0 1-1.5.4v10.43Z"
    />
    <path
      fill="#BDADEB"
      d="m17.97 34.76 11.22 15.37c.2.28.5.41.8.41V40.11a3 3 0 0 1-1.49-.4l-9.88-5.68c-.47-.27-.97.3-.65.73Z"
    />
    <path
      fill="#401AB3"
      d="M42.6 30.03 30 24.5v13.14a3 3 0 0 0 1.5-.4l10.14-5.83a2 2 0 0 0 .95-1.38Z"
    />
    <path
      fill="#7C5AE2"
      d="M30 37.64V24.46l-12.6 5.57a2 2 0 0 0 .97 1.39l10.13 5.82a3 3 0 0 0 1.5.4Z"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `
  , layersSvg = b`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="3" />
  <path
    fill="#1FAD7E"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 29.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 19.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#86F999"
    stroke="#fff"
    stroke-width="2"
    d="m46.69 21.06-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-6.32-3.51-.18-.1c-2.33-1.3-3.72-2.06-5.22-2.33a9 9 0 0 0-3.08 0c-1.5.27-2.9 1.04-5.22 2.33l-.17.1-6.33 3.51-.05.03c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45Z"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`
  , lockSvg = b`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#C653C6" rx="3" />
  <path
    fill="#fff"
    d="M20.03 15.22C20 15.6 20 16.07 20 17v2.8c0 1.14 0 1.7-.2 2.12-.15.31-.3.5-.58.71-.37.28-1.06.42-2.43.7-.59.12-1.11.29-1.6.51a9 9 0 0 0-4.35 4.36C10 30 10 32.34 10 37c0 4.66 0 7 .84 8.8a9 9 0 0 0 4.36 4.36C17 51 19.34 51 24 51h12c4.66 0 7 0 8.8-.84a9 9 0 0 0 4.36-4.36C50 44 50 41.66 50 37c0-4.66 0-7-.84-8.8a9 9 0 0 0-4.36-4.36c-.48-.22-1-.39-1.6-.5-1.36-.29-2.05-.43-2.42-.7-.27-.22-.43-.4-.58-.72-.2-.42-.2-.98-.2-2.11V17c0-.93 0-1.4-.03-1.78a9 9 0 0 0-8.19-8.19C31.4 7 30.93 7 30 7s-1.4 0-1.78.03a9 9 0 0 0-8.19 8.19Z"
  />
  <path
    fill="#E87DE8"
    d="M22 17c0-.93 0-1.4.04-1.78a7 7 0 0 1 6.18-6.18C28.6 9 29.07 9 30 9s1.4 0 1.78.04a7 7 0 0 1 6.18 6.18c.04.39.04.85.04 1.78v4.5a1.5 1.5 0 0 1-3 0V17c0-.93 0-1.4-.08-1.78a4 4 0 0 0-3.14-3.14C31.39 12 30.93 12 30 12s-1.4 0-1.78.08a4 4 0 0 0-3.14 3.14c-.08.39-.08.85-.08 1.78v4.5a1.5 1.5 0 0 1-3 0V17Z"
  />
  <path
    fill="#E87DE8"
    fill-rule="evenodd"
    d="M12 36.62c0-4.32 0-6.48.92-8.09a7 7 0 0 1 2.61-2.61C17.14 25 19.3 25 23.62 25h6.86c.46 0 .7 0 .9.02 2.73.22 4.37 2.43 4.62 4.98.27-2.7 2.11-5 5.02-5A6.98 6.98 0 0 1 48 31.98v5.4c0 4.32 0 6.48-.92 8.09a7 7 0 0 1-2.61 2.61c-1.61.92-3.77.92-8.09.92h-5.86c-.46 0-.7 0-.9-.02-2.73-.22-4.37-2.43-4.62-4.98-.26 2.58-1.94 4.82-4.71 4.99l-.7.01c-.55 0-.82 0-1.05-.02a7 7 0 0 1-6.52-6.52c-.02-.23-.02-.5-.02-1.05v-4.79Zm21.24-.27a4 4 0 1 0-6.48 0 31.28 31.28 0 0 1 1.57 2.23c.17.4.17.81.17 1.24V42.5a1.5 1.5 0 0 0 3 0V39.82c0-.43 0-.85.17-1.24.09-.2.58-.87 1.57-2.23Z"
    clip-rule="evenodd"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`
  , loginSvg = b`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#EB8B47"
      d="M0 24.9c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02 0 15.65 0 24.9 0h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.02 60 15.65 60 24.9v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6C48.98 60 44.35 60 35.1 60H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 48.98 0 44.35 0 35.1V24.9Z"
    />
    <path
      stroke="#062B2B"
      stroke-opacity=".1"
      d="M.5 24.9c0-4.64 0-8.08.24-10.8.25-2.7.73-4.65 1.66-6.28A14.5 14.5 0 0 1 7.82 2.4C9.46 1.47 11.39 1 14.1.74A133 133 0 0 1 24.9.5h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.66a14.5 14.5 0 0 1 5.42 5.42c.93 1.63 1.41 3.57 1.66 6.28.24 2.72.24 6.16.24 10.8v10.2c0 4.63 0 8.08-.24 10.8-.25 2.7-.73 4.64-1.66 6.28a14.5 14.5 0 0 1-5.42 5.41c-1.63.94-3.57 1.42-6.28 1.67-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.67a14.5 14.5 0 0 1-5.42-5.4C1.47 50.53 1 48.6.74 45.88A133 133 0 0 1 .5 35.1V24.9Z"
    />
    <path
      fill="#FF974C"
      stroke="#fff"
      stroke-width="2"
      d="M39.2 29.2a13 13 0 1 0-18.4 0l1.3 1.28a12.82 12.82 0 0 1 2.1 2.39 6 6 0 0 1 .6 1.47c.2.76.2 1.56.2 3.17v11.24c0 1.08 0 1.61.13 2.12a4 4 0 0 0 .41.98c.26.45.64.83 1.4 1.6l.3.29c.65.65.98.98 1.36 1.09.26.07.54.07.8 0 .38-.11.7-.44 1.36-1.1l3.48-3.47c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.47-.48c-.65-.65-.98-.98-1.09-1.36a1.5 1.5 0 0 1 0-.8c.1-.38.44-.7 1.1-1.36l.47-.48c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.48-.5c-.65-.64-.98-.97-1.08-1.35a1.5 1.5 0 0 1 0-.79c.1-.38.42-.7 1.06-1.36l5.46-5.55Z"
    />
    <circle cx="30" cy="17" r="4" fill="#EB8B47" stroke="#fff" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg> `
  , networkSvg$1 = b`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#00ACE6" rx="30" />
    <circle cx="64" cy="39" r="50" fill="#1AC6FF" stroke="#fff" stroke-width="2" />
    <circle cx="78" cy="30" r="50" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="72" cy="15" r="35" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-17" r="45" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-5" r="50" stroke="#fff" stroke-width="2" />
    <circle cx="30" cy="45" r="4" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="39.5" cy="27.5" r="4" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="16" cy="24" r="4" fill="#19C6FF" stroke="#fff" stroke-width="2" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg>`
  , nftSvg = b`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="3" />
    <path
      fill="#E87DE8"
      stroke="#fff"
      stroke-width="2"
      d="M52.1 47.34c0-4.24-1.44-9.55-5.9-12.4a2.86 2.86 0 0 0-1.6-3.89v-.82c0-1.19-.52-2.26-1.35-3a4.74 4.74 0 0 0-2.4-6.26v-5.5a11.31 11.31 0 1 0-22.63 0v2.15a3.34 3.34 0 0 0-1.18 5.05 4.74 4.74 0 0 0-.68 6.44A5.22 5.22 0 0 0 14 35.92c-3.06 4.13-6.1 8.3-6.1 15.64 0 2.67.37 4.86.74 6.39a20.3 20.3 0 0 0 .73 2.39l.02.04v.01l.92-.39-.92.4.26.6h38.26l.3-.49-.87-.51.86.5.02-.01.03-.07a16.32 16.32 0 0 0 .57-1.05c.36-.72.85-1.74 1.33-2.96a25.51 25.51 0 0 0 1.94-9.07Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M26.5 29.5c-3-.5-5.5-3-5.5-7v-7c0-.47 0-.7.03-.9a3 3 0 0 1 2.58-2.57c.2-.03.42-.03.89-.03 2 0 2.5-2.5 2.5-2.5s0 2.5 2.5 2.5c1.4 0 2.1 0 2.65.23a3 3 0 0 1 1.62 1.62c.23.55.23 1.25.23 2.65v6c0 4-3 7-6.5 7 1.35.23 4 0 6.5-2v9.53C34 38.5 31.5 40 28 40s-6-1.5-6-2.97L24 34l2.5 1.5v-6ZM26 47h4.5c2.5 0 3 4 3 5.5h-3l-1-1.5H26v-4Zm-6.25 5.5H24V57h-8c0-1 1-4.5 3.75-4.5Z"
      clip-rule="evenodd"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="3" /></clipPath>
  </defs>
</svg> `
  , nounSvg = b`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#794CFF" rx="3" />
  <path
    fill="#987DE8"
    stroke="#fff"
    stroke-width="2"
    d="M33 22.5v-1H16v5H8.5V36H13v-5h3v7.5h17V31h1v7.5h17v-17H34v5h-1v-4Z"
  />
  <path fill="#fff" d="M37.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M42.5 25h5v10h-5z" />
  <path fill="#fff" d="M19.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M24.5 25h5v10h-5z" />
  <path fill="#fff" d="M12 30.5h4V37h-4v-6.5Z" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`
  , profileSvg = b`<svg
  viewBox="0 0 60 60"
  fill="none"
>
  <g clip-path="url(#1)">
    <rect width="60" height="60" rx="30" fill="#00ACE6" />
    <path
      d="M59 73C59 89.0163 46.0163 102 30 102C13.9837 102 1 89.0163 1 73C1 56.9837 12 44 30 44C48 44 59 56.9837 59 73Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M18.6904 19.9015C19.6264 15.3286 23.3466 11.8445 27.9708 11.2096C29.3231 11.024 30.6751 11.0238 32.0289 11.2096C36.6532 11.8445 40.3733 15.3286 41.3094 19.9015C41.4868 20.7681 41.6309 21.6509 41.7492 22.5271C41.8811 23.5041 41.8811 24.4944 41.7492 25.4715C41.6309 26.3476 41.4868 27.2304 41.3094 28.097C40.3733 32.6699 36.6532 36.154 32.0289 36.7889C30.6772 36.9744 29.3216 36.9743 27.9708 36.7889C23.3466 36.154 19.6264 32.6699 18.6904 28.097C18.513 27.2304 18.3689 26.3476 18.2506 25.4715C18.1186 24.4944 18.1186 23.5041 18.2506 22.5271C18.3689 21.6509 18.513 20.7681 18.6904 19.9015Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="24.5" cy="23.5" r="1.5" fill="white" />
    <circle cx="35.5" cy="23.5" r="1.5" fill="white" />
    <path
      d="M31 20L28 28H32"
      stroke="white"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    />
  </g>
  <rect x="0.5" y="0.5" width="59" height="59" rx="29.5" stroke="white" stroke-opacity="0.1" />
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" rx="30" fill="white" />
    </clipPath>
  </defs>
</svg> `
  , systemSvg = b`<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#1)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#794CFF"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M35.1403 31.5016C35.1193 30.9637 35.388 30.4558 35.8446 30.1707C36.1207 29.9982 36.4761 29.8473 36.7921 29.7685C37.3143 29.6382 37.8664 29.7977 38.2386 30.1864C38.8507 30.8257 39.3004 31.6836 39.8033 32.408C40.2796 33.0942 41.4695 33.2512 41.9687 32.5047C42.4839 31.7341 42.9405 30.8229 43.572 30.1399C43.9375 29.7447 44.4866 29.5756 45.0111 29.6967C45.3283 29.7701 45.6863 29.9147 45.9655 30.0823C46.4269 30.3595 46.7045 30.8626 46.6928 31.4008C46.6731 32.3083 46.3764 33.2571 46.2158 34.1473C46.061 35.0048 46.9045 35.8337 47.7592 35.664C48.6464 35.4878 49.5899 35.1747 50.497 35.1391C51.0348 35.1181 51.5427 35.3868 51.8279 35.8433C52.0004 36.1195 52.1513 36.4749 52.2301 36.7908C52.3604 37.3131 52.2009 37.8651 51.8121 38.2374C51.1729 38.8495 50.3151 39.2991 49.5908 39.8019C48.9046 40.2782 48.7473 41.4683 49.4939 41.9675C50.2644 42.4827 51.1757 42.9393 51.8587 43.5708C52.2539 43.9362 52.423 44.4854 52.3018 45.0099C52.2285 45.3271 52.0839 45.6851 51.9162 45.9642C51.6391 46.4257 51.1359 46.7032 50.5978 46.6916C49.6903 46.6719 48.7417 46.3753 47.8516 46.2146C46.9939 46.0598 46.1648 46.9035 46.3346 47.7583C46.5108 48.6454 46.8239 49.5888 46.8594 50.4958C46.8805 51.0336 46.6117 51.5415 46.1552 51.8267C45.879 51.9992 45.5236 52.15 45.2077 52.2289C44.6854 52.3592 44.1334 52.1997 43.7611 51.8109C43.1491 51.1718 42.6996 50.314 42.1968 49.5897C41.7203 48.9034 40.5301 48.7463 40.0309 49.493C39.5157 50.2634 39.0592 51.1746 38.4278 51.8574C38.0623 52.2527 37.5132 52.4218 36.9887 52.3006C36.6715 52.2273 36.3135 52.0826 36.0343 51.915C35.5729 51.6379 35.2953 51.1347 35.307 50.5966C35.3267 49.6891 35.6233 48.7405 35.7839 47.8505C35.9388 46.9928 35.0951 46.1636 34.2402 46.3334C33.3531 46.5096 32.4098 46.8227 31.5028 46.8582C30.9649 46.8793 30.457 46.6105 30.1719 46.154C29.9994 45.8778 29.8485 45.5224 29.7697 45.2065C29.6394 44.6842 29.7989 44.1322 30.1877 43.7599C30.8269 43.1479 31.6847 42.6982 32.4091 42.1954C33.0954 41.7189 33.2522 40.5289 32.5056 40.0297C31.7351 39.5145 30.824 39.058 30.1411 38.4265C29.7459 38.0611 29.5768 37.5119 29.698 36.9875C29.7713 36.6702 29.9159 36.3122 30.0836 36.0331C30.3607 35.5717 30.8638 35.2941 31.402 35.3058C32.3095 35.3255 33.2583 35.6221 34.1485 35.7828C35.006 35.9376 35.8349 35.094 35.6652 34.2393C35.489 33.3521 35.1759 32.4087 35.1403 31.5016Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M20.7706 8.22357C20.9036 7.51411 21.5231 7 22.2449 7H23.7551C24.4769 7 25.0964 7.51411 25.2294 8.22357C25.5051 9.69403 25.4829 11.6321 27.1202 12.2606C27.3092 12.3331 27.4958 12.4105 27.6798 12.4926C29.2818 13.2072 30.6374 11.8199 31.8721 10.9752C32.4678 10.5676 33.2694 10.6421 33.7798 11.1525L34.8477 12.2204C35.3581 12.7308 35.4326 13.5323 35.025 14.128C34.1802 15.3627 32.7931 16.7183 33.5077 18.3202C33.5898 18.5043 33.6672 18.6909 33.7398 18.88C34.3683 20.5171 36.3061 20.4949 37.7764 20.7706C38.4859 20.9036 39 21.5231 39 22.2449V23.7551C39 24.4769 38.4859 25.0964 37.7764 25.2294C36.3061 25.5051 34.3685 25.483 33.7401 27.1201C33.6675 27.3093 33.59 27.4961 33.5079 27.6803C32.7934 29.282 34.1803 30.6374 35.025 31.8719C35.4326 32.4677 35.3581 33.2692 34.8477 33.7796L33.7798 34.8475C33.2694 35.3579 32.4678 35.4324 31.8721 35.0248C30.6376 34.1801 29.2823 32.7934 27.6806 33.508C27.4962 33.5903 27.3093 33.6678 27.12 33.7405C25.483 34.3688 25.5051 36.3062 25.2294 37.7764C25.0964 38.4859 24.4769 39 23.7551 39H22.2449C21.5231 39 20.9036 38.4859 20.7706 37.7764C20.4949 36.3062 20.517 34.3688 18.88 33.7405C18.6908 33.6678 18.5039 33.5903 18.3196 33.5081C16.7179 32.7936 15.3625 34.1804 14.1279 35.0251C13.5322 35.4327 12.7307 35.3582 12.2203 34.8478L11.1524 33.7799C10.642 33.2695 10.5675 32.4679 10.9751 31.8722C11.8198 30.6376 13.2067 29.2822 12.4922 27.6804C12.41 27.4962 12.3325 27.3093 12.2599 27.1201C11.6315 25.483 9.69392 25.5051 8.22357 25.2294C7.51411 25.0964 7 24.4769 7 23.7551V22.2449C7 21.5231 7.51411 20.9036 8.22357 20.7706C9.69394 20.4949 11.6317 20.5171 12.2602 18.88C12.3328 18.6909 12.4103 18.5042 12.4924 18.3201C13.207 16.7181 11.8198 15.3625 10.975 14.1278C10.5674 13.5321 10.6419 12.7305 11.1523 12.2201L12.2202 11.1522C12.7306 10.6418 13.5322 10.5673 14.1279 10.9749C15.3626 11.8197 16.7184 13.2071 18.3204 12.4925C18.5044 12.4105 18.6909 12.3331 18.8799 12.2606C20.5171 11.6321 20.4949 9.69403 20.7706 8.22357Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="23" cy="23" r="6" fill="#794CFF" stroke="white" stroke-width="2" />
    <circle cx="41" cy="41" r="4" fill="#794CFF" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `
  , styles$Q = i$4`
  :host {
    display: block;
    width: 55px;
    height: 55px;
  }
`;
var __decorate$19 = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
const svgOptions = {
    browser: browserSvg,
    dao: daoSvg,
    defi: defiSvg,
    defiAlt: defiAltSvg,
    eth: ethSvg,
    layers: layersSvg,
    lock: lockSvg,
    login: loginSvg,
    network: networkSvg$1,
    nft: nftSvg,
    noun: nounSvg,
    profile: profileSvg,
    system: systemSvg
};
let WuiVisual = class extends s$1 {
    constructor() {
        super(...arguments),
        this.name = "browser"
    }
    render() {
        return x$1`${svgOptions[this.name]}`
    }
}
;
WuiVisual.styles = [resetStyles, styles$Q],
__decorate$19([n$2()], WuiVisual.prototype, "name", void 0),
WuiVisual = __decorate$19([customElement("wui-visual")], WuiVisual);
const o$2 = W=>W ?? T$1
  , UiHelperUtil = {
    getSpacingStyles: (W,z)=>Array.isArray(W) ? W[z] ? `var(--wui-spacing-${W[z]})` : void 0 : typeof W == "string" ? `var(--wui-spacing-${W})` : void 0,
    getFormattedDate: W=>new Intl.DateTimeFormat("en-US",{
        month: "short",
        day: "numeric"
    }).format(W),
    getHostName: W=>new URL(W).hostname,
    getTruncateString: ({string: W, charsStart: z, charsEnd: Y, truncate: ne})=>W.length <= z + Y ? W : ne === "end" ? `${W.substring(0, z)}...` : ne === "start" ? `...${W.substring(W.length - Y)}` : `${W.substring(0, Math.floor(z))}...${W.substring(W.length - Math.floor(Y))}`,
    generateAvatarColors(W) {
        const z = W.toLowerCase().replace(/^0x/iu, "").substring(0, 6)
          , Y = this.hexToRgb(z)
          , ne = [];
        for (let le = 0; le < 5; le += 1) {
            const ue = this.tintColor(Y, .15 * le);
            ne.push(`rgb(${ue[0]}, ${ue[1]}, ${ue[2]})`)
        }
        return `
    --local-color-1: ${ne[0]};
    --local-color-2: ${ne[1]};
    --local-color-3: ${ne[2]};
    --local-color-4: ${ne[3]};
    --local-color-5: ${ne[4]};
   `
    },
    hexToRgb(W) {
        const z = parseInt(W, 16);
        return [z >> 16 & 255, z >> 8 & 255, 255 & z]
    },
    tintColor(W, z) {
        const [Y,ne,le] = W;
        return [Math.round(Y + (255 - Y) * z), Math.round(ne + (255 - ne) * z), Math.round(le + (255 - le) * z)]
    },
    isNumber: W=>/^[0-9]+$/u.test(W),
    getColorTheme: W=>W || (typeof window < "u" && window.matchMedia ? window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light" : "dark")
}
  , styles$P = i$4`
  :host {
    display: flex;
    width: inherit;
    height: inherit;
  }
`;
var __decorate$18 = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiFlex = class extends s$1 {
    render() {
        return this.style.cssText = `
      flex-direction: ${this.flexDirection};
      flex-wrap: ${this.flexWrap};
      flex-basis: ${this.flexBasis};
      flex-grow: ${this.flexGrow};
      flex-shrink: ${this.flexShrink};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 3)};
    `,
        x$1`<slot></slot>`
    }
}
;
WuiFlex.styles = [resetStyles, styles$P],
__decorate$18([n$2()], WuiFlex.prototype, "flexDirection", void 0),
__decorate$18([n$2()], WuiFlex.prototype, "flexWrap", void 0),
__decorate$18([n$2()], WuiFlex.prototype, "flexBasis", void 0),
__decorate$18([n$2()], WuiFlex.prototype, "flexGrow", void 0),
__decorate$18([n$2()], WuiFlex.prototype, "flexShrink", void 0),
__decorate$18([n$2()], WuiFlex.prototype, "alignItems", void 0),
__decorate$18([n$2()], WuiFlex.prototype, "justifyContent", void 0),
__decorate$18([n$2()], WuiFlex.prototype, "columnGap", void 0),
__decorate$18([n$2()], WuiFlex.prototype, "rowGap", void 0),
__decorate$18([n$2()], WuiFlex.prototype, "gap", void 0),
__decorate$18([n$2()], WuiFlex.prototype, "padding", void 0),
__decorate$18([n$2()], WuiFlex.prototype, "margin", void 0),
WuiFlex = __decorate$18([customElement("wui-flex")], WuiFlex);
const styles$O = i$4`
  :host {
    display: block;
    width: 64px;
    height: 64px;
    border-radius: var(--wui-border-radius-3xl);
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    overflow: hidden;
    position: relative;
  }

  :host([data-variant='generated']) {
    --mixed-local-color-1: var(--local-color-1);
    --mixed-local-color-2: var(--local-color-2);
    --mixed-local-color-3: var(--local-color-3);
    --mixed-local-color-4: var(--local-color-4);
    --mixed-local-color-5: var(--local-color-5);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host([data-variant='generated']) {
      --mixed-local-color-1: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-1)
      );
      --mixed-local-color-2: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-2)
      );
      --mixed-local-color-3: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-3)
      );
      --mixed-local-color-4: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-4)
      );
      --mixed-local-color-5: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-5)
      );
    }
  }

  :host([data-variant='generated']) {
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    background: radial-gradient(
      75.29% 75.29% at 64.96% 24.36%,
      #fff 0.52%,
      var(--mixed-local-color-5) 31.25%,
      var(--mixed-local-color-3) 51.56%,
      var(--mixed-local-color-2) 65.63%,
      var(--mixed-local-color-1) 82.29%,
      var(--mixed-local-color-4) 100%
    );
  }

  :host([data-variant='default']) {
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    background: radial-gradient(
      75.29% 75.29% at 64.96% 24.36%,
      #fff 0.52%,
      #f5ccfc 31.25%,
      #dba4f5 51.56%,
      #9a8ee8 65.63%,
      #6493da 82.29%,
      #6ebdea 100%
    );
  }
`;
var __decorate$17 = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiAvatar = class extends s$1 {
    constructor() {
        super(...arguments),
        this.imageSrc = void 0,
        this.alt = void 0,
        this.address = void 0
    }
    render() {
        return x$1`${this.visualTemplate()}`
    }
    visualTemplate() {
        if (this.imageSrc)
            return this.dataset.variant = "image",
            x$1`<wui-image src=${this.imageSrc} alt=${this.alt ?? "avatar"}></wui-image>`;
        if (this.address) {
            this.dataset.variant = "generated";
            const W = UiHelperUtil.generateAvatarColors(this.address);
            return this.style.cssText = W,
            null
        }
        return this.dataset.variant = "default",
        null
    }
}
;
WuiAvatar.styles = [resetStyles, styles$O],
__decorate$17([n$2()], WuiAvatar.prototype, "imageSrc", void 0),
__decorate$17([n$2()], WuiAvatar.prototype, "alt", void 0),
__decorate$17([n$2()], WuiAvatar.prototype, "address", void 0),
WuiAvatar = __decorate$17([customElement("wui-avatar")], WuiAvatar);
const styles$N = i$4`
  :host {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    position: relative;
    overflow: hidden;
    background-color: var(--wui-gray-glass-020);
    border-radius: var(--local-border-radius);
    box-shadow: 0 0 0 1px var(--local-border);
    width: var(--local-size);
    height: var(--local-size);
    min-height: var(--local-size);
    min-width: var(--local-size);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host {
      background-color: color-mix(in srgb, var(--local-bg-value) var(--local-bg-mix), transparent);
    }
  }
`;
var __decorate$16 = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiIconBox = class extends s$1 {
    constructor() {
        super(...arguments),
        this.size = "md",
        this.backgroundColor = "accent-100",
        this.iconColor = "accent-100",
        this.background = "transparent",
        this.border = !1,
        this.borderColor = "wui-color-bg-125",
        this.icon = "copy"
    }
    render() {
        const W = this.iconSize || this.size
          , z = this.size === "lg"
          , Y = z ? "12%" : "16%"
          , ne = z ? "xxs" : "3xl"
          , le = this.background === "gray"
          , ue = this.background === "opaque"
          , de = this.backgroundColor === "accent-100" && ue || this.backgroundColor === "success-100" && ue || this.backgroundColor === "error-100" && ue || this.backgroundColor === "inverse-100" && ue;
        let he = `var(--wui-color-${this.backgroundColor})`;
        return de ? he = `var(--wui-icon-box-bg-${this.backgroundColor})` : le && (he = `var(--wui-gray-${this.backgroundColor})`),
        this.style.cssText = `
       --local-bg-value: ${he};
       --local-bg-mix: ${de || le ? "100%" : Y};
       --local-border-radius: var(--wui-border-radius-${ne});
       --local-size: var(--wui-icon-box-size-${this.size});
       --local-border: ${this.borderColor === "wui-color-bg-125" ? "2px" : "1px"} solid ${this.border ? `var(--${this.borderColor})` : "transparent"}
   `,
        x$1` <wui-icon color=${this.iconColor} size=${W} name=${this.icon}></wui-icon> `
    }
}
;
WuiIconBox.styles = [resetStyles, elementStyles, styles$N],
__decorate$16([n$2()], WuiIconBox.prototype, "size", void 0),
__decorate$16([n$2()], WuiIconBox.prototype, "backgroundColor", void 0),
__decorate$16([n$2()], WuiIconBox.prototype, "iconColor", void 0),
__decorate$16([n$2()], WuiIconBox.prototype, "iconSize", void 0),
__decorate$16([n$2()], WuiIconBox.prototype, "background", void 0),
__decorate$16([n$2({
    type: Boolean
})], WuiIconBox.prototype, "border", void 0),
__decorate$16([n$2()], WuiIconBox.prototype, "borderColor", void 0),
__decorate$16([n$2()], WuiIconBox.prototype, "icon", void 0),
WuiIconBox = __decorate$16([customElement("wui-icon-box")], WuiIconBox);
const styles$M = i$4`
  :host {
    display: block;
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
    background: var(--wui-gray-glass-002);
    display: flex;
    gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) var(--wui-spacing-3xs)
      var(--wui-spacing-xs);
    border: 1px solid var(--wui-gray-glass-005);
  }

  button:disabled {
    background: var(--wui-gray-glass-015);
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-flex > wui-text {
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-image,
  button:disabled > wui-icon-box,
  button:disabled > wui-flex > wui-avatar {
    filter: grayscale(1);
  }

  button:has(wui-image) {
    padding: var(--wui-spacing-3xs) var(--wui-spacing-3xs) var(--wui-spacing-3xs)
      var(--wui-spacing-xs);
  }

  wui-text {
    color: var(--wui-color-fg-100);
  }

  wui-flex > wui-text {
    color: var(--wui-color-fg-200);
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
  }

  wui-image,
  wui-icon-box {
    border-radius: var(--wui-border-radius-3xl);
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }

  wui-flex {
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-005);
    background: var(--wui-gray-glass-005);
    padding: 4px var(--wui-spacing-m) 4px var(--wui-spacing-xxs);
  }

  wui-flex.local-no-balance {
    border-radius: 0px;
    border: none;
    background: transparent;
  }

  wui-avatar {
    width: 20px;
    height: 20px;
    box-shadow: 0 0 0 2px var(--wui-accent-glass-010);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled > wui-flex > wui-text {
      color: var(--wui-color-fg-175);
    }

    button:active:enabled > wui-flex > wui-text {
      color: var(--wui-color-fg-175);
    }
  }
`;
var __decorate$15 = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiAccountButton = class extends s$1 {
    constructor() {
        super(...arguments),
        this.networkSrc = void 0,
        this.avatarSrc = void 0,
        this.balance = void 0,
        this.disabled = !1,
        this.isProfileName = !1,
        this.address = ""
    }
    render() {
        return x$1`
      <button ?disabled=${this.disabled}>
        ${this.balanceTemplate()}
        <wui-flex
          gap="xxs"
          alignItems="center"
          class=${o$2(this.balance ? void 0 : "local-no-balance")}
        >
          <wui-avatar
            .imageSrc=${this.avatarSrc}
            alt=${this.address}
            address=${this.address}
          ></wui-avatar>
          <wui-text variant="paragraph-600" color="inherit">
            ${UiHelperUtil.getTruncateString({
            string: this.address,
            charsStart: this.isProfileName ? 18 : 4,
            charsEnd: this.isProfileName ? 0 : 6,
            truncate: this.isProfileName ? "end" : "middle"
        })}
          </wui-text>
        </wui-flex>
      </button>
    `
    }
    balanceTemplate() {
        if (this.balance) {
            const W = this.networkSrc ? x$1`<wui-image src=${this.networkSrc}></wui-image>` : x$1`
            <wui-icon-box
              size="sm"
              iconColor="fg-200"
              backgroundColor="fg-300"
              icon="networkPlaceholder"
            ></wui-icon-box>
          `;
            return x$1`
        ${W}
        <wui-text variant="paragraph-600" color="inherit"> ${this.balance} </wui-text>
      `
        }
        return null
    }
}
;
WuiAccountButton.styles = [resetStyles, elementStyles, styles$M],
__decorate$15([n$2()], WuiAccountButton.prototype, "networkSrc", void 0),
__decorate$15([n$2()], WuiAccountButton.prototype, "avatarSrc", void 0),
__decorate$15([n$2()], WuiAccountButton.prototype, "balance", void 0),
__decorate$15([n$2({
    type: Boolean
})], WuiAccountButton.prototype, "disabled", void 0),
__decorate$15([n$2({
    type: Boolean
})], WuiAccountButton.prototype, "isProfileName", void 0),
__decorate$15([n$2()], WuiAccountButton.prototype, "address", void 0),
WuiAccountButton = __decorate$15([customElement("wui-account-button")], WuiAccountButton);
const styles$L = i$4`
  :host {
    position: relative;
    border-radius: inherit;
    overflow: hidden;
    background-color: var(--wui-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-size);
    height: var(--local-size);
    border-radius: var(--local-border-radius);
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  :host([name='Extension'])::after {
    border: 1px solid var(--wui-accent-glass-010);
  }

  :host([data-wallet-icon='allWallets']) {
    background-color: var(--wui-all-wallets-bg-100);
  }

  :host([data-wallet-icon='allWallets'])::after {
    border: 1px solid var(--wui-accent-glass-010);
  }

  wui-icon[data-parent-size='inherit'] {
    width: 75%;
    height: 75%;
    align-items: center;
  }

  wui-icon[data-parent-size='sm'] {
    width: 18px;
    height: 18px;
  }

  wui-icon[data-parent-size='md'] {
    width: 24px;
    height: 24px;
  }

  wui-icon[data-parent-size='lg'] {
    width: 42px;
    height: 42px;
  }

  wui-icon[data-parent-size='full'] {
    width: 100%;
    height: 100%;
  }
`;
var __decorate$14 = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiWalletImage = class extends s$1 {
    constructor() {
        super(...arguments),
        this.size = "md",
        this.name = ""
    }
    render() {
        let W = "xxs";
        return W = this.size === "lg" ? "m" : this.size === "md" ? "xs" : "xxs",
        this.style.cssText = `
       --local-border-radius: var(--wui-border-radius-${W});
       --local-size: var(--wui-wallet-image-size-${this.size});
   `,
        this.walletIcon && (this.dataset.walletIcon = this.walletIcon),
        x$1` ${this.templateVisual()}`
    }
    templateVisual() {
        return this.imageSrc ? x$1`<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>` : this.walletIcon ? x$1`<wui-icon
        data-parent-size="md"
        size="md"
        color="inherit"
        name=${this.walletIcon}
      ></wui-icon>` : x$1`<wui-icon
      data-parent-size=${this.size}
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></wui-icon>`
    }
}
;
WuiWalletImage.styles = [resetStyles, styles$L],
__decorate$14([n$2()], WuiWalletImage.prototype, "size", void 0),
__decorate$14([n$2()], WuiWalletImage.prototype, "name", void 0),
__decorate$14([n$2()], WuiWalletImage.prototype, "imageSrc", void 0),
__decorate$14([n$2()], WuiWalletImage.prototype, "walletIcon", void 0),
WuiWalletImage = __decorate$14([customElement("wui-wallet-image")], WuiWalletImage);
const styles$K = i$4`
  :host {
    position: relative;
    border-radius: var(--wui-border-radius-xxs);
    width: 40px;
    height: 40px;
    overflow: hidden;
    background: var(--wui-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    gap: var(--wui-spacing-4xs);
    padding: 3.75px !important;
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  :host > wui-wallet-image {
    width: 14px;
    height: 14px;
    border-radius: var(--wui-border-radius-5xs);
  }
`;
var __decorate$13 = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
const TOTAL_IMAGES = 4;
let WuiAllWalletsImage = class extends s$1 {
    constructor() {
        super(...arguments),
        this.walletImages = []
    }
    render() {
        const W = this.walletImages.length < TOTAL_IMAGES;
        return x$1`${this.walletImages.slice(0, TOTAL_IMAGES).map(({src: z, walletName: Y})=>x$1`
          <wui-wallet-image
            size="inherit"
            imageSrc=${z}
            name=${o$2(Y)}
          ></wui-wallet-image>
        `)}
    ${W ? [...Array(TOTAL_IMAGES - this.walletImages.length)].map(()=>x$1` <wui-wallet-image size="inherit" name=""></wui-wallet-image>`) : null}`
    }
}
;
WuiAllWalletsImage.styles = [resetStyles, styles$K],
__decorate$13([n$2({
    type: Array
})], WuiAllWalletsImage.prototype, "walletImages", void 0),
WuiAllWalletsImage = __decorate$13([customElement("wui-all-wallets-image")], WuiAllWalletsImage);
const styles$J = i$4`
  :host {
    width: var(--local-width);
    position: relative;
  }

  button {
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-m);
    width: var(--local-width);
  }

  button:disabled {
    border: 1px solid var(--wui-gray-glass-010);
  }

  button[data-size='sm'] {
    padding: 6px 12px;
  }

  ::slotted(*) {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  button > wui-text {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  button[data-size='md'] {
    padding: 9px var(--wui-spacing-l) 9px var(--wui-spacing-l);
  }

  wui-loading-spinner {
    position: absolute;
    left: 50%;
    top: 50%;
    transition: all 200ms ease-in-out;
    transform: translate(-50%, -50%);
    opacity: var(--local-opacity-000);
  }
`;
var __decorate$12 = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiButton = class extends s$1 {
    constructor() {
        super(...arguments),
        this.size = "md",
        this.disabled = !1,
        this.fullWidth = !1,
        this.loading = !1,
        this.variant = "fill"
    }
    render() {
        this.style.cssText = `
    --local-width: ${this.fullWidth ? "100%" : "auto"};
    --local-opacity-100: ${this.loading ? 0 : 1};
    --local-opacity-000: ${this.loading ? 1 : 0};`;
        const W = this.size === "md" ? "paragraph-600" : "small-600";
        return x$1`
      <button
        data-variant=${this.variant}
        data-size=${this.size}
        ?disabled=${this.disabled || this.loading}
        ontouchstart
      >
        ${this.loadingTemplate()}
        <slot name="iconLeft"></slot>
        <wui-text variant=${W} color="inherit">
          <slot></slot>
        </wui-text>
        <slot name="iconRight"></slot>
      </button>
    `
    }
    loadingTemplate() {
        return this.loading ? x$1`<wui-loading-spinner color="fg-300"></wui-loading-spinner>` : x$1``
    }
}
;
WuiButton.styles = [resetStyles, elementStyles, styles$J],
__decorate$12([n$2()], WuiButton.prototype, "size", void 0),
__decorate$12([n$2({
    type: Boolean
})], WuiButton.prototype, "disabled", void 0),
__decorate$12([n$2({
    type: Boolean
})], WuiButton.prototype, "fullWidth", void 0),
__decorate$12([n$2({
    type: Boolean
})], WuiButton.prototype, "loading", void 0),
__decorate$12([n$2()], WuiButton.prototype, "variant", void 0),
WuiButton = __decorate$12([customElement("wui-button")], WuiButton);
const networkSvg = b`<svg  viewBox="0 0 48 54" fill="none">
  <path
    d="M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z"
  />
</svg>`
  , styles$I = i$4`
  :host {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) 10px;
    background-color: var(--wui-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
    position: relative;
  }

  wui-shimmer[data-type='network'] {
    border: none;
    -webkit-clip-path: var(--wui-path-network);
    clip-path: var(--wui-path-network);
  }

  svg {
    position: absolute;
    width: 48px;
    height: 54px;
    z-index: 1;
  }

  svg > path {
    stroke: var(--wui-gray-glass-010);
    stroke-width: 1px;
  }
`;
var __decorate$11 = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiCardSelectLoader = class extends s$1 {
    constructor() {
        super(...arguments),
        this.type = "wallet"
    }
    render() {
        return x$1`
      ${this.shimmerTemplate()}
      <wui-shimmer width="56px" height="20px" borderRadius="xs"></wui-shimmer>
    `
    }
    shimmerTemplate() {
        return this.type === "network" ? x$1` <wui-shimmer
          data-type=${this.type}
          width="48px"
          height="54px"
          borderRadius="xs"
        ></wui-shimmer>
        ${networkSvg}` : x$1`<wui-shimmer width="56px" height="56px" borderRadius="xs"></wui-shimmer>`
    }
}
;
WuiCardSelectLoader.styles = [resetStyles, elementStyles, styles$I],
__decorate$11([n$2()], WuiCardSelectLoader.prototype, "type", void 0),
WuiCardSelectLoader = __decorate$11([customElement("wui-card-select-loader")], WuiCardSelectLoader);
const networkLgSvg = b`<svg width="86" height="96" fill="none">
  <path
    d="M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z"
  />
</svg>`
  , styles$H = i$4`
  :host {
    position: relative;
    border-radius: inherit;
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-width);
    height: var(--local-height);
  }

  svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    fill: var(--wui-gray-glass-002);
  }

  svg > path {
    stroke: var(--local-stroke);
    transition: stroke var(--wui-ease-out-power-1) var(--wui-duration-lg);
  }

  wui-image {
    width: 100%;
    height: 100%;
    -webkit-clip-path: var(--local-path);
    clip-path: var(--local-path);
    background: var(--wui-gray-glass-002);
  }

  wui-icon {
    transform: translateY(-5%);
    width: var(--local-icon-size);
    height: var(--local-icon-size);
  }
`;
var __decorate$10 = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiNetworkImage = class extends s$1 {
    constructor() {
        super(...arguments),
        this.size = "md",
        this.name = "uknown",
        this.selected = !1
    }
    render() {
        const W = this.size === "lg";
        return this.style.cssText = `
      --local-stroke: ${this.selected ? "var(--wui-color-accent-100)" : "var(--wui-gray-glass-010)"};
      --local-path: ${W ? "var(--wui-path-network-lg)" : "var(--wui-path-network)"};
      --local-width: ${W ? "86px" : "48px"};
      --local-height: ${W ? "96px" : "54px"};
      --local-icon-size: ${W ? "42px" : "24px"};
    `,
        x$1`${this.templateVisual()} ${W ? networkLgSvg : networkSvg}`
    }
    templateVisual() {
        return this.imageSrc ? x$1`<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>` : x$1`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`
    }
}
;
WuiNetworkImage.styles = [resetStyles, styles$H],
__decorate$10([n$2()], WuiNetworkImage.prototype, "size", void 0),
__decorate$10([n$2()], WuiNetworkImage.prototype, "name", void 0),
__decorate$10([n$2()], WuiNetworkImage.prototype, "imageSrc", void 0),
__decorate$10([n$2({
    type: Boolean
})], WuiNetworkImage.prototype, "selected", void 0),
WuiNetworkImage = __decorate$10([customElement("wui-network-image")], WuiNetworkImage);
const styles$G = i$4`
  button {
    flex-direction: column;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) var(--wui-spacing-0);
    background-color: var(--wui-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
  }

  button > wui-text {
    color: var(--wui-color-fg-100);
    max-width: 64px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    justify-content: center;
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  [data-selected='true'] {
    background-color: var(--wui-accent-glass-020);
  }

  @media (hover: hover) and (pointer: fine) {
    [data-selected='true']:hover:enabled {
      background-color: var(--wui-accent-glass-015);
    }
  }

  [data-selected='true']:active:enabled {
    background-color: var(--wui-accent-glass-010);
  }
`;
var __decorate$$ = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiCardSelect = class extends s$1 {
    constructor() {
        super(...arguments),
        this.name = "Unknown",
        this.type = "wallet",
        this.imageSrc = void 0,
        this.disabled = !1,
        this.selected = !1
    }
    render() {
        return x$1`
      <button data-selected=${o$2(this.selected)} ?disabled=${this.disabled} ontouchstart>
        ${this.imageTemplate()}
        <wui-text variant="tiny-500" color=${this.selected ? "accent-100" : "inherit"}>
          ${this.name}
        </wui-text>
      </button>
    `
    }
    imageTemplate() {
        return this.type === "network" ? x$1`
        <wui-network-image
          .selected=${this.selected}
          imageSrc=${o$2(this.imageSrc)}
          name=${this.name}
        >
        </wui-network-image>
      ` : x$1`
      <wui-wallet-image size="md" imageSrc=${o$2(this.imageSrc)} name=${this.name}>
      </wui-wallet-image>
    `
    }
}
;
WuiCardSelect.styles = [resetStyles, elementStyles, styles$G],
__decorate$$([n$2()], WuiCardSelect.prototype, "name", void 0),
__decorate$$([n$2()], WuiCardSelect.prototype, "type", void 0),
__decorate$$([n$2()], WuiCardSelect.prototype, "imageSrc", void 0),
__decorate$$([n$2({
    type: Boolean
})], WuiCardSelect.prototype, "disabled", void 0),
__decorate$$([n$2({
    type: Boolean
})], WuiCardSelect.prototype, "selected", void 0),
WuiCardSelect = __decorate$$([customElement("wui-card-select")], WuiCardSelect);
const styles$F = i$4`
  a {
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-image {
    border-radius: var(--wui-border-radius-3xl);
    overflow: hidden;
  }

  a.disabled > wui-icon,
  a.disabled > wui-image {
    filter: grayscale(1);
  }

  a[data-variant='fill'] {
    color: var(--wui-color-inverse-100);
    background-color: var(--wui-color-accent-100);
  }

  a[data-variant='shade'] {
    background-color: transparent;
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  a[data-variant='transparent'] {
    column-gap: var(--wui-spacing-xxs);
    background-color: transparent;
    padding: 7px var(--wui-spacing-s) 7px 10px;
    color: var(--wui-color-fg-150);
  }

  a[data-variant='transparent']:has(wui-text:first-child) {
    padding: 7px var(--wui-spacing-s);
  }

  a[data-variant='fill'],
  a[data-variant='shade'] {
    column-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-xxs)
      var(--wui-spacing-xs);
  }

  a[data-variant='fill']:has(wui-text:first-child),
  a[data-variant='shade']:has(wui-text:first-child) {
    padding: 8.5px var(--wui-spacing-m) 9.5px var(--wui-spacing-m);
  }

  a[data-variant='fill'] > wui-image,
  a[data-variant='shade'] > wui-image {
    width: 24px;
    height: 24px;
  }

  a[data-variant='fill'] > wui-image {
    border: 1px solid var(--wui-color-accent-090);
  }

  a[data-variant='shade'] > wui-image {
    border: 1px solid var(--wui-gray-glass-010);
  }

  a[data-variant='fill'] > wui-icon,
  a[data-variant='shade'] > wui-icon {
    width: 14px;
    height: 14px;
  }

  a[data-variant='transparent'] > wui-image {
    width: 14px;
    height: 14px;
  }

  a[data-variant='transparent'] > wui-icon {
    width: 12px;
    height: 12px;
  }

  a[data-variant='fill']:focus-visible {
    background-color: var(--wui-color-accent-090);
  }

  a[data-variant='shade']:focus-visible {
    background-color: var(--wui-gray-glass-015);
  }

  a[data-variant='transparent']:focus-visible {
    background-color: var(--wui-gray-glass-005);
  }

  a.disabled {
    color: var(--wui-gray-glass-015);
    background-color: var(--wui-gray-glass-015);
    pointer-events: none;
  }

  @media (hover: hover) and (pointer: fine) {
    a[data-variant='fill']:hover {
      background-color: var(--wui-color-accent-090);
    }

    a[data-variant='shade']:hover {
      background-color: var(--wui-gray-glass-015);
    }

    a[data-variant='transparent']:hover {
      background-color: var(--wui-gray-glass-005);
    }
  }

  a[data-variant='fill']:active {
    background-color: var(--wui-color-accent-080);
  }

  a[data-variant='shade']:active {
    background-color: var(--wui-gray-glass-020);
  }

  a[data-variant='transparent']:active {
    background-color: var(--wui-gray-glass-010);
  }
`;
var __decorate$_ = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiChip = class extends s$1 {
    constructor() {
        super(...arguments),
        this.variant = "fill",
        this.imageSrc = void 0,
        this.disabled = !1,
        this.icon = "externalLink",
        this.href = ""
    }
    render() {
        const W = this.variant === "transparent" ? "small-600" : "paragraph-600";
        return x$1`
      <a
        rel="noreferrer"
        target="_blank"
        href=${this.href}
        class=${this.disabled ? "disabled" : ""}
        data-variant=${this.variant}
      >
        ${this.imageTemplate()}
        <wui-text variant=${W} color="inherit">
          ${UiHelperUtil.getHostName(this.href)}
        </wui-text>
        <wui-icon name=${this.icon} color="inherit" size="inherit"></wui-icon>
      </a>
    `
    }
    imageTemplate() {
        return this.imageSrc ? x$1`<wui-image src=${this.imageSrc}></wui-image>` : null
    }
}
;
WuiChip.styles = [resetStyles, elementStyles, styles$F],
__decorate$_([n$2()], WuiChip.prototype, "variant", void 0),
__decorate$_([n$2()], WuiChip.prototype, "imageSrc", void 0),
__decorate$_([n$2({
    type: Boolean
})], WuiChip.prototype, "disabled", void 0),
__decorate$_([n$2()], WuiChip.prototype, "icon", void 0),
__decorate$_([n$2()], WuiChip.prototype, "href", void 0),
WuiChip = __decorate$_([customElement("wui-chip")], WuiChip);
const styles$E = i$4`
  :host {
    position: relative;
    display: block;
  }

  button {
    background: var(--wui-color-accent-100);
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-m);
    gap: var(--wui-spacing-xs);
  }

  button.loading {
    background: var(--wui-gray-glass-010);
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    border: 1px solid var(--wui-gray-glass-010);
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button:active:enabled {
      background-color: var(--wui-color-accent-080);
    }
  }

  button:focus-visible {
    border: 1px solid var(--wui-gray-glass-010);
    background-color: var(--wui-color-accent-090);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  button[data-size='sm'] {
    padding: 6.75px 10px 7.25px;
  }

  ::slotted(*) {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  button > wui-text {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
    color: var(--wui-color-inverse-100);
  }

  button[data-size='md'] {
    padding: 9px var(--wui-spacing-l) 9px var(--wui-spacing-l);
  }

  button[data-size='md'] + wui-text {
    padding-left: var(--wui-spacing-3xs);
  }

  wui-loading-spinner {
    width: 14px;
    height: 14px;
  }

  wui-loading-spinner::slotted(svg) {
    width: 10px !important;
    height: 10px !important;
  }

  button[data-size='sm'] > wui-loading-spinner {
    width: 12px;
    height: 12px;
  }
`;
var __decorate$Z = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiConnectButton = class extends s$1 {
    constructor() {
        super(...arguments),
        this.size = "md",
        this.loading = !1
    }
    render() {
        const W = this.size === "md" ? "paragraph-600" : "small-600";
        return x$1`
      <button data-size=${this.size} ?disabled=${this.loading} ontouchstart>
        ${this.loadingTemplate()}
        <wui-text variant=${W} color=${this.loading ? "accent-100" : "inherit"}>
          <slot></slot>
        </wui-text>
      </button>
    `
    }
    loadingTemplate() {
        return this.loading ? x$1`<wui-loading-spinner size=${this.size} color="accent-100"></wui-loading-spinner>` : null
    }
}
;
WuiConnectButton.styles = [resetStyles, elementStyles, styles$E],
__decorate$Z([n$2()], WuiConnectButton.prototype, "size", void 0),
__decorate$Z([n$2({
    type: Boolean
})], WuiConnectButton.prototype, "loading", void 0),
WuiConnectButton = __decorate$Z([customElement("wui-connect-button")], WuiConnectButton);
const styles$D = i$4`
  wui-flex {
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;
var __decorate$Y = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiCtaButton = class extends s$1 {
    constructor() {
        super(...arguments),
        this.disabled = !1,
        this.label = "",
        this.buttonLabel = ""
    }
    render() {
        return x$1`
      <wui-flex
        justifyContent="space-between"
        alignItems="center"
        .padding=${["1xs", "2l", "1xs", "2l"]}
      >
        <wui-text variant="paragraph-500" colo="fg-200">${this.label}</wui-text>
        <wui-button size="sm" variant="accent">
          ${this.buttonLabel}
          <wui-icon size="sm" color="inherit" slot="iconRight" name="chevronRight"></wui-icon>
        </wui-button>
      </wui-flex>
    `
    }
}
;
WuiCtaButton.styles = [resetStyles, elementStyles, styles$D],
__decorate$Y([n$2({
    type: Boolean
})], WuiCtaButton.prototype, "disabled", void 0),
__decorate$Y([n$2()], WuiCtaButton.prototype, "label", void 0),
__decorate$Y([n$2()], WuiCtaButton.prototype, "buttonLabel", void 0),
WuiCtaButton = __decorate$Y([customElement("wui-cta-button")], WuiCtaButton);
const f$1 = W=>W.strings === void 0
  , s = (W,z)=>{
    const Y = W._$AN;
    if (Y === void 0)
        return !1;
    for (const ne of Y)
        ne._$AO?.(z, !1),
        s(ne, z);
    return !0
}
  , o$1 = W=>{
    let z, Y;
    do {
        if ((z = W._$AM) === void 0)
            break;
        Y = z._$AN,
        Y.delete(W),
        W = z
    } while (Y?.size === 0)
}
  , r = W=>{
    for (let z; z = W._$AM; W = z) {
        let Y = z._$AN;
        if (Y === void 0)
            z._$AN = Y = new Set;
        else if (Y.has(W))
            break;
        Y.add(W),
        c(z)
    }
}
;
function h$2(W) {
    this._$AN !== void 0 ? (o$1(this),
    this._$AM = W,
    r(this)) : this._$AM = W
}
function n$1(W, z=!1, Y=0) {
    const ne = this._$AH
      , le = this._$AN;
    if (le !== void 0 && le.size !== 0)
        if (z)
            if (Array.isArray(ne))
                for (let ue = Y; ue < ne.length; ue++)
                    s(ne[ue], !1),
                    o$1(ne[ue]);
            else
                ne != null && (s(ne, !1),
                o$1(ne));
        else
            s(this, W)
}
const c = W=>{
    W.type == t$1.CHILD && (W._$AP ??= n$1,
    W._$AQ ??= h$2)
}
;
class f extends i$1 {
    constructor() {
        super(...arguments),
        this._$AN = void 0
    }
    _$AT(z, Y, ne) {
        super._$AT(z, Y, ne),
        r(this),
        this.isConnected = z._$AU
    }
    _$AO(z, Y=!0) {
        z !== this.isConnected && (this.isConnected = z,
        z ? this.reconnected?.() : this.disconnected?.()),
        Y && (s(this, z),
        o$1(this))
    }
    setValue(z) {
        if (f$1(this._$Ct))
            this._$Ct._$AI(z, this);
        else {
            const Y = [...this._$Ct._$AH];
            Y[this._$Ci] = z,
            this._$Ct._$AI(Y, this, 0)
        }
    }
    disconnected() {}
    reconnected() {}
}
const e = ()=>new h$1;
let h$1 = class {
}
;
const o = new WeakMap
  , n = e$2(class extends f {
    render(W) {
        return T$1
    }
    update(W, [z]) {
        const Y = z !== this.G;
        return Y && this.G !== void 0 && this.ot(void 0),
        (Y || this.rt !== this.lt) && (this.G = z,
        this.ct = W.options?.host,
        this.ot(this.lt = W.element)),
        T$1
    }
    ot(W) {
        if (typeof this.G == "function") {
            const z = this.ct ?? globalThis;
            let Y = o.get(z);
            Y === void 0 && (Y = new WeakMap,
            o.set(z, Y)),
            Y.get(this.G) !== void 0 && this.G.call(this.ct, void 0),
            Y.set(this.G, W),
            W !== void 0 && this.G.call(this.ct, W)
        } else
            this.G.value = W
    }
    get rt() {
        return typeof this.G == "function" ? o.get(this.ct ?? globalThis)?.get(this.G) : this.G?.value
    }
    disconnected() {
        this.rt === this.lt && this.ot(void 0)
    }
    reconnected() {
        this.ot(this.lt)
    }
}
)
  , styles$C = i$4`
  :host {
    position: relative;
    width: 100%;
    display: inline-block;
    color: var(--wui-color-fg-275);
  }

  input {
    width: 100%;
    border-radius: var(--wui-border-radius-xxs);
    border: 1px solid var(--wui-gray-glass-005);
    background: var(--wui-gray-glass-005);
    font-size: var(--wui-font-size-paragraph);
    font-weight: var(--wui-font-weight-regular);
    letter-spacing: var(--wui-letter-spacing-paragraph);
    color: var(--wui-color-fg-100);
    transition: all var(--wui-ease-inout-power-1) var(--wui-duration-lg);
    caret-color: var(--wui-color-accent-100);
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-gray-glass-010);
    background: var(--wui-gray-glass-015);
  }

  input:disabled::placeholder,
  input:disabled + wui-icon {
    color: var(--wui-color-fg-300);
  }

  input::placeholder {
    color: var(--wui-color-fg-275);
  }

  input:focus:enabled {
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
    background-color: var(--wui-gray-glass-010);
    border: 1px solid var(--wui-color-accent-100);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  input:hover:enabled {
    background-color: var(--wui-gray-glass-010);
  }

  wui-icon {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
  }

  .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px var(--wui-spacing-s);
  }

  wui-icon + .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px 36px;
  }

  wui-icon[data-input='sm'] {
    left: var(--wui-spacing-s);
  }

  .wui-size-md {
    padding: 15px var(--wui-spacing-m) var(--wui-spacing-l) var(--wui-spacing-m);
  }

  wui-icon + .wui-size-md {
    padding: 15px var(--wui-spacing-m) var(--wui-spacing-l) 42px;
  }

  wui-icon[data-input='md'] {
    left: var(--wui-spacing-m);
  }

  input:placeholder-shown ~ ::slotted(wui-input-element),
  input:placeholder-shown ~ ::slotted(wui-icon) {
    opacity: 0;
    pointer-events: none;
  }

  ::slotted(wui-input-element),
  ::slotted(wui-icon) {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    transition: all var(--wui-ease-in-power-2) var(--wui-duration-md);
  }

  ::slotted(wui-input-element) {
    right: var(--wui-spacing-m);
  }

  ::slotted(wui-icon) {
    right: 0px;
  }
`;
var __decorate$X = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiInputText = class extends s$1 {
    constructor() {
        super(...arguments),
        this.size = "md",
        this.disabled = !1,
        this.placeholder = "",
        this.type = "text",
        this.inputElementRef = e()
    }
    render() {
        const W = `wui-size-${this.size}`;
        return x$1` ${this.templateIcon()}
      <input
        ${n(this.inputElementRef)}
        class=${W}
        type=${this.type}
        enterkeyhint=${o$2(this.enterKeyHint)}
        ?disabled=${this.disabled}
        placeholder=${this.placeholder}
        @input=${this.dispatchInputChangeEvent.bind(this)}
      />
      <slot></slot>`
    }
    templateIcon() {
        return this.icon ? x$1`<wui-icon
        data-input=${this.size}
        size="md"
        color="inherit"
        name=${this.icon}
      ></wui-icon>` : null
    }
    dispatchInputChangeEvent() {
        this.dispatchEvent(new CustomEvent("inputChange",{
            detail: this.inputElementRef.value?.value,
            bubbles: !0,
            composed: !0
        }))
    }
}
;
WuiInputText.styles = [resetStyles, elementStyles, styles$C],
__decorate$X([n$2()], WuiInputText.prototype, "size", void 0),
__decorate$X([n$2()], WuiInputText.prototype, "icon", void 0),
__decorate$X([n$2({
    type: Boolean
})], WuiInputText.prototype, "disabled", void 0),
__decorate$X([n$2()], WuiInputText.prototype, "placeholder", void 0),
__decorate$X([n$2()], WuiInputText.prototype, "type", void 0),
__decorate$X([n$2()], WuiInputText.prototype, "keyHint", void 0),
WuiInputText = __decorate$X([customElement("wui-input-text")], WuiInputText);
const styles$B = i$4`
  :host {
    position: relative;
    display: inline-block;
  }

  wui-icon {
    padding: var(--wui-spacing-xl);
    cursor: pointer;
    transition: all var(--wui-duration-lg) var(--wui-ease-in-power-1);
  }

  wui-icon:hover {
    color: var(--wui-color-fg-200) !important;
  }

  wui-icon::part(chevronRight) {
    width: 12px;
    height: 12px;
  }

  wui-text {
    margin: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-0) var(--wui-spacing-m);
  }
`;
var __decorate$W = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiEmailInput = class extends s$1 {
    render() {
        return x$1`
      <wui-input-text placeholder="Email" icon="mail" size="md">
        <wui-icon size="inherit" color="fg-100" name="chevronRight"></wui-icon>
      </wui-input-text>
      ${this.templateError()}
    `
    }
    templateError() {
        return this.errorMessage ? x$1`<wui-text variant="tiny-500" color="error-100">${this.errorMessage}</wui-text>` : null
    }
}
;
WuiEmailInput.styles = [resetStyles, styles$B],
__decorate$W([n$2()], WuiEmailInput.prototype, "errorMessage", void 0),
WuiEmailInput = __decorate$W([customElement("wui-email-input")], WuiEmailInput);
const styles$A = i$4`
  button {
    border-radius: var(--wui-border-radius-xxs);
    color: var(--wui-color-fg-100);
    padding: var(--wui-spacing-2xs);
  }

  @media (max-width: 700px) {
    button {
      padding: var(--wui-spacing-s);
    }
  }

  button > wui-icon {
    pointer-events: none;
  }

  button:disabled > wui-icon {
    color: var(--wui-color-bg-300) !important;
  }

  button:disabled {
    background-color: transparent;
  }
`;
var __decorate$V = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiIconLink = class extends s$1 {
    constructor() {
        super(...arguments),
        this.size = "md",
        this.disabled = !1,
        this.icon = "copy",
        this.iconColor = "inherit"
    }
    render() {
        return x$1`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-icon color=${this.iconColor} size=${this.size} name=${this.icon}></wui-icon>
      </button>
    `
    }
}
;
WuiIconLink.styles = [resetStyles, elementStyles, colorStyles, styles$A],
__decorate$V([n$2()], WuiIconLink.prototype, "size", void 0),
__decorate$V([n$2({
    type: Boolean
})], WuiIconLink.prototype, "disabled", void 0),
__decorate$V([n$2()], WuiIconLink.prototype, "icon", void 0),
__decorate$V([n$2()], WuiIconLink.prototype, "iconColor", void 0),
WuiIconLink = __decorate$V([customElement("wui-icon-link")], WuiIconLink);
const styles$z = i$4`
  button {
    background-color: var(--wui-color-fg-300);
    border-radius: var(--wui-border-radius-4xs);
    width: 16px;
    height: 16px;
  }

  button:disabled {
    background-color: var(--wui-color-bg-300);
  }

  wui-icon {
    color: var(--wui-color-bg-200) !important;
  }

  button:focus-visible {
    background-color: var(--wui-color-fg-250);
    border: 1px solid var(--wui-color-accent-100);
  }

  button:active:enabled {
    background-color: var(--wui-color-fg-225);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-fg-250);
    }
  }
`;
var __decorate$U = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiInputElement = class extends s$1 {
    constructor() {
        super(...arguments),
        this.icon = "copy"
    }
    render() {
        return x$1`
      <button>
        <wui-icon color="inherit" size="xxs" name=${this.icon}></wui-icon>
      </button>
    `
    }
}
;
WuiInputElement.styles = [resetStyles, elementStyles, styles$z],
__decorate$U([n$2()], WuiInputElement.prototype, "icon", void 0),
WuiInputElement = __decorate$U([customElement("wui-input-element")], WuiInputElement);
const styles$y = i$4`
  :host {
    position: relative;
    display: inline-block;
  }

  input {
    width: 50px;
    height: 50px;
    background: var(--wui-gray-glass-005);
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-gray-glass-005);
    font-family: var(--wui-font-family);
    font-size: var(--wui-font-size-large);
    font-weight: var(--wui-font-weight-regular);
    letter-spacing: var(--wui-letter-spacing-large);
    text-align: center;
    color: var(--wui-color-fg-100);
    caret-color: var(--wui-color-accent-100);
    transition: all var(--wui-ease-inout-power-1) var(--wui-duration-lg);
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: textfield;
    padding: 0px;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-gray-glass-010);
    background: var(--wui-gray-glass-015);
  }

  input:focus:enabled {
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
    background-color: var(--wui-gray-glass-010);
    border: 1px solid var(--wui-color-accent-100);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  input:hover:enabled {
    background-color: var(--wui-gray-glass-010);
  }
`;
var __decorate$T = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiInputNumeric = class extends s$1 {
    constructor() {
        super(...arguments),
        this.disabled = !1
    }
    render() {
        return x$1`<input
      type="number"
      maxlength="1"
      inputmode="numeric"
      autofocus
      ?disabled=${this.disabled}
    /> `
    }
}
;
WuiInputNumeric.styles = [resetStyles, elementStyles, styles$y],
__decorate$T([n$2({
    type: Boolean
})], WuiInputNumeric.prototype, "disabled", void 0),
WuiInputNumeric = __decorate$T([customElement("wui-input-numeric")], WuiInputNumeric);
const styles$x = i$4`
  button {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
    border-radius: var(--wui-border-radius-3xs);
    background-color: transparent;
    color: var(--wui-color-accent-100);
  }

  button:disabled {
    background-color: transparent;
    color: var(--wui-gray-glass-015);
  }
`;
var __decorate$S = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiLink = class extends s$1 {
    constructor() {
        super(...arguments),
        this.disabled = !1,
        this.color = "inherit"
    }
    render() {
        return x$1`
      <button ?disabled=${this.disabled} ontouchstart>
        <slot name="iconLeft"></slot>
        <wui-text variant="small-600" color=${this.color}>
          <slot></slot>
        </wui-text>
        <slot name="iconRight"></slot>
      </button>
    `
    }
}
;
WuiLink.styles = [resetStyles, elementStyles, styles$x],
__decorate$S([n$2({
    type: Boolean
})], WuiLink.prototype, "disabled", void 0),
__decorate$S([n$2()], WuiLink.prototype, "color", void 0),
WuiLink = __decorate$S([customElement("wui-link")], WuiLink);
const styles$w = i$4`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 11px 18px 11px var(--wui-spacing-s);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  button[data-iconvariant='square'],
  button[data-iconvariant='square-blue'] {
    padding: 6px 18px 6px 9px;
  }

  button > wui-flex {
    flex: 1;
  }

  button > wui-image {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
    border-radius: var(--wui-border-radius-3xl);
  }

  button > wui-icon {
    width: 36px;
    height: 36px;
  }

  button > wui-icon-box[data-variant='blue'] {
    box-shadow: 0 0 0 2px var(--wui-accent-glass-005);
  }

  button > wui-icon-box[data-variant='overlay'] {
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }

  button > wui-icon-box[data-variant='square-blue'] {
    border-radius: var(--wui-border-radius-3xs);
    position: relative;
    border: none;
    width: 36px;
    height: 36px;
  }

  button > wui-icon-box[data-variant='square-blue']::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-accent-glass-010);
    pointer-events: none;
  }

  button > wui-icon:last-child {
    width: 14px;
    height: 14px;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  button[data-loading='true'] > wui-icon {
    transition: opacity 200ms ease-in-out;
    opacity: 0;
  }

  wui-loading-spinner {
    position: absolute;
    right: 18px;
    top: 50%;
    transform: translateY(-50%);
  }
`;
var __decorate$R = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiListItem = class extends s$1 {
    constructor() {
        super(...arguments),
        this.variant = "icon",
        this.disabled = !1,
        this.imageSrc = void 0,
        this.alt = void 0,
        this.chevron = !1,
        this.loading = !1
    }
    render() {
        return x$1`
      <button
        ?disabled=${!!this.loading || !!this.disabled}
        data-loading=${this.loading}
        data-iconvariant=${o$2(this.iconVariant)}
        ontouchstart
      >
        ${this.loadingTemplate()} ${this.visualTemplate()}
        <wui-flex gap="3xs">
          <slot></slot>
        </wui-flex>
        ${this.chevronTemplate()}
      </button>
    `
    }
    visualTemplate() {
        if (this.variant === "image" && this.imageSrc)
            return x$1`<wui-image src=${this.imageSrc} alt=${this.alt ?? "list item"}></wui-image>`;
        if (this.iconVariant === "square" && this.icon && this.variant === "icon")
            return x$1`<wui-icon name=${this.icon}></wui-icon>`;
        if (this.variant === "icon" && this.icon && this.iconVariant) {
            const W = ["blue", "square-blue"].includes(this.iconVariant) ? "accent-100" : "fg-200"
              , z = this.iconVariant === "square-blue" ? "mdl" : "md"
              , Y = this.iconSize ? this.iconSize : z;
            return x$1`
        <wui-icon-box
          data-variant=${this.iconVariant}
          icon=${this.icon}
          iconSize=${Y}
          background="transparent"
          iconColor=${W}
          backgroundColor=${W}
          size=${z}
        ></wui-icon-box>
      `
        }
        return null
    }
    loadingTemplate() {
        return this.loading ? x$1`<wui-loading-spinner color="fg-300"></wui-loading-spinner>` : x$1``
    }
    chevronTemplate() {
        return this.chevron ? x$1`<wui-icon size="inherit" color="fg-200" name="chevronRight"></wui-icon>` : null
    }
}
;
var TransactionTypePastTense;
WuiListItem.styles = [resetStyles, elementStyles, styles$w],
__decorate$R([n$2()], WuiListItem.prototype, "icon", void 0),
__decorate$R([n$2()], WuiListItem.prototype, "iconSize", void 0),
__decorate$R([n$2()], WuiListItem.prototype, "variant", void 0),
__decorate$R([n$2()], WuiListItem.prototype, "iconVariant", void 0),
__decorate$R([n$2({
    type: Boolean
})], WuiListItem.prototype, "disabled", void 0),
__decorate$R([n$2()], WuiListItem.prototype, "imageSrc", void 0),
__decorate$R([n$2()], WuiListItem.prototype, "alt", void 0),
__decorate$R([n$2({
    type: Boolean
})], WuiListItem.prototype, "chevron", void 0),
__decorate$R([n$2({
    type: Boolean
})], WuiListItem.prototype, "loading", void 0),
WuiListItem = __decorate$R([customElement("wui-list-item")], WuiListItem),
function(W) {
    W.approve = "approved",
    W.bought = "bought",
    W.borrow = "borrowed",
    W.burn = "burnt",
    W.cancel = "canceled",
    W.claim = "claimed",
    W.deploy = "deployed",
    W.deposit = "deposited",
    W.execute = "executed",
    W.mint = "minted",
    W.receive = "received",
    W.repay = "repaid",
    W.send = "sent",
    W.sell = "sold",
    W.stake = "staked",
    W.trade = "swapped",
    W.unstake = "unstaked",
    W.withdraw = "withdrawn"
}(TransactionTypePastTense || (TransactionTypePastTense = {}));
const styles$v = i$4`
  :host > wui-flex {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    width: 40px;
    height: 40px;
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
    background-color: var(--wui-gray-glass-005);
  }

  :host > wui-flex wui-image {
    display: block;
    z-index: -1;
  }

  :host > wui-flex,
  :host > wui-flex wui-image,
  .swap-images-container,
  .swap-images-container.nft,
  wui-image.nft {
    border-top-left-radius: var(--local-left-border-radius);
    border-top-right-radius: var(--local-right-border-radius);
    border-bottom-left-radius: var(--local-left-border-radius);
    border-bottom-right-radius: var(--local-right-border-radius);
  }

  wui-icon {
    width: 20px;
    height: 20px;
  }

  wui-icon-box {
    position: absolute;
    right: 0;
    bottom: 0;
    transform: translate(20%, 20%);
  }

  .swap-images-container {
    position: relative;
    width: 40px;
    height: 40px;
    overflow: hidden;
  }

  .swap-images-container wui-image:first-child {
    position: absolute;
    width: 40px;
    height: 40px;
    top: 0;
    left: 0%;
    clip-path: inset(0px calc(50% + 2px) 0px 0%);
  }

  .swap-images-container wui-image:last-child {
    clip-path: inset(0px 0px 0px calc(50% + 2px));
  }
`;
var __decorate$Q = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiTransactionVisual = class extends s$1 {
    constructor() {
        super(...arguments),
        this.images = [],
        this.secondImage = {
            type: void 0,
            url: ""
        }
    }
    render() {
        const [W,z] = this.images
          , Y = W?.type === "NFT"
          , ne = Y ? "var(--wui-border-radius-xxs)" : "var(--wui-border-radius-s)"
          , le = (z?.url ? z.type === "NFT" : Y) ? "var(--wui-border-radius-xxs)" : "var(--wui-border-radius-s)";
        return this.style.cssText = `
    --local-left-border-radius: ${ne};
    --local-right-border-radius: ${le};
    `,
        x$1`<wui-flex> ${this.templateVisual()} ${this.templateIcon()} </wui-flex>`
    }
    templateVisual() {
        const [W,z] = this.images
          , Y = W?.type;
        return this.images.length === 2 && (W?.url || z?.url) ? x$1`<div class="swap-images-container">
        ${W?.url ? x$1`<wui-image src=${W.url} alt="Transaction image"></wui-image>` : null}
        ${z?.url ? x$1`<wui-image src=${z.url} alt="Transaction image"></wui-image>` : null}
      </div>` : W?.url ? x$1`<wui-image src=${W.url} alt="Transaction image"></wui-image>` : Y === "NFT" ? x$1`<wui-icon size="inherit" color="fg-200" name="nftPlaceholder"></wui-icon>` : x$1`<wui-icon size="inherit" color="fg-200" name="coinPlaceholder"></wui-icon>`
    }
    templateIcon() {
        let W, z = "accent-100";
        return W = this.getIcon(),
        this.status && (z = this.getStatusColor()),
        W ? x$1`
      <wui-icon-box
        size="xxs"
        iconColor=${z}
        backgroundColor=${z}
        background="opaque"
        icon=${W}
        ?border=${!0}
        borderColor="wui-color-bg-125"
      ></wui-icon-box>
    ` : null
    }
    getDirectionIcon() {
        switch (this.direction) {
        case "in":
            return "arrowBottom";
        case "out":
            return "arrowTop";
        default:
            return
        }
    }
    getIcon() {
        return this.onlyDirectionIcon ? this.getDirectionIcon() : this.type === "trade" ? "swapHorizontalBold" : this.type === "approve" ? "checkmark" : this.type === "cancel" ? "close" : this.getDirectionIcon()
    }
    getStatusColor() {
        switch (this.status) {
        case "confirmed":
            return "success-100";
        case "failed":
            return "error-100";
        case "pending":
            return "inverse-100";
        default:
            return "accent-100"
        }
    }
}
;
WuiTransactionVisual.styles = [styles$v],
__decorate$Q([n$2()], WuiTransactionVisual.prototype, "type", void 0),
__decorate$Q([n$2()], WuiTransactionVisual.prototype, "status", void 0),
__decorate$Q([n$2()], WuiTransactionVisual.prototype, "direction", void 0),
__decorate$Q([n$2()], WuiTransactionVisual.prototype, "onlyDirectionIcon", void 0),
__decorate$Q([n$2()], WuiTransactionVisual.prototype, "images", void 0),
__decorate$Q([n$2()], WuiTransactionVisual.prototype, "secondImage", void 0),
WuiTransactionVisual = __decorate$Q([customElement("wui-transaction-visual")], WuiTransactionVisual);
const styles$u = i$4`
  :host > wui-flex:first-child {
    align-items: center;
    column-gap: var(--wui-spacing-s);
    padding: 6.5px var(--wui-spacing-l) 6.5px var(--wui-spacing-xs);
    width: 100%;
  }

  :host > wui-flex:first-child wui-text:nth-child(1) {
    text-transform: capitalize;
  }

  wui-transaction-visual {
    width: 40px;
    height: 40px;
  }

  wui-flex {
    flex: 1;
  }

  :host wui-flex wui-flex {
    overflow: hidden;
  }

  :host .description-container wui-text span {
    word-break: break-all;
  }

  :host .description-container wui-text {
    overflow: hidden;
  }

  :host .description-separator-icon {
    margin: 0px 6px;
  }

  :host wui-text > span {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }
`;
var __decorate$P = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiTransactionListItem = class extends s$1 {
    constructor() {
        super(...arguments),
        this.type = "approve",
        this.onlyDirectionIcon = !1,
        this.images = []
    }
    render() {
        return x$1`
      <wui-flex>
        <wui-transaction-visual
          status=${this.status}
          direction=${this.direction}
          type=${this.type}
          onlyDirectionIcon=${this.onlyDirectionIcon}
          .images=${this.images}
        ></wui-transaction-visual>
        <wui-flex flexDirection="column" gap="3xs">
          <wui-text variant="paragraph-600" color="fg-100">
            ${TransactionTypePastTense[this.type]}
          </wui-text>
          <wui-flex class="description-container">
            ${this.templateDescription()} ${this.templateSecondDescription()}
          </wui-flex>
        </wui-flex>
        <wui-text variant="micro-700" color="fg-300"><span>${this.date}</span></wui-text>
      </wui-flex>
    `
    }
    templateDescription() {
        const W = this.descriptions?.[0];
        return W ? x$1`
          <wui-text variant="small-500" color="fg-200">
            <span>${W}</span>
          </wui-text>
        ` : null
    }
    templateSecondDescription() {
        const W = this.descriptions?.[1];
        return W ? x$1`
          <wui-icon class="description-separator-icon" size="xxs" name="arrowRight"></wui-icon>
          <wui-text variant="small-400" color="fg-200">
            <span>${W}</span>
          </wui-text>
        ` : null
    }
}
;
WuiTransactionListItem.styles = [resetStyles, styles$u],
__decorate$P([n$2()], WuiTransactionListItem.prototype, "type", void 0),
__decorate$P([n$2()], WuiTransactionListItem.prototype, "descriptions", void 0),
__decorate$P([n$2()], WuiTransactionListItem.prototype, "date", void 0),
__decorate$P([n$2()], WuiTransactionListItem.prototype, "onlyDirectionIcon", void 0),
__decorate$P([n$2()], WuiTransactionListItem.prototype, "status", void 0),
__decorate$P([n$2()], WuiTransactionListItem.prototype, "direction", void 0),
__decorate$P([n$2()], WuiTransactionListItem.prototype, "images", void 0),
WuiTransactionListItem = __decorate$P([customElement("wui-transaction-list-item")], WuiTransactionListItem);
const styles$t = i$4`
  :host > wui-flex:first-child {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
  }

  wui-flex {
    display: flex;
    flex: 1;
  }
`;
var __decorate$O = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiTransactionListItemLoader = class extends s$1 {
    render() {
        return x$1`
      <wui-flex alignItems="center">
        <wui-shimmer width="40px" height="40px"></wui-shimmer>
        <wui-flex flexDirection="column" gap="2xs">
          <wui-shimmer width="72px" height="16px" borderRadius="4xs"></wui-shimmer>
          <wui-shimmer width="148px" height="14px" borderRadius="4xs"></wui-shimmer>
        </wui-flex>
        <wui-shimmer width="24px" height="12px" borderRadius="5xs"></wui-shimmer>
      </wui-flex>
    `
    }
}
;
WuiTransactionListItemLoader.styles = [resetStyles, styles$t],
WuiTransactionListItemLoader = __decorate$O([customElement("wui-transaction-list-item-loader")], WuiTransactionListItemLoader);
const styles$s = i$4`
  :host {
    display: block;
    padding: 3.5px 5px !important;
    border-radius: var(--wui-border-radius-5xs);
  }

  :host([data-variant='main']) {
    background-color: var(--wui-accent-glass-015);
    color: var(--wui-color-accent-100);
  }

  :host([data-variant='shade']) {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  :host([data-variant='success']) {
    background-color: var(--wui-icon-box-bg-success-100);
    color: var(--wui-color-success-100);
  }

  :host([data-variant='error']) {
    background-color: var(--wui-icon-box-bg-error-100);
    color: var(--wui-color-error-100);
  }
`;
var __decorate$N = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiTag = class extends s$1 {
    constructor() {
        super(...arguments),
        this.variant = "main"
    }
    render() {
        return this.dataset.variant = this.variant,
        x$1`
      <wui-text data-variant=${this.variant} variant="micro-700" color="inherit">
        <slot></slot>
      </wui-text>
    `
    }
}
;
WuiTag.styles = [resetStyles, styles$s],
__decorate$N([n$2()], WuiTag.prototype, "variant", void 0),
WuiTag = __decorate$N([customElement("wui-tag")], WuiTag);
const styles$r = i$4`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
  }

  button > wui-text:nth-child(2) {
    display: flex;
    flex: 1;
  }

  wui-icon {
    color: var(--wui-color-fg-200) !important;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-tag {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-300);
  }
`;
var __decorate$M = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiListWallet = class extends s$1 {
    constructor() {
        super(...arguments),
        this.walletImages = [],
        this.imageSrc = "",
        this.name = "",
        this.disabled = !1,
        this.showAllWallets = !1
    }
    render() {
        return x$1`
      <button ?disabled=${this.disabled} ontouchstart>
        ${this.templateAllWallets()} ${this.templateWalletImage()}
        <wui-text variant="paragraph-500" color="inherit">${this.name}</wui-text>
        ${this.templateStatus()}
      </button>
    `
    }
    templateAllWallets() {
        return this.showAllWallets && this.imageSrc ? x$1` <wui-all-wallets-image .imageeSrc=${this.imageSrc}> </wui-all-wallets-image> ` : this.showAllWallets && this.walletIcon ? x$1` <wui-wallet-image .walletIcon=${this.walletIcon} size="sm"> </wui-wallet-image> ` : null
    }
    templateWalletImage() {
        return !this.showAllWallets && this.imageSrc ? x$1`<wui-wallet-image
        size="sm"
        imageSrc=${this.imageSrc}
        name=${this.name}
      ></wui-wallet-image>` : this.showAllWallets || this.imageSrc ? null : x$1`<wui-wallet-image size="sm" name=${this.name}></wui-wallet-image>`
    }
    templateStatus() {
        return this.tagLabel && this.tagVariant ? x$1`<wui-tag variant=${this.tagVariant}>${this.tagLabel}</wui-tag>` : this.icon ? x$1`<wui-icon color="inherit" size="sm" name=${this.icon}></wui-icon>` : null
    }
}
;
WuiListWallet.styles = [resetStyles, elementStyles, styles$r],
__decorate$M([n$2({
    type: Array
})], WuiListWallet.prototype, "walletImages", void 0),
__decorate$M([n$2()], WuiListWallet.prototype, "imageSrc", void 0),
__decorate$M([n$2()], WuiListWallet.prototype, "name", void 0),
__decorate$M([n$2()], WuiListWallet.prototype, "tagLabel", void 0),
__decorate$M([n$2()], WuiListWallet.prototype, "tagVariant", void 0),
__decorate$M([n$2()], WuiListWallet.prototype, "icon", void 0),
__decorate$M([n$2()], WuiListWallet.prototype, "walletIcon", void 0),
__decorate$M([n$2({
    type: Boolean
})], WuiListWallet.prototype, "disabled", void 0),
__decorate$M([n$2({
    type: Boolean
})], WuiListWallet.prototype, "showAllWallets", void 0),
WuiListWallet = __decorate$M([customElement("wui-list-wallet")], WuiListWallet);
const styles$q = i$4`
  :host {
    display: block;
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-010);
    overflow: hidden;
  }

  wui-icon {
    width: 100%;
    height: 100%;
  }
`;
var __decorate$L = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiLogo = class extends s$1 {
    constructor() {
        super(...arguments),
        this.logo = "google"
    }
    render() {
        return x$1`<wui-icon color="inherit" size="inherit" name=${this.logo}></wui-icon> `
    }
}
;
WuiLogo.styles = [resetStyles, styles$q],
__decorate$L([n$2()], WuiLogo.prototype, "logo", void 0),
WuiLogo = __decorate$L([customElement("wui-logo")], WuiLogo);
const styles$p = i$4`
  :host {
    display: block;
  }

  button {
    width: 50px;
    height: 50px;
    background: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;
var __decorate$K = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiLogoSelect = class extends s$1 {
    constructor() {
        super(...arguments),
        this.logo = "google",
        this.disabled = !1
    }
    render() {
        return x$1`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-logo logo=${this.logo}></wui-logo>
      </button>
    `
    }
}
;
WuiLogoSelect.styles = [resetStyles, elementStyles, styles$p],
__decorate$K([n$2()], WuiLogoSelect.prototype, "logo", void 0),
__decorate$K([n$2({
    type: Boolean
})], WuiLogoSelect.prototype, "disabled", void 0),
WuiLogoSelect = __decorate$K([customElement("wui-logo-select")], WuiLogoSelect);
const styles$o = i$4`
  :host {
    display: block;
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
    display: flex;
    gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-2xs) var(--wui-spacing-s) var(--wui-spacing-2xs)
      var(--wui-spacing-xs);
    border: 1px solid var(--wui-gray-glass-010);
    background-color: var(--wui-gray-glass-005);
    color: var(--wui-color-fg-100);
  }

  button:disabled {
    border: 1px solid var(--wui-gray-glass-005);
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-gray-glass-010);
    }

    button:active:enabled {
      background-color: var(--wui-gray-glass-015);
    }
  }

  wui-image,
  wui-icon-box {
    border-radius: var(--wui-border-radius-3xl);
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }
`;
var __decorate$J = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiNetworkButton = class extends s$1 {
    constructor() {
        super(...arguments),
        this.imageSrc = void 0,
        this.disabled = !1
    }
    render() {
        return x$1`
      <button ?disabled=${this.disabled}>
        ${this.visualTemplate()}
        <wui-text variant="paragraph-600" color="inherit">
          <slot></slot>
        </wui-text>
      </button>
    `
    }
    visualTemplate() {
        return this.imageSrc ? x$1`<wui-image src=${this.imageSrc}></wui-image>` : x$1`
      <wui-icon-box
        size="sm"
        iconColor="inverse-100"
        backgroundColor="fg-100"
        icon="networkPlaceholder"
      ></wui-icon-box>
    `
    }
}
;
WuiNetworkButton.styles = [resetStyles, elementStyles, styles$o],
__decorate$J([n$2()], WuiNetworkButton.prototype, "imageSrc", void 0),
__decorate$J([n$2({
    type: Boolean
})], WuiNetworkButton.prototype, "disabled", void 0),
WuiNetworkButton = __decorate$J([customElement("wui-network-button")], WuiNetworkButton);
const styles$n = i$4`
  :host {
    position: relative;
    display: block;
  }
`;
var __decorate$I = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiOtp = class extends s$1 {
    constructor() {
        super(...arguments),
        this.length = 6,
        this.numerics = [],
        this.handleKeyDown = (W,z)=>{
            const Y = W.target
              , ne = this.getInputElement(Y);
            if (!ne)
                return;
            ["ArrowLeft", "ArrowRight", "Shift", "Delete"].includes(W.key) && W.preventDefault();
            const le = ne.selectionStart;
            switch (W.key) {
            case "ArrowLeft":
                le && ne.setSelectionRange(le + 1, le + 1),
                this.focusInputField("prev", z);
                break;
            case "ArrowRight":
            case "Shift":
                this.focusInputField("next", z);
                break;
            case "Delete":
            case "Backspace":
                ne.value === "" ? this.focusInputField("prev", z) : ne.value = ""
            }
        }
        ,
        this.focusInputField = (W,z)=>{
            if (W === "next") {
                const Y = z + 1
                  , ne = this.numerics[Y < this.length ? Y : z]
                  , le = ne ? this.getInputElement(ne) : void 0;
                le && le.focus()
            }
            if (W === "prev") {
                const Y = z - 1
                  , ne = this.numerics[Y > -1 ? Y : z]
                  , le = ne ? this.getInputElement(ne) : void 0;
                le && le.focus()
            }
        }
    }
    firstUpdated() {
        const W = this.shadowRoot?.querySelectorAll("wui-input-numeric");
        W && (this.numerics = Array.from(W))
    }
    render() {
        return x$1`
      <wui-flex gap="xxs">
        ${[...Array(this.length)].map((W,z)=>x$1`
            <wui-input-numeric
              @input=${Y=>this.handleInput(Y, z)}
              @keydown=${Y=>this.handleKeyDown(Y, z)}
            >
            </wui-input-numeric>
          `)}
      </wui-flex>
    `
    }
    handleInput(W, z) {
        const Y = W.target
          , ne = this.getInputElement(Y);
        if (ne) {
            const le = ne.value;
            W.inputType === "insertFromPaste" ? this.handlePaste(ne, le, z) : UiHelperUtil.isNumber(le) && W.data ? (ne.value = W.data,
            this.focusInputField("next", z)) : ne.value = ""
        }
    }
    handlePaste(W, z, Y) {
        const ne = z[0];
        if (ne && UiHelperUtil.isNumber(ne)) {
            W.value = ne;
            const le = z.substring(1);
            if (Y + 1 < this.length && le.length) {
                const ue = this.numerics[Y + 1]
                  , de = ue ? this.getInputElement(ue) : void 0;
                de && this.handlePaste(de, le, Y + 1)
            } else
                this.focusInputField("next", Y)
        } else
            W.value = ""
    }
    getInputElement(W) {
        return W.shadowRoot?.querySelector("input") ? W.shadowRoot.querySelector("input") : null
    }
}
;
WuiOtp.styles = [resetStyles, styles$n],
__decorate$I([n$2({
    type: Number
})], WuiOtp.prototype, "length", void 0),
WuiOtp = __decorate$I([customElement("wui-otp")], WuiOtp);
var browser$1 = {}
  , canPromise$1 = function() {
    return typeof Promise == "function" && Promise.prototype && Promise.prototype.then
}
  , qrcode = {}
  , utils$2 = {};
let toSJISFunction;
const CODEWORDS_COUNT = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
utils$2.getSymbolSize = function(W) {
    if (!W)
        throw new Error('"version" cannot be null or undefined');
    if (W < 1 || W > 40)
        throw new Error('"version" should be in range from 1 to 40');
    return 4 * W + 17
}
,
utils$2.getSymbolTotalCodewords = function(W) {
    return CODEWORDS_COUNT[W]
}
,
utils$2.getBCHDigit = function(W) {
    let z = 0;
    for (; W !== 0; )
        z++,
        W >>>= 1;
    return z
}
,
utils$2.setToSJISFunction = function(W) {
    if (typeof W != "function")
        throw new Error('"toSJISFunc" is not a valid function.');
    toSJISFunction = W
}
,
utils$2.isKanjiModeEnabled = function() {
    return toSJISFunction !== void 0
}
,
utils$2.toSJIS = function(W) {
    return toSJISFunction(W)
}
;
var errorCorrectionLevel = {}, exports;
function BitBuffer$1() {
    this.buffer = [],
    this.length = 0
}
exports = errorCorrectionLevel,
exports.L = {
    bit: 1
},
exports.M = {
    bit: 0
},
exports.Q = {
    bit: 3
},
exports.H = {
    bit: 2
},
exports.isValid = function(W) {
    return W && W.bit !== void 0 && W.bit >= 0 && W.bit < 4
}
,
exports.from = function(W, z) {
    if (exports.isValid(W))
        return W;
    try {
        return function(Y) {
            if (typeof Y != "string")
                throw new Error("Param is not a string");
            switch (Y.toLowerCase()) {
            case "l":
            case "low":
                return exports.L;
            case "m":
            case "medium":
                return exports.M;
            case "q":
            case "quartile":
                return exports.Q;
            case "h":
            case "high":
                return exports.H;
            default:
                throw new Error("Unknown EC Level: " + Y)
            }
        }(W)
    } catch {
        return z
    }
}
,
BitBuffer$1.prototype = {
    get: function(W) {
        const z = Math.floor(W / 8);
        return (this.buffer[z] >>> 7 - W % 8 & 1) == 1
    },
    put: function(W, z) {
        for (let Y = 0; Y < z; Y++)
            this.putBit((W >>> z - Y - 1 & 1) == 1)
    },
    getLengthInBits: function() {
        return this.length
    },
    putBit: function(W) {
        const z = Math.floor(this.length / 8);
        this.buffer.length <= z && this.buffer.push(0),
        W && (this.buffer[z] |= 128 >>> this.length % 8),
        this.length++
    }
};
var bitBuffer = BitBuffer$1;
function BitMatrix$1(W) {
    if (!W || W < 1)
        throw new Error("BitMatrix size must be defined and greater than 0");
    this.size = W,
    this.data = new Uint8Array(W * W),
    this.reservedBit = new Uint8Array(W * W)
}
BitMatrix$1.prototype.set = function(W, z, Y, ne) {
    const le = W * this.size + z;
    this.data[le] = Y,
    ne && (this.reservedBit[le] = !0)
}
,
BitMatrix$1.prototype.get = function(W, z) {
    return this.data[W * this.size + z]
}
,
BitMatrix$1.prototype.xor = function(W, z, Y) {
    this.data[W * this.size + z] ^= Y
}
,
BitMatrix$1.prototype.isReserved = function(W, z) {
    return this.reservedBit[W * this.size + z]
}
;
var bitMatrix = BitMatrix$1
  , alignmentPattern = {};
(function(W) {
    const z = utils$2.getSymbolSize;
    W.getRowColCoords = function(Y) {
        if (Y === 1)
            return [];
        const ne = Math.floor(Y / 7) + 2
          , le = z(Y)
          , ue = le === 145 ? 26 : 2 * Math.ceil((le - 13) / (2 * ne - 2))
          , de = [le - 7];
        for (let he = 1; he < ne - 1; he++)
            de[he] = de[he - 1] - ue;
        return de.push(6),
        de.reverse()
    }
    ,
    W.getPositions = function(Y) {
        const ne = []
          , le = W.getRowColCoords(Y)
          , ue = le.length;
        for (let de = 0; de < ue; de++)
            for (let he = 0; he < ue; he++)
                de === 0 && he === 0 || de === 0 && he === ue - 1 || de === ue - 1 && he === 0 || ne.push([le[de], le[he]]);
        return ne
    }
}
)(alignmentPattern);
var finderPattern = {};
const getSymbolSize = utils$2.getSymbolSize
  , FINDER_PATTERN_SIZE = 7;
finderPattern.getPositions = function(W) {
    const z = getSymbolSize(W);
    return [[0, 0], [z - FINDER_PATTERN_SIZE, 0], [0, z - FINDER_PATTERN_SIZE]]
}
;
var maskPattern = {};
(function(W) {
    W.Patterns = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7
    };
    const z = 3
      , Y = 3
      , ne = 40
      , le = 10;
    function ue(de, he, fe) {
        switch (de) {
        case W.Patterns.PATTERN000:
            return (he + fe) % 2 == 0;
        case W.Patterns.PATTERN001:
            return he % 2 == 0;
        case W.Patterns.PATTERN010:
            return fe % 3 == 0;
        case W.Patterns.PATTERN011:
            return (he + fe) % 3 == 0;
        case W.Patterns.PATTERN100:
            return (Math.floor(he / 2) + Math.floor(fe / 3)) % 2 == 0;
        case W.Patterns.PATTERN101:
            return he * fe % 2 + he * fe % 3 == 0;
        case W.Patterns.PATTERN110:
            return (he * fe % 2 + he * fe % 3) % 2 == 0;
        case W.Patterns.PATTERN111:
            return (he * fe % 3 + (he + fe) % 2) % 2 == 0;
        default:
            throw new Error("bad maskPattern:" + de)
        }
    }
    W.isValid = function(de) {
        return de != null && de !== "" && !isNaN(de) && de >= 0 && de <= 7
    }
    ,
    W.from = function(de) {
        return W.isValid(de) ? parseInt(de, 10) : void 0
    }
    ,
    W.getPenaltyN1 = function(de) {
        const he = de.size;
        let fe = 0
          , ge = 0
          , xe = 0
          , $e = null
          , Ee = null;
        for (let Se = 0; Se < he; Se++) {
            ge = xe = 0,
            $e = Ee = null;
            for (let Ne = 0; Ne < he; Ne++) {
                let tt = de.get(Se, Ne);
                tt === $e ? ge++ : (ge >= 5 && (fe += z + (ge - 5)),
                $e = tt,
                ge = 1),
                tt = de.get(Ne, Se),
                tt === Ee ? xe++ : (xe >= 5 && (fe += z + (xe - 5)),
                Ee = tt,
                xe = 1)
            }
            ge >= 5 && (fe += z + (ge - 5)),
            xe >= 5 && (fe += z + (xe - 5))
        }
        return fe
    }
    ,
    W.getPenaltyN2 = function(de) {
        const he = de.size;
        let fe = 0;
        for (let ge = 0; ge < he - 1; ge++)
            for (let xe = 0; xe < he - 1; xe++) {
                const $e = de.get(ge, xe) + de.get(ge, xe + 1) + de.get(ge + 1, xe) + de.get(ge + 1, xe + 1);
                $e !== 4 && $e !== 0 || fe++
            }
        return fe * Y
    }
    ,
    W.getPenaltyN3 = function(de) {
        const he = de.size;
        let fe = 0
          , ge = 0
          , xe = 0;
        for (let $e = 0; $e < he; $e++) {
            ge = xe = 0;
            for (let Ee = 0; Ee < he; Ee++)
                ge = ge << 1 & 2047 | de.get($e, Ee),
                Ee >= 10 && (ge === 1488 || ge === 93) && fe++,
                xe = xe << 1 & 2047 | de.get(Ee, $e),
                Ee >= 10 && (xe === 1488 || xe === 93) && fe++
        }
        return fe * ne
    }
    ,
    W.getPenaltyN4 = function(de) {
        let he = 0;
        const fe = de.data.length;
        for (let ge = 0; ge < fe; ge++)
            he += de.data[ge];
        return Math.abs(Math.ceil(100 * he / fe / 5) - 10) * le
    }
    ,
    W.applyMask = function(de, he) {
        const fe = he.size;
        for (let ge = 0; ge < fe; ge++)
            for (let xe = 0; xe < fe; xe++)
                he.isReserved(xe, ge) || he.xor(xe, ge, ue(de, xe, ge))
    }
    ,
    W.getBestMask = function(de, he) {
        const fe = Object.keys(W.Patterns).length;
        let ge = 0
          , xe = 1 / 0;
        for (let $e = 0; $e < fe; $e++) {
            he($e),
            W.applyMask($e, de);
            const Ee = W.getPenaltyN1(de) + W.getPenaltyN2(de) + W.getPenaltyN3(de) + W.getPenaltyN4(de);
            W.applyMask($e, de),
            Ee < xe && (xe = Ee,
            ge = $e)
        }
        return ge
    }
}
)(maskPattern);
var errorCorrectionCode = {};
const ECLevel$1 = errorCorrectionLevel
  , EC_BLOCKS_TABLE = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81]
  , EC_CODEWORDS_TABLE = [7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];
errorCorrectionCode.getBlocksCount = function(W, z) {
    switch (z) {
    case ECLevel$1.L:
        return EC_BLOCKS_TABLE[4 * (W - 1) + 0];
    case ECLevel$1.M:
        return EC_BLOCKS_TABLE[4 * (W - 1) + 1];
    case ECLevel$1.Q:
        return EC_BLOCKS_TABLE[4 * (W - 1) + 2];
    case ECLevel$1.H:
        return EC_BLOCKS_TABLE[4 * (W - 1) + 3];
    default:
        return
    }
}
,
errorCorrectionCode.getTotalCodewordsCount = function(W, z) {
    switch (z) {
    case ECLevel$1.L:
        return EC_CODEWORDS_TABLE[4 * (W - 1) + 0];
    case ECLevel$1.M:
        return EC_CODEWORDS_TABLE[4 * (W - 1) + 1];
    case ECLevel$1.Q:
        return EC_CODEWORDS_TABLE[4 * (W - 1) + 2];
    case ECLevel$1.H:
        return EC_CODEWORDS_TABLE[4 * (W - 1) + 3];
    default:
        return
    }
}
;
var polynomial = {}
  , galoisField = {};
const EXP_TABLE = new Uint8Array(512)
  , LOG_TABLE = new Uint8Array(256);
(function() {
    let W = 1;
    for (let z = 0; z < 255; z++)
        EXP_TABLE[z] = W,
        LOG_TABLE[W] = z,
        W <<= 1,
        256 & W && (W ^= 285);
    for (let z = 255; z < 512; z++)
        EXP_TABLE[z] = EXP_TABLE[z - 255]
}
)(),
galoisField.log = function(W) {
    if (W < 1)
        throw new Error("log(" + W + ")");
    return LOG_TABLE[W]
}
,
galoisField.exp = function(W) {
    return EXP_TABLE[W]
}
,
galoisField.mul = function(W, z) {
    return W === 0 || z === 0 ? 0 : EXP_TABLE[LOG_TABLE[W] + LOG_TABLE[z]]
}
,
function(W) {
    const z = galoisField;
    W.mul = function(Y, ne) {
        const le = new Uint8Array(Y.length + ne.length - 1);
        for (let ue = 0; ue < Y.length; ue++)
            for (let de = 0; de < ne.length; de++)
                le[ue + de] ^= z.mul(Y[ue], ne[de]);
        return le
    }
    ,
    W.mod = function(Y, ne) {
        let le = new Uint8Array(Y);
        for (; le.length - ne.length >= 0; ) {
            const ue = le[0];
            for (let he = 0; he < ne.length; he++)
                le[he] ^= z.mul(ne[he], ue);
            let de = 0;
            for (; de < le.length && le[de] === 0; )
                de++;
            le = le.slice(de)
        }
        return le
    }
    ,
    W.generateECPolynomial = function(Y) {
        let ne = new Uint8Array([1]);
        for (let le = 0; le < Y; le++)
            ne = W.mul(ne, new Uint8Array([1, z.exp(le)]));
        return ne
    }
}(polynomial);
const Polynomial = polynomial;
function ReedSolomonEncoder$1(W) {
    this.genPoly = void 0,
    this.degree = W,
    this.degree && this.initialize(this.degree)
}
ReedSolomonEncoder$1.prototype.initialize = function(W) {
    this.degree = W,
    this.genPoly = Polynomial.generateECPolynomial(this.degree)
}
,
ReedSolomonEncoder$1.prototype.encode = function(W) {
    if (!this.genPoly)
        throw new Error("Encoder not initialized");
    const z = new Uint8Array(W.length + this.degree);
    z.set(W);
    const Y = Polynomial.mod(z, this.genPoly)
      , ne = this.degree - Y.length;
    if (ne > 0) {
        const le = new Uint8Array(this.degree);
        return le.set(Y, ne),
        le
    }
    return Y
}
;
var reedSolomonEncoder = ReedSolomonEncoder$1
  , version = {}
  , mode = {}
  , versionCheck = {
    isValid: function(W) {
        return !isNaN(W) && W >= 1 && W <= 40
    }
}
  , regex = {};
const numeric = "[0-9]+"
  , alphanumeric = "[A-Z $%*+\\-./:]+";
let kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
kanji = kanji.replace(/u/g, "\\u");
const byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + `)(?:.|[\r
]))+`;
regex.KANJI = new RegExp(kanji,"g"),
regex.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+","g"),
regex.BYTE = new RegExp(byte,"g"),
regex.NUMERIC = new RegExp(numeric,"g"),
regex.ALPHANUMERIC = new RegExp(alphanumeric,"g");
const TEST_KANJI = new RegExp("^" + kanji + "$")
  , TEST_NUMERIC = new RegExp("^" + numeric + "$")
  , TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
regex.testKanji = function(W) {
    return TEST_KANJI.test(W)
}
,
regex.testNumeric = function(W) {
    return TEST_NUMERIC.test(W)
}
,
regex.testAlphanumeric = function(W) {
    return TEST_ALPHANUMERIC.test(W)
}
,
function(W) {
    const z = versionCheck
      , Y = regex;
    W.NUMERIC = {
        id: "Numeric",
        bit: 1,
        ccBits: [10, 12, 14]
    },
    W.ALPHANUMERIC = {
        id: "Alphanumeric",
        bit: 2,
        ccBits: [9, 11, 13]
    },
    W.BYTE = {
        id: "Byte",
        bit: 4,
        ccBits: [8, 16, 16]
    },
    W.KANJI = {
        id: "Kanji",
        bit: 8,
        ccBits: [8, 10, 12]
    },
    W.MIXED = {
        bit: -1
    },
    W.getCharCountIndicator = function(ne, le) {
        if (!ne.ccBits)
            throw new Error("Invalid mode: " + ne);
        if (!z.isValid(le))
            throw new Error("Invalid version: " + le);
        return le >= 1 && le < 10 ? ne.ccBits[0] : le < 27 ? ne.ccBits[1] : ne.ccBits[2]
    }
    ,
    W.getBestModeForData = function(ne) {
        return Y.testNumeric(ne) ? W.NUMERIC : Y.testAlphanumeric(ne) ? W.ALPHANUMERIC : Y.testKanji(ne) ? W.KANJI : W.BYTE
    }
    ,
    W.toString = function(ne) {
        if (ne && ne.id)
            return ne.id;
        throw new Error("Invalid mode")
    }
    ,
    W.isValid = function(ne) {
        return ne && ne.bit && ne.ccBits
    }
    ,
    W.from = function(ne, le) {
        if (W.isValid(ne))
            return ne;
        try {
            return function(ue) {
                if (typeof ue != "string")
                    throw new Error("Param is not a string");
                switch (ue.toLowerCase()) {
                case "numeric":
                    return W.NUMERIC;
                case "alphanumeric":
                    return W.ALPHANUMERIC;
                case "kanji":
                    return W.KANJI;
                case "byte":
                    return W.BYTE;
                default:
                    throw new Error("Unknown mode: " + ue)
                }
            }(ne)
        } catch {
            return le
        }
    }
}(mode),
function(W) {
    const z = utils$2
      , Y = errorCorrectionCode
      , ne = errorCorrectionLevel
      , le = mode
      , ue = versionCheck
      , de = z.getBCHDigit(7973);
    function he(ge, xe) {
        return le.getCharCountIndicator(ge, xe) + 4
    }
    function fe(ge, xe) {
        let $e = 0;
        return ge.forEach(function(Ee) {
            const Se = he(Ee.mode, xe);
            $e += Se + Ee.getBitsLength()
        }),
        $e
    }
    W.from = function(ge, xe) {
        return ue.isValid(ge) ? parseInt(ge, 10) : xe
    }
    ,
    W.getCapacity = function(ge, xe, $e) {
        if (!ue.isValid(ge))
            throw new Error("Invalid QR Code version");
        $e === void 0 && ($e = le.BYTE);
        const Ee = 8 * (z.getSymbolTotalCodewords(ge) - Y.getTotalCodewordsCount(ge, xe));
        if ($e === le.MIXED)
            return Ee;
        const Se = Ee - he($e, ge);
        switch ($e) {
        case le.NUMERIC:
            return Math.floor(Se / 10 * 3);
        case le.ALPHANUMERIC:
            return Math.floor(Se / 11 * 2);
        case le.KANJI:
            return Math.floor(Se / 13);
        case le.BYTE:
        default:
            return Math.floor(Se / 8)
        }
    }
    ,
    W.getBestVersionForData = function(ge, xe) {
        let $e;
        const Ee = ne.from(xe, ne.M);
        if (Array.isArray(ge)) {
            if (ge.length > 1)
                return function(Se, Ne) {
                    for (let tt = 1; tt <= 40; tt++)
                        if (fe(Se, tt) <= W.getCapacity(tt, Ne, le.MIXED))
                            return tt
                }(ge, Ee);
            if (ge.length === 0)
                return 1;
            $e = ge[0]
        } else
            $e = ge;
        return function(Se, Ne, tt) {
            for (let rr = 1; rr <= 40; rr++)
                if (Ne <= W.getCapacity(rr, tt, Se))
                    return rr
        }($e.mode, $e.getLength(), Ee)
    }
    ,
    W.getEncodedBits = function(ge) {
        if (!ue.isValid(ge) || ge < 7)
            throw new Error("Invalid QR Code version");
        let xe = ge << 12;
        for (; z.getBCHDigit(xe) - de >= 0; )
            xe ^= 7973 << z.getBCHDigit(xe) - de;
        return ge << 12 | xe
    }
}(version);
var formatInfo = {};
const Utils$3 = utils$2
  , G15 = 1335
  , G15_MASK = 21522
  , G15_BCH = Utils$3.getBCHDigit(G15);
formatInfo.getEncodedBits = function(W, z) {
    const Y = W.bit << 3 | z;
    let ne = Y << 10;
    for (; Utils$3.getBCHDigit(ne) - G15_BCH >= 0; )
        ne ^= G15 << Utils$3.getBCHDigit(ne) - G15_BCH;
    return (Y << 10 | ne) ^ G15_MASK
}
;
var segments = {};
const Mode$4 = mode;
function NumericData(W) {
    this.mode = Mode$4.NUMERIC,
    this.data = W.toString()
}
NumericData.getBitsLength = function(W) {
    return 10 * Math.floor(W / 3) + (W % 3 ? W % 3 * 3 + 1 : 0)
}
,
NumericData.prototype.getLength = function() {
    return this.data.length
}
,
NumericData.prototype.getBitsLength = function() {
    return NumericData.getBitsLength(this.data.length)
}
,
NumericData.prototype.write = function(W) {
    let z, Y, ne;
    for (z = 0; z + 3 <= this.data.length; z += 3)
        Y = this.data.substr(z, 3),
        ne = parseInt(Y, 10),
        W.put(ne, 10);
    const le = this.data.length - z;
    le > 0 && (Y = this.data.substr(z),
    ne = parseInt(Y, 10),
    W.put(ne, 3 * le + 1))
}
;
var numericData = NumericData;
const Mode$3 = mode
  , ALPHA_NUM_CHARS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];
function AlphanumericData(W) {
    this.mode = Mode$3.ALPHANUMERIC,
    this.data = W
}
AlphanumericData.getBitsLength = function(W) {
    return 11 * Math.floor(W / 2) + W % 2 * 6
}
,
AlphanumericData.prototype.getLength = function() {
    return this.data.length
}
,
AlphanumericData.prototype.getBitsLength = function() {
    return AlphanumericData.getBitsLength(this.data.length)
}
,
AlphanumericData.prototype.write = function(W) {
    let z;
    for (z = 0; z + 2 <= this.data.length; z += 2) {
        let Y = 45 * ALPHA_NUM_CHARS.indexOf(this.data[z]);
        Y += ALPHA_NUM_CHARS.indexOf(this.data[z + 1]),
        W.put(Y, 11)
    }
    this.data.length % 2 && W.put(ALPHA_NUM_CHARS.indexOf(this.data[z]), 6)
}
;
var alphanumericData = AlphanumericData
  , encodeUtf8$1 = function(W) {
    for (var z = [], Y = W.length, ne = 0; ne < Y; ne++) {
        var le = W.charCodeAt(ne);
        if (le >= 55296 && le <= 56319 && Y > ne + 1) {
            var ue = W.charCodeAt(ne + 1);
            ue >= 56320 && ue <= 57343 && (le = 1024 * (le - 55296) + ue - 56320 + 65536,
            ne += 1)
        }
        le < 128 ? z.push(le) : le < 2048 ? (z.push(le >> 6 | 192),
        z.push(63 & le | 128)) : le < 55296 || le >= 57344 && le < 65536 ? (z.push(le >> 12 | 224),
        z.push(le >> 6 & 63 | 128),
        z.push(63 & le | 128)) : le >= 65536 && le <= 1114111 ? (z.push(le >> 18 | 240),
        z.push(le >> 12 & 63 | 128),
        z.push(le >> 6 & 63 | 128),
        z.push(63 & le | 128)) : z.push(239, 191, 189)
    }
    return new Uint8Array(z).buffer
};
const encodeUtf8 = encodeUtf8$1
  , Mode$2 = mode;
function ByteData(W) {
    this.mode = Mode$2.BYTE,
    typeof W == "string" && (W = encodeUtf8(W)),
    this.data = new Uint8Array(W)
}
ByteData.getBitsLength = function(W) {
    return 8 * W
}
,
ByteData.prototype.getLength = function() {
    return this.data.length
}
,
ByteData.prototype.getBitsLength = function() {
    return ByteData.getBitsLength(this.data.length)
}
,
ByteData.prototype.write = function(W) {
    for (let z = 0, Y = this.data.length; z < Y; z++)
        W.put(this.data[z], 8)
}
;
var byteData = ByteData;
const Mode$1 = mode
  , Utils$2 = utils$2;
function KanjiData(W) {
    this.mode = Mode$1.KANJI,
    this.data = W
}
KanjiData.getBitsLength = function(W) {
    return 13 * W
}
,
KanjiData.prototype.getLength = function() {
    return this.data.length
}
,
KanjiData.prototype.getBitsLength = function() {
    return KanjiData.getBitsLength(this.data.length)
}
,
KanjiData.prototype.write = function(W) {
    let z;
    for (z = 0; z < this.data.length; z++) {
        let Y = Utils$2.toSJIS(this.data[z]);
        if (Y >= 33088 && Y <= 40956)
            Y -= 33088;
        else {
            if (!(Y >= 57408 && Y <= 60351))
                throw new Error("Invalid SJIS character: " + this.data[z] + `
Make sure your charset is UTF-8`);
            Y -= 49472
        }
        Y = 192 * (Y >>> 8 & 255) + (255 & Y),
        W.put(Y, 13)
    }
}
;
var kanjiData = KanjiData
  , dijkstra = {
    exports: {}
};
(function(W) {
    var z = {
        single_source_shortest_paths: function(Y, ne, le) {
            var ue = {}
              , de = {};
            de[ne] = 0;
            var he, fe, ge, xe, $e, Ee, Se, Ne = z.PriorityQueue.make();
            for (Ne.push(ne, 0); !Ne.empty(); )
                for (ge in fe = (he = Ne.pop()).value,
                xe = he.cost,
                $e = Y[fe] || {})
                    $e.hasOwnProperty(ge) && (Ee = xe + $e[ge],
                    Se = de[ge],
                    (de[ge] === void 0 || Se > Ee) && (de[ge] = Ee,
                    Ne.push(ge, Ee),
                    ue[ge] = fe));
            if (le !== void 0 && de[le] === void 0) {
                var tt = ["Could not find a path from ", ne, " to ", le, "."].join("");
                throw new Error(tt)
            }
            return ue
        },
        extract_shortest_path_from_predecessor_list: function(Y, ne) {
            for (var le = [], ue = ne; ue; )
                le.push(ue),
                Y[ue],
                ue = Y[ue];
            return le.reverse(),
            le
        },
        find_path: function(Y, ne, le) {
            var ue = z.single_source_shortest_paths(Y, ne, le);
            return z.extract_shortest_path_from_predecessor_list(ue, le)
        },
        PriorityQueue: {
            make: function(Y) {
                var ne, le = z.PriorityQueue, ue = {};
                for (ne in Y = Y || {},
                le)
                    le.hasOwnProperty(ne) && (ue[ne] = le[ne]);
                return ue.queue = [],
                ue.sorter = Y.sorter || le.default_sorter,
                ue
            },
            default_sorter: function(Y, ne) {
                return Y.cost - ne.cost
            },
            push: function(Y, ne) {
                var le = {
                    value: Y,
                    cost: ne
                };
                this.queue.push(le),
                this.queue.sort(this.sorter)
            },
            pop: function() {
                return this.queue.shift()
            },
            empty: function() {
                return this.queue.length === 0
            }
        }
    };
    W.exports = z
}
)(dijkstra);
var dijkstraExports = dijkstra.exports;
(function(W) {
    const z = mode
      , Y = numericData
      , ne = alphanumericData
      , le = byteData
      , ue = kanjiData
      , de = regex
      , he = utils$2
      , fe = dijkstraExports;
    function ge(Ne) {
        return unescape(encodeURIComponent(Ne)).length
    }
    function xe(Ne, tt, rr) {
        const tr = [];
        let we;
        for (; (we = Ne.exec(rr)) !== null; )
            tr.push({
                data: we[0],
                index: we.index,
                mode: tt,
                length: we[0].length
            });
        return tr
    }
    function $e(Ne) {
        const tt = xe(de.NUMERIC, z.NUMERIC, Ne)
          , rr = xe(de.ALPHANUMERIC, z.ALPHANUMERIC, Ne);
        let tr, we;
        return he.isKanjiModeEnabled() ? (tr = xe(de.BYTE, z.BYTE, Ne),
        we = xe(de.KANJI, z.KANJI, Ne)) : (tr = xe(de.BYTE_KANJI, z.BYTE, Ne),
        we = []),
        tt.concat(rr, tr, we).sort(function(Ut, lr) {
            return Ut.index - lr.index
        }).map(function(Ut) {
            return {
                data: Ut.data,
                mode: Ut.mode,
                length: Ut.length
            }
        })
    }
    function Ee(Ne, tt) {
        switch (tt) {
        case z.NUMERIC:
            return Y.getBitsLength(Ne);
        case z.ALPHANUMERIC:
            return ne.getBitsLength(Ne);
        case z.KANJI:
            return ue.getBitsLength(Ne);
        case z.BYTE:
            return le.getBitsLength(Ne)
        }
    }
    function Se(Ne, tt) {
        let rr;
        const tr = z.getBestModeForData(Ne);
        if (rr = z.from(tt, tr),
        rr !== z.BYTE && rr.bit < tr.bit)
            throw new Error('"' + Ne + '" cannot be encoded with mode ' + z.toString(rr) + `.
 Suggested mode is: ` + z.toString(tr));
        switch (rr !== z.KANJI || he.isKanjiModeEnabled() || (rr = z.BYTE),
        rr) {
        case z.NUMERIC:
            return new Y(Ne);
        case z.ALPHANUMERIC:
            return new ne(Ne);
        case z.KANJI:
            return new ue(Ne);
        case z.BYTE:
            return new le(Ne)
        }
    }
    W.fromArray = function(Ne) {
        return Ne.reduce(function(tt, rr) {
            return typeof rr == "string" ? tt.push(Se(rr, null)) : rr.data && tt.push(Se(rr.data, rr.mode)),
            tt
        }, [])
    }
    ,
    W.fromString = function(Ne, tt) {
        const rr = function(lr) {
            const cr = [];
            for (let be = 0; be < lr.length; be++) {
                const mr = lr[be];
                switch (mr.mode) {
                case z.NUMERIC:
                    cr.push([mr, {
                        data: mr.data,
                        mode: z.ALPHANUMERIC,
                        length: mr.length
                    }, {
                        data: mr.data,
                        mode: z.BYTE,
                        length: mr.length
                    }]);
                    break;
                case z.ALPHANUMERIC:
                    cr.push([mr, {
                        data: mr.data,
                        mode: z.BYTE,
                        length: mr.length
                    }]);
                    break;
                case z.KANJI:
                    cr.push([mr, {
                        data: mr.data,
                        mode: z.BYTE,
                        length: ge(mr.data)
                    }]);
                    break;
                case z.BYTE:
                    cr.push([{
                        data: mr.data,
                        mode: z.BYTE,
                        length: ge(mr.data)
                    }])
                }
            }
            return cr
        }($e(Ne, he.isKanjiModeEnabled()))
          , tr = function(lr, cr) {
            const be = {}
              , mr = {
                start: {}
            };
            let fr = ["start"];
            for (let Rr = 0; Rr < lr.length; Rr++) {
                const Pr = lr[Rr]
                  , Fr = [];
                for (let br = 0; br < Pr.length; br++) {
                    const xr = Pr[br]
                      , _r = "" + Rr + br;
                    Fr.push(_r),
                    be[_r] = {
                        node: xr,
                        lastCount: 0
                    },
                    mr[_r] = {};
                    for (let Ir = 0; Ir < fr.length; Ir++) {
                        const Nr = fr[Ir];
                        be[Nr] && be[Nr].node.mode === xr.mode ? (mr[Nr][_r] = Ee(be[Nr].lastCount + xr.length, xr.mode) - Ee(be[Nr].lastCount, xr.mode),
                        be[Nr].lastCount += xr.length) : (be[Nr] && (be[Nr].lastCount = xr.length),
                        mr[Nr][_r] = Ee(xr.length, xr.mode) + 4 + z.getCharCountIndicator(xr.mode, cr))
                    }
                }
                fr = Fr
            }
            for (let Rr = 0; Rr < fr.length; Rr++)
                mr[fr[Rr]].end = 0;
            return {
                map: mr,
                table: be
            }
        }(rr, tt)
          , we = fe.find_path(tr.map, "start", "end")
          , Ut = [];
        for (let lr = 1; lr < we.length - 1; lr++)
            Ut.push(tr.table[we[lr]].node);
        return W.fromArray(function(lr) {
            return lr.reduce(function(cr, be) {
                const mr = cr.length - 1 >= 0 ? cr[cr.length - 1] : null;
                return mr && mr.mode === be.mode ? (cr[cr.length - 1].data += be.data,
                cr) : (cr.push(be),
                cr)
            }, [])
        }(Ut))
    }
    ,
    W.rawSplit = function(Ne) {
        return W.fromArray($e(Ne, he.isKanjiModeEnabled()))
    }
}
)(segments);
const Utils$1 = utils$2
  , ECLevel = errorCorrectionLevel
  , BitBuffer = bitBuffer
  , BitMatrix = bitMatrix
  , AlignmentPattern = alignmentPattern
  , FinderPattern = finderPattern
  , MaskPattern = maskPattern
  , ECCode = errorCorrectionCode
  , ReedSolomonEncoder = reedSolomonEncoder
  , Version = version
  , FormatInfo = formatInfo
  , Mode = mode
  , Segments = segments;
function setupFinderPattern(W, z) {
    const Y = W.size
      , ne = FinderPattern.getPositions(z);
    for (let le = 0; le < ne.length; le++) {
        const ue = ne[le][0]
          , de = ne[le][1];
        for (let he = -1; he <= 7; he++)
            if (!(ue + he <= -1 || Y <= ue + he))
                for (let fe = -1; fe <= 7; fe++)
                    de + fe <= -1 || Y <= de + fe || (he >= 0 && he <= 6 && (fe === 0 || fe === 6) || fe >= 0 && fe <= 6 && (he === 0 || he === 6) || he >= 2 && he <= 4 && fe >= 2 && fe <= 4 ? W.set(ue + he, de + fe, !0, !0) : W.set(ue + he, de + fe, !1, !0))
    }
}
function setupTimingPattern(W) {
    const z = W.size;
    for (let Y = 8; Y < z - 8; Y++) {
        const ne = Y % 2 == 0;
        W.set(Y, 6, ne, !0),
        W.set(6, Y, ne, !0)
    }
}
function setupAlignmentPattern(W, z) {
    const Y = AlignmentPattern.getPositions(z);
    for (let ne = 0; ne < Y.length; ne++) {
        const le = Y[ne][0]
          , ue = Y[ne][1];
        for (let de = -2; de <= 2; de++)
            for (let he = -2; he <= 2; he++)
                de === -2 || de === 2 || he === -2 || he === 2 || de === 0 && he === 0 ? W.set(le + de, ue + he, !0, !0) : W.set(le + de, ue + he, !1, !0)
    }
}
function setupVersionInfo(W, z) {
    const Y = W.size
      , ne = Version.getEncodedBits(z);
    let le, ue, de;
    for (let he = 0; he < 18; he++)
        le = Math.floor(he / 3),
        ue = he % 3 + Y - 8 - 3,
        de = (ne >> he & 1) == 1,
        W.set(le, ue, de, !0),
        W.set(ue, le, de, !0)
}
function setupFormatInfo(W, z, Y) {
    const ne = W.size
      , le = FormatInfo.getEncodedBits(z, Y);
    let ue, de;
    for (ue = 0; ue < 15; ue++)
        de = (le >> ue & 1) == 1,
        ue < 6 ? W.set(ue, 8, de, !0) : ue < 8 ? W.set(ue + 1, 8, de, !0) : W.set(ne - 15 + ue, 8, de, !0),
        ue < 8 ? W.set(8, ne - ue - 1, de, !0) : ue < 9 ? W.set(8, 15 - ue - 1 + 1, de, !0) : W.set(8, 15 - ue - 1, de, !0);
    W.set(ne - 8, 8, 1, !0)
}
function setupData(W, z) {
    const Y = W.size;
    let ne = -1
      , le = Y - 1
      , ue = 7
      , de = 0;
    for (let he = Y - 1; he > 0; he -= 2)
        for (he === 6 && he--; ; ) {
            for (let fe = 0; fe < 2; fe++)
                if (!W.isReserved(le, he - fe)) {
                    let ge = !1;
                    de < z.length && (ge = (z[de] >>> ue & 1) == 1),
                    W.set(le, he - fe, ge),
                    ue--,
                    ue === -1 && (de++,
                    ue = 7)
                }
            if (le += ne,
            le < 0 || Y <= le) {
                le -= ne,
                ne = -ne;
                break
            }
        }
}
function createData(W, z, Y) {
    const ne = new BitBuffer;
    Y.forEach(function(de) {
        ne.put(de.mode.bit, 4),
        ne.put(de.getLength(), Mode.getCharCountIndicator(de.mode, W)),
        de.write(ne)
    });
    const le = 8 * (Utils$1.getSymbolTotalCodewords(W) - ECCode.getTotalCodewordsCount(W, z));
    for (ne.getLengthInBits() + 4 <= le && ne.put(0, 4); ne.getLengthInBits() % 8 != 0; )
        ne.putBit(0);
    const ue = (le - ne.getLengthInBits()) / 8;
    for (let de = 0; de < ue; de++)
        ne.put(de % 2 ? 17 : 236, 8);
    return createCodewords(ne, W, z)
}
function createCodewords(W, z, Y) {
    const ne = Utils$1.getSymbolTotalCodewords(z)
      , le = ne - ECCode.getTotalCodewordsCount(z, Y)
      , ue = ECCode.getBlocksCount(z, Y)
      , de = ue - ne % ue
      , he = Math.floor(ne / ue)
      , fe = Math.floor(le / ue)
      , ge = fe + 1
      , xe = he - fe
      , $e = new ReedSolomonEncoder(xe);
    let Ee = 0;
    const Se = new Array(ue)
      , Ne = new Array(ue);
    let tt = 0;
    const rr = new Uint8Array(W.buffer);
    for (let cr = 0; cr < ue; cr++) {
        const be = cr < de ? fe : ge;
        Se[cr] = rr.slice(Ee, Ee + be),
        Ne[cr] = $e.encode(Se[cr]),
        Ee += be,
        tt = Math.max(tt, be)
    }
    const tr = new Uint8Array(ne);
    let we, Ut, lr = 0;
    for (we = 0; we < tt; we++)
        for (Ut = 0; Ut < ue; Ut++)
            we < Se[Ut].length && (tr[lr++] = Se[Ut][we]);
    for (we = 0; we < xe; we++)
        for (Ut = 0; Ut < ue; Ut++)
            tr[lr++] = Ne[Ut][we];
    return tr
}
function createSymbol(W, z, Y, ne) {
    let le;
    if (Array.isArray(W))
        le = Segments.fromArray(W);
    else {
        if (typeof W != "string")
            throw new Error("Invalid data");
        {
            let ge = z;
            if (!ge) {
                const xe = Segments.rawSplit(W);
                ge = Version.getBestVersionForData(xe, Y)
            }
            le = Segments.fromString(W, ge || 40)
        }
    }
    const ue = Version.getBestVersionForData(le, Y);
    if (!ue)
        throw new Error("The amount of data is too big to be stored in a QR Code");
    if (z) {
        if (z < ue)
            throw new Error(`
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: ` + ue + `.
`)
    } else
        z = ue;
    const de = createData(z, Y, le)
      , he = Utils$1.getSymbolSize(z)
      , fe = new BitMatrix(he);
    return setupFinderPattern(fe, z),
    setupTimingPattern(fe),
    setupAlignmentPattern(fe, z),
    setupFormatInfo(fe, Y, 0),
    z >= 7 && setupVersionInfo(fe, z),
    setupData(fe, de),
    isNaN(ne) && (ne = MaskPattern.getBestMask(fe, setupFormatInfo.bind(null, fe, Y))),
    MaskPattern.applyMask(ne, fe),
    setupFormatInfo(fe, Y, ne),
    {
        modules: fe,
        version: z,
        errorCorrectionLevel: Y,
        maskPattern: ne,
        segments: le
    }
}
qrcode.create = function(W, z) {
    if (W === void 0 || W === "")
        throw new Error("No input text");
    let Y, ne, le = ECLevel.M;
    return z !== void 0 && (le = ECLevel.from(z.errorCorrectionLevel, ECLevel.M),
    Y = Version.from(z.version),
    ne = MaskPattern.from(z.maskPattern),
    z.toSJISFunc && Utils$1.setToSJISFunction(z.toSJISFunc)),
    createSymbol(W, Y, le, ne)
}
;
var canvas = {}
  , utils$1 = {};
(function(W) {
    function z(Y) {
        if (typeof Y == "number" && (Y = Y.toString()),
        typeof Y != "string")
            throw new Error("Color should be defined as hex string");
        let ne = Y.slice().replace("#", "").split("");
        if (ne.length < 3 || ne.length === 5 || ne.length > 8)
            throw new Error("Invalid hex color: " + Y);
        ne.length !== 3 && ne.length !== 4 || (ne = Array.prototype.concat.apply([], ne.map(function(ue) {
            return [ue, ue]
        }))),
        ne.length === 6 && ne.push("F", "F");
        const le = parseInt(ne.join(""), 16);
        return {
            r: le >> 24 & 255,
            g: le >> 16 & 255,
            b: le >> 8 & 255,
            a: 255 & le,
            hex: "#" + ne.slice(0, 6).join("")
        }
    }
    W.getOptions = function(Y) {
        Y || (Y = {}),
        Y.color || (Y.color = {});
        const ne = Y.margin === void 0 || Y.margin === null || Y.margin < 0 ? 4 : Y.margin
          , le = Y.width && Y.width >= 21 ? Y.width : void 0
          , ue = Y.scale || 4;
        return {
            width: le,
            scale: le ? 4 : ue,
            margin: ne,
            color: {
                dark: z(Y.color.dark || "#000000ff"),
                light: z(Y.color.light || "#ffffffff")
            },
            type: Y.type,
            rendererOpts: Y.rendererOpts || {}
        }
    }
    ,
    W.getScale = function(Y, ne) {
        return ne.width && ne.width >= Y + 2 * ne.margin ? ne.width / (Y + 2 * ne.margin) : ne.scale
    }
    ,
    W.getImageWidth = function(Y, ne) {
        const le = W.getScale(Y, ne);
        return Math.floor((Y + 2 * ne.margin) * le)
    }
    ,
    W.qrToImageData = function(Y, ne, le) {
        const ue = ne.modules.size
          , de = ne.modules.data
          , he = W.getScale(ue, le)
          , fe = Math.floor((ue + 2 * le.margin) * he)
          , ge = le.margin * he
          , xe = [le.color.light, le.color.dark];
        for (let $e = 0; $e < fe; $e++)
            for (let Ee = 0; Ee < fe; Ee++) {
                let Se = 4 * ($e * fe + Ee)
                  , Ne = le.color.light;
                $e >= ge && Ee >= ge && $e < fe - ge && Ee < fe - ge && (Ne = xe[de[Math.floor(($e - ge) / he) * ue + Math.floor((Ee - ge) / he)] ? 1 : 0]),
                Y[Se++] = Ne.r,
                Y[Se++] = Ne.g,
                Y[Se++] = Ne.b,
                Y[Se] = Ne.a
            }
    }
}
)(utils$1),
function(W) {
    const z = utils$1;
    W.render = function(Y, ne, le) {
        let ue = le
          , de = ne;
        ue !== void 0 || ne && ne.getContext || (ue = ne,
        ne = void 0),
        ne || (de = function() {
            try {
                return document.createElement("canvas")
            } catch {
                throw new Error("You need to specify a canvas element")
            }
        }()),
        ue = z.getOptions(ue);
        const he = z.getImageWidth(Y.modules.size, ue)
          , fe = de.getContext("2d")
          , ge = fe.createImageData(he, he);
        return z.qrToImageData(ge.data, Y, ue),
        function(xe, $e, Ee) {
            xe.clearRect(0, 0, $e.width, $e.height),
            $e.style || ($e.style = {}),
            $e.height = Ee,
            $e.width = Ee,
            $e.style.height = Ee + "px",
            $e.style.width = Ee + "px"
        }(fe, de, he),
        fe.putImageData(ge, 0, 0),
        de
    }
    ,
    W.renderToDataURL = function(Y, ne, le) {
        let ue = le;
        ue !== void 0 || ne && ne.getContext || (ue = ne,
        ne = void 0),
        ue || (ue = {});
        const de = W.render(Y, ne, ue)
          , he = ue.type || "image/png"
          , fe = ue.rendererOpts || {};
        return de.toDataURL(he, fe.quality)
    }
}(canvas);
var svgTag = {};
const Utils = utils$1;
function getColorAttrib(W, z) {
    const Y = W.a / 255
      , ne = z + '="' + W.hex + '"';
    return Y < 1 ? ne + " " + z + '-opacity="' + Y.toFixed(2).slice(1) + '"' : ne
}
function svgCmd(W, z, Y) {
    let ne = W + z;
    return Y !== void 0 && (ne += " " + Y),
    ne
}
function qrToPath(W, z, Y) {
    let ne = ""
      , le = 0
      , ue = !1
      , de = 0;
    for (let he = 0; he < W.length; he++) {
        const fe = Math.floor(he % z)
          , ge = Math.floor(he / z);
        fe || ue || (ue = !0),
        W[he] ? (de++,
        he > 0 && fe > 0 && W[he - 1] || (ne += ue ? svgCmd("M", fe + Y, .5 + ge + Y) : svgCmd("m", le, 0),
        le = 0,
        ue = !1),
        fe + 1 < z && W[he + 1] || (ne += svgCmd("h", de),
        de = 0)) : le++
    }
    return ne
}
svgTag.render = function(W, z, Y) {
    const ne = Utils.getOptions(z)
      , le = W.modules.size
      , ue = W.modules.data
      , de = le + 2 * ne.margin
      , he = ne.color.light.a ? "<path " + getColorAttrib(ne.color.light, "fill") + ' d="M0 0h' + de + "v" + de + 'H0z"/>' : ""
      , fe = "<path " + getColorAttrib(ne.color.dark, "stroke") + ' d="' + qrToPath(ue, le, ne.margin) + '"/>'
      , ge = 'viewBox="0 0 ' + de + " " + de + '"'
      , xe = '<svg xmlns="http://www.w3.org/2000/svg" ' + (ne.width ? 'width="' + ne.width + '" height="' + ne.width + '" ' : "") + ge + ' shape-rendering="crispEdges">' + he + fe + `</svg>
`;
    return typeof Y == "function" && Y(null, xe),
    xe
}
;
const canPromise = canPromise$1
  , QRCode = qrcode
  , CanvasRenderer = canvas
  , SvgRenderer = svgTag;
function renderCanvas(W, z, Y, ne, le) {
    const ue = [].slice.call(arguments, 1)
      , de = ue.length
      , he = typeof ue[de - 1] == "function";
    if (!he && !canPromise())
        throw new Error("Callback required as last argument");
    if (!he) {
        if (de < 1)
            throw new Error("Too few arguments provided");
        return de === 1 ? (Y = z,
        z = ne = void 0) : de !== 2 || z.getContext || (ne = Y,
        Y = z,
        z = void 0),
        new Promise(function(fe, ge) {
            try {
                const xe = QRCode.create(Y, ne);
                fe(W(xe, z, ne))
            } catch (xe) {
                ge(xe)
            }
        }
        )
    }
    if (de < 2)
        throw new Error("Too few arguments provided");
    de === 2 ? (le = Y,
    Y = z,
    z = ne = void 0) : de === 3 && (z.getContext && le === void 0 ? (le = ne,
    ne = void 0) : (le = ne,
    ne = Y,
    Y = z,
    z = void 0));
    try {
        const fe = QRCode.create(Y, ne);
        le(null, W(fe, z, ne))
    } catch (fe) {
        le(fe)
    }
}
browser$1.create = QRCode.create,
browser$1.toCanvas = renderCanvas.bind(null, CanvasRenderer.render),
browser$1.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL),
browser$1.toString = renderCanvas.bind(null, function(W, z, Y) {
    return SvgRenderer.render(W, Y)
});
const CONNECTING_ERROR_MARGIN = .1
  , CIRCLE_SIZE_MODIFIER = 2.5
  , QRCODE_MATRIX_MARGIN = 7;
function isAdjecentDots(W, z, Y) {
    return W === z ? !1 : (W - z < 0 ? z - W : W - z) <= Y + CONNECTING_ERROR_MARGIN
}
function getMatrix(W, z) {
    const Y = Array.prototype.slice.call(browser$1.create(W, {
        errorCorrectionLevel: z
    }).modules.data, 0)
      , ne = Math.sqrt(Y.length);
    return Y.reduce((le,ue,de)=>(de % ne == 0 ? le.push([ue]) : le[le.length - 1].push(ue)) && le, [])
}
const QrCodeUtil = {
    generate(W, z, Y) {
        const ne = "#141414"
          , le = []
          , ue = getMatrix(W, "Q")
          , de = z / ue.length
          , he = [{
            x: 0,
            y: 0
        }, {
            x: 1,
            y: 0
        }, {
            x: 0,
            y: 1
        }];
        he.forEach(({x: Se, y: Ne})=>{
            const tt = (ue.length - QRCODE_MATRIX_MARGIN) * de * Se
              , rr = (ue.length - QRCODE_MATRIX_MARGIN) * de * Ne
              , tr = .45;
            for (let we = 0; we < he.length; we += 1) {
                const Ut = de * (QRCODE_MATRIX_MARGIN - 2 * we);
                le.push(b`
            <rect
              fill=${we === 2 ? ne : "transparent"}
              width=${we === 0 ? Ut - 5 : Ut}
              rx= ${we === 0 ? (Ut - 5) * tr : Ut * tr}
              ry= ${we === 0 ? (Ut - 5) * tr : Ut * tr}
              stroke=${ne}
              stroke-width=${we === 0 ? 5 : 0}
              height=${we === 0 ? Ut - 5 : Ut}
              x= ${we === 0 ? rr + de * we + 2.5 : rr + de * we}
              y= ${we === 0 ? tt + de * we + 2.5 : tt + de * we}
            />
          `)
            }
        }
        );
        const fe = Math.floor((Y + 25) / de)
          , ge = ue.length / 2 - fe / 2
          , xe = ue.length / 2 + fe / 2 - 1
          , $e = [];
        ue.forEach((Se,Ne)=>{
            Se.forEach((tt,rr)=>{
                if (ue[Ne][rr] && !(Ne < QRCODE_MATRIX_MARGIN && rr < QRCODE_MATRIX_MARGIN || Ne > ue.length - (QRCODE_MATRIX_MARGIN + 1) && rr < QRCODE_MATRIX_MARGIN || Ne < QRCODE_MATRIX_MARGIN && rr > ue.length - (QRCODE_MATRIX_MARGIN + 1) || Ne > ge && Ne < xe && rr > ge && rr < xe)) {
                    const tr = Ne * de + de / 2
                      , we = rr * de + de / 2;
                    $e.push([tr, we])
                }
            }
            )
        }
        );
        const Ee = {};
        return $e.forEach(([Se,Ne])=>{
            Ee[Se] ? Ee[Se]?.push(Ne) : Ee[Se] = [Ne]
        }
        ),
        Object.entries(Ee).map(([Se,Ne])=>{
            const tt = Ne.filter(rr=>Ne.every(tr=>!isAdjecentDots(rr, tr, de)));
            return [Number(Se), tt]
        }
        ).forEach(([Se,Ne])=>{
            Ne.forEach(tt=>{
                le.push(b`<circle cx=${Se} cy=${tt} fill=${ne} r=${de / CIRCLE_SIZE_MODIFIER} />`)
            }
            )
        }
        ),
        Object.entries(Ee).filter(([Se,Ne])=>Ne.length > 1).map(([Se,Ne])=>{
            const tt = Ne.filter(rr=>Ne.some(tr=>isAdjecentDots(rr, tr, de)));
            return [Number(Se), tt]
        }
        ).map(([Se,Ne])=>{
            Ne.sort((rr,tr)=>rr < tr ? -1 : 1);
            const tt = [];
            for (const rr of Ne) {
                const tr = tt.find(we=>we.some(Ut=>isAdjecentDots(rr, Ut, de)));
                tr ? tr.push(rr) : tt.push([rr])
            }
            return [Se, tt.map(rr=>[rr[0], rr[rr.length - 1]])]
        }
        ).forEach(([Se,Ne])=>{
            Ne.forEach(([tt,rr])=>{
                le.push(b`
              <line
                x1=${Se}
                x2=${Se}
                y1=${tt}
                y2=${rr}
                stroke=${ne}
                stroke-width=${de / (CIRCLE_SIZE_MODIFIER / 2)}
                stroke-linecap="round"
              />
            `)
            }
            )
        }
        ),
        le
    }
}
  , styles$m = i$4`
  :host {
    position: relative;
    user-select: none;
    display: block;
    overflow: hidden;
    aspect-ratio: 1 / 1;
    width: var(--local-size);
  }

  :host([data-theme='dark']) {
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px);
    background-color: var(--wui-color-inverse-100);
    padding: var(--wui-spacing-l);
  }

  :host([data-theme='light']) {
    box-shadow: 0 0 0 1px var(--wui-color-bg-125);
    background-color: var(--wui-color-bg-125);
  }

  svg:first-child,
  wui-image,
  wui-icon {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translateY(-50%) translateX(-50%);
  }

  wui-image {
    width: 25%;
    height: 25%;
    border-radius: var(--wui-border-radius-xs);
  }

  wui-icon {
    width: 100%;
    height: 100%;
    color: #3396ff !important;
    transform: translateY(-50%) translateX(-50%) scale(0.25);
  }
`;
var __decorate$H = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiQrCode = class extends s$1 {
    constructor() {
        super(...arguments),
        this.uri = "",
        this.size = 0,
        this.theme = "dark",
        this.imageSrc = void 0,
        this.alt = void 0
    }
    render() {
        return this.dataset.theme = this.theme,
        this.style.cssText = `--local-size: ${this.size}px`,
        x$1`${this.templateVisual()} ${this.templateSvg()}`
    }
    templateSvg() {
        const W = this.theme === "light" ? this.size : this.size - 32;
        return b`
      <svg height=${W} width=${W}>
        ${QrCodeUtil.generate(this.uri, W, W / 4)}
      </svg>
    `
    }
    templateVisual() {
        return this.imageSrc ? x$1`<wui-image src=${this.imageSrc} alt=${this.alt ?? "logo"}></wui-image>` : x$1`<wui-icon size="inherit" color="inherit" name="walletConnect"></wui-icon>`
    }
}
;
WuiQrCode.styles = [resetStyles, styles$m],
__decorate$H([n$2()], WuiQrCode.prototype, "uri", void 0),
__decorate$H([n$2({
    type: Number
})], WuiQrCode.prototype, "size", void 0),
__decorate$H([n$2()], WuiQrCode.prototype, "theme", void 0),
__decorate$H([n$2()], WuiQrCode.prototype, "imageSrc", void 0),
__decorate$H([n$2()], WuiQrCode.prototype, "alt", void 0),
WuiQrCode = __decorate$H([customElement("wui-qr-code")], WuiQrCode);
const styles$l = i$4`
  :host {
    position: relative;
    display: inline-block;
    width: 100%;
  }
`;
var __decorate$G = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiSearchBar = class extends s$1 {
    constructor() {
        super(...arguments),
        this.inputComponentRef = e()
    }
    render() {
        return x$1`
      <wui-input-text
        ${n(this.inputComponentRef)}
        placeholder="Search wallet"
        icon="search"
        type="search"
        enterKeyHint="search"
        size="sm"
      >
        <wui-input-element @click=${this.clearValue} icon="close"></wui-input-element>
      </wui-input-text>
    `
    }
    clearValue() {
        const W = this.inputComponentRef.value
          , z = W?.inputElementRef.value;
        z && (z.value = "",
        z.focus(),
        z.dispatchEvent(new Event("input")))
    }
}
;
WuiSearchBar.styles = [resetStyles, styles$l],
WuiSearchBar = __decorate$G([customElement("wui-search-bar")], WuiSearchBar);
const styles$k = i$4`
  :host {
    display: flex;
    column-gap: var(--wui-spacing-xs);
    align-items: center;
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-005);
    background-color: var(--wui-color-bg-175);
    box-shadow:
      0px 14px 64px -4px rgba(0, 0, 0, 0.15),
      0px 8px 22px -6px rgba(0, 0, 0, 0.15);
  }
`;
var __decorate$F = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiSnackbar = class extends s$1 {
    constructor() {
        super(...arguments),
        this.backgroundColor = "accent-100",
        this.iconColor = "accent-100",
        this.icon = "checkmark",
        this.message = ""
    }
    render() {
        return x$1`
      <wui-icon-box
        size="xs"
        iconColor=${this.iconColor}
        backgroundColor=${this.backgroundColor}
        icon=${this.icon}
      ></wui-icon-box>
      <wui-text variant="paragraph-500" color="fg-100">${this.message}</wui-text>
    `
    }
}
;
WuiSnackbar.styles = [resetStyles, styles$k],
__decorate$F([n$2()], WuiSnackbar.prototype, "backgroundColor", void 0),
__decorate$F([n$2()], WuiSnackbar.prototype, "iconColor", void 0),
__decorate$F([n$2()], WuiSnackbar.prototype, "icon", void 0),
__decorate$F([n$2()], WuiSnackbar.prototype, "message", void 0),
WuiSnackbar = __decorate$F([customElement("wui-snackbar")], WuiSnackbar);
const styles$j = i$4`
  :host {
    display: inline-flex;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    padding: var(--wui-spacing-3xs);
    position: relative;
    height: 36px;
    overflow: hidden;
  }

  :host::before {
    content: '';
    position: absolute;
    pointer-events: none;
    top: 4px;
    left: 4px;
    display: block;
    width: var(--local-tab-width);
    height: 28px;
    border-radius: var(--wui-border-radius-3xl);
    background-color: var(--wui-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-002);
    transform: translateX(calc(var(--local-tab) * var(--local-tab-width)));
    transition: transform var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  :host([data-type='flex'])::before {
    left: 3px;
    transform: translateX(calc((var(--local-tab) * 34px) + (var(--local-tab) * 4px)));
  }

  :host([data-type='flex']) {
    display: flex;
    padding: 0px 0px 0px 12px;
    gap: 4px;
  }

  :host([data-type='flex']) > button > wui-text {
    position: absolute;
    left: 18px;
    opacity: 0;
  }

  button[data-active='true'] > wui-icon,
  button[data-active='true'] > wui-text {
    color: var(--wui-color-fg-100);
  }

  button[data-active='false'] > wui-icon,
  button[data-active='false'] > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='true']:disabled,
  button[data-active='false']:disabled {
    background-color: transparent;
    opacity: 0.5;
    cursor: not-allowed;
  }

  button[data-active='true']:disabled > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='false']:disabled > wui-text {
    color: var(--wui-color-fg-300);
  }

  button > wui-icon,
  button > wui-text {
    pointer-events: none;
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  button {
    width: var(--local-tab-width);
  }

  :host([data-type='flex']) > button {
    width: 34px;
    position: relative;
    display: flex;
    justify-content: flex-start;
  }

  button:hover:enabled,
  button:active:enabled {
    background-color: transparent !important;
  }

  button:hover:enabled > wui-icon,
  button:active:enabled > wui-icon {
    color: var(--wui-color-fg-125);
  }

  button:hover:enabled > wui-text,
  button:active:enabled > wui-text {
    color: var(--wui-color-fg-125);
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
  }
`;
var __decorate$E = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiTabs = class extends s$1 {
    constructor() {
        super(...arguments),
        this.tabs = [],
        this.onTabChange = ()=>null,
        this.buttons = [],
        this.disabled = !1,
        this.activeTab = 0,
        this.localTabWidth = "100px",
        this.isDense = !1
    }
    render() {
        return this.isDense = this.tabs.length > 3,
        this.style.cssText = `
      --local-tab: ${this.activeTab};
      --local-tab-width: ${this.localTabWidth};
    `,
        this.dataset.type = this.isDense ? "flex" : "block",
        this.tabs.map((W,z)=>{
            const Y = z === this.activeTab;
            return x$1`
        <button
          ?disabled=${this.disabled}
          @click=${()=>this.onTabClick(z)}
          data-active=${Y}
        >
          <wui-icon size="sm" color="inherit" name=${W.icon}></wui-icon>
          <wui-text variant="small-600" color="inherit"> ${W.label} </wui-text>
        </button>
      `
        }
        )
    }
    firstUpdated() {
        this.shadowRoot && this.isDense && (this.buttons = [...this.shadowRoot.querySelectorAll("button")],
        setTimeout(()=>{
            this.animateTabs(0, !0)
        }
        , 0))
    }
    onTabClick(W) {
        this.buttons && this.animateTabs(W, !1),
        this.activeTab = W,
        this.onTabChange(W)
    }
    animateTabs(W, z) {
        const Y = this.buttons[this.activeTab]
          , ne = this.buttons[W]
          , le = Y?.querySelector("wui-text")
          , ue = ne?.querySelector("wui-text")
          , de = ne?.getBoundingClientRect()
          , he = ue?.getBoundingClientRect();
        Y && le && !z && W !== this.activeTab && (le.animate([{
            opacity: 0
        }], {
            duration: 50,
            easing: "ease",
            fill: "forwards"
        }),
        Y.animate([{
            width: "34px"
        }], {
            duration: 500,
            easing: "ease",
            fill: "forwards"
        })),
        ne && de && he && ue && (W !== this.activeTab || z) && (this.localTabWidth = `${Math.round(de.width + he.width) + 6}px`,
        ne.animate([{
            width: `${de.width + he.width}px`
        }], {
            duration: z ? 0 : 500,
            fill: "forwards",
            easing: "ease"
        }),
        ue.animate([{
            opacity: 1
        }], {
            duration: z ? 0 : 125,
            delay: z ? 0 : 200,
            fill: "forwards",
            easing: "ease"
        }))
    }
}
;
WuiTabs.styles = [resetStyles, elementStyles, styles$j],
__decorate$E([n$2({
    type: Array
})], WuiTabs.prototype, "tabs", void 0),
__decorate$E([n$2()], WuiTabs.prototype, "onTabChange", void 0),
__decorate$E([n$2({
    type: Array
})], WuiTabs.prototype, "buttons", void 0),
__decorate$E([n$2({
    type: Boolean
})], WuiTabs.prototype, "disabled", void 0),
__decorate$E([r$1()], WuiTabs.prototype, "activeTab", void 0),
__decorate$E([r$1()], WuiTabs.prototype, "localTabWidth", void 0),
__decorate$E([r$1()], WuiTabs.prototype, "isDense", void 0),
WuiTabs = __decorate$E([customElement("wui-tabs")], WuiTabs);
const styles$i = i$4`
  :host {
    display: block;
    padding: 9px var(--wui-spacing-s) 10px var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    background-color: var(--wui-color-fg-100);
    color: var(--wui-color-bg-100);
    position: relative;
  }

  wui-icon {
    position: absolute;
    width: 12px !important;
    height: 4px !important;
  }

  wui-icon[data-placement='top'] {
    bottom: 0;
    left: 50%;
    transform: translate(-50%, 95%);
  }

  wui-icon[data-placement='bottom'] {
    top: 0;
    left: 50%;
    transform: translate(-50%, -95%) rotate(180deg);
  }

  wui-icon[data-placement='right'] {
    top: 50%;
    left: 0;
    transform: translate(-65%, -50%) rotate(90deg);
  }

  wui-icon[data-placement='left'] {
    top: 50%;
    right: 0%;
    transform: translate(65%, -50%) rotate(270deg);
  }
`;
var __decorate$D = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiTooltip = class extends s$1 {
    constructor() {
        super(...arguments),
        this.placement = "top",
        this.message = ""
    }
    render() {
        return x$1`<wui-icon
        data-placement=${this.placement}
        color="fg-100"
        size="inherit"
        name="cursor"
      ></wui-icon>
      <wui-text color="inherit" variant="small-500">${this.message}</wui-text>`
    }
}
;
WuiTooltip.styles = [resetStyles, elementStyles, styles$i],
__decorate$D([n$2()], WuiTooltip.prototype, "placement", void 0),
__decorate$D([n$2()], WuiTooltip.prototype, "message", void 0),
WuiTooltip = __decorate$D([customElement("wui-tooltip")], WuiTooltip);
const styles$h = i$4`
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 64px;
    height: 64px;
    box-shadow: 0 0 0 8px var(--wui-thumbnail-border);
    border-radius: var(--local-border-radius);
    overflow: hidden;
  }

  wui-icon {
    width: 32px;
    height: 32px;
  }
`;
var __decorate$C = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiVisualThumbnail = class extends s$1 {
    render() {
        return this.style.cssText = `--local-border-radius: ${this.borderRadiusFull ? "1000px" : "20px"};`,
        x$1`${this.templateVisual()}`
    }
    templateVisual() {
        return this.imageSrc ? x$1`<wui-image src=${this.imageSrc} alt=${this.alt ?? ""}></wui-image>` : x$1`<wui-icon
      data-parent-size="md"
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></wui-icon>`
    }
}
;
WuiVisualThumbnail.styles = [resetStyles, styles$h],
__decorate$C([n$2()], WuiVisualThumbnail.prototype, "imageSrc", void 0),
__decorate$C([n$2()], WuiVisualThumbnail.prototype, "alt", void 0),
__decorate$C([n$2({
    type: Boolean
})], WuiVisualThumbnail.prototype, "borderRadiusFull", void 0),
WuiVisualThumbnail = __decorate$C([customElement("wui-visual-thumbnail")], WuiVisualThumbnail);
const styles$g = i$4`
  :host {
    display: grid;
    width: inherit;
    height: inherit;
  }
`;
var __decorate$B = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiGrid = class extends s$1 {
    render() {
        return this.style.cssText = `
      grid-template-rows: ${this.gridTemplateRows};
      grid-template-columns: ${this.gridTemplateColumns};
      justify-items: ${this.justifyItems};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      align-content: ${this.alignContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 3)};
    `,
        x$1`<slot></slot>`
    }
}
;
WuiGrid.styles = [resetStyles, styles$g],
__decorate$B([n$2()], WuiGrid.prototype, "gridTemplateRows", void 0),
__decorate$B([n$2()], WuiGrid.prototype, "gridTemplateColumns", void 0),
__decorate$B([n$2()], WuiGrid.prototype, "justifyItems", void 0),
__decorate$B([n$2()], WuiGrid.prototype, "alignItems", void 0),
__decorate$B([n$2()], WuiGrid.prototype, "justifyContent", void 0),
__decorate$B([n$2()], WuiGrid.prototype, "alignContent", void 0),
__decorate$B([n$2()], WuiGrid.prototype, "columnGap", void 0),
__decorate$B([n$2()], WuiGrid.prototype, "rowGap", void 0),
__decorate$B([n$2()], WuiGrid.prototype, "gap", void 0),
__decorate$B([n$2()], WuiGrid.prototype, "padding", void 0),
__decorate$B([n$2()], WuiGrid.prototype, "margin", void 0),
WuiGrid = __decorate$B([customElement("wui-grid")], WuiGrid);
const styles$f = i$4`
  :host {
    position: relative;
    display: flex;
    width: 100%;
    height: 1px;
    background-color: var(--wui-gray-glass-005);
    justify-content: center;
    align-items: center;
  }

  :host > wui-text {
    position: absolute;
    padding: 0px 10px;
    background-color: var(--wui-color-bg-125);
  }
`;
var __decorate$A = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let WuiSeparator = class extends s$1 {
    constructor() {
        super(...arguments),
        this.text = ""
    }
    render() {
        return x$1`${this.template()}`
    }
    template() {
        return this.text ? x$1`<wui-text variant="small-500" color="fg-200">${this.text}</wui-text>` : null
    }
}
;
WuiSeparator.styles = [resetStyles, styles$f],
__decorate$A([n$2()], WuiSeparator.prototype, "text", void 0),
WuiSeparator = __decorate$A([customElement("wui-separator")], WuiSeparator);
var updateLocale$1 = {
    exports: {}
};
updateLocale$1.exports = function(W, z, Y) {
    Y.updateLocale = function(ne, le) {
        var ue = Y.Ls[ne];
        if (ue)
            return (le ? Object.keys(le) : []).forEach(function(de) {
                ue[de] = le[de]
            }),
            ue
    }
}
;
var updateLocaleExports = updateLocale$1.exports;
const updateLocale = getDefaultExportFromCjs(updateLocaleExports);
var relativeTime$1 = {
    exports: {}
};
relativeTime$1.exports = function(W, z, Y) {
    W = W || {};
    var ne = z.prototype
      , le = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
    };
    function ue(he, fe, ge, xe) {
        return ne.fromToBase(he, fe, ge, xe)
    }
    Y.en.relativeTime = le,
    ne.fromToBase = function(he, fe, ge, xe, $e) {
        for (var Ee, Se, Ne, tt = ge.$locale().relativeTime || le, rr = W.thresholds || [{
            l: "s",
            r: 44,
            d: "second"
        }, {
            l: "m",
            r: 89
        }, {
            l: "mm",
            r: 44,
            d: "minute"
        }, {
            l: "h",
            r: 89
        }, {
            l: "hh",
            r: 21,
            d: "hour"
        }, {
            l: "d",
            r: 35
        }, {
            l: "dd",
            r: 25,
            d: "day"
        }, {
            l: "M",
            r: 45
        }, {
            l: "MM",
            r: 10,
            d: "month"
        }, {
            l: "y",
            r: 17
        }, {
            l: "yy",
            d: "year"
        }], tr = rr.length, we = 0; we < tr; we += 1) {
            var Ut = rr[we];
            Ut.d && (Ee = xe ? Y(he).diff(ge, Ut.d, !0) : ge.diff(he, Ut.d, !0));
            var lr = (W.rounding || Math.round)(Math.abs(Ee));
            if (Ne = Ee > 0,
            lr <= Ut.r || !Ut.r) {
                lr <= 1 && we > 0 && (Ut = rr[we - 1]);
                var cr = tt[Ut.l];
                $e && (lr = $e("" + lr)),
                Se = typeof cr == "string" ? cr.replace("%d", lr) : cr(lr, fe, Ut.l, Ne);
                break
            }
        }
        if (fe)
            return Se;
        var be = Ne ? tt.future : tt.past;
        return typeof be == "function" ? be(Se) : be.replace("%s", Se)
    }
    ,
    ne.to = function(he, fe) {
        return ue(he, fe, this, !0)
    }
    ,
    ne.from = function(he, fe) {
        return ue(he, fe, this)
    }
    ;
    var de = function(he) {
        return he.$u ? Y.utc() : Y()
    };
    ne.toNow = function(he) {
        return this.to(de(this), he)
    }
    ,
    ne.fromNow = function(he) {
        return this.from(de(this), he)
    }
}
;
var relativeTimeExports = relativeTime$1.exports;
const relativeTime = getDefaultExportFromCjs(relativeTimeExports);
dayjs.extend(relativeTime),
dayjs.extend(updateLocale),
dayjs.updateLocale("en", {
    relativeTime: {
        future: "in %s",
        past: "%s ago",
        s: "%s sec",
        m: "1 min",
        mm: "%d min",
        h: "1 hr",
        hh: "%d hrs",
        d: "1 d",
        dd: "%d d",
        M: "1 mo",
        MM: "%d mo",
        y: "1 yr",
        yy: "%d yr"
    }
});
const DateUtil = {
    getYear: (W=new Date().toISOString())=>dayjs(W).year(),
    getRelativeDateFromNow: W=>dayjs(W).fromNow(!0)
}
  , FLOAT_FIXED_VALUE = 3
  , plusTypes = ["receive", "deposit", "borrow", "claim"]
  , minusTypes = ["withdraw", "repay", "burn"]
  , TransactionUtil = {
    getTransactionGroupTitle: W=>W === DateUtil.getYear() ? "This Year" : W,
    getTransactionImages(W) {
        const [z,Y] = W
          , ne = !!z && W?.every(ue=>!!ue.nft_info)
          , le = W?.length > 1;
        return W?.length === 2 && !ne ? [this.getTransactionImage(z), this.getTransactionImage(Y)] : le ? W.map(ue=>this.getTransactionImage(ue)) : [this.getTransactionImage(z)]
    },
    getTransactionImage: W=>({
        type: TransactionUtil.getTransactionTransferTokenType(W),
        url: TransactionUtil.getTransactionImageURL(W)
    }),
    getTransactionImageURL(W) {
        let z = null;
        const Y = !!W?.nft_info
          , ne = !!W?.fungible_info;
        return W && Y ? z = W?.nft_info?.content?.preview?.url : W && ne && (z = W?.fungible_info?.icon?.url),
        z
    },
    getTransactionTransferTokenType: W=>W?.fungible_info ? "FUNGIBLE" : W?.nft_info ? "NFT" : null,
    getTransactionDescriptions(W) {
        const z = W.metadata?.operationType
          , Y = W.transfers
          , ne = W.transfers?.length > 0
          , le = W.transfers?.length > 1
          , ue = ne && Y?.every($e=>!!$e.fungible_info)
          , [de,he] = Y;
        let fe = this.getTransferDescription(de)
          , ge = this.getTransferDescription(he);
        if (!ne)
            return (z === "send" || z === "receive") && ue ? (fe = UiHelperUtil.getTruncateString({
                string: W.metadata.sentFrom,
                charsStart: 4,
                charsEnd: 6,
                truncate: "middle"
            }),
            ge = UiHelperUtil.getTruncateString({
                string: W.metadata.sentTo,
                charsStart: 4,
                charsEnd: 6,
                truncate: "middle"
            }),
            [fe, ge]) : [W.metadata.status];
        if (le)
            return Y.map($e=>this.getTransferDescription($e));
        let xe = "";
        return plusTypes.includes(z) ? xe = "+" : minusTypes.includes(z) && (xe = "-"),
        fe = xe.concat(fe),
        [fe]
    },
    getTransferDescription(W) {
        let z = "";
        return W && (W?.nft_info ? z = W?.nft_info?.name || "-" : W?.fungible_info && (z = this.getFungibleTransferDescription(W) || "-")),
        z
    },
    getFungibleTransferDescription(W) {
        return W ? [this.getQuantityFixedValue(W?.quantity.numeric), W?.fungible_info?.symbol].join(" ").trim() : null
    },
    getQuantityFixedValue(W) {
        return W ? parseFloat(W).toFixed(FLOAT_FIXED_VALUE) : null
    }
};
var __decorate$z = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mAccountButton = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.networkImages = AssetController.state.networkImages,
        this.disabled = !1,
        this.balance = "show",
        this.address = AccountController.state.address,
        this.balanceVal = AccountController.state.balance,
        this.balanceSymbol = AccountController.state.balanceSymbol,
        this.profileName = AccountController.state.profileName,
        this.profileImage = AccountController.state.profileImage,
        this.network = NetworkController.state.caipNetwork,
        this.unsubscribe.push(AccountController.subscribe(W=>{
            W.isConnected ? (this.address = W.address,
            this.balanceVal = W.balance,
            this.profileName = W.profileName,
            this.profileImage = W.profileImage,
            this.balanceSymbol = W.balanceSymbol) : (this.address = "",
            this.balanceVal = "",
            this.profileName = "",
            this.profileImage = "",
            this.balanceSymbol = "")
        }
        ), NetworkController.subscribeKey("caipNetwork", W=>this.network = W))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(W=>W())
    }
    render() {
        const W = this.networkImages[this.network?.imageId ?? ""]
          , z = this.balance === "show";
        return x$1`
      <wui-account-button
        .disabled=${!!this.disabled}
        address=${o$2(this.profileName ?? this.address)}
        ?isProfileName=${!!this.profileName}
        networkSrc=${o$2(W)}
        avatarSrc=${o$2(this.profileImage)}
        balance=${z ? CoreHelperUtil.formatBalance(this.balanceVal, this.balanceSymbol) : ""}
        @click=${this.onClick.bind(this)}
      >
      </wui-account-button>
    `
    }
    onClick() {
        ModalController.open()
    }
}
;
__decorate$z([n$2({
    type: Boolean
})], W3mAccountButton.prototype, "disabled", void 0),
__decorate$z([n$2()], W3mAccountButton.prototype, "balance", void 0),
__decorate$z([r$1()], W3mAccountButton.prototype, "address", void 0),
__decorate$z([r$1()], W3mAccountButton.prototype, "balanceVal", void 0),
__decorate$z([r$1()], W3mAccountButton.prototype, "balanceSymbol", void 0),
__decorate$z([r$1()], W3mAccountButton.prototype, "profileName", void 0),
__decorate$z([r$1()], W3mAccountButton.prototype, "profileImage", void 0),
__decorate$z([r$1()], W3mAccountButton.prototype, "network", void 0),
W3mAccountButton = __decorate$z([customElement("w3m-account-button")], W3mAccountButton);
var __decorate$y = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mButton = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.disabled = !1,
        this.balance = void 0,
        this.size = void 0,
        this.label = void 0,
        this.loadingLabel = void 0,
        this.isAccount = AccountController.state.isConnected,
        this.unsubscribe.push(AccountController.subscribeKey("isConnected", W=>{
            this.isAccount = W
        }
        ))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(W=>W())
    }
    render() {
        return this.isAccount ? x$1`
          <w3m-account-button
            .disabled=${!!this.disabled}
            balance=${o$2(this.balance)}
          >
          </w3m-account-button>
        ` : x$1`
          <w3m-connect-button
            size=${o$2(this.size)}
            label=${o$2(this.label)}
            loadingLabel=${o$2(this.loadingLabel)}
          ></w3m-connect-button>
        `
    }
}
;
__decorate$y([n$2({
    type: Boolean
})], W3mButton.prototype, "disabled", void 0),
__decorate$y([n$2()], W3mButton.prototype, "balance", void 0),
__decorate$y([n$2()], W3mButton.prototype, "size", void 0),
__decorate$y([n$2()], W3mButton.prototype, "label", void 0),
__decorate$y([n$2()], W3mButton.prototype, "loadingLabel", void 0),
__decorate$y([r$1()], W3mButton.prototype, "isAccount", void 0),
W3mButton = __decorate$y([customElement("w3m-button")], W3mButton);
var __decorate$x = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mConnectButton = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.size = "md",
        this.label = "Connect Wallet",
        this.loadingLabel = "Connecting...",
        this.open = ModalController.state.open,
        this.unsubscribe.push(ModalController.subscribeKey("open", W=>this.open = W))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(W=>W())
    }
    render() {
        return x$1`
      <wui-connect-button
        size=${o$2(this.size)}
        .loading=${this.open}
        @click=${this.onClick.bind(this)}
      >
        ${this.open ? this.loadingLabel : this.label}
      </wui-connect-button>
    `
    }
    onClick() {
        this.open ? ModalController.close() : ModalController.open()
    }
}
;
__decorate$x([n$2()], W3mConnectButton.prototype, "size", void 0),
__decorate$x([n$2()], W3mConnectButton.prototype, "label", void 0),
__decorate$x([n$2()], W3mConnectButton.prototype, "loadingLabel", void 0),
__decorate$x([r$1()], W3mConnectButton.prototype, "open", void 0),
W3mConnectButton = __decorate$x([customElement("w3m-connect-button")], W3mConnectButton);
const styles$e = i$4`
  :host {
    z-index: var(--w3m-z-index);
    display: block;
    backface-visibility: hidden;
    will-change: opacity;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    opacity: 0;
    background-color: var(--wui-cover);
  }

  @keyframes zoom-in {
    0% {
      transform: scale(0.95) translateY(0);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  @keyframes slide-in {
    0% {
      transform: scale(1) translateY(50px);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  wui-card {
    max-width: 360px;
    width: 100%;
    position: relative;
    animation-delay: 0.3s;
    animation-duration: 0.2s;
    animation-name: zoom-in;
    animation-fill-mode: backwards;
    animation-timing-function: var(--wui-ease-out-power-2);
    outline: none;
  }

  wui-flex {
    overflow-x: hidden;
    overflow-y: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
  }

  @media (max-height: 700px) and (min-width: 431px) {
    wui-flex {
      align-items: flex-start;
    }

    wui-card {
      margin: var(--wui-spacing-xxl) 0px;
    }
  }

  @media (max-width: 430px) {
    wui-flex {
      align-items: flex-end;
    }

    wui-card {
      max-width: 100%;
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      border-bottom: none;
      animation-name: slide-in;
    }
  }
`;
var __decorate$w = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
const SCROLL_LOCK = "scroll-lock";
let W3mModal = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.abortController = void 0,
        this.open = ModalController.state.open,
        this.initializeTheming(),
        ApiController.prefetch(),
        this.unsubscribe.push(ModalController.subscribeKey("open", W=>W ? this.onOpen() : this.onClose())),
        EventsController.sendEvent({
            type: "track",
            event: "MODAL_LOADED"
        })
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(W=>W()),
        this.onRemoveKeyboardListener()
    }
    render() {
        return this.open ? x$1`
          <wui-flex @click=${this.onOverlayClick.bind(this)}>
            <wui-card role="alertdialog" aria-modal="true" tabindex="0">
              <w3m-header></w3m-header>
              <w3m-router></w3m-router>
              <w3m-snackbar></w3m-snackbar>
            </wui-card>
          </wui-flex>
        ` : null
    }
    onOverlayClick(W) {
        W.target === W.currentTarget && ModalController.close()
    }
    initializeTheming() {
        const {themeVariables: W, themeMode: z} = ThemeController.state;
        initializeTheming(W, UiHelperUtil.getColorTheme(z))
    }
    async onClose() {
        this.onScrollUnlock(),
        await this.animate([{
            opacity: 1
        }, {
            opacity: 0
        }], {
            duration: 200,
            easing: "ease",
            fill: "forwards"
        }).finished,
        SnackController.hide(),
        this.open = !1,
        this.onRemoveKeyboardListener()
    }
    async onOpen() {
        this.onScrollLock(),
        this.open = !0,
        await this.animate([{
            opacity: 0
        }, {
            opacity: 1
        }], {
            duration: 200,
            easing: "ease",
            fill: "forwards",
            delay: 300
        }).finished,
        this.onAddKeyboardListener()
    }
    onScrollLock() {
        const W = document.createElement("style");
        W.dataset.w3m = SCROLL_LOCK,
        W.textContent = `
      html, body {
        touch-action: none;
        overflow: hidden;
        overscroll-behavior: contain;
      }
      w3m-modal {
        pointer-events: auto;
      }
    `,
        document.head.appendChild(W)
    }
    onScrollUnlock() {
        const W = document.head.querySelector(`style[data-w3m="${SCROLL_LOCK}"]`);
        W && W.remove()
    }
    onAddKeyboardListener() {
        this.abortController = new AbortController;
        const W = this.shadowRoot?.querySelector("wui-card");
        W?.focus(),
        window.addEventListener("keydown", z=>{
            if (z.key === "Escape")
                ModalController.close();
            else if (z.key === "Tab") {
                const {tagName: Y} = z.target;
                !Y || Y.includes("W3M-") || Y.includes("WUI-") || W?.focus()
            }
        }
        , this.abortController)
    }
    onRemoveKeyboardListener() {
        this.abortController?.abort(),
        this.abortController = void 0
    }
}
;
W3mModal.styles = styles$e,
__decorate$w([r$1()], W3mModal.prototype, "open", void 0),
W3mModal = __decorate$w([customElement("w3m-modal")], W3mModal);
const index = Object.freeze(Object.defineProperty({
    __proto__: null,
    get W3mModal() {
        return W3mModal
    }
}, Symbol.toStringTag, {
    value: "Module"
}));
var __decorate$v = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mNetworkButton = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.disabled = !1,
        this.network = NetworkController.state.caipNetwork,
        this.connected = AccountController.state.isConnected,
        this.unsubscribe.push(NetworkController.subscribeKey("caipNetwork", W=>this.network = W), AccountController.subscribeKey("isConnected", W=>this.connected = W))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(W=>W())
    }
    render() {
        return x$1`
      <wui-network-button
        .disabled=${!!this.disabled}
        imageSrc=${o$2(AssetUtil.getNetworkImage(this.network))}
        @click=${this.onClick.bind(this)}
      >
        ${this.network?.name ?? (this.connected ? "Unknown Network" : "Select Network")}
      </wui-network-button>
    `
    }
    onClick() {
        ModalController.open({
            view: "Networks"
        })
    }
}
;
__decorate$v([n$2({
    type: Boolean
})], W3mNetworkButton.prototype, "disabled", void 0),
__decorate$v([r$1()], W3mNetworkButton.prototype, "network", void 0),
__decorate$v([r$1()], W3mNetworkButton.prototype, "connected", void 0),
W3mNetworkButton = __decorate$v([customElement("w3m-network-button")], W3mNetworkButton);
const styles$d = i$4`
  :host {
    display: block;
    will-change: transform, opacity;
  }
`;
var __decorate$u = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mRouter = class extends s$1 {
    constructor() {
        super(),
        this.resizeObserver = void 0,
        this.prevHeight = "0px",
        this.prevHistoryLength = 1,
        this.unsubscribe = [],
        this.view = RouterController.state.view,
        this.unsubscribe.push(RouterController.subscribeKey("view", W=>this.onViewChange(W)))
    }
    firstUpdated() {
        this.resizeObserver = new ResizeObserver(async([W])=>{
            const z = `${W?.contentRect.height}px`;
            this.prevHeight !== "0px" && (await this.animate([{
                height: this.prevHeight
            }, {
                height: z
            }], {
                duration: 150,
                easing: "ease",
                fill: "forwards"
            }).finished,
            this.style.height = "auto"),
            this.prevHeight = z
        }
        ),
        this.resizeObserver.observe(this.getWrapper())
    }
    disconnectedCallback() {
        this.resizeObserver?.unobserve(this.getWrapper()),
        this.unsubscribe.forEach(W=>W())
    }
    render() {
        return x$1`<div>${this.viewTemplate()}</div>`
    }
    viewTemplate() {
        switch (this.view) {
        case "Connect":
        default:
            return x$1`<w3m-connect-view></w3m-connect-view>`;
        case "ConnectingWalletConnect":
            return x$1`<w3m-connecting-wc-view></w3m-connecting-wc-view>`;
        case "ConnectingExternal":
            return x$1`<w3m-connecting-external-view></w3m-connecting-external-view>`;
        case "ConnectingSiwe":
            return x$1`<w3m-connecting-siwe-view></w3m-connecting-siwe-view>`;
        case "AllWallets":
            return x$1`<w3m-all-wallets-view></w3m-all-wallets-view>`;
        case "Networks":
            return x$1`<w3m-networks-view></w3m-networks-view>`;
        case "SwitchNetwork":
            return x$1`<w3m-network-switch-view></w3m-network-switch-view>`;
        case "Account":
            return x$1`<w3m-account-view></w3m-account-view>`;
        case "WhatIsAWallet":
            return x$1`<w3m-what-is-a-wallet-view></w3m-what-is-a-wallet-view>`;
        case "WhatIsANetwork":
            return x$1`<w3m-what-is-a-network-view></w3m-what-is-a-network-view>`;
        case "GetWallet":
            return x$1`<w3m-get-wallet-view></w3m-get-wallet-view>`;
        case "Downloads":
            return x$1`<w3m-downloads-view></w3m-downloads-view>`;
        case "Transactions":
            return x$1`<w3m-transactions-view></w3m-transactions-view>`
        }
    }
    async onViewChange(W) {
        const {history: z} = RouterController.state;
        let Y = -10
          , ne = 10;
        z.length < this.prevHistoryLength && (Y = 10,
        ne = -10),
        this.prevHistoryLength = z.length,
        await this.animate([{
            opacity: 1,
            transform: "translateX(0px)"
        }, {
            opacity: 0,
            transform: `translateX(${Y}px)`
        }], {
            duration: 150,
            easing: "ease",
            fill: "forwards"
        }).finished,
        this.view = W,
        await this.animate([{
            opacity: 0,
            transform: `translateX(${ne}px)`
        }, {
            opacity: 1,
            transform: "translateX(0px)"
        }], {
            duration: 150,
            easing: "ease",
            fill: "forwards",
            delay: 50
        }).finished
    }
    getWrapper() {
        return this.shadowRoot?.querySelector("div")
    }
}
;
W3mRouter.styles = styles$d,
__decorate$u([r$1()], W3mRouter.prototype, "view", void 0),
W3mRouter = __decorate$u([customElement("w3m-router")], W3mRouter);
const styles$c = i$4`
  wui-flex {
    width: 100%;
  }

  :host > wui-flex:first-child {
    transform: translateY(calc(var(--wui-spacing-xxs) * -1));
  }

  wui-icon-link {
    margin-right: calc(var(--wui-icon-box-size-md) * -1);
  }
`;
var __decorate$t = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mAccountView = class extends s$1 {
    constructor() {
        super(),
        this.usubscribe = [],
        this.networkImages = AssetController.state.networkImages,
        this.address = AccountController.state.address,
        this.profileImage = AccountController.state.profileImage,
        this.profileName = AccountController.state.profileName,
        this.balance = AccountController.state.balance,
        this.balanceSymbol = AccountController.state.balanceSymbol,
        this.network = NetworkController.state.caipNetwork,
        this.disconecting = !1,
        this.usubscribe.push(AccountController.subscribe(W=>{
            W.address ? (this.address = W.address,
            this.profileImage = W.profileImage,
            this.profileName = W.profileName,
            this.balance = W.balance,
            this.balanceSymbol = W.balanceSymbol) : ModalController.close()
        }
        ), NetworkController.subscribeKey("caipNetwork", W=>{
            W?.id && (this.network = W)
        }
        ))
    }
    disconnectedCallback() {
        this.usubscribe.forEach(W=>W())
    }
    render() {
        if (!this.address)
            throw new Error("w3m-account-view: No account provided");
        const W = this.networkImages[this.network?.imageId ?? ""];
        return x$1`
      <wui-flex
        flexDirection="column"
        .padding=${["0", "s", "m", "s"]}
        alignItems="center"
        gap="l"
      >
        <wui-avatar
          alt=${this.address}
          address=${this.address}
          imageSrc=${o$2(this.profileImage)}
        ></wui-avatar>

        <wui-flex flexDirection="column" alignItems="center">
          <wui-flex gap="3xs" alignItems="center" justifyContent="center">
            <wui-text variant="large-600" color="fg-100">
              ${this.profileName ? UiHelperUtil.getTruncateString({
            string: this.profileName,
            charsStart: 20,
            charsEnd: 0,
            truncate: "end"
        }) : UiHelperUtil.getTruncateString({
            string: this.address,
            charsStart: 4,
            charsEnd: 6,
            truncate: "middle"
        })}
            </wui-text>
            <wui-icon-link
              size="md"
              icon="copy"
              iconColor="fg-200"
              @click=${this.onCopyAddress}
            ></wui-icon-link>
          </wui-flex>
          <wui-flex gap="s" flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-500" color="fg-200">
              ${CoreHelperUtil.formatBalance(this.balance, this.balanceSymbol)}
            </wui-text>

            ${this.explorerBtnTemplate()}
          </wui-flex>
        </wui-flex>
      </wui-flex>

      <wui-flex flexDirection="column" gap="xs" .padding=${["0", "s", "s", "s"]}>
        <wui-list-item
          .variant=${W ? "image" : "icon"}
          iconVariant="overlay"
          icon="networkPlaceholder"
          imageSrc=${o$2(W)}
          ?chevron=${this.isAllowedNetworkSwitch()}
          @click=${this.onNetworks.bind(this)}
        >
          <wui-text variant="paragraph-500" color="fg-100">
            ${this.network?.name ?? "Unknown"}
          </wui-text>
        </wui-list-item>
        <wui-list-item
          iconVariant="blue"
          icon="swapHorizontalBold"
          iconSize="sm"
          ?chevron=${!0}
          @click=${this.onTransactions.bind(this)}
        >
          <wui-text variant="paragraph-500" color="fg-100">Activity</wui-text>
        </wui-list-item>
        <wui-list-item
          variant="icon"
          iconVariant="overlay"
          icon="disconnect"
          ?chevron=${!1}
          .loading=${this.disconecting}
          @click=${this.onDisconnect.bind(this)}
        >
          <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
        </wui-list-item>
      </wui-flex>
    `
    }
    explorerBtnTemplate() {
        const {addressExplorerUrl: W} = AccountController.state;
        return W ? x$1`
      <wui-button size="sm" variant="shade" @click=${this.onExplorer.bind(this)}>
        <wui-icon size="sm" color="inherit" slot="iconLeft" name="compass"></wui-icon>
        Block Explorer
        <wui-icon size="sm" color="inherit" slot="iconRight" name="externalLink"></wui-icon>
      </wui-button>
    ` : null
    }
    isAllowedNetworkSwitch() {
        const {requestedCaipNetworks: W} = NetworkController.state
          , z = !!W && W.length > 1
          , Y = W?.find(({id: ne})=>ne === this.network?.id);
        return z || !Y
    }
    onCopyAddress() {
        try {
            this.address && (CoreHelperUtil.copyToClopboard(this.address),
            SnackController.showSuccess("Address copied"))
        } catch {
            SnackController.showError("Failed to copy")
        }
    }
    onNetworks() {
        this.isAllowedNetworkSwitch() && RouterController.push("Networks")
    }
    onTransactions() {
        EventsController.sendEvent({
            type: "track",
            event: "CLICK_TRANSACTIONS"
        }),
        RouterController.push("Transactions")
    }
    async onDisconnect() {
        try {
            this.disconecting = !0,
            await ConnectionController.disconnect(),
            EventsController.sendEvent({
                type: "track",
                event: "DISCONNECT_SUCCESS"
            }),
            ModalController.close()
        } catch {
            EventsController.sendEvent({
                type: "track",
                event: "DISCONNECT_ERROR"
            }),
            SnackController.showError("Failed to disconnect")
        } finally {
            this.disconecting = !1
        }
    }
    onExplorer() {
        const {addressExplorerUrl: W} = AccountController.state;
        W && CoreHelperUtil.openHref(W, "_blank")
    }
}
;
W3mAccountView.styles = styles$c,
__decorate$t([r$1()], W3mAccountView.prototype, "address", void 0),
__decorate$t([r$1()], W3mAccountView.prototype, "profileImage", void 0),
__decorate$t([r$1()], W3mAccountView.prototype, "profileName", void 0),
__decorate$t([r$1()], W3mAccountView.prototype, "balance", void 0),
__decorate$t([r$1()], W3mAccountView.prototype, "balanceSymbol", void 0),
__decorate$t([r$1()], W3mAccountView.prototype, "network", void 0),
__decorate$t([r$1()], W3mAccountView.prototype, "disconecting", void 0),
W3mAccountView = __decorate$t([customElement("w3m-account-view")], W3mAccountView);
var __decorate$s = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mAllWalletsView = class extends s$1 {
    constructor() {
        super(...arguments),
        this.search = "",
        this.onDebouncedSearch = CoreHelperUtil.debounce(W=>{
            this.search = W
        }
        )
    }
    render() {
        const W = this.search.length >= 2;
        return x$1`
      <wui-flex padding="s" gap="s">
        <wui-search-bar @inputChange=${this.onInputChange.bind(this)}></wui-search-bar>
        ${this.qrButtonTemplate()}
      </wui-flex>
      ${W ? x$1`<w3m-all-wallets-search query=${this.search}></w3m-all-wallets-search>` : x$1`<w3m-all-wallets-list></w3m-all-wallets-list>`}
    `
    }
    onInputChange(W) {
        this.onDebouncedSearch(W.detail)
    }
    qrButtonTemplate() {
        return CoreHelperUtil.isMobile() ? x$1`
        <wui-icon-box
          size="lg"
          iconSize="xl"
          iconColor="accent-100"
          backgroundColor="accent-100"
          icon="qrCode"
          background="transparent"
          border
          borderColor="wui-accent-glass-010"
          @click=${this.onWalletConnectQr.bind(this)}
        ></wui-icon-box>
      ` : null
    }
    onWalletConnectQr() {
        RouterController.push("ConnectingWalletConnect")
    }
}
;
__decorate$s([r$1()], W3mAllWalletsView.prototype, "search", void 0),
W3mAllWalletsView = __decorate$s([customElement("w3m-all-wallets-view")], W3mAllWalletsView);
const styles$b = i$4`
  wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  wui-flex::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$r = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mConnectView = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.connectors = ConnectorController.state.connectors,
        this.unsubscribe.push(ConnectorController.subscribeKey("connectors", W=>this.connectors = W))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(W=>W())
    }
    render() {
        return x$1`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        ${this.walletConnectConnectorTemplate()} ${this.recentTemplate()}
        ${this.announcedTemplate()} ${this.injectedTemplate()} ${this.featuredTemplate()}
        ${this.customTemplate()} ${this.recommendedTemplate()} ${this.connectorsTemplate()}
        ${this.allWalletsTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `
    }
    walletConnectConnectorTemplate() {
        if (CoreHelperUtil.isMobile())
            return null;
        const W = this.connectors.find(z=>z.type === "WALLET_CONNECT");
        return W ? x$1`
      <wui-list-wallet
        imageSrc=${o$2(AssetUtil.getConnectorImage(W))}
        name=${W.name ?? "Unknown"}
        @click=${()=>this.onConnector(W)}
        tagLabel="qr code"
        tagVariant="main"
      >
      </wui-list-wallet>
    ` : null
    }
    customTemplate() {
        const {customWallets: W} = OptionsController.state;
        return W?.length ? this.filterOutDuplicateWallets(W).map(z=>x$1`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getWalletImage(z))}
          name=${z.name ?? "Unknown"}
          @click=${()=>this.onConnectWallet(z)}
        >
        </wui-list-wallet>
      `) : null
    }
    featuredTemplate() {
        const {featured: W} = ApiController.state;
        return W.length ? this.filterOutDuplicateWallets(W).map(z=>x$1`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getWalletImage(z))}
          name=${z.name ?? "Unknown"}
          @click=${()=>this.onConnectWallet(z)}
        >
        </wui-list-wallet>
      `) : null
    }
    recentTemplate() {
        return StorageUtil.getRecentWallets().map(W=>x$1`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getWalletImage(W))}
          name=${W.name ?? "Unknown"}
          @click=${()=>this.onConnectWallet(W)}
          tagLabel="recent"
          tagVariant="shade"
        >
        </wui-list-wallet>
      `)
    }
    announcedTemplate() {
        return this.connectors.map(W=>W.type !== "ANNOUNCED" ? null : x$1`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getConnectorImage(W))}
          name=${W.name ?? "Unknown"}
          @click=${()=>this.onConnector(W)}
          tagLabel="installed"
          tagVariant="success"
        >
        </wui-list-wallet>
      `)
    }
    injectedTemplate() {
        const W = this.connectors.find(z=>z.type === "ANNOUNCED");
        return this.connectors.map(z=>z.type !== "INJECTED" ? null : ConnectionController.checkInstalled() ? x$1`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getConnectorImage(z))}
          name=${z.name ?? "Unknown"}
          @click=${()=>this.onConnector(z)}
          tagLabel=${o$2(W ? void 0 : "installed")}
          tagVariant=${o$2(W ? void 0 : "success")}
        >
        </wui-list-wallet>
      ` : null)
    }
    connectorsTemplate() {
        return this.connectors.map(W=>["WALLET_CONNECT", "INJECTED", "ANNOUNCED"].includes(W.type) ? null : x$1`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getConnectorImage(W))}
          name=${W.name ?? "Unknown"}
          @click=${()=>this.onConnector(W)}
        >
        </wui-list-wallet>
      `)
    }
    allWalletsTemplate() {
        const W = 10 * Math.floor(ApiController.state.count / 10);
        return x$1`
      <wui-list-wallet
        name="All Wallets"
        walletIcon="allWallets"
        showAllWallets
        @click=${this.onAllWallets.bind(this)}
        tagLabel=${`${W}+`}
        tagVariant="shade"
      ></wui-list-wallet>
    `
    }
    recommendedTemplate() {
        const {recommended: W} = ApiController.state
          , {customWallets: z, featuredWalletIds: Y} = OptionsController.state
          , {connectors: ne} = ConnectorController.state
          , le = StorageUtil.getRecentWallets()
          , ue = ne.filter(fe=>fe.type === "ANNOUNCED");
        if (Y || z || !W.length)
            return null;
        const de = ue.length + le.length
          , he = Math.max(0, 2 - de);
        return this.filterOutDuplicateWallets(W).slice(0, he).map(fe=>x$1`
        <wui-list-wallet
          imageSrc=${o$2(AssetUtil.getWalletImage(fe))}
          name=${fe?.name ?? "Unknown"}
          @click=${()=>this.onConnectWallet(fe)}
        >
        </wui-list-wallet>
      `)
    }
    onConnector(W) {
        W.type === "WALLET_CONNECT" ? CoreHelperUtil.isMobile() ? RouterController.push("AllWallets") : RouterController.push("ConnectingWalletConnect") : RouterController.push("ConnectingExternal", {
            connector: W
        })
    }
    filterOutDuplicateWallets(W) {
        const {connectors: z} = ConnectorController.state
          , Y = StorageUtil.getRecentWallets().map(le=>le.id)
          , ne = z.map(le=>le.info?.rdns).filter(Boolean);
        return W.filter(le=>!Y.includes(le.id) && !ne.includes(le.rdns ?? void 0))
    }
    onAllWallets() {
        EventsController.sendEvent({
            type: "track",
            event: "CLICK_ALL_WALLETS"
        }),
        RouterController.push("AllWallets")
    }
    onConnectWallet(W) {
        RouterController.push("ConnectingWalletConnect", {
            wallet: W
        })
    }
}
;
W3mConnectView.styles = styles$b,
__decorate$r([r$1()], W3mConnectView.prototype, "connectors", void 0),
W3mConnectView = __decorate$r([customElement("w3m-connect-view")], W3mConnectView);
const styles$a = i$4`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }
`;
var __decorate$q = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
class W3mConnectingWidget extends s$1 {
    constructor() {
        super(),
        this.wallet = RouterController.state.data?.wallet,
        this.connector = RouterController.state.data?.connector,
        this.timeout = void 0,
        this.secondaryBtnLabel = "Try again",
        this.secondaryBtnIcon = "refresh",
        this.secondaryLabel = "Accept connection request in the wallet",
        this.onConnect = void 0,
        this.onRender = void 0,
        this.onAutoConnect = void 0,
        this.isWalletConnect = !0,
        this.unsubscribe = [],
        this.imageSrc = AssetUtil.getWalletImage(this.wallet) ?? AssetUtil.getConnectorImage(this.connector),
        this.name = this.wallet?.name ?? this.connector?.name ?? "Wallet",
        this.isRetrying = !1,
        this.uri = ConnectionController.state.wcUri,
        this.error = ConnectionController.state.wcError,
        this.ready = !1,
        this.showRetry = !1,
        this.buffering = !1,
        this.isMobile = !1,
        this.onRetry = void 0,
        this.unsubscribe.push(ConnectionController.subscribeKey("wcUri", z=>{
            this.uri = z,
            this.isRetrying && this.onRetry && (this.isRetrying = !1,
            this.onConnect?.())
        }
        ), ConnectionController.subscribeKey("wcError", z=>this.error = z), ConnectionController.subscribeKey("buffering", z=>this.buffering = z))
    }
    firstUpdated() {
        this.onAutoConnect?.(),
        this.showRetry = !this.onAutoConnect
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(z=>z()),
        clearTimeout(this.timeout)
    }
    render() {
        this.onRender?.(),
        this.onShowRetry();
        const z = this.error ? "Connection can be declined if a previous request is still active" : this.secondaryLabel;
        let Y = `Continue in ${this.name}`;
        return this.buffering && (Y = "Connecting..."),
        this.error && (Y = "Connection declined"),
        x$1`
      <wui-flex
        data-error=${o$2(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-wallet-image size="lg" imageSrc=${o$2(this.imageSrc)}></wui-wallet-image>

          ${this.error ? null : this.loaderTemplate()}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text variant="paragraph-500" color=${this.error ? "error-100" : "fg-100"}>
            ${Y}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${z}</wui-text>
        </wui-flex>

        <wui-button
          variant="accent"
          ?disabled=${!this.error && this.buffering}
          @click=${this.onTryAgain.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name=${this.secondaryBtnIcon}></wui-icon>
          ${this.secondaryBtnLabel}
        </wui-button>
      </wui-flex>

      ${this.isWalletConnect ? x$1`
            <wui-flex .padding=${["0", "xl", "xl", "xl"]} justifyContent="center">
              <wui-link @click=${this.onCopyUri} color="fg-200">
                <wui-icon size="sm" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
                Copy Link
              </wui-link>
            </wui-flex>
          ` : null}

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `
    }
    onShowRetry() {
        this.error && !this.showRetry && (this.showRetry = !0,
        (this.shadowRoot?.querySelector("wui-button")).animate([{
            opacity: 0
        }, {
            opacity: 1
        }], {
            fill: "forwards",
            easing: "ease"
        }))
    }
    onTryAgain() {
        this.buffering || (ConnectionController.setWcError(!1),
        this.onRetry ? (this.isRetrying = !0,
        this.onRetry?.()) : this.onConnect?.())
    }
    loaderTemplate() {
        const z = ThemeController.state.themeVariables["--w3m-border-radius-master"]
          , Y = z ? parseInt(z.replace("px", ""), 10) : 4;
        return x$1`<wui-loading-thumbnail radius=${9 * Y}></wui-loading-thumbnail>`
    }
    onCopyUri() {
        try {
            this.uri && (CoreHelperUtil.copyToClopboard(this.uri),
            SnackController.showSuccess("Link copied"))
        } catch {
            SnackController.showError("Failed to copy")
        }
    }
}
W3mConnectingWidget.styles = styles$a,
__decorate$q([r$1()], W3mConnectingWidget.prototype, "uri", void 0),
__decorate$q([r$1()], W3mConnectingWidget.prototype, "error", void 0),
__decorate$q([r$1()], W3mConnectingWidget.prototype, "ready", void 0),
__decorate$q([r$1()], W3mConnectingWidget.prototype, "showRetry", void 0),
__decorate$q([r$1()], W3mConnectingWidget.prototype, "buffering", void 0),
__decorate$q([n$2({
    type: Boolean
})], W3mConnectingWidget.prototype, "isMobile", void 0),
__decorate$q([n$2()], W3mConnectingWidget.prototype, "onRetry", void 0);
var __decorate$p = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
const platformMap = {
    INJECTED: "browser",
    ANNOUNCED: "browser"
};
let W3mConnectingExternalView = class extends W3mConnectingWidget {
    constructor() {
        if (super(),
        !this.connector)
            throw new Error("w3m-connecting-view: No connector provided");
        EventsController.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: this.connector.name ?? "Unknown",
                platform: platformMap[this.connector.type] ?? "external"
            }
        }),
        this.onConnect = this.onConnectProxy.bind(this),
        this.onAutoConnect = this.onConnectProxy.bind(this),
        this.isWalletConnect = !1
    }
    async onConnectProxy() {
        try {
            this.error = !1,
            this.connector && (this.connector.imageUrl && StorageUtil.setConnectedWalletImageUrl(this.connector.imageUrl),
            await ConnectionController.connectExternal(this.connector),
            ModalController.close(),
            EventsController.sendEvent({
                type: "track",
                event: "CONNECT_SUCCESS",
                properties: {
                    method: "external"
                }
            }))
        } catch (W) {
            EventsController.sendEvent({
                type: "track",
                event: "CONNECT_ERROR",
                properties: {
                    message: W?.message ?? "Unknown"
                }
            }),
            this.error = !0
        }
    }
}
;
W3mConnectingExternalView = __decorate$p([customElement("w3m-connecting-external-view")], W3mConnectingExternalView);
var __decorate$o = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mConnectingSiweView = class extends s$1 {
    constructor() {
        super(...arguments),
        this.dappUrl = OptionsController.state.metadata?.url,
        this.dappName = OptionsController.state.metadata?.name
    }
    render() {
        return x$1`
      <wui-flex justifyContent="center" .padding=${["2xl", "0", "xxl", "0"]}>
        <w3m-connecting-siwe></w3m-connecting-siwe>
      </wui-flex>
      <wui-flex
        .padding=${["0", "4xl", "l", "4xl"]}
        gap="s"
        justifyContent="space-between"
      >
        <wui-text variant="paragraph-500" align="center" color="fg-100"
          >${this.dappName ?? "Dapp"} wants to connect to your wallet</wui-text
        >
      </wui-flex>
      ${this.urlTemplate()}
      <wui-flex
        .padding=${["0", "3xl", "l", "3xl"]}
        gap="s"
        justifyContent="space-between"
      >
        <wui-text variant="small-400" align="center" color="fg-200"
          >Sign this message to prove you own this wallet and to continue</wui-text
        >
      </wui-flex>
      <wui-flex .padding=${["l", "xl", "xl", "xl"]} gap="s" justifyContent="space-between">
        <wui-button size="md" ?fullwidth=${!0} variant="shade" @click=${this.onCancel.bind(this)}>
          Cancel
        </wui-button>
        <wui-button size="md" ?fullwidth=${!0} variant="fill" @click=${this.onSign.bind(this)}>
          Sign
        </wui-button>
      </wui-flex>
    `
    }
    urlTemplate() {
        return this.dappUrl ? x$1`<wui-flex .padding=${["0", "0", "l", "0"]} justifyContent="center">
        <wui-button size="sm" variant="accentBg" @click=${this.onDappLink.bind(this)}>
          ${this.dappUrl}
          <wui-icon size="sm" color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-button>
      </wui-flex>` : null
    }
    onDappLink() {
        this.dappUrl && CoreHelperUtil.openHref(this.dappUrl, "_blank")
    }
    onSign() {}
    onCancel() {
        RouterController.goBack()
    }
}
;
W3mConnectingSiweView = __decorate$o([customElement("w3m-connecting-siwe-view")], W3mConnectingSiweView);
var __decorate$n = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mConnectingWcView = class extends s$1 {
    constructor() {
        super(),
        this.interval = void 0,
        this.lastRetry = Date.now(),
        this.wallet = RouterController.state.data?.wallet,
        this.platform = void 0,
        this.platforms = [],
        this.initializeConnection(),
        this.interval = setInterval(this.initializeConnection.bind(this), ConstantsUtil$1.TEN_SEC_MS)
    }
    disconnectedCallback() {
        clearTimeout(this.interval)
    }
    render() {
        return this.wallet ? (this.determinePlatforms(),
        x$1`
      ${this.headerTemplate()}
      <div>${this.platformTemplate()}</div>
    `) : x$1`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`
    }
    async initializeConnection(W=!1) {
        try {
            const {wcPairingExpiry: z} = ConnectionController.state;
            if (W || CoreHelperUtil.isPairingExpired(z)) {
                if (ConnectionController.connectWalletConnect(),
                this.wallet) {
                    const Y = AssetUtil.getWalletImage(this.wallet);
                    Y && StorageUtil.setConnectedWalletImageUrl(Y)
                } else {
                    const Y = ConnectorController.state.connectors.find(le=>le.type === "WALLET_CONNECT")
                      , ne = AssetUtil.getConnectorImage(Y);
                    ne && StorageUtil.setConnectedWalletImageUrl(ne)
                }
                await ConnectionController.state.wcPromise,
                this.finalizeConnection(),
                ModalController.close()
            }
        } catch (z) {
            EventsController.sendEvent({
                type: "track",
                event: "CONNECT_ERROR",
                properties: {
                    message: z?.message ?? "Unknown"
                }
            }),
            ConnectionController.setWcError(!0),
            CoreHelperUtil.isAllowedRetry(this.lastRetry) && (SnackController.showError("Declined"),
            this.lastRetry = Date.now(),
            this.initializeConnection(!0))
        }
    }
    finalizeConnection() {
        const {wcLinking: W, recentWallet: z} = ConnectionController.state;
        W && StorageUtil.setWalletConnectDeepLink(W),
        z && StorageUtil.setWeb3ModalRecent(z),
        EventsController.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            properties: {
                method: W ? "mobile" : "qrcode"
            }
        })
    }
    determinePlatforms() {
        if (!this.wallet)
            throw new Error("w3m-connecting-wc-view:determinePlatforms No wallet");
        if (this.platform)
            return;
        const {mobile_link: W, desktop_link: z, webapp_link: Y, injected: ne, rdns: le} = this.wallet
          , ue = ne?.map(({injected_id: Se})=>Se).filter(Boolean)
          , de = le ? [le] : ue ?? []
          , he = de.length
          , fe = W
          , ge = Y
          , xe = ConnectionController.checkInstalled(de)
          , $e = he && xe
          , Ee = z && !CoreHelperUtil.isMobile();
        $e && this.platforms.push("browser"),
        fe && this.platforms.push(CoreHelperUtil.isMobile() ? "mobile" : "qrcode"),
        ge && this.platforms.push("web"),
        Ee && this.platforms.push("desktop"),
        !$e && he && this.platforms.push("unsupported"),
        this.platform = this.platforms[0]
    }
    platformTemplate() {
        switch (this.platform) {
        case "browser":
            return x$1`<w3m-connecting-wc-browser></w3m-connecting-wc-browser>`;
        case "desktop":
            return x$1`
          <w3m-connecting-wc-desktop .onRetry=${()=>this.initializeConnection(!0)}>
          </w3m-connecting-wc-desktop>
        `;
        case "web":
            return x$1`
          <w3m-connecting-wc-web .onRetry=${()=>this.initializeConnection(!0)}>
          </w3m-connecting-wc-web>
        `;
        case "mobile":
            return x$1`
          <w3m-connecting-wc-mobile isMobile .onRetry=${()=>this.initializeConnection(!0)}>
          </w3m-connecting-wc-mobile>
        `;
        case "qrcode":
            return x$1`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
        default:
            return x$1`<w3m-connecting-wc-unsupported></w3m-connecting-wc-unsupported>`
        }
    }
    headerTemplate() {
        return this.platforms.length > 1 ? x$1`
      <w3m-connecting-header
        .platforms=${this.platforms}
        .onSelectPlatfrom=${this.onSelectPlatform.bind(this)}
      >
      </w3m-connecting-header>
    ` : null
    }
    async onSelectPlatform(W) {
        const z = this.shadowRoot?.querySelector("div");
        z && (await z.animate([{
            opacity: 1
        }, {
            opacity: 0
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }).finished,
        this.platform = W,
        z.animate([{
            opacity: 0
        }, {
            opacity: 1
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }))
    }
}
;
__decorate$n([r$1()], W3mConnectingWcView.prototype, "platform", void 0),
__decorate$n([r$1()], W3mConnectingWcView.prototype, "platforms", void 0),
W3mConnectingWcView = __decorate$n([customElement("w3m-connecting-wc-view")], W3mConnectingWcView);
var __decorate$m = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mDownloadsView = class extends s$1 {
    constructor() {
        super(...arguments),
        this.wallet = RouterController.state.data?.wallet
    }
    render() {
        if (!this.wallet)
            throw new Error("w3m-downloads-view");
        return x$1`
      <wui-flex gap="xs" flexDirection="column" .padding=${["s", "s", "l", "s"]}>
        ${this.chromeTemplate()} ${this.iosTemplate()} ${this.androidTemplate()}
        ${this.homepageTemplate()}
      </wui-flex>
    `
    }
    chromeTemplate() {
        return this.wallet?.chrome_store ? x$1`<wui-list-item
      variant="icon"
      icon="chromeStore"
      iconVariant="square"
      @click=${this.onChromeStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Chrome Extension</wui-text>
    </wui-list-item>` : null
    }
    iosTemplate() {
        return this.wallet?.app_store ? x$1`<wui-list-item
      variant="icon"
      icon="appStore"
      iconVariant="square"
      @click=${this.onAppStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">iOS App</wui-text>
    </wui-list-item>` : null
    }
    androidTemplate() {
        return this.wallet?.play_store ? x$1`<wui-list-item
      variant="icon"
      icon="playStore"
      iconVariant="square"
      @click=${this.onPlayStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Android App</wui-text>
    </wui-list-item>` : null
    }
    homepageTemplate() {
        return this.wallet?.homepage ? x$1`
      <wui-list-item
        variant="icon"
        icon="browser"
        iconVariant="square-blue"
        @click=${this.onHomePage.bind(this)}
        chevron
      >
        <wui-text variant="paragraph-500" color="fg-100">Website</wui-text>
      </wui-list-item>
    ` : null
    }
    onChromeStore() {
        this.wallet?.chrome_store && CoreHelperUtil.openHref(this.wallet.chrome_store, "_blank")
    }
    onAppStore() {
        this.wallet?.app_store && CoreHelperUtil.openHref(this.wallet.app_store, "_blank")
    }
    onPlayStore() {
        this.wallet?.play_store && CoreHelperUtil.openHref(this.wallet.play_store, "_blank")
    }
    onHomePage() {
        this.wallet?.homepage && CoreHelperUtil.openHref(this.wallet.homepage, "_blank")
    }
}
;
W3mDownloadsView = __decorate$m([customElement("w3m-downloads-view")], W3mDownloadsView);
var __decorate$l = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
const EXPLORER = "https://walletconnect.com/explorer";
let W3mGetWalletView = class extends s$1 {
    render() {
        return x$1`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        ${this.recommendedWalletsTemplate()}
        <wui-list-wallet
          name="Explore all"
          showAllWallets
          walletIcon="allWallets"
          icon="externalLink"
          @click=${()=>{
            CoreHelperUtil.openHref("https://walletconnect.com/explorer?type=wallet", "_blank")
        }
        }
        ></wui-list-wallet>
      </wui-flex>
    `
    }
    recommendedWalletsTemplate() {
        const {recommended: W, featured: z} = ApiController.state
          , {customWallets: Y} = OptionsController.state;
        return [...z, ...Y ?? [], ...W].slice(0, 4).map(ne=>x$1`
        <wui-list-wallet
          name=${ne.name ?? "Unknown"}
          tagVariant="main"
          imageSrc=${o$2(AssetUtil.getWalletImage(ne))}
          @click=${()=>{
            CoreHelperUtil.openHref(ne.homepage ?? EXPLORER, "_blank")
        }
        }
        ></wui-list-wallet>
      `)
    }
}
;
W3mGetWalletView = __decorate$l([customElement("w3m-get-wallet-view")], W3mGetWalletView);
const styles$9 = i$4`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: 4px;
    bottom: 0;
    opacity: 0;
    transform: scale(0.5);
    z-index: 1;
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  wui-button {
    display: none;
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  wui-button[data-retry='true'] {
    display: block;
    opacity: 1;
  }
`;
var __decorate$k = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mNetworkSwitchView = class extends s$1 {
    constructor() {
        super(),
        this.network = RouterController.state.data?.network,
        this.unsubscribe = [],
        this.showRetry = !1,
        this.error = !1,
        this.currentNetwork = NetworkController.state.caipNetwork,
        this.unsubscribe.push(NetworkController.subscribeKey("caipNetwork", W=>{
            W?.id !== this.currentNetwork?.id && RouterController.goBack()
        }
        ))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(W=>W())
    }
    firstUpdated() {
        this.onSwitchNetwork()
    }
    render() {
        if (!this.network)
            throw new Error("w3m-network-switch-view: No network provided");
        this.onShowRetry();
        const W = this.error ? "Switch declined" : "Approve in wallet"
          , z = this.error ? "Switch can be declined if chain is not supported by a wallet or previous request is still active" : "Accept connection request in your wallet";
        return x$1`
      <wui-flex
        data-error=${this.error}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "3xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-network-image
            size="lg"
            imageSrc=${o$2(AssetUtil.getNetworkImage(this.network))}
          ></wui-network-image>

          ${this.error ? null : x$1`<wui-loading-hexagon></wui-loading-hexagon>`}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            ?border=${!0}
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100">${W}</wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${z}</wui-text>
        </wui-flex>

        <wui-button
          data-retry=${this.showRetry}
          variant="fill"
          .disabled=${!this.error}
          @click=${this.onSwitchNetwork.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name="refresh"></wui-icon>
          Try again
        </wui-button>
      </wui-flex>
    `
    }
    onShowRetry() {
        this.error && !this.showRetry && (this.showRetry = !0,
        (this.shadowRoot?.querySelector("wui-button")).animate([{
            opacity: 0
        }, {
            opacity: 1
        }], {
            fill: "forwards",
            easing: "ease"
        }))
    }
    async onSwitchNetwork() {
        try {
            this.error = !1,
            this.network && (await NetworkController.switchActiveNetwork(this.network),
            RouterController.goBack())
        } catch {
            this.error = !0
        }
    }
}
;
W3mNetworkSwitchView.styles = styles$9,
__decorate$k([r$1()], W3mNetworkSwitchView.prototype, "showRetry", void 0),
__decorate$k([r$1()], W3mNetworkSwitchView.prototype, "error", void 0),
__decorate$k([r$1()], W3mNetworkSwitchView.prototype, "currentNetwork", void 0),
W3mNetworkSwitchView = __decorate$k([customElement("w3m-network-switch-view")], W3mNetworkSwitchView);
var __decorate$j = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mNetworksView = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.caipNetwork = NetworkController.state.caipNetwork,
        this.unsubscribe.push(NetworkController.subscribeKey("caipNetwork", W=>this.caipNetwork = W))
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(W=>W())
    }
    render() {
        return x$1`
      <wui-grid padding="s" gridTemplateColumns="repeat(4, 1fr)" rowGap="l" columnGap="xs">
        ${this.networksTemplate()}
      </wui-grid>

      <wui-separator></wui-separator>

      <wui-flex padding="s" flexDirection="column" gap="m" alignItems="center">
        <wui-text variant="small-500" color="fg-300" align="center">
          Your connected wallet may not support some of the networks available for this dApp
        </wui-text>
        <wui-link @click=${this.onNetworkHelp.bind(this)}>
          <wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></wui-icon>
          What is a network
        </wui-link>
      </wui-flex>
    `
    }
    onNetworkHelp() {
        EventsController.sendEvent({
            type: "track",
            event: "CLICK_NETWORK_HELP"
        }),
        RouterController.push("WhatIsANetwork")
    }
    networksTemplate() {
        const {approvedCaipNetworkIds: W, requestedCaipNetworks: z, supportsAllNetworks: Y} = NetworkController.state
          , ne = W
          , le = z;
        return ne?.length && le?.sort((ue,de)=>ne.indexOf(de.id) - ne.indexOf(ue.id)),
        le?.map(ue=>x$1`
        <wui-card-select
          .selected=${this.caipNetwork?.id === ue.id}
          imageSrc=${o$2(AssetUtil.getNetworkImage(ue))}
          type="network"
          name=${ue.name ?? ue.id}
          @click=${()=>this.onSwitchNetwork(ue)}
          .disabled=${!Y && !ne?.includes(ue.id)}
        ></wui-card-select>
      `)
    }
    async onSwitchNetwork(W) {
        const {isConnected: z} = AccountController.state
          , {approvedCaipNetworkIds: Y, supportsAllNetworks: ne, caipNetwork: le} = NetworkController.state;
        z && le?.id !== W.id ? Y?.includes(W.id) ? await NetworkController.switchActiveNetwork(W) : ne && RouterController.push("SwitchNetwork", {
            network: W
        }) : z || (NetworkController.setCaipNetwork(W),
        RouterController.push("Connect"))
    }
}
;
__decorate$j([r$1()], W3mNetworksView.prototype, "caipNetwork", void 0),
W3mNetworksView = __decorate$j([customElement("w3m-networks-view")], W3mNetworksView);
const styles$8 = i$4`
  :host > wui-flex:first-child {
    height: 500px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }
`;
var __decorate$i = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
const PAGINATOR_ID$1 = "last-transaction"
  , LOADING_ITEM_COUNT = 7;
let W3mTransactionsView = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.paginationObserver = void 0,
        this.address = AccountController.state.address,
        this.transactions = TransactionsController.state.transactions,
        this.transactionsByYear = TransactionsController.state.transactionsByYear,
        this.loading = TransactionsController.state.loading,
        this.empty = TransactionsController.state.empty,
        this.next = TransactionsController.state.next,
        this.unsubscribe.push(AccountController.subscribe(W=>{
            W.isConnected && this.address !== W.address && (this.address = W.address,
            TransactionsController.resetTransactions(),
            TransactionsController.fetchTransactions(W.address))
        }
        ), TransactionsController.subscribe(W=>{
            this.transactions = W.transactions,
            this.transactionsByYear = W.transactionsByYear,
            this.loading = W.loading,
            this.empty = W.empty,
            this.next = W.next
        }
        ))
    }
    firstUpdated() {
        this.transactions.length === 0 && TransactionsController.fetchTransactions(this.address),
        this.createPaginationObserver()
    }
    updated() {
        this.setPaginationObserver()
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(W=>W())
    }
    render() {
        return x$1`
      <wui-flex flexDirection="column" padding="s" gap="s">
        ${this.empty ? null : this.templateTransactionsByYear()}
        ${this.loading ? this.templateLoading() : null}
        ${!this.loading && this.empty ? this.templateEmpty() : null}
      </wui-flex>
    `
    }
    templateTransactionsByYear() {
        const W = Object.keys(this.transactionsByYear).sort().reverse();
        return W.map((z,Y)=>{
            const ne = Y === W.length - 1
              , le = parseInt(z, 10)
              , ue = TransactionUtil.getTransactionGroupTitle(le)
              , de = this.transactionsByYear[le];
            return de ? x$1`
        <wui-flex flexDirection="column" gap="sm">
          <wui-flex
            alignItems="center"
            flexDirection="row"
            .padding=${["xs", "s", "s", "s"]}
          >
            <wui-text variant="paragraph-500" color="fg-200">${ue}</wui-text>
          </wui-flex>
          <wui-flex flexDirection="column" gap="xs">
            ${this.templateTransactions(de, ne)}
          </wui-flex>
        </wui-flex>
      ` : null
        }
        )
    }
    templateRenderTransaction(W, z) {
        const {date: Y, descriptions: ne, direction: le, isAllNFT: ue, images: de, status: he, transfers: fe, type: ge} = this.getTransactionListItemProps(W)
          , xe = fe?.length > 1;
        return fe?.length === 2 && !ue ? x$1`
        <wui-transaction-list-item
          date=${Y}
          direction=${le}
          id=${z && this.next ? PAGINATOR_ID$1 : ""}
          status=${he}
          type=${ge}
          .images=${de}
          .descriptions=${ne}
        ></wui-transaction-list-item>
      ` : xe ? fe.map(($e,Ee)=>{
            const Se = TransactionUtil.getTransferDescription($e)
              , Ne = z && Ee === fe.length - 1;
            return x$1` <wui-transaction-list-item
          date=${Y}
          direction=${$e.direction}
          id=${Ne && this.next ? PAGINATOR_ID$1 : ""}
          status=${he}
          type=${ge}
          onlyDirectionIcon=${!0}
          .images=${[de?.[Ee]]}
          .descriptions=${[Se]}
        ></wui-transaction-list-item>`
        }
        ) : x$1`
      <wui-transaction-list-item
        date=${Y}
        direction=${le}
        id=${z && this.next ? PAGINATOR_ID$1 : ""}
        status=${he}
        type=${ge}
        .images=${de}
        .descriptions=${ne}
      ></wui-transaction-list-item>
    `
    }
    templateTransactions(W, z) {
        return W.map((Y,ne)=>{
            const le = z && ne === W.length - 1;
            return x$1`${this.templateRenderTransaction(Y, le)}`
        }
        )
    }
    templateEmpty() {
        return x$1`
      <wui-flex
        flexGrow="1"
        flexDirection="column"
        justifyContent="center"
        alignItems="center"
        .padding=${["3xl", "xl", "3xl", "xl"]}
        gap="xl"
      >
        <wui-icon-box
          backgroundColor="glass-005"
          background="gray"
          iconColor="fg-200"
          icon="wallet"
          size="lg"
          ?border=${!0}
          borderColor="wui-color-bg-125"
        ></wui-icon-box>
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100"
            >No Transactions yet</wui-text
          >
          <wui-text align="center" variant="small-500" color="fg-200"
            >Start trading on dApps <br />
            to grow your wallet!</wui-text
          >
        </wui-flex>
      </wui-flex>
    `
    }
    templateLoading() {
        return Array(LOADING_ITEM_COUNT).fill(x$1` <wui-transaction-list-item-loader></wui-transaction-list-item-loader> `).map(W=>W)
    }
    createPaginationObserver() {
        const {projectId: W} = OptionsController.state;
        this.paginationObserver = new IntersectionObserver(([z])=>{
            z?.isIntersecting && !this.loading && (TransactionsController.fetchTransactions(this.address),
            EventsController.sendEvent({
                type: "track",
                event: "LOAD_MORE_TRANSACTIONS",
                properties: {
                    address: this.address,
                    projectId: W,
                    cursor: this.next
                }
            }))
        }
        ,{}),
        this.setPaginationObserver()
    }
    setPaginationObserver() {
        this.paginationObserver?.disconnect();
        const W = this.shadowRoot?.querySelector(`#${PAGINATOR_ID$1}`);
        W && this.paginationObserver?.observe(W)
    }
    getTransactionListItemProps(W) {
        const z = DateUtil.getRelativeDateFromNow(W?.metadata?.minedAt)
          , Y = TransactionUtil.getTransactionDescriptions(W)
          , ne = W?.transfers
          , le = W?.transfers?.[0]
          , ue = !!le && W?.transfers?.every(he=>!!he.nft_info)
          , de = TransactionUtil.getTransactionImages(ne);
        return {
            date: z,
            direction: le?.direction,
            descriptions: Y,
            isAllNFT: ue,
            images: de,
            status: W.metadata?.status,
            transfers: ne,
            type: W.metadata?.operationType
        }
    }
}
;
W3mTransactionsView.styles = styles$8,
__decorate$i([r$1()], W3mTransactionsView.prototype, "address", void 0),
__decorate$i([r$1()], W3mTransactionsView.prototype, "transactions", void 0),
__decorate$i([r$1()], W3mTransactionsView.prototype, "transactionsByYear", void 0),
__decorate$i([r$1()], W3mTransactionsView.prototype, "loading", void 0),
__decorate$i([r$1()], W3mTransactionsView.prototype, "empty", void 0),
__decorate$i([r$1()], W3mTransactionsView.prototype, "next", void 0),
W3mTransactionsView = __decorate$i([customElement("w3m-transactions-view")], W3mTransactionsView);
var __decorate$h = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
const data$1 = [{
    images: ["network", "layers", "system"],
    title: "The systemâs nuts and bolts",
    text: "A network is what brings the blockchain to life, as this technical infrastructure allows apps to access the ledger and smart contract services."
}, {
    images: ["noun", "defiAlt", "dao"],
    title: "Designed for different uses",
    text: "Each network is designed differently, and may therefore suit certain apps and experiences."
}];
let W3mWhatIsANetworkView = class extends s$1 {
    render() {
        return x$1`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${data$1}></w3m-help-widget>
        <wui-button
          variant="fill"
          size="sm"
          @click=${()=>{
            CoreHelperUtil.openHref("https://ethereum.org/en/developers/docs/networks/", "_blank")
        }
        }
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-button>
      </wui-flex>
    `
    }
}
;
W3mWhatIsANetworkView = __decorate$h([customElement("w3m-what-is-a-network-view")], W3mWhatIsANetworkView);
var __decorate$g = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
const data = [{
    images: ["login", "profile", "lock"],
    title: "One login for all of web3",
    text: "Log in to any app by connecting your wallet. Say goodbye to countless passwords!"
}, {
    images: ["defi", "nft", "eth"],
    title: "A home for your digital assets",
    text: "A wallet lets you store, send and receive digital assets like cryptocurrencies and NFTs."
}, {
    images: ["browser", "noun", "dao"],
    title: "Your gateway to a new web",
    text: "With your wallet, you can explore and interact with DeFi, NFTs, DAOs, and much more."
}];
let W3mWhatIsAWalletView = class extends s$1 {
    render() {
        return x$1`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${data}></w3m-help-widget>
        <wui-button variant="fill" size="sm" @click=${this.onGetWallet.bind(this)}>
          <wui-icon color="inherit" slot="iconLeft" name="wallet"></wui-icon>
          Get a Wallet
        </wui-button>
      </wui-flex>
    `
    }
    onGetWallet() {
        EventsController.sendEvent({
            type: "track",
            event: "CLICK_GET_WALLET"
        }),
        RouterController.push("GetWallet")
    }
}
;
W3mWhatIsAWalletView = __decorate$g([customElement("w3m-what-is-a-wallet-view")], W3mWhatIsAWalletView);
const styles$7 = i$4`
  wui-grid {
    max-height: clamp(360px, 400px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 76px);
  }

  @media (max-width: 435px) {
    wui-grid {
      grid-template-columns: repeat(auto-fill, 77px);
    }
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    justify-content: center;
    grid-column: 1 / span 4;
  }
`;
var __decorate$f = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
const PAGINATOR_ID = "local-paginator";
let W3mAllWalletsList = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.paginationObserver = void 0,
        this.initial = !ApiController.state.wallets.length,
        this.wallets = ApiController.state.wallets,
        this.recommended = ApiController.state.recommended,
        this.featured = ApiController.state.featured,
        this.unsubscribe.push(ApiController.subscribeKey("wallets", W=>this.wallets = W), ApiController.subscribeKey("recommended", W=>this.recommended = W), ApiController.subscribeKey("featured", W=>this.featured = W))
    }
    firstUpdated() {
        this.initialFetch(),
        this.createPaginationObserver()
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(W=>W()),
        this.paginationObserver?.disconnect()
    }
    render() {
        return x$1`
      <wui-grid
        data-scroll=${!this.initial}
        .padding=${["0", "s", "s", "s"]}
        columnGap="xxs"
        rowGap="l"
        justifyContent="space-between"
      >
        ${this.initial ? this.shimmerTemplate(16) : this.walletsTemplate()}
        ${this.paginationLoaderTemplate()}
      </wui-grid>
    `
    }
    async initialFetch() {
        const W = this.shadowRoot?.querySelector("wui-grid");
        this.initial && W && (await ApiController.fetchWallets({
            page: 1
        }),
        await W.animate([{
            opacity: 1
        }, {
            opacity: 0
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }).finished,
        this.initial = !1,
        W.animate([{
            opacity: 0
        }, {
            opacity: 1
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }))
    }
    shimmerTemplate(W, z) {
        return [...Array(W)].map(()=>x$1`
        <wui-card-select-loader type="wallet" id=${o$2(z)}></wui-card-select-loader>
      `)
    }
    walletsTemplate() {
        return [...this.featured, ...this.recommended, ...this.wallets].map(W=>x$1`
        <wui-card-select
          imageSrc=${o$2(AssetUtil.getWalletImage(W))}
          type="wallet"
          name=${W.name}
          @click=${()=>this.onConnectWallet(W)}
        ></wui-card-select>
      `)
    }
    paginationLoaderTemplate() {
        const {wallets: W, recommended: z, featured: Y, count: ne} = ApiController.state
          , le = window.innerWidth < 352 ? 3 : 4
          , ue = W.length + z.length;
        let de = Math.ceil(ue / le) * le - ue + le;
        return de -= W.length ? Y.length % le : 0,
        ne === 0 || [...Y, ...W, ...z].length < ne ? this.shimmerTemplate(de, PAGINATOR_ID) : null
    }
    createPaginationObserver() {
        const W = this.shadowRoot?.querySelector(`#${PAGINATOR_ID}`);
        W && (this.paginationObserver = new IntersectionObserver(([z])=>{
            if (z?.isIntersecting && !this.initial) {
                const {page: Y, count: ne, wallets: le} = ApiController.state;
                le.length < ne && ApiController.fetchWallets({
                    page: Y + 1
                })
            }
        }
        ),
        this.paginationObserver.observe(W))
    }
    onConnectWallet(W) {
        const {connectors: z} = ConnectorController.state
          , Y = z.find(({explorerId: ne})=>ne === W.id);
        Y ? RouterController.push("ConnectingExternal", {
            connector: Y
        }) : RouterController.push("ConnectingWalletConnect", {
            wallet: W
        })
    }
}
;
W3mAllWalletsList.styles = styles$7,
__decorate$f([r$1()], W3mAllWalletsList.prototype, "initial", void 0),
__decorate$f([r$1()], W3mAllWalletsList.prototype, "wallets", void 0),
__decorate$f([r$1()], W3mAllWalletsList.prototype, "recommended", void 0),
__decorate$f([r$1()], W3mAllWalletsList.prototype, "featured", void 0),
W3mAllWalletsList = __decorate$f([customElement("w3m-all-wallets-list")], W3mAllWalletsList);
const styles$6 = i$4`
  wui-grid,
  wui-loading-spinner,
  wui-flex {
    height: 360px;
  }

  wui-grid {
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    justify-content: center;
    align-items: center;
  }
`;
var __decorate$e = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mAllWalletsSearch = class extends s$1 {
    constructor() {
        super(...arguments),
        this.prevQuery = "",
        this.loading = !0,
        this.query = ""
    }
    render() {
        return this.onSearch(),
        this.loading ? x$1`<wui-loading-spinner color="accent-100"></wui-loading-spinner>` : this.walletsTemplate()
    }
    async onSearch() {
        this.query !== this.prevQuery && (this.prevQuery = this.query,
        this.loading = !0,
        await ApiController.searchWallet({
            search: this.query
        }),
        this.loading = !1)
    }
    walletsTemplate() {
        const {search: W} = ApiController.state;
        return W.length ? x$1`
      <wui-grid
        .padding=${["0", "s", "s", "s"]}
        gridTemplateColumns="repeat(4, 1fr)"
        rowGap="l"
        columnGap="xs"
      >
        ${W.map(z=>x$1`
            <wui-card-select
              imageSrc=${o$2(AssetUtil.getWalletImage(z))}
              type="wallet"
              name=${z.name}
              @click=${()=>this.onConnectWallet(z)}
            ></wui-card-select>
          `)}
      </wui-grid>
    ` : x$1`
        <wui-flex justifyContent="center" alignItems="center" gap="s" flexDirection="column">
          <wui-icon-box
            size="lg"
            iconColor="fg-200"
            backgroundColor="fg-300"
            icon="wallet"
            background="transparent"
          ></wui-icon-box>
          <wui-text color="fg-200" variant="paragraph-500">No Wallet found</wui-text>
        </wui-flex>
      `
    }
    onConnectWallet(W) {
        const {connectors: z} = ConnectorController.state
          , Y = z.find(({explorerId: ne})=>ne === W.id);
        Y ? RouterController.push("ConnectingExternal", {
            connector: Y
        }) : RouterController.push("ConnectingWalletConnect", {
            wallet: W
        })
    }
}
;
W3mAllWalletsSearch.styles = styles$6,
__decorate$e([r$1()], W3mAllWalletsSearch.prototype, "loading", void 0),
__decorate$e([n$2()], W3mAllWalletsSearch.prototype, "query", void 0),
W3mAllWalletsSearch = __decorate$e([customElement("w3m-all-wallets-search")], W3mAllWalletsSearch);
var __decorate$d = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mConnectingHeader = class extends s$1 {
    constructor() {
        super(),
        this.platformTabs = [],
        this.unsubscribe = [],
        this.platforms = [],
        this.onSelectPlatfrom = void 0,
        this.buffering = !1,
        this.unsubscribe.push(ConnectionController.subscribeKey("buffering", W=>this.buffering = W))
    }
    disconnectCallback() {
        this.unsubscribe.forEach(W=>W())
    }
    render() {
        const W = this.generateTabs();
        return x$1`
      <wui-flex justifyContent="center" .padding=${["l", "0", "0", "0"]}>
        <wui-tabs
          ?disabled=${this.buffering}
          .tabs=${W}
          .onTabChange=${this.onTabChange.bind(this)}
        ></wui-tabs>
      </wui-flex>
    `
    }
    generateTabs() {
        const W = this.platforms.map(z=>z === "browser" ? {
            label: "Browser",
            icon: "extension",
            platform: "browser"
        } : z === "mobile" ? {
            label: "Mobile",
            icon: "mobile",
            platform: "mobile"
        } : z === "qrcode" ? {
            label: "Mobile",
            icon: "mobile",
            platform: "qrcode"
        } : z === "web" ? {
            label: "Webapp",
            icon: "browser",
            platform: "web"
        } : z === "desktop" ? {
            label: "Desktop",
            icon: "desktop",
            platform: "desktop"
        } : {
            label: "Browser",
            icon: "extension",
            platform: "unsupported"
        });
        return this.platformTabs = W.map(({platform: z})=>z),
        W
    }
    onTabChange(W) {
        const z = this.platformTabs[W];
        z && this.onSelectPlatfrom?.(z)
    }
}
;
__decorate$d([n$2({
    type: Array
})], W3mConnectingHeader.prototype, "platforms", void 0),
__decorate$d([n$2()], W3mConnectingHeader.prototype, "onSelectPlatfrom", void 0),
__decorate$d([r$1()], W3mConnectingHeader.prototype, "buffering", void 0),
W3mConnectingHeader = __decorate$d([customElement("w3m-connecting-header")], W3mConnectingHeader);
var __decorate$c = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mConnectingWcBrowser = class extends W3mConnectingWidget {
    constructor() {
        if (super(),
        !this.wallet)
            throw new Error("w3m-connecting-wc-browser: No wallet provided");
        this.onConnect = this.onConnectProxy.bind(this),
        this.onAutoConnect = this.onConnectProxy.bind(this),
        EventsController.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: this.wallet.name,
                platform: "browser"
            }
        })
    }
    async onConnectProxy() {
        try {
            this.error = !1;
            const {connectors: W} = ConnectorController.state
              , z = W.find(ne=>ne.type === "ANNOUNCED" && ne.info?.rdns === this.wallet?.rdns)
              , Y = W.find(ne=>ne.type === "INJECTED");
            z ? await ConnectionController.connectExternal(z) : Y && await ConnectionController.connectExternal(Y),
            ModalController.close(),
            EventsController.sendEvent({
                type: "track",
                event: "CONNECT_SUCCESS",
                properties: {
                    method: "browser"
                }
            })
        } catch (W) {
            EventsController.sendEvent({
                type: "track",
                event: "CONNECT_ERROR",
                properties: {
                    message: W?.message ?? "Unknown"
                }
            }),
            this.error = !0
        }
    }
}
;
W3mConnectingWcBrowser = __decorate$c([customElement("w3m-connecting-wc-browser")], W3mConnectingWcBrowser);
var __decorate$b = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mConnectingWcDesktop = class extends W3mConnectingWidget {
    constructor() {
        if (super(),
        !this.wallet)
            throw new Error("w3m-connecting-wc-desktop: No wallet provided");
        this.onConnect = this.onConnectProxy.bind(this),
        this.onRender = this.onRenderProxy.bind(this),
        EventsController.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: this.wallet.name,
                platform: "desktop"
            }
        })
    }
    onRenderProxy() {
        !this.ready && this.uri && (this.ready = !0,
        this.timeout = setTimeout(()=>{
            this.onConnect?.()
        }
        , 200))
    }
    onConnectProxy() {
        if (this.wallet?.desktop_link && this.uri)
            try {
                this.error = !1;
                const {desktop_link: W, name: z} = this.wallet
                  , {redirect: Y, href: ne} = CoreHelperUtil.formatNativeUrl(W, this.uri);
                ConnectionController.setWcLinking({
                    name: z,
                    href: ne
                }),
                ConnectionController.setRecentWallet(this.wallet),
                CoreHelperUtil.openHref(Y, "_self")
            } catch {
                this.error = !0
            }
    }
}
;
W3mConnectingWcDesktop = __decorate$b([customElement("w3m-connecting-wc-desktop")], W3mConnectingWcDesktop);
var __decorate$a = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mConnectingWcMobile = class extends W3mConnectingWidget {
    constructor() {
        if (super(),
        !this.wallet)
            throw new Error("w3m-connecting-wc-mobile: No wallet provided");
        this.onConnect = this.onConnectProxy.bind(this),
        this.onRender = this.onRenderProxy.bind(this),
        document.addEventListener("visibilitychange", this.onBuffering.bind(this)),
        EventsController.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: this.wallet.name,
                platform: "mobile"
            }
        })
    }
    disconnectedCallback() {
        super.disconnectedCallback(),
        document.removeEventListener("visibilitychange", this.onBuffering.bind(this))
    }
    onRenderProxy() {
        !this.ready && this.uri && (this.ready = !0,
        this.onConnect?.())
    }
    onConnectProxy() {
        if (this.wallet?.mobile_link && this.uri)
            try {
                this.error = !1;
                const {mobile_link: W, name: z} = this.wallet
                  , {redirect: Y, href: ne} = CoreHelperUtil.formatNativeUrl(W, this.uri);
                ConnectionController.setWcLinking({
                    name: z,
                    href: ne
                }),
                ConnectionController.setRecentWallet(this.wallet),
                CoreHelperUtil.openHref(Y, "_self")
            } catch {
                this.error = !0
            }
    }
    onBuffering() {
        const W = CoreHelperUtil.isIos();
        document?.visibilityState === "visible" && !this.error && W && (ConnectionController.setBuffering(!0),
        setTimeout(()=>{
            ConnectionController.setBuffering(!1)
        }
        , 5e3))
    }
}
;
W3mConnectingWcMobile = __decorate$a([customElement("w3m-connecting-wc-mobile")], W3mConnectingWcMobile);
const styles$5 = i$4`
  @keyframes fadein {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  wui-shimmer {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px) !important;
  }

  wui-qr-code {
    opacity: 0;
    animation-duration: 200ms;
    animation-timing-function: ease;
    animation-name: fadein;
    animation-fill-mode: forwards;
  }
`;
var __decorate$9 = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mConnectingWcQrcode = class extends W3mConnectingWidget {
    constructor() {
        super(),
        this.forceUpdate = ()=>{
            this.requestUpdate()
        }
        ,
        window.addEventListener("resize", this.forceUpdate),
        EventsController.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: this.wallet?.name ?? "WalletConnect",
                platform: "qrcode"
            }
        })
    }
    disconnectedCallback() {
        super.disconnectedCallback(),
        window.removeEventListener("resize", this.forceUpdate)
    }
    render() {
        return this.onRenderProxy(),
        x$1`
      <wui-flex padding="xl" flexDirection="column" gap="xl" alignItems="center">
        <wui-shimmer borderRadius="l" width="100%"> ${this.qrCodeTemplate()} </wui-shimmer>

        <wui-text variant="paragraph-500" color="fg-100">
          Scan this QR Code with your phone
        </wui-text>

        <wui-link @click=${this.onCopyUri} color="fg-200">
          <wui-icon size="sm" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
          Copy Link
        </wui-link>
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `
    }
    onRenderProxy() {
        !this.ready && this.uri && (this.timeout = setTimeout(()=>{
            this.ready = !0
        }
        , 200))
    }
    qrCodeTemplate() {
        if (!this.uri || !this.ready)
            return null;
        const W = this.getBoundingClientRect().width - 40
          , z = this.wallet ? this.wallet.name : void 0;
        return ConnectionController.setWcLinking(void 0),
        ConnectionController.setRecentWallet(this.wallet),
        x$1`<wui-qr-code
      size=${W}
      theme=${ThemeController.state.themeMode}
      uri=${this.uri}
      imageSrc=${o$2(AssetUtil.getWalletImage(this.wallet))}
      alt=${o$2(z)}
    ></wui-qr-code>`
    }
}
;
W3mConnectingWcQrcode.styles = styles$5,
W3mConnectingWcQrcode = __decorate$9([customElement("w3m-connecting-wc-qrcode")], W3mConnectingWcQrcode);
const styles$4 = i$4`
  :host {
    display: flex;
    justify-content: center;
    gap: var(--wui-spacing-2xl);
  }

  wui-visual-thumbnail:nth-child(1) {
    z-index: 1;
  }
`;
var __decorate$8 = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mConnectingSiwe = class extends s$1 {
    constructor() {
        super(...arguments),
        this.dappImageUrl = OptionsController.state.metadata?.icons,
        this.walletImageUrl = StorageUtil.getConnectedWalletImageUrl()
    }
    firstUpdated() {
        const W = this.shadowRoot?.querySelectorAll("wui-visual-thumbnail");
        W?.[0] && this.createAnimation(W[0], "translate(18px)"),
        W?.[1] && this.createAnimation(W[1], "translate(-18px)")
    }
    render() {
        return x$1`
      <wui-visual-thumbnail
        ?borderRadiusFull=${!0}
        .imageSrc=${this.dappImageUrl?.[0]}
      ></wui-visual-thumbnail>
      <wui-visual-thumbnail .imageSrc=${this.walletImageUrl}></wui-visual-thumbnail>
    `
    }
    createAnimation(W, z) {
        W.animate([{
            transform: "translateX(0px)"
        }, {
            transform: z
        }], {
            duration: 1600,
            easing: "cubic-bezier(0.56, 0, 0.48, 1)",
            direction: "alternate",
            iterations: 1 / 0
        })
    }
}
;
W3mConnectingSiwe.styles = styles$4,
W3mConnectingSiwe = __decorate$8([customElement("w3m-connecting-siwe")], W3mConnectingSiwe);
var __decorate$7 = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mConnectingWcUnsupported = class extends s$1 {
    constructor() {
        if (super(),
        this.wallet = RouterController.state.data?.wallet,
        !this.wallet)
            throw new Error("w3m-connecting-wc-unsupported: No wallet provided");
        EventsController.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: this.wallet.name,
                platform: "browser"
            }
        })
    }
    render() {
        return x$1`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-wallet-image
          size="lg"
          imageSrc=${o$2(AssetUtil.getWalletImage(this.wallet))}
        ></wui-wallet-image>

        <wui-text variant="paragraph-500" color="fg-100">Not Detected</wui-text>
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `
    }
}
;
W3mConnectingWcUnsupported = __decorate$7([customElement("w3m-connecting-wc-unsupported")], W3mConnectingWcUnsupported);
var __decorate$6 = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mConnectingWcWeb = class extends W3mConnectingWidget {
    constructor() {
        if (super(),
        !this.wallet)
            throw new Error("w3m-connecting-wc-web: No wallet provided");
        this.onConnect = this.onConnectProxy.bind(this),
        this.secondaryBtnLabel = "Open",
        this.secondaryLabel = "Open and continue in a new browser tab",
        this.secondaryBtnIcon = "externalLink",
        EventsController.sendEvent({
            type: "track",
            event: "SELECT_WALLET",
            properties: {
                name: this.wallet.name,
                platform: "web"
            }
        })
    }
    onConnectProxy() {
        if (this.wallet?.webapp_link && this.uri)
            try {
                this.error = !1;
                const {webapp_link: W, name: z} = this.wallet
                  , {redirect: Y, href: ne} = CoreHelperUtil.formatUniversalUrl(W, this.uri);
                ConnectionController.setWcLinking({
                    name: z,
                    href: ne
                }),
                ConnectionController.setRecentWallet(this.wallet),
                CoreHelperUtil.openHref(Y, "_blank")
            } catch {
                this.error = !0
            }
    }
}
;
W3mConnectingWcWeb = __decorate$6([customElement("w3m-connecting-wc-web")], W3mConnectingWcWeb);
const styles$3 = i$4`
  wui-icon-link[data-hidden='true'] {
    opacity: 0 !important;
    pointer-events: none;
  }
`;
var __decorate$5 = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
function headings() {
    const W = RouterController.state.data?.connector?.name
      , z = RouterController.state.data?.wallet?.name
      , Y = RouterController.state.data?.network?.name
      , ne = z ?? W;
    return {
        Connect: "Connect Wallet",
        Account: void 0,
        ConnectingExternal: ne ?? "Connect Wallet",
        ConnectingWalletConnect: ne ?? "WalletConnect",
        ConnectingSiwe: "Sign In",
        Networks: "Choose Network",
        SwitchNetwork: Y ?? "Switch Network",
        AllWallets: "All Wallets",
        WhatIsANetwork: "What is a network?",
        WhatIsAWallet: "What is a wallet?",
        GetWallet: "Get a Wallet",
        Downloads: ne ? `Get ${ne}` : "Downloads",
        Transactions: "Activity"
    }
}
let W3mHeader = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.heading = headings()[RouterController.state.view],
        this.buffering = !1,
        this.showBack = !1,
        this.unsubscribe.push(RouterController.subscribeKey("view", W=>{
            this.onViewChange(W),
            this.onHistoryChange()
        }
        ), ConnectionController.subscribeKey("buffering", W=>this.buffering = W))
    }
    disconnectCallback() {
        this.unsubscribe.forEach(W=>W())
    }
    render() {
        return x$1`
      <wui-flex .padding=${this.getPadding()} justifyContent="space-between" alignItems="center">
        ${this.dynamicButtonTemplate()} ${this.titleTemplate()}
        <wui-icon-link
          ?disabled=${this.buffering}
          icon="close"
          @click=${ModalController.close}
        ></wui-icon-link>
      </wui-flex>
      ${this.separatorTemplate()}
    `
    }
    onWalletHelp() {
        EventsController.sendEvent({
            type: "track",
            event: "CLICK_WALLET_HELP"
        }),
        RouterController.push("WhatIsAWallet")
    }
    titleTemplate() {
        return x$1`<wui-text variant="paragraph-700" color="fg-100">${this.heading}</wui-text>`
    }
    dynamicButtonTemplate() {
        const {view: W} = RouterController.state
          , z = W === "Connect";
        return this.showBack ? x$1`<wui-icon-link
        id="dynamic"
        icon="chevronLeft"
        ?disabled=${this.buffering}
        @click=${RouterController.goBack}
      ></wui-icon-link>` : x$1`<wui-icon-link
      data-hidden=${!z}
      id="dynamic"
      icon="helpCircle"
      @click=${this.onWalletHelp.bind(this)}
    ></wui-icon-link>`
    }
    separatorTemplate() {
        return this.heading ? x$1`<wui-separator></wui-separator>` : null
    }
    getPadding() {
        return this.heading ? ["l", "2l", "l", "2l"] : ["l", "2l", "0", "2l"]
    }
    async onViewChange(W) {
        const z = this.shadowRoot?.querySelector("wui-text");
        if (z) {
            const Y = headings()[W];
            await z.animate([{
                opacity: 1
            }, {
                opacity: 0
            }], {
                duration: 200,
                fill: "forwards",
                easing: "ease"
            }).finished,
            this.heading = Y,
            z.animate([{
                opacity: 0
            }, {
                opacity: 1
            }], {
                duration: 200,
                fill: "forwards",
                easing: "ease"
            })
        }
    }
    async onHistoryChange() {
        const {history: W} = RouterController.state
          , z = this.shadowRoot?.querySelector("#dynamic");
        W.length > 1 && !this.showBack && z ? (await z.animate([{
            opacity: 1
        }, {
            opacity: 0
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }).finished,
        this.showBack = !0,
        z.animate([{
            opacity: 0
        }, {
            opacity: 1
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        })) : W.length <= 1 && this.showBack && z && (await z.animate([{
            opacity: 1
        }, {
            opacity: 0
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }).finished,
        this.showBack = !1,
        z.animate([{
            opacity: 0
        }, {
            opacity: 1
        }], {
            duration: 200,
            fill: "forwards",
            easing: "ease"
        }))
    }
}
;
W3mHeader.styles = [styles$3],
__decorate$5([r$1()], W3mHeader.prototype, "heading", void 0),
__decorate$5([r$1()], W3mHeader.prototype, "buffering", void 0),
__decorate$5([r$1()], W3mHeader.prototype, "showBack", void 0),
W3mHeader = __decorate$5([customElement("w3m-header")], W3mHeader);
var __decorate$4 = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mHelpWidget = class extends s$1 {
    constructor() {
        super(...arguments),
        this.data = []
    }
    render() {
        return x$1`
      <wui-flex flexDirection="column" alignItems="center" gap="l">
        ${this.data.map(W=>x$1`
            <wui-flex flexDirection="column" alignItems="center" gap="xl">
              <wui-flex flexDirection="row" justifyContent="center" gap="1xs">
                ${W.images.map(z=>x$1`<wui-visual name=${z}></wui-visual>`)}
              </wui-flex>
            </wui-flex>
            <wui-flex flexDirection="column" alignItems="center" gap="xxs">
              <wui-text variant="paragraph-500" color="fg-100" align="center">
                ${W.title}
              </wui-text>
              <wui-text variant="small-500" color="fg-200" align="center">${W.text}</wui-text>
            </wui-flex>
          `)}
      </wui-flex>
    `
    }
}
;
__decorate$4([n$2({
    type: Array
})], W3mHelpWidget.prototype, "data", void 0),
W3mHelpWidget = __decorate$4([customElement("w3m-help-widget")], W3mHelpWidget);
const styles$2 = i$4`
  wui-flex {
    background-color: var(--wui-gray-glass-005);
  }

  a {
    text-decoration: none;
    color: var(--wui-color-fg-175);
    font-weight: 600;
  }
`;
var __decorate$3 = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mLegalFooter = class extends s$1 {
    render() {
        const {termsConditionsUrl: W, privacyPolicyUrl: z} = OptionsController.state;
        return W || z ? x$1`
      <wui-flex .padding=${["m", "s", "s", "s"]} justifyContent="center">
        <wui-text color="fg-250" variant="small-500" align="center">
          By connecting your wallet, you agree to our <br />
          ${this.termsTemplate()} ${this.andTemplate()} ${this.privacyTemplate()}
        </wui-text>
      </wui-flex>
    ` : null
    }
    andTemplate() {
        const {termsConditionsUrl: W, privacyPolicyUrl: z} = OptionsController.state;
        return W && z ? "and" : ""
    }
    termsTemplate() {
        const {termsConditionsUrl: W} = OptionsController.state;
        return W ? x$1`<a href=${W}>Terms of Service</a>` : null
    }
    privacyTemplate() {
        const {privacyPolicyUrl: W} = OptionsController.state;
        return W ? x$1`<a href=${W}>Privacy Policy</a>` : null
    }
}
;
W3mLegalFooter.styles = [styles$2],
W3mLegalFooter = __decorate$3([customElement("w3m-legal-footer")], W3mLegalFooter);
const styles$1 = i$4`
  :host {
    display: block;
    padding: 0 var(--wui-spacing-xl) var(--wui-spacing-xl);
  }
`;
var __decorate$2 = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
let W3mMobileDownloadLinks = class extends s$1 {
    constructor() {
        super(...arguments),
        this.wallet = void 0
    }
    render() {
        if (!this.wallet)
            return this.style.display = "none",
            null;
        const {name: W, app_store: z, play_store: Y, chrome_store: ne, homepage: le} = this.wallet
          , ue = CoreHelperUtil.isMobile()
          , de = CoreHelperUtil.isIos()
          , he = CoreHelperUtil.isAndroid()
          , fe = [z, Y, le, ne].filter(Boolean).length > 1
          , ge = UiHelperUtil.getTruncateString({
            string: W,
            charsStart: 12,
            charsEnd: 0,
            truncate: "end"
        });
        return fe && !ue ? x$1`
        <wui-cta-button
          label=${`Don't have ${ge}?`}
          buttonLabel="Get"
          @click=${()=>RouterController.push("Downloads", {
            wallet: this.wallet
        })}
        ></wui-cta-button>
      ` : !fe && le ? x$1`
        <wui-cta-button
          label=${`Don't have ${ge}?`}
          buttonLabel="Get"
          @click=${this.onHomePage.bind(this)}
        ></wui-cta-button>
      ` : z && de ? x$1`
        <wui-cta-button
          label=${`Don't have ${ge}?`}
          buttonLabel="Get"
          @click=${this.onAppStore.bind(this)}
        ></wui-cta-button>
      ` : Y && he ? x$1`
        <wui-cta-button
          label=${`Don't have ${ge}?`}
          buttonLabel="Get"
          @click=${this.onPlayStore.bind(this)}
        ></wui-cta-button>
      ` : (this.style.display = "none",
        null)
    }
    onAppStore() {
        this.wallet?.app_store && CoreHelperUtil.openHref(this.wallet.app_store, "_blank")
    }
    onPlayStore() {
        this.wallet?.play_store && CoreHelperUtil.openHref(this.wallet.play_store, "_blank")
    }
    onHomePage() {
        this.wallet?.homepage && CoreHelperUtil.openHref(this.wallet.homepage, "_blank")
    }
}
;
W3mMobileDownloadLinks.styles = [styles$1],
__decorate$2([n$2({
    type: Object
})], W3mMobileDownloadLinks.prototype, "wallet", void 0),
W3mMobileDownloadLinks = __decorate$2([customElement("w3m-mobile-download-links")], W3mMobileDownloadLinks);
const styles = i$4`
  :host {
    display: block;
    position: absolute;
    opacity: 0;
    pointer-events: none;
    top: 11px;
    left: 50%;
  }
`;
var __decorate$1 = globalThis && globalThis.__decorate || function(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
;
const presets = {
    success: {
        backgroundColor: "success-100",
        iconColor: "success-100",
        icon: "checkmark"
    },
    error: {
        backgroundColor: "error-100",
        iconColor: "error-100",
        icon: "close"
    }
};
let W3mSnackBar = class extends s$1 {
    constructor() {
        super(),
        this.unsubscribe = [],
        this.timeout = void 0,
        this.open = SnackController.state.open,
        this.unsubscribe.push(SnackController.subscribeKey("open", W=>{
            this.open = W,
            this.onOpen()
        }
        ))
    }
    disconnectedCallback() {
        clearTimeout(this.timeout),
        this.unsubscribe.forEach(W=>W())
    }
    render() {
        const {message: W, variant: z} = SnackController.state
          , Y = presets[z];
        return x$1`
      <wui-snackbar
        message=${W}
        backgroundColor=${Y.backgroundColor}
        iconColor=${Y.iconColor}
        icon=${Y.icon}
      ></wui-snackbar>
    `
    }
    onOpen() {
        clearTimeout(this.timeout),
        this.open ? (this.animate([{
            opacity: 0,
            transform: "translateX(-50%) scale(0.85)"
        }, {
            opacity: 1,
            transform: "translateX(-50%) scale(1)"
        }], {
            duration: 150,
            fill: "forwards",
            easing: "ease"
        }),
        this.timeout = setTimeout(()=>SnackController.hide(), 2500)) : this.animate([{
            opacity: 1,
            transform: "translateX(-50%) scale(1)"
        }, {
            opacity: 0,
            transform: "translateX(-50%) scale(0.85)"
        }], {
            duration: 150,
            fill: "forwards",
            easing: "ease"
        })
    }
}
;
W3mSnackBar.styles = styles,
__decorate$1([r$1()], W3mSnackBar.prototype, "open", void 0),
W3mSnackBar = __decorate$1([customElement("w3m-snackbar")], W3mSnackBar);
let isInitialized = !1;
class Web3ModalScaffold {
    constructor(z) {
        this.initPromise = void 0,
        this.setIsConnected = Y=>{
            AccountController.setIsConnected(Y)
        }
        ,
        this.setCaipAddress = Y=>{
            AccountController.setCaipAddress(Y)
        }
        ,
        this.setBalance = (Y,ne)=>{
            AccountController.setBalance(Y, ne)
        }
        ,
        this.setProfileName = Y=>{
            AccountController.setProfileName(Y)
        }
        ,
        this.setProfileImage = Y=>{
            AccountController.setProfileImage(Y)
        }
        ,
        this.resetAccount = ()=>{
            AccountController.resetAccount()
        }
        ,
        this.setCaipNetwork = Y=>{
            NetworkController.setCaipNetwork(Y)
        }
        ,
        this.getCaipNetwork = ()=>NetworkController.state.caipNetwork,
        this.setRequestedCaipNetworks = Y=>{
            NetworkController.setRequestedCaipNetworks(Y)
        }
        ,
        this.getApprovedCaipNetworksData = ()=>NetworkController.getApprovedCaipNetworksData(),
        this.resetNetwork = ()=>{
            NetworkController.resetNetwork()
        }
        ,
        this.setConnectors = Y=>{
            ConnectorController.setConnectors(Y)
        }
        ,
        this.addConnector = Y=>{
            ConnectorController.addConnector(Y)
        }
        ,
        this.getConnectors = ()=>ConnectorController.getConnectors(),
        this.resetWcConnection = ()=>{
            ConnectionController.resetWcConnection()
        }
        ,
        this.fetchIdentity = Y=>BlockchainApiController.fetchIdentity(Y),
        this.setAddressExplorerUrl = Y=>{
            AccountController.setAddressExplorerUrl(Y)
        }
        ,
        this.setSIWENonce = Y=>{
            SIWEController.setNonce(Y)
        }
        ,
        this.setSIWESession = Y=>{
            SIWEController.setSession(Y)
        }
        ,
        this.setSIWEStatus = Y=>{
            SIWEController.setStatus(Y)
        }
        ,
        this.setSIWEMessage = Y=>{
            SIWEController.setMessage(Y)
        }
        ,
        this.getSIWENonce = ()=>SIWEController.state.nonce,
        this.getSIWESession = ()=>SIWEController.state.session,
        this.getSIWEStatus = ()=>SIWEController.state.status,
        this.getSIWEMessage = ()=>SIWEController.state.message,
        this.initControllers(z),
        this.initOrContinue()
    }
    async open(z) {
        await this.initOrContinue(),
        ModalController.open(z)
    }
    async close() {
        await this.initOrContinue(),
        ModalController.close()
    }
    getThemeMode() {
        return ThemeController.state.themeMode
    }
    getThemeVariables() {
        return ThemeController.state.themeVariables
    }
    setThemeMode(z) {
        ThemeController.setThemeMode(z),
        setColorTheme(ThemeController.state.themeMode)
    }
    setThemeVariables(z) {
        ThemeController.setThemeVariables(z),
        setThemeVariables(ThemeController.state.themeVariables)
    }
    subscribeTheme(z) {
        return ThemeController.subscribe(z)
    }
    getState() {
        return {
            ...PublicStateController.state
        }
    }
    subscribeState(z) {
        return PublicStateController.subscribe(z)
    }
    getEvent() {
        return {
            ...EventsController.state
        }
    }
    subscribeEvents(z) {
        return EventsController.subscribe(z)
    }
    subscribeSIWEState(z) {
        return SIWEController.subscribe(z)
    }
    initControllers(z) {
        NetworkController.setClient(z.networkControllerClient),
        NetworkController.setDefaultCaipNetwork(z.defaultChain),
        OptionsController.setProjectId(z.projectId),
        OptionsController.setIncludeWalletIds(z.includeWalletIds),
        OptionsController.setExcludeWalletIds(z.excludeWalletIds),
        OptionsController.setFeaturedWalletIds(z.featuredWalletIds),
        OptionsController.setTokens(z.tokens),
        OptionsController.setTermsConditionsUrl(z.termsConditionsUrl),
        OptionsController.setPrivacyPolicyUrl(z.privacyPolicyUrl),
        OptionsController.setCustomWallets(z.customWallets),
        OptionsController.setEnableAnalytics(z.enableAnalytics),
        OptionsController.setSdkVersion(z._sdkVersion),
        ConnectionController.setClient(z.connectionControllerClient),
        z.siweControllerClient && SIWEController.setSIWEClient(z.siweControllerClient),
        z.metadata && OptionsController.setMetadata(z.metadata),
        z.themeMode && ThemeController.setThemeMode(z.themeMode),
        z.themeVariables && ThemeController.setThemeVariables(z.themeVariables)
    }
    async initOrContinue() {
        /*return this.initPromise || isInitialized || !CoreHelperUtil.isClient() || (isInitialized = !0,
        this.initPromise = new Promise(async z=>{
            await Promise.all([__vitePreload(()=>import("https://evergem.io/_astro/index.9d6d6ca6.js"), []), __vitePreload(()=>Promise.resolve().then(()=>index), void 0)]);
            const Y = document.createElement("w3m-modal");
            document.body.insertAdjacentElement("beforeend", Y),
            z()
        }
        )),
        this.initPromise*/
    }
}
const ConstantsUtil = {
    WALLET_CONNECT_CONNECTOR_ID: "walletConnect",
    INJECTED_CONNECTOR_ID: "injected",
    COINBASE_CONNECTOR_ID: "coinbaseWallet",
    SAFE_CONNECTOR_ID: "safe",
    LEDGER_CONNECTOR_ID: "ledger",
    EIP6963_CONNECTOR_ID: "eip6963",
    EIP155: "eip155",
    ADD_CHAIN_METHOD: "wallet_addEthereumChain",
    EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
    EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
    VERSION: "3.4.0"
}
  , PresetsUtil = {
    ConnectorExplorerIds: {
        [ConstantsUtil.COINBASE_CONNECTOR_ID]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
        [ConstantsUtil.SAFE_CONNECTOR_ID]: "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
        [ConstantsUtil.LEDGER_CONNECTOR_ID]: "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927"
    },
    EIP155NetworkImageIds: {
        1: "692ed6ba-e569-459a-556a-776476829e00",
        42161: "600a9a04-c1b9-42ca-6785-9b4b6ff85200",
        43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
        56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
        250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
        10: "ab9c186a-c52f-464b-2906-ca59d760a400",
        137: "41d04d42-da3b-4453-8506-668cc0727900",
        100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
        9001: "f926ff41-260d-4028-635e-91913fc28e00",
        324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
        314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
        4689: "34e68754-e536-40da-c153-6ef2e7188a00",
        1088: "3897a66d-40b9-4833-162f-a2c90531c900",
        1284: "161038da-44ae-4ec7-1208-0ea569454b00",
        1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
        7777777: "845c60df-d429-4991-e687-91ae45791600",
        42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
        8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
        1313161554: "3ff73439-a619-4894-9262-4470c773a100"
    },
    ConnectorImageIds: {
        [ConstantsUtil.COINBASE_CONNECTOR_ID]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
        [ConstantsUtil.SAFE_CONNECTOR_ID]: "461db637-8616-43ce-035a-d89b8a1d5800",
        [ConstantsUtil.LEDGER_CONNECTOR_ID]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
        [ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID]: "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
        [ConstantsUtil.INJECTED_CONNECTOR_ID]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00"
    },
    ConnectorNamesMap: {
        [ConstantsUtil.INJECTED_CONNECTOR_ID]: "Browser Wallet",
        [ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID]: "WalletConnect",
        [ConstantsUtil.COINBASE_CONNECTOR_ID]: "Coinbase",
        [ConstantsUtil.LEDGER_CONNECTOR_ID]: "Ledger",
        [ConstantsUtil.SAFE_CONNECTOR_ID]: "Safe"
    },
    ConnectorTypesMap: {
        [ConstantsUtil.INJECTED_CONNECTOR_ID]: "INJECTED",
        [ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID]: "WALLET_CONNECT",
        [ConstantsUtil.EIP6963_CONNECTOR_ID]: "ANNOUNCED"
    }
}
  , HelpersUtil = {
    caipNetworkIdToNumber: W=>W ? Number(W.split(":")[1]) : void 0,
    getCaipTokens(W) {
        if (!W)
            return;
        const z = {};
        return Object.entries(W).forEach(([Y,ne])=>{
            z[`${ConstantsUtil.EIP155}:${Y}`] = ne
        }
        ),
        z
    }
};
function getCaipDefaultChain(W) {
    if (W)
        return {
            id: `${ConstantsUtil.EIP155}:${W.id}`,
            name: W.name,
            imageId: PresetsUtil.EIP155NetworkImageIds[W.id]
        }
}
const WALLET_CHOICE_KEY = "wagmi.wallet";
class Web3Modal extends Web3ModalScaffold {
    constructor(z) {
        const {wagmiConfig: Y, siweConfig: ne, chains: le, defaultChain: ue, tokens: de, _sdkVersion: he, ...fe} = z;
        if (!Y)
            throw new Error("web3modal:constructor - wagmiConfig is undefined");
        if (!fe.projectId)
            throw new Error("web3modal:constructor - projectId is undefined");
        if (!Y.connectors.find($e=>$e.id === ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID))
            throw new Error("web3modal:constructor - WalletConnectConnector is required");
        const ge = {
            switchCaipNetwork: async $e=>{
                const Ee = HelpersUtil.caipNetworkIdToNumber($e?.id);
                Ee && await switchNetwork({
                    chainId: Ee
                })
            }
            ,
            async getApprovedCaipNetworksData() {
                if (localStorage.getItem(WALLET_CHOICE_KEY)?.includes(ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID)) {
                    const Ee = Y.connectors.find(tr=>tr.id === ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID);
                    if (!Ee)
                        throw new Error("networkControllerClient:getApprovedCaipNetworks - connector is undefined");
                    const Se = await Ee.getProvider()
                      , Ne = Se.signer?.session?.namespaces
                      , tt = Ne?.[ConstantsUtil.EIP155]?.methods
                      , rr = Ne?.[ConstantsUtil.EIP155]?.chains;
                    return {
                        supportsAllNetworks: tt?.includes(ConstantsUtil.ADD_CHAIN_METHOD),
                        approvedCaipNetworkIds: rr
                    }
                }
                return {
                    approvedCaipNetworkIds: void 0,
                    supportsAllNetworks: !0
                }
            }
        }
          , xe = {
            connectWalletConnect: async $e=>{
                const Ee = Y.connectors.find(Ne=>Ne.id === ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID);
                if (!Ee)
                    throw new Error("connectionControllerClient:getWalletConnectUri - connector is undefined");
                Ee.on("message", Ne=>{
                    Ne.type === "display_uri" && ($e(Ne.data),
                    Ee.removeAllListeners())
                }
                );
                const Se = HelpersUtil.caipNetworkIdToNumber(this.getCaipNetwork()?.id);
                await connect({
                    connector: Ee,
                    chainId: Se
                })
            }
            ,
            connectExternal: async({id: $e, provider: Ee, info: Se})=>{
                const Ne = Y.connectors.find(rr=>rr.id === $e);
                if (!Ne)
                    throw new Error("connectionControllerClient:connectExternal - connector is undefined");
                Ee && Se && Ne.id === ConstantsUtil.EIP6963_CONNECTOR_ID && Ne.setEip6963Wallet?.({
                    provider: Ee,
                    info: Se
                });
                const tt = HelpersUtil.caipNetworkIdToNumber(this.getCaipNetwork()?.id);
                await connect({
                    connector: Ne,
                    chainId: tt
                })
            }
            ,
            checkInstalled: $e=>{
                const Ee = this.getConnectors().filter(Ne=>Ne.type === "ANNOUNCED")
                  , Se = this.getConnectors().find(Ne=>Ne.type === "INJECTED");
                return $e ? Ee.length && $e.some(tt=>Ee.some(rr=>rr.info?.rdns === tt)) ? !0 : !!Se && !!window?.ethereum && $e.some(Ne=>!!window.ethereum?.[String(Ne)]) : !!window.ethereum
            }
            ,
            disconnect
        };
        super({
            networkControllerClient: ge,
            connectionControllerClient: xe,
            siweControllerClient: ne,
            defaultChain: getCaipDefaultChain(ue),
            tokens: HelpersUtil.getCaipTokens(de),
            _sdkVersion: he ?? `html-wagmi-${ConstantsUtil.VERSION}`,
            ...fe
        }),
        this.hasSyncedConnectedAccount = !1,
        this.options = void 0,
        this.options = z,
        this.syncRequestedNetworks(le),
        this.syncConnectors(Y),
        this.listenConnectors(Y),
        watchAccount(()=>this.syncAccount()),
        watchNetwork(()=>this.syncNetwork())
    }
    getState() {
        const z = super.getState();
        return {
            ...z,
            selectedNetworkId: HelpersUtil.caipNetworkIdToNumber(z.selectedNetworkId)
        }
    }
    subscribeState(z) {
        return super.subscribeState(Y=>z({
            ...Y,
            selectedNetworkId: HelpersUtil.caipNetworkIdToNumber(Y.selectedNetworkId)
        }))
    }
    syncRequestedNetworks(z) {
        const Y = z?.map(ne=>({
            id: `${ConstantsUtil.EIP155}:${ne.id}`,
            name: ne.name,
            imageId: PresetsUtil.EIP155NetworkImageIds[ne.id],
            imageUrl: this.options?.chainImages?.[ne.id]
        }));
        this.setRequestedCaipNetworks(Y ?? [])
    }
    async syncAccount() {
        const {address: z, isConnected: Y} = getAccount()
          , {chain: ne} = getNetwork();
        if (this.resetAccount(),
        Y && z && ne) {
            const le = `${ConstantsUtil.EIP155}:${ne.id}:${z}`;
            this.setIsConnected(Y),
            this.setCaipAddress(le),
            await Promise.all([this.syncProfile(z), this.syncBalance(z, ne), this.getApprovedCaipNetworksData()]),
            this.hasSyncedConnectedAccount = !0
        } else
            !Y && this.hasSyncedConnectedAccount && (this.resetWcConnection(),
            this.resetNetwork())
    }
    async syncNetwork() {
        const {address: z, isConnected: Y} = getAccount()
          , {chain: ne} = getNetwork();
        if (ne) {
            const le = String(ne.id)
              , ue = `${ConstantsUtil.EIP155}:${le}`;
            if (this.setCaipNetwork({
                id: ue,
                name: ne.name,
                imageId: PresetsUtil.EIP155NetworkImageIds[ne.id],
                imageUrl: this.options?.chainImages?.[ne.id]
            }),
            Y && z) {
                const de = `${ConstantsUtil.EIP155}:${ne.id}:${z}`;
                if (this.setCaipAddress(de),
                ne.blockExplorers?.default?.url) {
                    const he = `${ne.blockExplorers.default.url}/address/${z}`;
                    this.setAddressExplorerUrl(he)
                } else
                    this.setAddressExplorerUrl(void 0);
                this.hasSyncedConnectedAccount && await this.syncBalance(z, ne)
            }
        }
    }
    async syncProfile(z) {
        try {
            const {name: Y, avatar: ne} = await this.fetchIdentity({
                caipChainId: `${ConstantsUtil.EIP155}:${mainnet.id}`,
                address: z
            });
            this.setProfileName(Y),
            this.setProfileImage(ne)
        } catch {
            const Y = await fetchEnsName({
                address: z,
                chainId: mainnet.id
            });
            if (Y) {
                this.setProfileName(Y);
                const ne = await fetchEnsAvatar({
                    name: Y,
                    chainId: mainnet.id
                });
                ne && this.setProfileImage(ne)
            }
        }
    }
    async syncBalance(z, Y) {
        const ne = await fetchBalance({
            address: z,
            chainId: Y.id,
            token: this.options?.tokens?.[Y.id]?.address
        });
        this.setBalance(ne.formatted, ne.symbol)
    }
    syncConnectors(z) {
        const Y = [];
        z.connectors.forEach(({id: ne, name: le})=>{
            ne !== ConstantsUtil.EIP6963_CONNECTOR_ID && Y.push({
                id: ne,
                explorerId: PresetsUtil.ConnectorExplorerIds[ne],
                imageId: PresetsUtil.ConnectorImageIds[ne],
                imageUrl: this.options?.connectorImages?.[ne],
                name: PresetsUtil.ConnectorNamesMap[ne] ?? le,
                type: PresetsUtil.ConnectorTypesMap[ne] ?? "EXTERNAL"
            })
        }
        ),
        this.setConnectors(Y)
    }
    eip6963EventHandler(z, Y) {
        if (Y.detail) {
            const {info: ne, provider: le} = Y.detail;
            this.getConnectors().find(de=>de.name === ne.name) || (this.addConnector({
                id: ConstantsUtil.EIP6963_CONNECTOR_ID,
                type: "ANNOUNCED",
                imageUrl: ne.icon ?? this.options?.connectorImages?.[ConstantsUtil.EIP6963_CONNECTOR_ID],
                name: ne.name,
                provider: le,
                info: ne
            }),
            z.isAuthorized({
                info: ne,
                provider: le
            }))
        }
    }
    listenConnectors(z) {
        const Y = z.connectors.find(ne=>ne.id === ConstantsUtil.EIP6963_CONNECTOR_ID);
        if (typeof window < "u" && Y) {
            const ne = this.eip6963EventHandler.bind(this, Y);
            window.addEventListener(ConstantsUtil.EIP6963_ANNOUNCE_EVENT, ne),
            window.dispatchEvent(new Event(ConstantsUtil.EIP6963_REQUEST_EVENT))
        }
    }
}
var __classPrivateFieldSet$1 = globalThis && globalThis.__classPrivateFieldSet || function(W, z, Y, ne, le) {
    if (ne === "m")
        throw new TypeError("Private method is not writable");
    if (ne === "a" && !le)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof z == "function" ? W !== z || !le : !z.has(W))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return ne === "a" ? le.call(W, Y) : le ? le.value = Y : z.set(W, Y),
    Y
}
, __classPrivateFieldGet$1 = globalThis && globalThis.__classPrivateFieldGet || function(W, z, Y, ne) {
    if (Y === "a" && !ne)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof z == "function" ? W !== z || !ne : !z.has(W))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return Y === "m" ? ne : Y === "a" ? ne.call(W) : ne ? ne.value : z.get(W)
}
, _EIP6963Connector_defaultProvider, _EIP6963Connector_eip6963Wallet;
const connectedRdnsKey = "connectedRdns";
class EIP6963Connector extends InjectedConnector {
    constructor(z) {
        super({
            chains: z.chains,
            options: {
                shimDisconnect: !0
            }
        }),
        this.id = "eip6963",
        this.name = "EIP6963",
        _EIP6963Connector_defaultProvider.set(this, void 0),
        _EIP6963Connector_eip6963Wallet.set(this, void 0),
        __classPrivateFieldSet$1(this, _EIP6963Connector_defaultProvider, this.options.getProvider(), "f")
    }
    async connect(z) {
        const Y = await super.connect(z);
        return __classPrivateFieldGet$1(this, _EIP6963Connector_eip6963Wallet, "f") && this.storage?.setItem(connectedRdnsKey, __classPrivateFieldGet$1(this, _EIP6963Connector_eip6963Wallet, "f").info.rdns),
        Y
    }
    async disconnect() {
        await super.disconnect(),
        this.storage?.removeItem(connectedRdnsKey),
        __classPrivateFieldSet$1(this, _EIP6963Connector_eip6963Wallet, void 0, "f")
    }
    async isAuthorized(z) {
        const Y = this.storage?.getItem(connectedRdnsKey);
        if (Y) {
            if (!z || Y !== z.info.rdns)
                return !0;
            __classPrivateFieldSet$1(this, _EIP6963Connector_eip6963Wallet, z, "f")
        }
        return super.isAuthorized()
    }
    async getProvider() {
        return Promise.resolve(__classPrivateFieldGet$1(this, _EIP6963Connector_eip6963Wallet, "f")?.provider ?? __classPrivateFieldGet$1(this, _EIP6963Connector_defaultProvider, "f"))
    }
    setEip6963Wallet(z) {
        __classPrivateFieldSet$1(this, _EIP6963Connector_eip6963Wallet, z, "f")
    }
}
_EIP6963Connector_defaultProvider = new WeakMap,
_EIP6963Connector_eip6963Wallet = new WeakMap;
var buffer = {}
  , base64Js = {};
base64Js.byteLength = byteLength,
base64Js.toByteArray = toByteArray,
base64Js.fromByteArray = fromByteArray;
for (var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, len = code.length; i < len; ++i)
    lookup[i] = code[i],
    revLookup[code.charCodeAt(i)] = i;
function getLens(W) {
    var z = W.length;
    if (z % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
    var Y = W.indexOf("=");
    return Y === -1 && (Y = z),
    [Y, Y === z ? 0 : 4 - Y % 4]
}
function byteLength(W) {
    var z = getLens(W)
      , Y = z[0]
      , ne = z[1];
    return 3 * (Y + ne) / 4 - ne
}
function _byteLength(W, z, Y) {
    return 3 * (z + Y) / 4 - Y
}
function toByteArray(W) {
    var z, Y, ne = getLens(W), le = ne[0], ue = ne[1], de = new Arr(_byteLength(W, le, ue)), he = 0, fe = ue > 0 ? le - 4 : le;
    for (Y = 0; Y < fe; Y += 4)
        z = revLookup[W.charCodeAt(Y)] << 18 | revLookup[W.charCodeAt(Y + 1)] << 12 | revLookup[W.charCodeAt(Y + 2)] << 6 | revLookup[W.charCodeAt(Y + 3)],
        de[he++] = z >> 16 & 255,
        de[he++] = z >> 8 & 255,
        de[he++] = 255 & z;
    return ue === 2 && (z = revLookup[W.charCodeAt(Y)] << 2 | revLookup[W.charCodeAt(Y + 1)] >> 4,
    de[he++] = 255 & z),
    ue === 1 && (z = revLookup[W.charCodeAt(Y)] << 10 | revLookup[W.charCodeAt(Y + 1)] << 4 | revLookup[W.charCodeAt(Y + 2)] >> 2,
    de[he++] = z >> 8 & 255,
    de[he++] = 255 & z),
    de
}
function tripletToBase64(W) {
    return lookup[W >> 18 & 63] + lookup[W >> 12 & 63] + lookup[W >> 6 & 63] + lookup[63 & W]
}
function encodeChunk(W, z, Y) {
    for (var ne, le = [], ue = z; ue < Y; ue += 3)
        ne = (W[ue] << 16 & 16711680) + (W[ue + 1] << 8 & 65280) + (255 & W[ue + 2]),
        le.push(tripletToBase64(ne));
    return le.join("")
}
function fromByteArray(W) {
    for (var z, Y = W.length, ne = Y % 3, le = [], ue = 16383, de = 0, he = Y - ne; de < he; de += ue)
        le.push(encodeChunk(W, de, de + ue > he ? he : de + ue));
    return ne === 1 ? (z = W[Y - 1],
    le.push(lookup[z >> 2] + lookup[z << 4 & 63] + "==")) : ne === 2 && (z = (W[Y - 2] << 8) + W[Y - 1],
    le.push(lookup[z >> 10] + lookup[z >> 4 & 63] + lookup[z << 2 & 63] + "=")),
    le.join("")
}
revLookup["-".charCodeAt(0)] = 62,
revLookup["_".charCodeAt(0)] = 63;
var ieee754 = {}, _client, _provider$1;
ieee754.read = function(W, z, Y, ne, le) {
    var ue, de, he = 8 * le - ne - 1, fe = (1 << he) - 1, ge = fe >> 1, xe = -7, $e = Y ? le - 1 : 0, Ee = Y ? -1 : 1, Se = W[z + $e];
    for ($e += Ee,
    ue = Se & (1 << -xe) - 1,
    Se >>= -xe,
    xe += he; xe > 0; ue = 256 * ue + W[z + $e],
    $e += Ee,
    xe -= 8)
        ;
    for (de = ue & (1 << -xe) - 1,
    ue >>= -xe,
    xe += ne; xe > 0; de = 256 * de + W[z + $e],
    $e += Ee,
    xe -= 8)
        ;
    if (ue === 0)
        ue = 1 - ge;
    else {
        if (ue === fe)
            return de ? NaN : 1 / 0 * (Se ? -1 : 1);
        de += Math.pow(2, ne),
        ue -= ge
    }
    return (Se ? -1 : 1) * de * Math.pow(2, ue - ne)
}
,
ieee754.write = function(W, z, Y, ne, le, ue) {
    var de, he, fe, ge = 8 * ue - le - 1, xe = (1 << ge) - 1, $e = xe >> 1, Ee = le === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Se = ne ? 0 : ue - 1, Ne = ne ? 1 : -1, tt = z < 0 || z === 0 && 1 / z < 0 ? 1 : 0;
    for (z = Math.abs(z),
    isNaN(z) || z === 1 / 0 ? (he = isNaN(z) ? 1 : 0,
    de = xe) : (de = Math.floor(Math.log(z) / Math.LN2),
    z * (fe = Math.pow(2, -de)) < 1 && (de--,
    fe *= 2),
    (z += de + $e >= 1 ? Ee / fe : Ee * Math.pow(2, 1 - $e)) * fe >= 2 && (de++,
    fe /= 2),
    de + $e >= xe ? (he = 0,
    de = xe) : de + $e >= 1 ? (he = (z * fe - 1) * Math.pow(2, le),
    de += $e) : (he = z * Math.pow(2, $e - 1) * Math.pow(2, le),
    de = 0)); le >= 8; W[Y + Se] = 255 & he,
    Se += Ne,
    he /= 256,
    le -= 8)
        ;
    for (de = de << le | he,
    ge += le; ge > 0; W[Y + Se] = 255 & de,
    Se += Ne,
    de /= 256,
    ge -= 8)
        ;
    W[Y + Se - Ne] |= 128 * tt
}
,
function(W) {
    const z = base64Js
      , Y = ieee754
      , ne = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    W.Buffer = de,
    W.SlowBuffer = function(Oe) {
        return +Oe != Oe && (Oe = 0),
        de.alloc(+Oe)
    }
    ,
    W.INSPECT_MAX_BYTES = 50;
    const le = 2147483647;
    function ue(Oe) {
        if (Oe > le)
            throw new RangeError('The value "' + Oe + '" is invalid for option "size"');
        const ot = new Uint8Array(Oe);
        return Object.setPrototypeOf(ot, de.prototype),
        ot
    }
    function de(Oe, ot, ir) {
        if (typeof Oe == "number") {
            if (typeof ot == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
            return ge(Oe)
        }
        return he(Oe, ot, ir)
    }
    function he(Oe, ot, ir) {
        if (typeof Oe == "string")
            return function(Ar, kr) {
                if (typeof kr == "string" && kr !== "" || (kr = "utf8"),
                !de.isEncoding(kr))
                    throw new TypeError("Unknown encoding: " + kr);
                const _n = 0 | Se(Ar, kr);
                let Qn = ue(_n);
                const gi = Qn.write(Ar, kr);
                return gi !== _n && (Qn = Qn.slice(0, gi)),
                Qn
            }(Oe, ot);
        if (ArrayBuffer.isView(Oe))
            return function(Ar) {
                if (dr(Ar, Uint8Array)) {
                    const kr = new Uint8Array(Ar);
                    return $e(kr.buffer, kr.byteOffset, kr.byteLength)
                }
                return xe(Ar)
            }(Oe);
        if (Oe == null)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Oe);
        if (dr(Oe, ArrayBuffer) || Oe && dr(Oe.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (dr(Oe, SharedArrayBuffer) || Oe && dr(Oe.buffer, SharedArrayBuffer)))
            return $e(Oe, ot, ir);
        if (typeof Oe == "number")
            throw new TypeError('The "value" argument must not be of type number. Received type number');
        const vr = Oe.valueOf && Oe.valueOf();
        if (vr != null && vr !== Oe)
            return de.from(vr, ot, ir);
        const Er = function(Ar) {
            if (de.isBuffer(Ar)) {
                const kr = 0 | Ee(Ar.length)
                  , _n = ue(kr);
                return _n.length === 0 || Ar.copy(_n, 0, 0, kr),
                _n
            }
            if (Ar.length !== void 0)
                return typeof Ar.length != "number" || Sr(Ar.length) ? ue(0) : xe(Ar);
            if (Ar.type === "Buffer" && Array.isArray(Ar.data))
                return xe(Ar.data)
        }(Oe);
        if (Er)
            return Er;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Oe[Symbol.toPrimitive] == "function")
            return de.from(Oe[Symbol.toPrimitive]("string"), ot, ir);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Oe)
    }
    function fe(Oe) {
        if (typeof Oe != "number")
            throw new TypeError('"size" argument must be of type number');
        if (Oe < 0)
            throw new RangeError('The value "' + Oe + '" is invalid for option "size"')
    }
    function ge(Oe) {
        return fe(Oe),
        ue(Oe < 0 ? 0 : 0 | Ee(Oe))
    }
    function xe(Oe) {
        const ot = Oe.length < 0 ? 0 : 0 | Ee(Oe.length)
          , ir = ue(ot);
        for (let vr = 0; vr < ot; vr += 1)
            ir[vr] = 255 & Oe[vr];
        return ir
    }
    function $e(Oe, ot, ir) {
        if (ot < 0 || Oe.byteLength < ot)
            throw new RangeError('"offset" is outside of buffer bounds');
        if (Oe.byteLength < ot + (ir || 0))
            throw new RangeError('"length" is outside of buffer bounds');
        let vr;
        return vr = ot === void 0 && ir === void 0 ? new Uint8Array(Oe) : ir === void 0 ? new Uint8Array(Oe,ot) : new Uint8Array(Oe,ot,ir),
        Object.setPrototypeOf(vr, de.prototype),
        vr
    }
    function Ee(Oe) {
        if (Oe >= le)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + le.toString(16) + " bytes");
        return 0 | Oe
    }
    function Se(Oe, ot) {
        if (de.isBuffer(Oe))
            return Oe.length;
        if (ArrayBuffer.isView(Oe) || dr(Oe, ArrayBuffer))
            return Oe.byteLength;
        if (typeof Oe != "string")
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Oe);
        const ir = Oe.length
          , vr = arguments.length > 2 && arguments[2] === !0;
        if (!vr && ir === 0)
            return 0;
        let Er = !1;
        for (; ; )
            switch (ot) {
            case "ascii":
            case "latin1":
            case "binary":
                return ir;
            case "utf8":
            case "utf-8":
                return Yn(Oe).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return 2 * ir;
            case "hex":
                return ir >>> 1;
            case "base64":
                return pi(Oe).length;
            default:
                if (Er)
                    return vr ? -1 : Yn(Oe).length;
                ot = ("" + ot).toLowerCase(),
                Er = !0
            }
    }
    function Ne(Oe, ot, ir) {
        let vr = !1;
        if ((ot === void 0 || ot < 0) && (ot = 0),
        ot > this.length || ((ir === void 0 || ir > this.length) && (ir = this.length),
        ir <= 0) || (ir >>>= 0) <= (ot >>>= 0))
            return "";
        for (Oe || (Oe = "utf8"); ; )
            switch (Oe) {
            case "hex":
                return br(this, ot, ir);
            case "utf8":
            case "utf-8":
                return fr(this, ot, ir);
            case "ascii":
                return Pr(this, ot, ir);
            case "latin1":
            case "binary":
                return Fr(this, ot, ir);
            case "base64":
                return mr(this, ot, ir);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return xr(this, ot, ir);
            default:
                if (vr)
                    throw new TypeError("Unknown encoding: " + Oe);
                Oe = (Oe + "").toLowerCase(),
                vr = !0
            }
    }
    function tt(Oe, ot, ir) {
        const vr = Oe[ot];
        Oe[ot] = Oe[ir],
        Oe[ir] = vr
    }
    function rr(Oe, ot, ir, vr, Er) {
        if (Oe.length === 0)
            return -1;
        if (typeof ir == "string" ? (vr = ir,
        ir = 0) : ir > 2147483647 ? ir = 2147483647 : ir < -2147483648 && (ir = -2147483648),
        Sr(ir = +ir) && (ir = Er ? 0 : Oe.length - 1),
        ir < 0 && (ir = Oe.length + ir),
        ir >= Oe.length) {
            if (Er)
                return -1;
            ir = Oe.length - 1
        } else if (ir < 0) {
            if (!Er)
                return -1;
            ir = 0
        }
        if (typeof ot == "string" && (ot = de.from(ot, vr)),
        de.isBuffer(ot))
            return ot.length === 0 ? -1 : tr(Oe, ot, ir, vr, Er);
        if (typeof ot == "number")
            return ot &= 255,
            typeof Uint8Array.prototype.indexOf == "function" ? Er ? Uint8Array.prototype.indexOf.call(Oe, ot, ir) : Uint8Array.prototype.lastIndexOf.call(Oe, ot, ir) : tr(Oe, [ot], ir, vr, Er);
        throw new TypeError("val must be string, number or Buffer")
    }
    function tr(Oe, ot, ir, vr, Er) {
        let Ar, kr = 1, _n = Oe.length, Qn = ot.length;
        if (vr !== void 0 && ((vr = String(vr).toLowerCase()) === "ucs2" || vr === "ucs-2" || vr === "utf16le" || vr === "utf-16le")) {
            if (Oe.length < 2 || ot.length < 2)
                return -1;
            kr = 2,
            _n /= 2,
            Qn /= 2,
            ir /= 2
        }
        function gi(ei, si) {
            return kr === 1 ? ei[si] : ei.readUInt16BE(si * kr)
        }
        if (Er) {
            let ei = -1;
            for (Ar = ir; Ar < _n; Ar++)
                if (gi(Oe, Ar) === gi(ot, ei === -1 ? 0 : Ar - ei)) {
                    if (ei === -1 && (ei = Ar),
                    Ar - ei + 1 === Qn)
                        return ei * kr
                } else
                    ei !== -1 && (Ar -= Ar - ei),
                    ei = -1
        } else
            for (ir + Qn > _n && (ir = _n - Qn),
            Ar = ir; Ar >= 0; Ar--) {
                let ei = !0;
                for (let si = 0; si < Qn; si++)
                    if (gi(Oe, Ar + si) !== gi(ot, si)) {
                        ei = !1;
                        break
                    }
                if (ei)
                    return Ar
            }
        return -1
    }
    function we(Oe, ot, ir, vr) {
        ir = Number(ir) || 0;
        const Er = Oe.length - ir;
        vr ? (vr = Number(vr)) > Er && (vr = Er) : vr = Er;
        const Ar = ot.length;
        let kr;
        for (vr > Ar / 2 && (vr = Ar / 2),
        kr = 0; kr < vr; ++kr) {
            const _n = parseInt(ot.substr(2 * kr, 2), 16);
            if (Sr(_n))
                return kr;
            Oe[ir + kr] = _n
        }
        return kr
    }
    function Ut(Oe, ot, ir, vr) {
        return yi(Yn(ot, Oe.length - ir), Oe, ir, vr)
    }
    function lr(Oe, ot, ir, vr) {
        return yi(function(Er) {
            const Ar = [];
            for (let kr = 0; kr < Er.length; ++kr)
                Ar.push(255 & Er.charCodeAt(kr));
            return Ar
        }(ot), Oe, ir, vr)
    }
    function cr(Oe, ot, ir, vr) {
        return yi(pi(ot), Oe, ir, vr)
    }
    function be(Oe, ot, ir, vr) {
        return yi(function(Er, Ar) {
            let kr, _n, Qn;
            const gi = [];
            for (let ei = 0; ei < Er.length && !((Ar -= 2) < 0); ++ei)
                kr = Er.charCodeAt(ei),
                _n = kr >> 8,
                Qn = kr % 256,
                gi.push(Qn),
                gi.push(_n);
            return gi
        }(ot, Oe.length - ir), Oe, ir, vr)
    }
    function mr(Oe, ot, ir) {
        return ot === 0 && ir === Oe.length ? z.fromByteArray(Oe) : z.fromByteArray(Oe.slice(ot, ir))
    }
    function fr(Oe, ot, ir) {
        ir = Math.min(Oe.length, ir);
        const vr = [];
        let Er = ot;
        for (; Er < ir; ) {
            const Ar = Oe[Er];
            let kr = null
              , _n = Ar > 239 ? 4 : Ar > 223 ? 3 : Ar > 191 ? 2 : 1;
            if (Er + _n <= ir) {
                let Qn, gi, ei, si;
                switch (_n) {
                case 1:
                    Ar < 128 && (kr = Ar);
                    break;
                case 2:
                    Qn = Oe[Er + 1],
                    (192 & Qn) == 128 && (si = (31 & Ar) << 6 | 63 & Qn,
                    si > 127 && (kr = si));
                    break;
                case 3:
                    Qn = Oe[Er + 1],
                    gi = Oe[Er + 2],
                    (192 & Qn) == 128 && (192 & gi) == 128 && (si = (15 & Ar) << 12 | (63 & Qn) << 6 | 63 & gi,
                    si > 2047 && (si < 55296 || si > 57343) && (kr = si));
                    break;
                case 4:
                    Qn = Oe[Er + 1],
                    gi = Oe[Er + 2],
                    ei = Oe[Er + 3],
                    (192 & Qn) == 128 && (192 & gi) == 128 && (192 & ei) == 128 && (si = (15 & Ar) << 18 | (63 & Qn) << 12 | (63 & gi) << 6 | 63 & ei,
                    si > 65535 && si < 1114112 && (kr = si))
                }
            }
            kr === null ? (kr = 65533,
            _n = 1) : kr > 65535 && (kr -= 65536,
            vr.push(kr >>> 10 & 1023 | 55296),
            kr = 56320 | 1023 & kr),
            vr.push(kr),
            Er += _n
        }
        return function(Ar) {
            const kr = Ar.length;
            if (kr <= Rr)
                return String.fromCharCode.apply(String, Ar);
            let _n = ""
              , Qn = 0;
            for (; Qn < kr; )
                _n += String.fromCharCode.apply(String, Ar.slice(Qn, Qn += Rr));
            return _n
        }(vr)
    }
    W.kMaxLength = le,
    de.TYPED_ARRAY_SUPPORT = function() {
        try {
            const Oe = new Uint8Array(1)
              , ot = {
                foo: function() {
                    return 42
                }
            };
            return Object.setPrototypeOf(ot, Uint8Array.prototype),
            Object.setPrototypeOf(Oe, ot),
            Oe.foo() === 42
        } catch {
            return !1
        }
    }(),
    de.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),
    Object.defineProperty(de.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (de.isBuffer(this))
                return this.buffer
        }
    }),
    Object.defineProperty(de.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (de.isBuffer(this))
                return this.byteOffset
        }
    }),
    de.poolSize = 8192,
    de.from = function(Oe, ot, ir) {
        return he(Oe, ot, ir)
    }
    ,
    Object.setPrototypeOf(de.prototype, Uint8Array.prototype),
    Object.setPrototypeOf(de, Uint8Array),
    de.alloc = function(Oe, ot, ir) {
        return function(vr, Er, Ar) {
            return fe(vr),
            vr <= 0 ? ue(vr) : Er !== void 0 ? typeof Ar == "string" ? ue(vr).fill(Er, Ar) : ue(vr).fill(Er) : ue(vr)
        }(Oe, ot, ir)
    }
    ,
    de.allocUnsafe = function(Oe) {
        return ge(Oe)
    }
    ,
    de.allocUnsafeSlow = function(Oe) {
        return ge(Oe)
    }
    ,
    de.isBuffer = function(Oe) {
        return Oe != null && Oe._isBuffer === !0 && Oe !== de.prototype
    }
    ,
    de.compare = function(Oe, ot) {
        if (dr(Oe, Uint8Array) && (Oe = de.from(Oe, Oe.offset, Oe.byteLength)),
        dr(ot, Uint8Array) && (ot = de.from(ot, ot.offset, ot.byteLength)),
        !de.isBuffer(Oe) || !de.isBuffer(ot))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (Oe === ot)
            return 0;
        let ir = Oe.length
          , vr = ot.length;
        for (let Er = 0, Ar = Math.min(ir, vr); Er < Ar; ++Er)
            if (Oe[Er] !== ot[Er]) {
                ir = Oe[Er],
                vr = ot[Er];
                break
            }
        return ir < vr ? -1 : vr < ir ? 1 : 0
    }
    ,
    de.isEncoding = function(Oe) {
        switch (String(Oe).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1
        }
    }
    ,
    de.concat = function(Oe, ot) {
        if (!Array.isArray(Oe))
            throw new TypeError('"list" argument must be an Array of Buffers');
        if (Oe.length === 0)
            return de.alloc(0);
        let ir;
        if (ot === void 0)
            for (ot = 0,
            ir = 0; ir < Oe.length; ++ir)
                ot += Oe[ir].length;
        const vr = de.allocUnsafe(ot);
        let Er = 0;
        for (ir = 0; ir < Oe.length; ++ir) {
            let Ar = Oe[ir];
            if (dr(Ar, Uint8Array))
                Er + Ar.length > vr.length ? (de.isBuffer(Ar) || (Ar = de.from(Ar)),
                Ar.copy(vr, Er)) : Uint8Array.prototype.set.call(vr, Ar, Er);
            else {
                if (!de.isBuffer(Ar))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                Ar.copy(vr, Er)
            }
            Er += Ar.length
        }
        return vr
    }
    ,
    de.byteLength = Se,
    de.prototype._isBuffer = !0,
    de.prototype.swap16 = function() {
        const Oe = this.length;
        if (Oe % 2 != 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let ot = 0; ot < Oe; ot += 2)
            tt(this, ot, ot + 1);
        return this
    }
    ,
    de.prototype.swap32 = function() {
        const Oe = this.length;
        if (Oe % 4 != 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let ot = 0; ot < Oe; ot += 4)
            tt(this, ot, ot + 3),
            tt(this, ot + 1, ot + 2);
        return this
    }
    ,
    de.prototype.swap64 = function() {
        const Oe = this.length;
        if (Oe % 8 != 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let ot = 0; ot < Oe; ot += 8)
            tt(this, ot, ot + 7),
            tt(this, ot + 1, ot + 6),
            tt(this, ot + 2, ot + 5),
            tt(this, ot + 3, ot + 4);
        return this
    }
    ,
    de.prototype.toString = function() {
        const Oe = this.length;
        return Oe === 0 ? "" : arguments.length === 0 ? fr(this, 0, Oe) : Ne.apply(this, arguments)
    }
    ,
    de.prototype.toLocaleString = de.prototype.toString,
    de.prototype.equals = function(Oe) {
        if (!de.isBuffer(Oe))
            throw new TypeError("Argument must be a Buffer");
        return this === Oe || de.compare(this, Oe) === 0
    }
    ,
    de.prototype.inspect = function() {
        let Oe = "";
        const ot = W.INSPECT_MAX_BYTES;
        return Oe = this.toString("hex", 0, ot).replace(/(.{2})/g, "$1 ").trim(),
        this.length > ot && (Oe += " ... "),
        "<Buffer " + Oe + ">"
    }
    ,
    ne && (de.prototype[ne] = de.prototype.inspect),
    de.prototype.compare = function(Oe, ot, ir, vr, Er) {
        if (dr(Oe, Uint8Array) && (Oe = de.from(Oe, Oe.offset, Oe.byteLength)),
        !de.isBuffer(Oe))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Oe);
        if (ot === void 0 && (ot = 0),
        ir === void 0 && (ir = Oe ? Oe.length : 0),
        vr === void 0 && (vr = 0),
        Er === void 0 && (Er = this.length),
        ot < 0 || ir > Oe.length || vr < 0 || Er > this.length)
            throw new RangeError("out of range index");
        if (vr >= Er && ot >= ir)
            return 0;
        if (vr >= Er)
            return -1;
        if (ot >= ir)
            return 1;
        if (this === Oe)
            return 0;
        let Ar = (Er >>>= 0) - (vr >>>= 0)
          , kr = (ir >>>= 0) - (ot >>>= 0);
        const _n = Math.min(Ar, kr)
          , Qn = this.slice(vr, Er)
          , gi = Oe.slice(ot, ir);
        for (let ei = 0; ei < _n; ++ei)
            if (Qn[ei] !== gi[ei]) {
                Ar = Qn[ei],
                kr = gi[ei];
                break
            }
        return Ar < kr ? -1 : kr < Ar ? 1 : 0
    }
    ,
    de.prototype.includes = function(Oe, ot, ir) {
        return this.indexOf(Oe, ot, ir) !== -1
    }
    ,
    de.prototype.indexOf = function(Oe, ot, ir) {
        return rr(this, Oe, ot, ir, !0)
    }
    ,
    de.prototype.lastIndexOf = function(Oe, ot, ir) {
        return rr(this, Oe, ot, ir, !1)
    }
    ,
    de.prototype.write = function(Oe, ot, ir, vr) {
        if (ot === void 0)
            vr = "utf8",
            ir = this.length,
            ot = 0;
        else if (ir === void 0 && typeof ot == "string")
            vr = ot,
            ir = this.length,
            ot = 0;
        else {
            if (!isFinite(ot))
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            ot >>>= 0,
            isFinite(ir) ? (ir >>>= 0,
            vr === void 0 && (vr = "utf8")) : (vr = ir,
            ir = void 0)
        }
        const Er = this.length - ot;
        if ((ir === void 0 || ir > Er) && (ir = Er),
        Oe.length > 0 && (ir < 0 || ot < 0) || ot > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
        vr || (vr = "utf8");
        let Ar = !1;
        for (; ; )
            switch (vr) {
            case "hex":
                return we(this, Oe, ot, ir);
            case "utf8":
            case "utf-8":
                return Ut(this, Oe, ot, ir);
            case "ascii":
            case "latin1":
            case "binary":
                return lr(this, Oe, ot, ir);
            case "base64":
                return cr(this, Oe, ot, ir);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return be(this, Oe, ot, ir);
            default:
                if (Ar)
                    throw new TypeError("Unknown encoding: " + vr);
                vr = ("" + vr).toLowerCase(),
                Ar = !0
            }
    }
    ,
    de.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    }
    ;
    const Rr = 4096;
    function Pr(Oe, ot, ir) {
        let vr = "";
        ir = Math.min(Oe.length, ir);
        for (let Er = ot; Er < ir; ++Er)
            vr += String.fromCharCode(127 & Oe[Er]);
        return vr
    }
    function Fr(Oe, ot, ir) {
        let vr = "";
        ir = Math.min(Oe.length, ir);
        for (let Er = ot; Er < ir; ++Er)
            vr += String.fromCharCode(Oe[Er]);
        return vr
    }
    function br(Oe, ot, ir) {
        const vr = Oe.length;
        (!ot || ot < 0) && (ot = 0),
        (!ir || ir < 0 || ir > vr) && (ir = vr);
        let Er = "";
        for (let Ar = ot; Ar < ir; ++Ar)
            Er += Gr[Oe[Ar]];
        return Er
    }
    function xr(Oe, ot, ir) {
        const vr = Oe.slice(ot, ir);
        let Er = "";
        for (let Ar = 0; Ar < vr.length - 1; Ar += 2)
            Er += String.fromCharCode(vr[Ar] + 256 * vr[Ar + 1]);
        return Er
    }
    function _r(Oe, ot, ir) {
        if (Oe % 1 != 0 || Oe < 0)
            throw new RangeError("offset is not uint");
        if (Oe + ot > ir)
            throw new RangeError("Trying to access beyond buffer length")
    }
    function Ir(Oe, ot, ir, vr, Er, Ar) {
        if (!de.isBuffer(Oe))
            throw new TypeError('"buffer" argument must be a Buffer instance');
        if (ot > Er || ot < Ar)
            throw new RangeError('"value" argument is out of bounds');
        if (ir + vr > Oe.length)
            throw new RangeError("Index out of range")
    }
    function Nr(Oe, ot, ir, vr, Er) {
        xi(ot, vr, Er, Oe, ir, 7);
        let Ar = Number(ot & BigInt(4294967295));
        Oe[ir++] = Ar,
        Ar >>= 8,
        Oe[ir++] = Ar,
        Ar >>= 8,
        Oe[ir++] = Ar,
        Ar >>= 8,
        Oe[ir++] = Ar;
        let kr = Number(ot >> BigInt(32) & BigInt(4294967295));
        return Oe[ir++] = kr,
        kr >>= 8,
        Oe[ir++] = kr,
        kr >>= 8,
        Oe[ir++] = kr,
        kr >>= 8,
        Oe[ir++] = kr,
        ir
    }
    function gn(Oe, ot, ir, vr, Er) {
        xi(ot, vr, Er, Oe, ir, 7);
        let Ar = Number(ot & BigInt(4294967295));
        Oe[ir + 7] = Ar,
        Ar >>= 8,
        Oe[ir + 6] = Ar,
        Ar >>= 8,
        Oe[ir + 5] = Ar,
        Ar >>= 8,
        Oe[ir + 4] = Ar;
        let kr = Number(ot >> BigInt(32) & BigInt(4294967295));
        return Oe[ir + 3] = kr,
        kr >>= 8,
        Oe[ir + 2] = kr,
        kr >>= 8,
        Oe[ir + 1] = kr,
        kr >>= 8,
        Oe[ir] = kr,
        ir + 8
    }
    function Zr(Oe, ot, ir, vr, Er, Ar) {
        if (ir + vr > Oe.length)
            throw new RangeError("Index out of range");
        if (ir < 0)
            throw new RangeError("Index out of range")
    }
    function Tn(Oe, ot, ir, vr, Er) {
        return ot = +ot,
        ir >>>= 0,
        Er || Zr(Oe, 0, ir, 4),
        Y.write(Oe, ot, ir, vr, 23, 4),
        ir + 4
    }
    function Zn(Oe, ot, ir, vr, Er) {
        return ot = +ot,
        ir >>>= 0,
        Er || Zr(Oe, 0, ir, 8),
        Y.write(Oe, ot, ir, vr, 52, 8),
        ir + 8
    }
    de.prototype.slice = function(Oe, ot) {
        const ir = this.length;
        (Oe = ~~Oe) < 0 ? (Oe += ir) < 0 && (Oe = 0) : Oe > ir && (Oe = ir),
        (ot = ot === void 0 ? ir : ~~ot) < 0 ? (ot += ir) < 0 && (ot = 0) : ot > ir && (ot = ir),
        ot < Oe && (ot = Oe);
        const vr = this.subarray(Oe, ot);
        return Object.setPrototypeOf(vr, de.prototype),
        vr
    }
    ,
    de.prototype.readUintLE = de.prototype.readUIntLE = function(Oe, ot, ir) {
        Oe >>>= 0,
        ot >>>= 0,
        ir || _r(Oe, ot, this.length);
        let vr = this[Oe]
          , Er = 1
          , Ar = 0;
        for (; ++Ar < ot && (Er *= 256); )
            vr += this[Oe + Ar] * Er;
        return vr
    }
    ,
    de.prototype.readUintBE = de.prototype.readUIntBE = function(Oe, ot, ir) {
        Oe >>>= 0,
        ot >>>= 0,
        ir || _r(Oe, ot, this.length);
        let vr = this[Oe + --ot]
          , Er = 1;
        for (; ot > 0 && (Er *= 256); )
            vr += this[Oe + --ot] * Er;
        return vr
    }
    ,
    de.prototype.readUint8 = de.prototype.readUInt8 = function(Oe, ot) {
        return Oe >>>= 0,
        ot || _r(Oe, 1, this.length),
        this[Oe]
    }
    ,
    de.prototype.readUint16LE = de.prototype.readUInt16LE = function(Oe, ot) {
        return Oe >>>= 0,
        ot || _r(Oe, 2, this.length),
        this[Oe] | this[Oe + 1] << 8
    }
    ,
    de.prototype.readUint16BE = de.prototype.readUInt16BE = function(Oe, ot) {
        return Oe >>>= 0,
        ot || _r(Oe, 2, this.length),
        this[Oe] << 8 | this[Oe + 1]
    }
    ,
    de.prototype.readUint32LE = de.prototype.readUInt32LE = function(Oe, ot) {
        return Oe >>>= 0,
        ot || _r(Oe, 4, this.length),
        (this[Oe] | this[Oe + 1] << 8 | this[Oe + 2] << 16) + 16777216 * this[Oe + 3]
    }
    ,
    de.prototype.readUint32BE = de.prototype.readUInt32BE = function(Oe, ot) {
        return Oe >>>= 0,
        ot || _r(Oe, 4, this.length),
        16777216 * this[Oe] + (this[Oe + 1] << 16 | this[Oe + 2] << 8 | this[Oe + 3])
    }
    ,
    de.prototype.readBigUInt64LE = Qr(function(Oe) {
        oi(Oe >>>= 0, "offset");
        const ot = this[Oe]
          , ir = this[Oe + 7];
        ot !== void 0 && ir !== void 0 || $i(Oe, this.length - 8);
        const vr = ot + 256 * this[++Oe] + 65536 * this[++Oe] + this[++Oe] * 2 ** 24
          , Er = this[++Oe] + 256 * this[++Oe] + 65536 * this[++Oe] + ir * 2 ** 24;
        return BigInt(vr) + (BigInt(Er) << BigInt(32))
    }),
    de.prototype.readBigUInt64BE = Qr(function(Oe) {
        oi(Oe >>>= 0, "offset");
        const ot = this[Oe]
          , ir = this[Oe + 7];
        ot !== void 0 && ir !== void 0 || $i(Oe, this.length - 8);
        const vr = ot * 2 ** 24 + 65536 * this[++Oe] + 256 * this[++Oe] + this[++Oe]
          , Er = this[++Oe] * 2 ** 24 + 65536 * this[++Oe] + 256 * this[++Oe] + ir;
        return (BigInt(vr) << BigInt(32)) + BigInt(Er)
    }),
    de.prototype.readIntLE = function(Oe, ot, ir) {
        Oe >>>= 0,
        ot >>>= 0,
        ir || _r(Oe, ot, this.length);
        let vr = this[Oe]
          , Er = 1
          , Ar = 0;
        for (; ++Ar < ot && (Er *= 256); )
            vr += this[Oe + Ar] * Er;
        return Er *= 128,
        vr >= Er && (vr -= Math.pow(2, 8 * ot)),
        vr
    }
    ,
    de.prototype.readIntBE = function(Oe, ot, ir) {
        Oe >>>= 0,
        ot >>>= 0,
        ir || _r(Oe, ot, this.length);
        let vr = ot
          , Er = 1
          , Ar = this[Oe + --vr];
        for (; vr > 0 && (Er *= 256); )
            Ar += this[Oe + --vr] * Er;
        return Er *= 128,
        Ar >= Er && (Ar -= Math.pow(2, 8 * ot)),
        Ar
    }
    ,
    de.prototype.readInt8 = function(Oe, ot) {
        return Oe >>>= 0,
        ot || _r(Oe, 1, this.length),
        128 & this[Oe] ? -1 * (255 - this[Oe] + 1) : this[Oe]
    }
    ,
    de.prototype.readInt16LE = function(Oe, ot) {
        Oe >>>= 0,
        ot || _r(Oe, 2, this.length);
        const ir = this[Oe] | this[Oe + 1] << 8;
        return 32768 & ir ? 4294901760 | ir : ir
    }
    ,
    de.prototype.readInt16BE = function(Oe, ot) {
        Oe >>>= 0,
        ot || _r(Oe, 2, this.length);
        const ir = this[Oe + 1] | this[Oe] << 8;
        return 32768 & ir ? 4294901760 | ir : ir
    }
    ,
    de.prototype.readInt32LE = function(Oe, ot) {
        return Oe >>>= 0,
        ot || _r(Oe, 4, this.length),
        this[Oe] | this[Oe + 1] << 8 | this[Oe + 2] << 16 | this[Oe + 3] << 24
    }
    ,
    de.prototype.readInt32BE = function(Oe, ot) {
        return Oe >>>= 0,
        ot || _r(Oe, 4, this.length),
        this[Oe] << 24 | this[Oe + 1] << 16 | this[Oe + 2] << 8 | this[Oe + 3]
    }
    ,
    de.prototype.readBigInt64LE = Qr(function(Oe) {
        oi(Oe >>>= 0, "offset");
        const ot = this[Oe]
          , ir = this[Oe + 7];
        ot !== void 0 && ir !== void 0 || $i(Oe, this.length - 8);
        const vr = this[Oe + 4] + 256 * this[Oe + 5] + 65536 * this[Oe + 6] + (ir << 24);
        return (BigInt(vr) << BigInt(32)) + BigInt(ot + 256 * this[++Oe] + 65536 * this[++Oe] + this[++Oe] * 2 ** 24)
    }),
    de.prototype.readBigInt64BE = Qr(function(Oe) {
        oi(Oe >>>= 0, "offset");
        const ot = this[Oe]
          , ir = this[Oe + 7];
        ot !== void 0 && ir !== void 0 || $i(Oe, this.length - 8);
        const vr = (ot << 24) + 65536 * this[++Oe] + 256 * this[++Oe] + this[++Oe];
        return (BigInt(vr) << BigInt(32)) + BigInt(this[++Oe] * 2 ** 24 + 65536 * this[++Oe] + 256 * this[++Oe] + ir)
    }),
    de.prototype.readFloatLE = function(Oe, ot) {
        return Oe >>>= 0,
        ot || _r(Oe, 4, this.length),
        Y.read(this, Oe, !0, 23, 4)
    }
    ,
    de.prototype.readFloatBE = function(Oe, ot) {
        return Oe >>>= 0,
        ot || _r(Oe, 4, this.length),
        Y.read(this, Oe, !1, 23, 4)
    }
    ,
    de.prototype.readDoubleLE = function(Oe, ot) {
        return Oe >>>= 0,
        ot || _r(Oe, 8, this.length),
        Y.read(this, Oe, !0, 52, 8)
    }
    ,
    de.prototype.readDoubleBE = function(Oe, ot) {
        return Oe >>>= 0,
        ot || _r(Oe, 8, this.length),
        Y.read(this, Oe, !1, 52, 8)
    }
    ,
    de.prototype.writeUintLE = de.prototype.writeUIntLE = function(Oe, ot, ir, vr) {
        Oe = +Oe,
        ot >>>= 0,
        ir >>>= 0,
        !vr && Ir(this, Oe, ot, ir, Math.pow(2, 8 * ir) - 1, 0);
        let Er = 1
          , Ar = 0;
        for (this[ot] = 255 & Oe; ++Ar < ir && (Er *= 256); )
            this[ot + Ar] = Oe / Er & 255;
        return ot + ir
    }
    ,
    de.prototype.writeUintBE = de.prototype.writeUIntBE = function(Oe, ot, ir, vr) {
        Oe = +Oe,
        ot >>>= 0,
        ir >>>= 0,
        !vr && Ir(this, Oe, ot, ir, Math.pow(2, 8 * ir) - 1, 0);
        let Er = ir - 1
          , Ar = 1;
        for (this[ot + Er] = 255 & Oe; --Er >= 0 && (Ar *= 256); )
            this[ot + Er] = Oe / Ar & 255;
        return ot + ir
    }
    ,
    de.prototype.writeUint8 = de.prototype.writeUInt8 = function(Oe, ot, ir) {
        return Oe = +Oe,
        ot >>>= 0,
        ir || Ir(this, Oe, ot, 1, 255, 0),
        this[ot] = 255 & Oe,
        ot + 1
    }
    ,
    de.prototype.writeUint16LE = de.prototype.writeUInt16LE = function(Oe, ot, ir) {
        return Oe = +Oe,
        ot >>>= 0,
        ir || Ir(this, Oe, ot, 2, 65535, 0),
        this[ot] = 255 & Oe,
        this[ot + 1] = Oe >>> 8,
        ot + 2
    }
    ,
    de.prototype.writeUint16BE = de.prototype.writeUInt16BE = function(Oe, ot, ir) {
        return Oe = +Oe,
        ot >>>= 0,
        ir || Ir(this, Oe, ot, 2, 65535, 0),
        this[ot] = Oe >>> 8,
        this[ot + 1] = 255 & Oe,
        ot + 2
    }
    ,
    de.prototype.writeUint32LE = de.prototype.writeUInt32LE = function(Oe, ot, ir) {
        return Oe = +Oe,
        ot >>>= 0,
        ir || Ir(this, Oe, ot, 4, 4294967295, 0),
        this[ot + 3] = Oe >>> 24,
        this[ot + 2] = Oe >>> 16,
        this[ot + 1] = Oe >>> 8,
        this[ot] = 255 & Oe,
        ot + 4
    }
    ,
    de.prototype.writeUint32BE = de.prototype.writeUInt32BE = function(Oe, ot, ir) {
        return Oe = +Oe,
        ot >>>= 0,
        ir || Ir(this, Oe, ot, 4, 4294967295, 0),
        this[ot] = Oe >>> 24,
        this[ot + 1] = Oe >>> 16,
        this[ot + 2] = Oe >>> 8,
        this[ot + 3] = 255 & Oe,
        ot + 4
    }
    ,
    de.prototype.writeBigUInt64LE = Qr(function(Oe, ot=0) {
        return Nr(this, Oe, ot, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    de.prototype.writeBigUInt64BE = Qr(function(Oe, ot=0) {
        return gn(this, Oe, ot, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    de.prototype.writeIntLE = function(Oe, ot, ir, vr) {
        if (Oe = +Oe,
        ot >>>= 0,
        !vr) {
            const _n = Math.pow(2, 8 * ir - 1);
            Ir(this, Oe, ot, ir, _n - 1, -_n)
        }
        let Er = 0
          , Ar = 1
          , kr = 0;
        for (this[ot] = 255 & Oe; ++Er < ir && (Ar *= 256); )
            Oe < 0 && kr === 0 && this[ot + Er - 1] !== 0 && (kr = 1),
            this[ot + Er] = (Oe / Ar >> 0) - kr & 255;
        return ot + ir
    }
    ,
    de.prototype.writeIntBE = function(Oe, ot, ir, vr) {
        if (Oe = +Oe,
        ot >>>= 0,
        !vr) {
            const _n = Math.pow(2, 8 * ir - 1);
            Ir(this, Oe, ot, ir, _n - 1, -_n)
        }
        let Er = ir - 1
          , Ar = 1
          , kr = 0;
        for (this[ot + Er] = 255 & Oe; --Er >= 0 && (Ar *= 256); )
            Oe < 0 && kr === 0 && this[ot + Er + 1] !== 0 && (kr = 1),
            this[ot + Er] = (Oe / Ar >> 0) - kr & 255;
        return ot + ir
    }
    ,
    de.prototype.writeInt8 = function(Oe, ot, ir) {
        return Oe = +Oe,
        ot >>>= 0,
        ir || Ir(this, Oe, ot, 1, 127, -128),
        Oe < 0 && (Oe = 255 + Oe + 1),
        this[ot] = 255 & Oe,
        ot + 1
    }
    ,
    de.prototype.writeInt16LE = function(Oe, ot, ir) {
        return Oe = +Oe,
        ot >>>= 0,
        ir || Ir(this, Oe, ot, 2, 32767, -32768),
        this[ot] = 255 & Oe,
        this[ot + 1] = Oe >>> 8,
        ot + 2
    }
    ,
    de.prototype.writeInt16BE = function(Oe, ot, ir) {
        return Oe = +Oe,
        ot >>>= 0,
        ir || Ir(this, Oe, ot, 2, 32767, -32768),
        this[ot] = Oe >>> 8,
        this[ot + 1] = 255 & Oe,
        ot + 2
    }
    ,
    de.prototype.writeInt32LE = function(Oe, ot, ir) {
        return Oe = +Oe,
        ot >>>= 0,
        ir || Ir(this, Oe, ot, 4, 2147483647, -2147483648),
        this[ot] = 255 & Oe,
        this[ot + 1] = Oe >>> 8,
        this[ot + 2] = Oe >>> 16,
        this[ot + 3] = Oe >>> 24,
        ot + 4
    }
    ,
    de.prototype.writeInt32BE = function(Oe, ot, ir) {
        return Oe = +Oe,
        ot >>>= 0,
        ir || Ir(this, Oe, ot, 4, 2147483647, -2147483648),
        Oe < 0 && (Oe = 4294967295 + Oe + 1),
        this[ot] = Oe >>> 24,
        this[ot + 1] = Oe >>> 16,
        this[ot + 2] = Oe >>> 8,
        this[ot + 3] = 255 & Oe,
        ot + 4
    }
    ,
    de.prototype.writeBigInt64LE = Qr(function(Oe, ot=0) {
        return Nr(this, Oe, ot, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }),
    de.prototype.writeBigInt64BE = Qr(function(Oe, ot=0) {
        return gn(this, Oe, ot, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }),
    de.prototype.writeFloatLE = function(Oe, ot, ir) {
        return Tn(this, Oe, ot, !0, ir)
    }
    ,
    de.prototype.writeFloatBE = function(Oe, ot, ir) {
        return Tn(this, Oe, ot, !1, ir)
    }
    ,
    de.prototype.writeDoubleLE = function(Oe, ot, ir) {
        return Zn(this, Oe, ot, !0, ir)
    }
    ,
    de.prototype.writeDoubleBE = function(Oe, ot, ir) {
        return Zn(this, Oe, ot, !1, ir)
    }
    ,
    de.prototype.copy = function(Oe, ot, ir, vr) {
        if (!de.isBuffer(Oe))
            throw new TypeError("argument should be a Buffer");
        if (ir || (ir = 0),
        vr || vr === 0 || (vr = this.length),
        ot >= Oe.length && (ot = Oe.length),
        ot || (ot = 0),
        vr > 0 && vr < ir && (vr = ir),
        vr === ir || Oe.length === 0 || this.length === 0)
            return 0;
        if (ot < 0)
            throw new RangeError("targetStart out of bounds");
        if (ir < 0 || ir >= this.length)
            throw new RangeError("Index out of range");
        if (vr < 0)
            throw new RangeError("sourceEnd out of bounds");
        vr > this.length && (vr = this.length),
        Oe.length - ot < vr - ir && (vr = Oe.length - ot + ir);
        const Er = vr - ir;
        return this === Oe && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(ot, ir, vr) : Uint8Array.prototype.set.call(Oe, this.subarray(ir, vr), ot),
        Er
    }
    ,
    de.prototype.fill = function(Oe, ot, ir, vr) {
        if (typeof Oe == "string") {
            if (typeof ot == "string" ? (vr = ot,
            ot = 0,
            ir = this.length) : typeof ir == "string" && (vr = ir,
            ir = this.length),
            vr !== void 0 && typeof vr != "string")
                throw new TypeError("encoding must be a string");
            if (typeof vr == "string" && !de.isEncoding(vr))
                throw new TypeError("Unknown encoding: " + vr);
            if (Oe.length === 1) {
                const Ar = Oe.charCodeAt(0);
                (vr === "utf8" && Ar < 128 || vr === "latin1") && (Oe = Ar)
            }
        } else
            typeof Oe == "number" ? Oe &= 255 : typeof Oe == "boolean" && (Oe = Number(Oe));
        if (ot < 0 || this.length < ot || this.length < ir)
            throw new RangeError("Out of range index");
        if (ir <= ot)
            return this;
        let Er;
        if (ot >>>= 0,
        ir = ir === void 0 ? this.length : ir >>> 0,
        Oe || (Oe = 0),
        typeof Oe == "number")
            for (Er = ot; Er < ir; ++Er)
                this[Er] = Oe;
        else {
            const Ar = de.isBuffer(Oe) ? Oe : de.from(Oe, vr)
              , kr = Ar.length;
            if (kr === 0)
                throw new TypeError('The value "' + Oe + '" is invalid for argument "value"');
            for (Er = 0; Er < ir - ot; ++Er)
                this[Er + ot] = Ar[Er % kr]
        }
        return this
    }
    ;
    const Cn = {};
    function Gn(Oe, ot, ir) {
        Cn[Oe] = class extends ir {
            constructor() {
                super(),
                Object.defineProperty(this, "message", {
                    value: ot.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }),
                this.name = `${this.name} [${Oe}]`,
                this.stack,
                delete this.name
            }
            get code() {
                return Oe
            }
            set code(vr) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: vr,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${Oe}]: ${this.message}`
            }
        }
    }
    function ni(Oe) {
        let ot = ""
          , ir = Oe.length;
        const vr = Oe[0] === "-" ? 1 : 0;
        for (; ir >= vr + 4; ir -= 3)
            ot = `_${Oe.slice(ir - 3, ir)}${ot}`;
        return `${Oe.slice(0, ir)}${ot}`
    }
    function xi(Oe, ot, ir, vr, Er, Ar) {
        if (Oe > ir || Oe < ot) {
            const kr = typeof ot == "bigint" ? "n" : "";
            let _n;
            throw _n = Ar > 3 ? ot === 0 || ot === BigInt(0) ? `>= 0${kr} and < 2${kr} ** ${8 * (Ar + 1)}${kr}` : `>= -(2${kr} ** ${8 * (Ar + 1) - 1}${kr}) and < 2 ** ${8 * (Ar + 1) - 1}${kr}` : `>= ${ot}${kr} and <= ${ir}${kr}`,
            new Cn.ERR_OUT_OF_RANGE("value",_n,Oe)
        }
        (function(kr, _n, Qn) {
            oi(_n, "offset"),
            kr[_n] !== void 0 && kr[_n + Qn] !== void 0 || $i(_n, kr.length - (Qn + 1))
        }
        )(vr, Er, Ar)
    }
    function oi(Oe, ot) {
        if (typeof Oe != "number")
            throw new Cn.ERR_INVALID_ARG_TYPE(ot,"number",Oe)
    }
    function $i(Oe, ot, ir) {
        throw Math.floor(Oe) !== Oe ? (oi(Oe, ir),
        new Cn.ERR_OUT_OF_RANGE(ir || "offset","an integer",Oe)) : ot < 0 ? new Cn.ERR_BUFFER_OUT_OF_BOUNDS : new Cn.ERR_OUT_OF_RANGE(ir || "offset",`>= ${ir ? 1 : 0} and <= ${ot}`,Oe)
    }
    Gn("ERR_BUFFER_OUT_OF_BOUNDS", function(Oe) {
        return Oe ? `${Oe} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError),
    Gn("ERR_INVALID_ARG_TYPE", function(Oe, ot) {
        return `The "${Oe}" argument must be of type number. Received type ${typeof ot}`
    }, TypeError),
    Gn("ERR_OUT_OF_RANGE", function(Oe, ot, ir) {
        let vr = `The value of "${Oe}" is out of range.`
          , Er = ir;
        return Number.isInteger(ir) && Math.abs(ir) > 2 ** 32 ? Er = ni(String(ir)) : typeof ir == "bigint" && (Er = String(ir),
        (ir > BigInt(2) ** BigInt(32) || ir < -(BigInt(2) ** BigInt(32))) && (Er = ni(Er)),
        Er += "n"),
        vr += ` It must be ${ot}. Received ${Er}`,
        vr
    }, RangeError);
    const Ci = /[^+/0-9A-Za-z-_]/g;
    function Yn(Oe, ot) {
        let ir;
        ot = ot || 1 / 0;
        const vr = Oe.length;
        let Er = null;
        const Ar = [];
        for (let kr = 0; kr < vr; ++kr) {
            if (ir = Oe.charCodeAt(kr),
            ir > 55295 && ir < 57344) {
                if (!Er) {
                    if (ir > 56319) {
                        (ot -= 3) > -1 && Ar.push(239, 191, 189);
                        continue
                    }
                    if (kr + 1 === vr) {
                        (ot -= 3) > -1 && Ar.push(239, 191, 189);
                        continue
                    }
                    Er = ir;
                    continue
                }
                if (ir < 56320) {
                    (ot -= 3) > -1 && Ar.push(239, 191, 189),
                    Er = ir;
                    continue
                }
                ir = 65536 + (Er - 55296 << 10 | ir - 56320)
            } else
                Er && (ot -= 3) > -1 && Ar.push(239, 191, 189);
            if (Er = null,
            ir < 128) {
                if ((ot -= 1) < 0)
                    break;
                Ar.push(ir)
            } else if (ir < 2048) {
                if ((ot -= 2) < 0)
                    break;
                Ar.push(ir >> 6 | 192, 63 & ir | 128)
            } else if (ir < 65536) {
                if ((ot -= 3) < 0)
                    break;
                Ar.push(ir >> 12 | 224, ir >> 6 & 63 | 128, 63 & ir | 128)
            } else {
                if (!(ir < 1114112))
                    throw new Error("Invalid code point");
                if ((ot -= 4) < 0)
                    break;
                Ar.push(ir >> 18 | 240, ir >> 12 & 63 | 128, ir >> 6 & 63 | 128, 63 & ir | 128)
            }
        }
        return Ar
    }
    function pi(Oe) {
        return z.toByteArray(function(ot) {
            if ((ot = (ot = ot.split("=")[0]).trim().replace(Ci, "")).length < 2)
                return "";
            for (; ot.length % 4 != 0; )
                ot += "=";
            return ot
        }(Oe))
    }
    function yi(Oe, ot, ir, vr) {
        let Er;
        for (Er = 0; Er < vr && !(Er + ir >= ot.length || Er >= Oe.length); ++Er)
            ot[Er + ir] = Oe[Er];
        return Er
    }
    function dr(Oe, ot) {
        return Oe instanceof ot || Oe != null && Oe.constructor != null && Oe.constructor.name != null && Oe.constructor.name === ot.name
    }
    function Sr(Oe) {
        return Oe != Oe
    }
    const Gr = function() {
        const Oe = "0123456789abcdef"
          , ot = new Array(256);
        for (let ir = 0; ir < 16; ++ir) {
            const vr = 16 * ir;
            for (let Er = 0; Er < 16; ++Er)
                ot[vr + Er] = Oe[ir] + Oe[Er]
        }
        return ot
    }();
    function Qr(Oe) {
        return typeof BigInt > "u" ? vn : Oe
    }
    function vn() {
        throw new Error("BigInt not supported")
    }
}(buffer),
typeof window < "u" && (window.Buffer || (window.Buffer = buffer.Buffer),
window.global || (window.global = window),
window.process || (window.process = {}),
window.process?.env || (window.process = {
    env: {}
}));
var CoinbaseWalletConnector = class extends Connector {
    constructor({chains: W, options: z}) {
        super({
            chains: W,
            options: {
                reloadOnDisconnect: !1,
                ...z
            }
        }),
        this.id = "coinbaseWallet",
        this.name = "Coinbase Wallet",
        this.ready = !0,
        __privateAdd$1(this, _client, void 0),
        __privateAdd$1(this, _provider$1, void 0),
        this.onAccountsChanged = Y=>{
            Y.length === 0 ? this.emit("disconnect") : this.emit("change", {
                account: getAddress(Y[0])
            })
        }
        ,
        this.onChainChanged = Y=>{
            const ne = normalizeChainId(Y)
              , le = this.isChainUnsupported(ne);
            this.emit("change", {
                chain: {
                    id: ne,
                    unsupported: le
                }
            })
        }
        ,
        this.onDisconnect = ()=>{
            this.emit("disconnect")
        }
    }
    async connect({chainId: W}={}) {
        try {
            const z = await this.getProvider();
            z.on("accountsChanged", this.onAccountsChanged),
            z.on("chainChanged", this.onChainChanged),
            z.on("disconnect", this.onDisconnect),
            this.emit("message", {
                type: "connecting"
            });
            const Y = getAddress((await z.enable())[0]);
            let ne = await this.getChainId()
              , le = this.isChainUnsupported(ne);
            return W && ne !== W && (ne = (await this.switchChain(W)).id,
            le = this.isChainUnsupported(ne)),
            {
                account: Y,
                chain: {
                    id: ne,
                    unsupported: le
                }
            }
        } catch (z) {
            throw /(user closed modal|accounts received is empty)/i.test(z.message) ? new UserRejectedRequestError(z) : z
        }
    }
    async disconnect() {
        if (!__privateGet$1(this, _provider$1))
            return;
        const W = await this.getProvider();
        W.removeListener("accountsChanged", this.onAccountsChanged),
        W.removeListener("chainChanged", this.onChainChanged),
        W.removeListener("disconnect", this.onDisconnect),
        W.disconnect(),
        W.close()
    }
    async getAccount() {
        const W = await this.getProvider();
        return getAddress((await W.request({
            method: "eth_accounts"
        }))[0])
    }
    async getChainId() {
        return normalizeChainId((await this.getProvider()).chainId)
    }
    async getProvider() {
       /* if (!__privateGet$1(this, _provider$1)) {
            let W = (await __vitePreload(()=>import("./index.80ea887e.js").then(ue=>ue.i), ["_astro/index.80ea887e.js", "_astro/events.86a01509.js"])).default;
            typeof W != "function" && typeof W.default == "function" && (W = W.default),
            __privateSet$1(this, _client, new W(this.options));
            const z = __privateGet$1(this, _client).walletExtension?.getChainId()
              , Y = this.chains.find(ue=>this.options.chainId ? ue.id === this.options.chainId : ue.id === z) || this.chains[0]
              , ne = this.options.chainId || Y?.id
              , le = this.options.jsonRpcUrl || Y?.rpcUrls.default.http[0];
            __privateSet$1(this, _provider$1, __privateGet$1(this, _client).makeWeb3Provider(le, ne))
        }
        return __privateGet$1(this, _provider$1)*/
    }
    async getWalletClient({chainId: W}={}) {
        const [z,Y] = await Promise.all([this.getProvider(), this.getAccount()])
          , ne = this.chains.find(le=>le.id === W);
        if (!z)
            throw new Error("provider is required.");
        return createWalletClient({
            account: Y,
            chain: ne,
            transport: custom(z)
        })
    }
    async isAuthorized() {
        try {
            return !!await this.getAccount()
        } catch {
            return !1
        }
    }
    async switchChain(W) {
        const z = await this.getProvider()
          , Y = numberToHex(W);
        try {
            return await z.request({
                method: "wallet_switchEthereumChain",
                params: [{
                    chainId: Y
                }]
            }),
            this.chains.find(ne=>ne.id === W) ?? {
                id: W,
                name: `Chain ${Y}`,
                network: `${Y}`,
                nativeCurrency: {
                    name: "Ether",
                    decimals: 18,
                    symbol: "ETH"
                },
                rpcUrls: {
                    default: {
                        http: [""]
                    },
                    public: {
                        http: [""]
                    }
                }
            }
        } catch (ne) {
            const le = this.chains.find(ue=>ue.id === W);
            if (!le)
                throw new ChainNotConfiguredForConnectorError({
                    chainId: W,
                    connectorId: this.id
                });
            if (ne.code === 4902)
                try {
                    return await z.request({
                        method: "wallet_addEthereumChain",
                        params: [{
                            chainId: Y,
                            chainName: le.name,
                            nativeCurrency: le.nativeCurrency,
                            rpcUrls: [le.rpcUrls.public?.http[0] ?? ""],
                            blockExplorerUrls: this.getBlockExplorerUrls(le)
                        }]
                    }),
                    le
                } catch (ue) {
                    throw new UserRejectedRequestError(ue)
                }
            throw new SwitchChainError(ne)
        }
    }
    async watchAsset({address: W, decimals: z=18, image: Y, symbol: ne}) {
        return (await this.getProvider()).request({
            method: "wallet_watchAsset",
            params: {
                type: "ERC20",
                options: {
                    address: W,
                    decimals: z,
                    image: Y,
                    symbol: ne
                }
            }
        })
    }
}
;
_client = new WeakMap,
_provider$1 = new WeakMap;
var chacha20poly1305 = {}
  , chacha = {}
  , binary = {}
  , int = {};
(function(W) {
    Object.defineProperty(W, "__esModule", {
        value: !0
    }),
    W.mul = Math.imul || function(z, Y) {
        var ne = 65535 & z
          , le = 65535 & Y;
        return ne * le + ((z >>> 16 & 65535) * le + ne * (Y >>> 16 & 65535) << 16 >>> 0) | 0
    }
    ,
    W.add = function(z, Y) {
        return z + Y | 0
    }
    ,
    W.sub = function(z, Y) {
        return z - Y | 0
    }
    ,
    W.rotl = function(z, Y) {
        return z << Y | z >>> 32 - Y
    }
    ,
    W.rotr = function(z, Y) {
        return z << 32 - Y | z >>> Y
    }
    ,
    W.isInteger = Number.isInteger || function(z) {
        return typeof z == "number" && isFinite(z) && Math.floor(z) === z
    }
    ,
    W.MAX_SAFE_INTEGER = 9007199254740991,
    W.isSafeInteger = function(z) {
        return W.isInteger(z) && z >= -W.MAX_SAFE_INTEGER && z <= W.MAX_SAFE_INTEGER
    }
}
)(int),
Object.defineProperty(binary, "__esModule", {
    value: !0
});
var int_1 = int;
function readInt16BE(W, z) {
    return z === void 0 && (z = 0),
    (W[z + 0] << 8 | W[z + 1]) << 16 >> 16
}
function readUint16BE(W, z) {
    return z === void 0 && (z = 0),
    (W[z + 0] << 8 | W[z + 1]) >>> 0
}
function readInt16LE(W, z) {
    return z === void 0 && (z = 0),
    (W[z + 1] << 8 | W[z]) << 16 >> 16
}
function readUint16LE(W, z) {
    return z === void 0 && (z = 0),
    (W[z + 1] << 8 | W[z]) >>> 0
}
function writeUint16BE(W, z, Y) {
    return z === void 0 && (z = new Uint8Array(2)),
    Y === void 0 && (Y = 0),
    z[Y + 0] = W >>> 8,
    z[Y + 1] = W >>> 0,
    z
}
function writeUint16LE(W, z, Y) {
    return z === void 0 && (z = new Uint8Array(2)),
    Y === void 0 && (Y = 0),
    z[Y + 0] = W >>> 0,
    z[Y + 1] = W >>> 8,
    z
}
function readInt32BE(W, z) {
    return z === void 0 && (z = 0),
    W[z] << 24 | W[z + 1] << 16 | W[z + 2] << 8 | W[z + 3]
}
function readUint32BE(W, z) {
    return z === void 0 && (z = 0),
    (W[z] << 24 | W[z + 1] << 16 | W[z + 2] << 8 | W[z + 3]) >>> 0
}
function readInt32LE(W, z) {
    return z === void 0 && (z = 0),
    W[z + 3] << 24 | W[z + 2] << 16 | W[z + 1] << 8 | W[z]
}
function readUint32LE(W, z) {
    return z === void 0 && (z = 0),
    (W[z + 3] << 24 | W[z + 2] << 16 | W[z + 1] << 8 | W[z]) >>> 0
}
function writeUint32BE(W, z, Y) {
    return z === void 0 && (z = new Uint8Array(4)),
    Y === void 0 && (Y = 0),
    z[Y + 0] = W >>> 24,
    z[Y + 1] = W >>> 16,
    z[Y + 2] = W >>> 8,
    z[Y + 3] = W >>> 0,
    z
}
function writeUint32LE(W, z, Y) {
    return z === void 0 && (z = new Uint8Array(4)),
    Y === void 0 && (Y = 0),
    z[Y + 0] = W >>> 0,
    z[Y + 1] = W >>> 8,
    z[Y + 2] = W >>> 16,
    z[Y + 3] = W >>> 24,
    z
}
function readInt64BE(W, z) {
    z === void 0 && (z = 0);
    var Y = readInt32BE(W, z)
      , ne = readInt32BE(W, z + 4);
    return 4294967296 * Y + ne - 4294967296 * (ne >> 31)
}
function readUint64BE(W, z) {
    return z === void 0 && (z = 0),
    4294967296 * readUint32BE(W, z) + readUint32BE(W, z + 4)
}
function readInt64LE(W, z) {
    z === void 0 && (z = 0);
    var Y = readInt32LE(W, z);
    return 4294967296 * readInt32LE(W, z + 4) + Y - 4294967296 * (Y >> 31)
}
function readUint64LE(W, z) {
    z === void 0 && (z = 0);
    var Y = readUint32LE(W, z);
    return 4294967296 * readUint32LE(W, z + 4) + Y
}
function writeUint64BE(W, z, Y) {
    return z === void 0 && (z = new Uint8Array(8)),
    Y === void 0 && (Y = 0),
    writeUint32BE(W / 4294967296 >>> 0, z, Y),
    writeUint32BE(W >>> 0, z, Y + 4),
    z
}
function writeUint64LE(W, z, Y) {
    return z === void 0 && (z = new Uint8Array(8)),
    Y === void 0 && (Y = 0),
    writeUint32LE(W >>> 0, z, Y),
    writeUint32LE(W / 4294967296 >>> 0, z, Y + 4),
    z
}
function readUintBE(W, z, Y) {
    if (Y === void 0 && (Y = 0),
    W % 8 != 0)
        throw new Error("readUintBE supports only bitLengths divisible by 8");
    if (W / 8 > z.length - Y)
        throw new Error("readUintBE: array is too short for the given bitLength");
    for (var ne = 0, le = 1, ue = W / 8 + Y - 1; ue >= Y; ue--)
        ne += z[ue] * le,
        le *= 256;
    return ne
}
function readUintLE(W, z, Y) {
    if (Y === void 0 && (Y = 0),
    W % 8 != 0)
        throw new Error("readUintLE supports only bitLengths divisible by 8");
    if (W / 8 > z.length - Y)
        throw new Error("readUintLE: array is too short for the given bitLength");
    for (var ne = 0, le = 1, ue = Y; ue < Y + W / 8; ue++)
        ne += z[ue] * le,
        le *= 256;
    return ne
}
function writeUintBE(W, z, Y, ne) {
    if (Y === void 0 && (Y = new Uint8Array(W / 8)),
    ne === void 0 && (ne = 0),
    W % 8 != 0)
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
    if (!int_1.isSafeInteger(z))
        throw new Error("writeUintBE value must be an integer");
    for (var le = 1, ue = W / 8 + ne - 1; ue >= ne; ue--)
        Y[ue] = z / le & 255,
        le *= 256;
    return Y
}
function writeUintLE(W, z, Y, ne) {
    if (Y === void 0 && (Y = new Uint8Array(W / 8)),
    ne === void 0 && (ne = 0),
    W % 8 != 0)
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
    if (!int_1.isSafeInteger(z))
        throw new Error("writeUintLE value must be an integer");
    for (var le = 1, ue = ne; ue < ne + W / 8; ue++)
        Y[ue] = z / le & 255,
        le *= 256;
    return Y
}
function readFloat32BE(W, z) {
    return z === void 0 && (z = 0),
    new DataView(W.buffer,W.byteOffset,W.byteLength).getFloat32(z)
}
function readFloat32LE(W, z) {
    return z === void 0 && (z = 0),
    new DataView(W.buffer,W.byteOffset,W.byteLength).getFloat32(z, !0)
}
function readFloat64BE(W, z) {
    return z === void 0 && (z = 0),
    new DataView(W.buffer,W.byteOffset,W.byteLength).getFloat64(z)
}
function readFloat64LE(W, z) {
    return z === void 0 && (z = 0),
    new DataView(W.buffer,W.byteOffset,W.byteLength).getFloat64(z, !0)
}
function writeFloat32BE(W, z, Y) {
    return z === void 0 && (z = new Uint8Array(4)),
    Y === void 0 && (Y = 0),
    new DataView(z.buffer,z.byteOffset,z.byteLength).setFloat32(Y, W),
    z
}
function writeFloat32LE(W, z, Y) {
    return z === void 0 && (z = new Uint8Array(4)),
    Y === void 0 && (Y = 0),
    new DataView(z.buffer,z.byteOffset,z.byteLength).setFloat32(Y, W, !0),
    z
}
function writeFloat64BE(W, z, Y) {
    return z === void 0 && (z = new Uint8Array(8)),
    Y === void 0 && (Y = 0),
    new DataView(z.buffer,z.byteOffset,z.byteLength).setFloat64(Y, W),
    z
}
function writeFloat64LE(W, z, Y) {
    return z === void 0 && (z = new Uint8Array(8)),
    Y === void 0 && (Y = 0),
    new DataView(z.buffer,z.byteOffset,z.byteLength).setFloat64(Y, W, !0),
    z
}
binary.readInt16BE = readInt16BE,
binary.readUint16BE = readUint16BE,
binary.readInt16LE = readInt16LE,
binary.readUint16LE = readUint16LE,
binary.writeUint16BE = writeUint16BE,
binary.writeInt16BE = writeUint16BE,
binary.writeUint16LE = writeUint16LE,
binary.writeInt16LE = writeUint16LE,
binary.readInt32BE = readInt32BE,
binary.readUint32BE = readUint32BE,
binary.readInt32LE = readInt32LE,
binary.readUint32LE = readUint32LE,
binary.writeUint32BE = writeUint32BE,
binary.writeInt32BE = writeUint32BE,
binary.writeUint32LE = writeUint32LE,
binary.writeInt32LE = writeUint32LE,
binary.readInt64BE = readInt64BE,
binary.readUint64BE = readUint64BE,
binary.readInt64LE = readInt64LE,
binary.readUint64LE = readUint64LE,
binary.writeUint64BE = writeUint64BE,
binary.writeInt64BE = writeUint64BE,
binary.writeUint64LE = writeUint64LE,
binary.writeInt64LE = writeUint64LE,
binary.readUintBE = readUintBE,
binary.readUintLE = readUintLE,
binary.writeUintBE = writeUintBE,
binary.writeUintLE = writeUintLE,
binary.readFloat32BE = readFloat32BE,
binary.readFloat32LE = readFloat32LE,
binary.readFloat64BE = readFloat64BE,
binary.readFloat64LE = readFloat64LE,
binary.writeFloat32BE = writeFloat32BE,
binary.writeFloat32LE = writeFloat32LE,
binary.writeFloat64BE = writeFloat64BE,
binary.writeFloat64LE = writeFloat64LE;
var wipe$1 = {};
function wipe(W) {
    for (var z = 0; z < W.length; z++)
        W[z] = 0;
    return W
}
Object.defineProperty(wipe$1, "__esModule", {
    value: !0
}),
wipe$1.wipe = wipe,
Object.defineProperty(chacha, "__esModule", {
    value: !0
});
var binary_1 = binary
  , wipe_1$3 = wipe$1
  , ROUNDS = 20;
function core(W, z, Y) {
    for (var ne = 1634760805, le = 857760878, ue = 2036477234, de = 1797285236, he = Y[3] << 24 | Y[2] << 16 | Y[1] << 8 | Y[0], fe = Y[7] << 24 | Y[6] << 16 | Y[5] << 8 | Y[4], ge = Y[11] << 24 | Y[10] << 16 | Y[9] << 8 | Y[8], xe = Y[15] << 24 | Y[14] << 16 | Y[13] << 8 | Y[12], $e = Y[19] << 24 | Y[18] << 16 | Y[17] << 8 | Y[16], Ee = Y[23] << 24 | Y[22] << 16 | Y[21] << 8 | Y[20], Se = Y[27] << 24 | Y[26] << 16 | Y[25] << 8 | Y[24], Ne = Y[31] << 24 | Y[30] << 16 | Y[29] << 8 | Y[28], tt = z[3] << 24 | z[2] << 16 | z[1] << 8 | z[0], rr = z[7] << 24 | z[6] << 16 | z[5] << 8 | z[4], tr = z[11] << 24 | z[10] << 16 | z[9] << 8 | z[8], we = z[15] << 24 | z[14] << 16 | z[13] << 8 | z[12], Ut = ne, lr = le, cr = ue, be = de, mr = he, fr = fe, Rr = ge, Pr = xe, Fr = $e, br = Ee, xr = Se, _r = Ne, Ir = tt, Nr = rr, gn = tr, Zr = we, Tn = 0; Tn < ROUNDS; Tn += 2)
        mr = (mr ^= Fr = Fr + (Ir = (Ir ^= Ut = Ut + mr | 0) >>> 16 | Ir << 16) | 0) >>> 20 | mr << 12,
        fr = (fr ^= br = br + (Nr = (Nr ^= lr = lr + fr | 0) >>> 16 | Nr << 16) | 0) >>> 20 | fr << 12,
        Rr = (Rr ^= xr = xr + (gn = (gn ^= cr = cr + Rr | 0) >>> 16 | gn << 16) | 0) >>> 20 | Rr << 12,
        Pr = (Pr ^= _r = _r + (Zr = (Zr ^= be = be + Pr | 0) >>> 16 | Zr << 16) | 0) >>> 20 | Pr << 12,
        Rr = (Rr ^= xr = xr + (gn = (gn ^= cr = cr + Rr | 0) >>> 24 | gn << 8) | 0) >>> 25 | Rr << 7,
        Pr = (Pr ^= _r = _r + (Zr = (Zr ^= be = be + Pr | 0) >>> 24 | Zr << 8) | 0) >>> 25 | Pr << 7,
        fr = (fr ^= br = br + (Nr = (Nr ^= lr = lr + fr | 0) >>> 24 | Nr << 8) | 0) >>> 25 | fr << 7,
        mr = (mr ^= Fr = Fr + (Ir = (Ir ^= Ut = Ut + mr | 0) >>> 24 | Ir << 8) | 0) >>> 25 | mr << 7,
        fr = (fr ^= xr = xr + (Zr = (Zr ^= Ut = Ut + fr | 0) >>> 16 | Zr << 16) | 0) >>> 20 | fr << 12,
        Rr = (Rr ^= _r = _r + (Ir = (Ir ^= lr = lr + Rr | 0) >>> 16 | Ir << 16) | 0) >>> 20 | Rr << 12,
        Pr = (Pr ^= Fr = Fr + (Nr = (Nr ^= cr = cr + Pr | 0) >>> 16 | Nr << 16) | 0) >>> 20 | Pr << 12,
        mr = (mr ^= br = br + (gn = (gn ^= be = be + mr | 0) >>> 16 | gn << 16) | 0) >>> 20 | mr << 12,
        Pr = (Pr ^= Fr = Fr + (Nr = (Nr ^= cr = cr + Pr | 0) >>> 24 | Nr << 8) | 0) >>> 25 | Pr << 7,
        mr = (mr ^= br = br + (gn = (gn ^= be = be + mr | 0) >>> 24 | gn << 8) | 0) >>> 25 | mr << 7,
        Rr = (Rr ^= _r = _r + (Ir = (Ir ^= lr = lr + Rr | 0) >>> 24 | Ir << 8) | 0) >>> 25 | Rr << 7,
        fr = (fr ^= xr = xr + (Zr = (Zr ^= Ut = Ut + fr | 0) >>> 24 | Zr << 8) | 0) >>> 25 | fr << 7;
    binary_1.writeUint32LE(Ut + ne | 0, W, 0),
    binary_1.writeUint32LE(lr + le | 0, W, 4),
    binary_1.writeUint32LE(cr + ue | 0, W, 8),
    binary_1.writeUint32LE(be + de | 0, W, 12),
    binary_1.writeUint32LE(mr + he | 0, W, 16),
    binary_1.writeUint32LE(fr + fe | 0, W, 20),
    binary_1.writeUint32LE(Rr + ge | 0, W, 24),
    binary_1.writeUint32LE(Pr + xe | 0, W, 28),
    binary_1.writeUint32LE(Fr + $e | 0, W, 32),
    binary_1.writeUint32LE(br + Ee | 0, W, 36),
    binary_1.writeUint32LE(xr + Se | 0, W, 40),
    binary_1.writeUint32LE(_r + Ne | 0, W, 44),
    binary_1.writeUint32LE(Ir + tt | 0, W, 48),
    binary_1.writeUint32LE(Nr + rr | 0, W, 52),
    binary_1.writeUint32LE(gn + tr | 0, W, 56),
    binary_1.writeUint32LE(Zr + we | 0, W, 60)
}
function streamXOR(W, z, Y, ne, le) {
    if (le === void 0 && (le = 0),
    W.length !== 32)
        throw new Error("ChaCha: key size must be 32 bytes");
    if (ne.length < Y.length)
        throw new Error("ChaCha: destination is shorter than source");
    var ue, de;
    if (le === 0) {
        if (z.length !== 8 && z.length !== 12)
            throw new Error("ChaCha nonce must be 8 or 12 bytes");
        de = (ue = new Uint8Array(16)).length - z.length,
        ue.set(z, de)
    } else {
        if (z.length !== 16)
            throw new Error("ChaCha nonce with counter must be 16 bytes");
        ue = z,
        de = le
    }
    for (var he = new Uint8Array(64), fe = 0; fe < Y.length; fe += 64) {
        core(he, ue, W);
        for (var ge = fe; ge < fe + 64 && ge < Y.length; ge++)
            ne[ge] = Y[ge] ^ he[ge - fe];
        incrementCounter(ue, 0, de)
    }
    return wipe_1$3.wipe(he),
    le === 0 && wipe_1$3.wipe(ue),
    ne
}
function stream(W, z, Y, ne) {
    return ne === void 0 && (ne = 0),
    wipe_1$3.wipe(Y),
    streamXOR(W, z, Y, Y, ne)
}
function incrementCounter(W, z, Y) {
    for (var ne = 1; Y--; )
        ne = ne + (255 & W[z]) | 0,
        W[z] = 255 & ne,
        ne >>>= 8,
        z++;
    if (ne > 0)
        throw new Error("ChaCha: counter overflow")
}
chacha.streamXOR = streamXOR,
chacha.stream = stream;
var poly1305 = {}
  , constantTime = {};
function select(W, z, Y) {
    return ~(W - 1) & z | W - 1 & Y
}
function lessOrEqual(W, z) {
    return (0 | W) - (0 | z) - 1 >>> 31 & 1
}
function compare(W, z) {
    if (W.length !== z.length)
        return 0;
    for (var Y = 0, ne = 0; ne < W.length; ne++)
        Y |= W[ne] ^ z[ne];
    return 1 & Y - 1 >>> 8
}
function equal(W, z) {
    return W.length !== 0 && z.length !== 0 && compare(W, z) !== 0
}
Object.defineProperty(constantTime, "__esModule", {
    value: !0
}),
constantTime.select = select,
constantTime.lessOrEqual = lessOrEqual,
constantTime.compare = compare,
constantTime.equal = equal,
function(W) {
    Object.defineProperty(W, "__esModule", {
        value: !0
    });
    var z = constantTime
      , Y = wipe$1;
    W.DIGEST_LENGTH = 16;
    var ne = function() {
        function le(ue) {
            this.digestLength = W.DIGEST_LENGTH,
            this._buffer = new Uint8Array(16),
            this._r = new Uint16Array(10),
            this._h = new Uint16Array(10),
            this._pad = new Uint16Array(8),
            this._leftover = 0,
            this._fin = 0,
            this._finished = !1;
            var de = ue[0] | ue[1] << 8;
            this._r[0] = 8191 & de;
            var he = ue[2] | ue[3] << 8;
            this._r[1] = 8191 & (de >>> 13 | he << 3);
            var fe = ue[4] | ue[5] << 8;
            this._r[2] = 7939 & (he >>> 10 | fe << 6);
            var ge = ue[6] | ue[7] << 8;
            this._r[3] = 8191 & (fe >>> 7 | ge << 9);
            var xe = ue[8] | ue[9] << 8;
            this._r[4] = 255 & (ge >>> 4 | xe << 12),
            this._r[5] = xe >>> 1 & 8190;
            var $e = ue[10] | ue[11] << 8;
            this._r[6] = 8191 & (xe >>> 14 | $e << 2);
            var Ee = ue[12] | ue[13] << 8;
            this._r[7] = 8065 & ($e >>> 11 | Ee << 5);
            var Se = ue[14] | ue[15] << 8;
            this._r[8] = 8191 & (Ee >>> 8 | Se << 8),
            this._r[9] = Se >>> 5 & 127,
            this._pad[0] = ue[16] | ue[17] << 8,
            this._pad[1] = ue[18] | ue[19] << 8,
            this._pad[2] = ue[20] | ue[21] << 8,
            this._pad[3] = ue[22] | ue[23] << 8,
            this._pad[4] = ue[24] | ue[25] << 8,
            this._pad[5] = ue[26] | ue[27] << 8,
            this._pad[6] = ue[28] | ue[29] << 8,
            this._pad[7] = ue[30] | ue[31] << 8
        }
        return le.prototype._blocks = function(ue, de, he) {
            for (var fe = this._fin ? 0 : 2048, ge = this._h[0], xe = this._h[1], $e = this._h[2], Ee = this._h[3], Se = this._h[4], Ne = this._h[5], tt = this._h[6], rr = this._h[7], tr = this._h[8], we = this._h[9], Ut = this._r[0], lr = this._r[1], cr = this._r[2], be = this._r[3], mr = this._r[4], fr = this._r[5], Rr = this._r[6], Pr = this._r[7], Fr = this._r[8], br = this._r[9]; he >= 16; ) {
                var xr = ue[de + 0] | ue[de + 1] << 8;
                ge += 8191 & xr;
                var _r = ue[de + 2] | ue[de + 3] << 8;
                xe += 8191 & (xr >>> 13 | _r << 3);
                var Ir = ue[de + 4] | ue[de + 5] << 8;
                $e += 8191 & (_r >>> 10 | Ir << 6);
                var Nr = ue[de + 6] | ue[de + 7] << 8;
                Ee += 8191 & (Ir >>> 7 | Nr << 9);
                var gn = ue[de + 8] | ue[de + 9] << 8;
                Se += 8191 & (Nr >>> 4 | gn << 12),
                Ne += gn >>> 1 & 8191;
                var Zr = ue[de + 10] | ue[de + 11] << 8;
                tt += 8191 & (gn >>> 14 | Zr << 2);
                var Tn = ue[de + 12] | ue[de + 13] << 8;
                rr += 8191 & (Zr >>> 11 | Tn << 5);
                var Zn = ue[de + 14] | ue[de + 15] << 8
                  , Cn = 0
                  , Gn = Cn;
                Gn += ge * Ut,
                Gn += xe * (5 * br),
                Gn += $e * (5 * Fr),
                Gn += Ee * (5 * Pr),
                Cn = (Gn += Se * (5 * Rr)) >>> 13,
                Gn &= 8191,
                Gn += Ne * (5 * fr),
                Gn += tt * (5 * mr),
                Gn += rr * (5 * be),
                Gn += (tr += 8191 & (Tn >>> 8 | Zn << 8)) * (5 * cr);
                var ni = Cn += (Gn += (we += Zn >>> 5 | fe) * (5 * lr)) >>> 13;
                ni += ge * lr,
                ni += xe * Ut,
                ni += $e * (5 * br),
                ni += Ee * (5 * Fr),
                Cn = (ni += Se * (5 * Pr)) >>> 13,
                ni &= 8191,
                ni += Ne * (5 * Rr),
                ni += tt * (5 * fr),
                ni += rr * (5 * mr),
                ni += tr * (5 * be),
                Cn += (ni += we * (5 * cr)) >>> 13,
                ni &= 8191;
                var xi = Cn;
                xi += ge * cr,
                xi += xe * lr,
                xi += $e * Ut,
                xi += Ee * (5 * br),
                Cn = (xi += Se * (5 * Fr)) >>> 13,
                xi &= 8191,
                xi += Ne * (5 * Pr),
                xi += tt * (5 * Rr),
                xi += rr * (5 * fr),
                xi += tr * (5 * mr);
                var oi = Cn += (xi += we * (5 * be)) >>> 13;
                oi += ge * be,
                oi += xe * cr,
                oi += $e * lr,
                oi += Ee * Ut,
                Cn = (oi += Se * (5 * br)) >>> 13,
                oi &= 8191,
                oi += Ne * (5 * Fr),
                oi += tt * (5 * Pr),
                oi += rr * (5 * Rr),
                oi += tr * (5 * fr);
                var $i = Cn += (oi += we * (5 * mr)) >>> 13;
                $i += ge * mr,
                $i += xe * be,
                $i += $e * cr,
                $i += Ee * lr,
                Cn = ($i += Se * Ut) >>> 13,
                $i &= 8191,
                $i += Ne * (5 * br),
                $i += tt * (5 * Fr),
                $i += rr * (5 * Pr),
                $i += tr * (5 * Rr);
                var Ci = Cn += ($i += we * (5 * fr)) >>> 13;
                Ci += ge * fr,
                Ci += xe * mr,
                Ci += $e * be,
                Ci += Ee * cr,
                Cn = (Ci += Se * lr) >>> 13,
                Ci &= 8191,
                Ci += Ne * Ut,
                Ci += tt * (5 * br),
                Ci += rr * (5 * Fr),
                Ci += tr * (5 * Pr);
                var Yn = Cn += (Ci += we * (5 * Rr)) >>> 13;
                Yn += ge * Rr,
                Yn += xe * fr,
                Yn += $e * mr,
                Yn += Ee * be,
                Cn = (Yn += Se * cr) >>> 13,
                Yn &= 8191,
                Yn += Ne * lr,
                Yn += tt * Ut,
                Yn += rr * (5 * br),
                Yn += tr * (5 * Fr);
                var pi = Cn += (Yn += we * (5 * Pr)) >>> 13;
                pi += ge * Pr,
                pi += xe * Rr,
                pi += $e * fr,
                pi += Ee * mr,
                Cn = (pi += Se * be) >>> 13,
                pi &= 8191,
                pi += Ne * cr,
                pi += tt * lr,
                pi += rr * Ut,
                pi += tr * (5 * br);
                var yi = Cn += (pi += we * (5 * Fr)) >>> 13;
                yi += ge * Fr,
                yi += xe * Pr,
                yi += $e * Rr,
                yi += Ee * fr,
                Cn = (yi += Se * mr) >>> 13,
                yi &= 8191,
                yi += Ne * be,
                yi += tt * cr,
                yi += rr * lr,
                yi += tr * Ut;
                var dr = Cn += (yi += we * (5 * br)) >>> 13;
                dr += ge * br,
                dr += xe * Fr,
                dr += $e * Pr,
                dr += Ee * Rr,
                Cn = (dr += Se * fr) >>> 13,
                dr &= 8191,
                dr += Ne * mr,
                dr += tt * be,
                dr += rr * cr,
                dr += tr * lr,
                ge = Gn = 8191 & (Cn = (Cn = ((Cn += (dr += we * Ut) >>> 13) << 2) + Cn | 0) + (Gn &= 8191) | 0),
                xe = ni += Cn >>>= 13,
                $e = xi &= 8191,
                Ee = oi &= 8191,
                Se = $i &= 8191,
                Ne = Ci &= 8191,
                tt = Yn &= 8191,
                rr = pi &= 8191,
                tr = yi &= 8191,
                we = dr &= 8191,
                de += 16,
                he -= 16
            }
            this._h[0] = ge,
            this._h[1] = xe,
            this._h[2] = $e,
            this._h[3] = Ee,
            this._h[4] = Se,
            this._h[5] = Ne,
            this._h[6] = tt,
            this._h[7] = rr,
            this._h[8] = tr,
            this._h[9] = we
        }
        ,
        le.prototype.finish = function(ue, de) {
            de === void 0 && (de = 0);
            var he, fe, ge, xe, $e = new Uint16Array(10);
            if (this._leftover) {
                for (xe = this._leftover,
                this._buffer[xe++] = 1; xe < 16; xe++)
                    this._buffer[xe] = 0;
                this._fin = 1,
                this._blocks(this._buffer, 0, 16)
            }
            for (he = this._h[1] >>> 13,
            this._h[1] &= 8191,
            xe = 2; xe < 10; xe++)
                this._h[xe] += he,
                he = this._h[xe] >>> 13,
                this._h[xe] &= 8191;
            for (this._h[0] += 5 * he,
            he = this._h[0] >>> 13,
            this._h[0] &= 8191,
            this._h[1] += he,
            he = this._h[1] >>> 13,
            this._h[1] &= 8191,
            this._h[2] += he,
            $e[0] = this._h[0] + 5,
            he = $e[0] >>> 13,
            $e[0] &= 8191,
            xe = 1; xe < 10; xe++)
                $e[xe] = this._h[xe] + he,
                he = $e[xe] >>> 13,
                $e[xe] &= 8191;
            for ($e[9] -= 8192,
            fe = (1 ^ he) - 1,
            xe = 0; xe < 10; xe++)
                $e[xe] &= fe;
            for (fe = ~fe,
            xe = 0; xe < 10; xe++)
                this._h[xe] = this._h[xe] & fe | $e[xe];
            for (this._h[0] = 65535 & (this._h[0] | this._h[1] << 13),
            this._h[1] = 65535 & (this._h[1] >>> 3 | this._h[2] << 10),
            this._h[2] = 65535 & (this._h[2] >>> 6 | this._h[3] << 7),
            this._h[3] = 65535 & (this._h[3] >>> 9 | this._h[4] << 4),
            this._h[4] = 65535 & (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14),
            this._h[5] = 65535 & (this._h[6] >>> 2 | this._h[7] << 11),
            this._h[6] = 65535 & (this._h[7] >>> 5 | this._h[8] << 8),
            this._h[7] = 65535 & (this._h[8] >>> 8 | this._h[9] << 5),
            ge = this._h[0] + this._pad[0],
            this._h[0] = 65535 & ge,
            xe = 1; xe < 8; xe++)
                ge = (this._h[xe] + this._pad[xe] | 0) + (ge >>> 16) | 0,
                this._h[xe] = 65535 & ge;
            return ue[de + 0] = this._h[0] >>> 0,
            ue[de + 1] = this._h[0] >>> 8,
            ue[de + 2] = this._h[1] >>> 0,
            ue[de + 3] = this._h[1] >>> 8,
            ue[de + 4] = this._h[2] >>> 0,
            ue[de + 5] = this._h[2] >>> 8,
            ue[de + 6] = this._h[3] >>> 0,
            ue[de + 7] = this._h[3] >>> 8,
            ue[de + 8] = this._h[4] >>> 0,
            ue[de + 9] = this._h[4] >>> 8,
            ue[de + 10] = this._h[5] >>> 0,
            ue[de + 11] = this._h[5] >>> 8,
            ue[de + 12] = this._h[6] >>> 0,
            ue[de + 13] = this._h[6] >>> 8,
            ue[de + 14] = this._h[7] >>> 0,
            ue[de + 15] = this._h[7] >>> 8,
            this._finished = !0,
            this
        }
        ,
        le.prototype.update = function(ue) {
            var de, he = 0, fe = ue.length;
            if (this._leftover) {
                (de = 16 - this._leftover) > fe && (de = fe);
                for (var ge = 0; ge < de; ge++)
                    this._buffer[this._leftover + ge] = ue[he + ge];
                if (fe -= de,
                he += de,
                this._leftover += de,
                this._leftover < 16)
                    return this;
                this._blocks(this._buffer, 0, 16),
                this._leftover = 0
            }
            if (fe >= 16 && (de = fe - fe % 16,
            this._blocks(ue, he, de),
            he += de,
            fe -= de),
            fe) {
                for (ge = 0; ge < fe; ge++)
                    this._buffer[this._leftover + ge] = ue[he + ge];
                this._leftover += fe
            }
            return this
        }
        ,
        le.prototype.digest = function() {
            if (this._finished)
                throw new Error("Poly1305 was finished");
            var ue = new Uint8Array(16);
            return this.finish(ue),
            ue
        }
        ,
        le.prototype.clean = function() {
            return Y.wipe(this._buffer),
            Y.wipe(this._r),
            Y.wipe(this._h),
            Y.wipe(this._pad),
            this._leftover = 0,
            this._fin = 0,
            this._finished = !0,
            this
        }
        ,
        le
    }();
    W.Poly1305 = ne,
    W.oneTimeAuth = function(le, ue) {
        var de = new ne(le);
        de.update(ue);
        var he = de.digest();
        return de.clean(),
        he
    }
    ,
    W.equal = function(le, ue) {
        return le.length === W.DIGEST_LENGTH && ue.length === W.DIGEST_LENGTH && z.equal(le, ue)
    }
}(poly1305),
function(W) {
    Object.defineProperty(W, "__esModule", {
        value: !0
    });
    var z = chacha
      , Y = poly1305
      , ne = wipe$1
      , le = binary
      , ue = constantTime;
    W.KEY_LENGTH = 32,
    W.NONCE_LENGTH = 12,
    W.TAG_LENGTH = 16;
    var de = new Uint8Array(16)
      , he = function() {
        function fe(ge) {
            if (this.nonceLength = W.NONCE_LENGTH,
            this.tagLength = W.TAG_LENGTH,
            ge.length !== W.KEY_LENGTH)
                throw new Error("ChaCha20Poly1305 needs 32-byte key");
            this._key = new Uint8Array(ge)
        }
        return fe.prototype.seal = function(ge, xe, $e, Ee) {
            if (ge.length > 16)
                throw new Error("ChaCha20Poly1305: incorrect nonce length");
            var Se = new Uint8Array(16);
            Se.set(ge, Se.length - ge.length);
            var Ne = new Uint8Array(32);
            z.stream(this._key, Se, Ne, 4);
            var tt, rr = xe.length + this.tagLength;
            if (Ee) {
                if (Ee.length !== rr)
                    throw new Error("ChaCha20Poly1305: incorrect destination length");
                tt = Ee
            } else
                tt = new Uint8Array(rr);
            return z.streamXOR(this._key, Se, xe, tt, 4),
            this._authenticate(tt.subarray(tt.length - this.tagLength, tt.length), Ne, tt.subarray(0, tt.length - this.tagLength), $e),
            ne.wipe(Se),
            tt
        }
        ,
        fe.prototype.open = function(ge, xe, $e, Ee) {
            if (ge.length > 16)
                throw new Error("ChaCha20Poly1305: incorrect nonce length");
            if (xe.length < this.tagLength)
                return null;
            var Se = new Uint8Array(16);
            Se.set(ge, Se.length - ge.length);
            var Ne = new Uint8Array(32);
            z.stream(this._key, Se, Ne, 4);
            var tt = new Uint8Array(this.tagLength);
            if (this._authenticate(tt, Ne, xe.subarray(0, xe.length - this.tagLength), $e),
            !ue.equal(tt, xe.subarray(xe.length - this.tagLength, xe.length)))
                return null;
            var rr, tr = xe.length - this.tagLength;
            if (Ee) {
                if (Ee.length !== tr)
                    throw new Error("ChaCha20Poly1305: incorrect destination length");
                rr = Ee
            } else
                rr = new Uint8Array(tr);
            return z.streamXOR(this._key, Se, xe.subarray(0, xe.length - this.tagLength), rr, 4),
            ne.wipe(Se),
            rr
        }
        ,
        fe.prototype.clean = function() {
            return ne.wipe(this._key),
            this
        }
        ,
        fe.prototype._authenticate = function(ge, xe, $e, Ee) {
            var Se = new Y.Poly1305(xe);
            Ee && (Se.update(Ee),
            Ee.length % 16 > 0 && Se.update(de.subarray(Ee.length % 16))),
            Se.update($e),
            $e.length % 16 > 0 && Se.update(de.subarray($e.length % 16));
            var Ne = new Uint8Array(8);
            Ee && le.writeUint64LE(Ee.length, Ne),
            Se.update(Ne),
            le.writeUint64LE($e.length, Ne),
            Se.update(Ne);
            for (var tt = Se.digest(), rr = 0; rr < tt.length; rr++)
                ge[rr] = tt[rr];
            Se.clean(),
            ne.wipe(tt),
            ne.wipe(Ne)
        }
        ,
        fe
    }();
    W.ChaCha20Poly1305 = he
}(chacha20poly1305);
var hkdf = {}
  , hmac$1 = {}
  , hash = {};
function isSerializableHash(W) {
    return W.saveState !== void 0 && W.restoreState !== void 0 && W.cleanSavedState !== void 0
}
Object.defineProperty(hash, "__esModule", {
    value: !0
}),
hash.isSerializableHash = isSerializableHash,
Object.defineProperty(hmac$1, "__esModule", {
    value: !0
});
var hash_1 = hash
  , constant_time_1 = constantTime
  , wipe_1$2 = wipe$1
  , HMAC = function() {
    function W(z, Y) {
        this._finished = !1,
        this._inner = new z,
        this._outer = new z,
        this.blockSize = this._outer.blockSize,
        this.digestLength = this._outer.digestLength;
        var ne = new Uint8Array(this.blockSize);
        Y.length > this.blockSize ? this._inner.update(Y).finish(ne).clean() : ne.set(Y);
        for (var le = 0; le < ne.length; le++)
            ne[le] ^= 54;
        for (this._inner.update(ne),
        le = 0; le < ne.length; le++)
            ne[le] ^= 106;
        this._outer.update(ne),
        hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(),
        this._outerKeyedState = this._outer.saveState()),
        wipe_1$2.wipe(ne)
    }
    return W.prototype.reset = function() {
        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer))
            throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
        return this._inner.restoreState(this._innerKeyedState),
        this._outer.restoreState(this._outerKeyedState),
        this._finished = !1,
        this
    }
    ,
    W.prototype.clean = function() {
        hash_1.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState),
        hash_1.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState),
        this._inner.clean(),
        this._outer.clean()
    }
    ,
    W.prototype.update = function(z) {
        return this._inner.update(z),
        this
    }
    ,
    W.prototype.finish = function(z) {
        return this._finished ? (this._outer.finish(z),
        this) : (this._inner.finish(z),
        this._outer.update(z.subarray(0, this.digestLength)).finish(z),
        this._finished = !0,
        this)
    }
    ,
    W.prototype.digest = function() {
        var z = new Uint8Array(this.digestLength);
        return this.finish(z),
        z
    }
    ,
    W.prototype.saveState = function() {
        if (!hash_1.isSerializableHash(this._inner))
            throw new Error("hmac: can't saveState() because hash doesn't implement it");
        return this._inner.saveState()
    }
    ,
    W.prototype.restoreState = function(z) {
        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer))
            throw new Error("hmac: can't restoreState() because hash doesn't implement it");
        return this._inner.restoreState(z),
        this._outer.restoreState(this._outerKeyedState),
        this._finished = !1,
        this
    }
    ,
    W.prototype.cleanSavedState = function(z) {
        if (!hash_1.isSerializableHash(this._inner))
            throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
        this._inner.cleanSavedState(z)
    }
    ,
    W
}();
function hmac(W, z, Y) {
    var ne = new HMAC(W,z);
    ne.update(Y);
    var le = ne.digest();
    return ne.clean(),
    le
}
hmac$1.HMAC = HMAC,
hmac$1.hmac = hmac,
hmac$1.equal = constant_time_1.equal,
Object.defineProperty(hkdf, "__esModule", {
    value: !0
});
var hmac_1 = hmac$1
  , wipe_1$1 = wipe$1
  , HKDF = function() {
    function W(z, Y, ne, le) {
        ne === void 0 && (ne = new Uint8Array(0)),
        this._counter = new Uint8Array(1),
        this._hash = z,
        this._info = le;
        var ue = hmac_1.hmac(this._hash, ne, Y);
        this._hmac = new hmac_1.HMAC(z,ue),
        this._buffer = new Uint8Array(this._hmac.digestLength),
        this._bufpos = this._buffer.length
    }
    return W.prototype._fillBuffer = function() {
        this._counter[0]++;
        var z = this._counter[0];
        if (z === 0)
            throw new Error("hkdf: cannot expand more");
        this._hmac.reset(),
        z > 1 && this._hmac.update(this._buffer),
        this._info && this._hmac.update(this._info),
        this._hmac.update(this._counter),
        this._hmac.finish(this._buffer),
        this._bufpos = 0
    }
    ,
    W.prototype.expand = function(z) {
        for (var Y = new Uint8Array(z), ne = 0; ne < Y.length; ne++)
            this._bufpos === this._buffer.length && this._fillBuffer(),
            Y[ne] = this._buffer[this._bufpos++];
        return Y
    }
    ,
    W.prototype.clean = function() {
        this._hmac.clean(),
        wipe_1$1.wipe(this._buffer),
        wipe_1$1.wipe(this._counter),
        this._bufpos = 0
    }
    ,
    W
}()
  , HKDF_1 = hkdf.HKDF = HKDF
  , random = {}
  , system = {}
  , browser = {};
Object.defineProperty(browser, "__esModule", {
    value: !0
}),
browser.BrowserRandomSource = void 0;
const QUOTA = 65536;
class BrowserRandomSource {
    constructor() {
        this.isAvailable = !1,
        this.isInstantiated = !1;
        const z = typeof self < "u" ? self.crypto || self.msCrypto : null;
        z && z.getRandomValues !== void 0 && (this._crypto = z,
        this.isAvailable = !0,
        this.isInstantiated = !0)
    }
    randomBytes(z) {
        if (!this.isAvailable || !this._crypto)
            throw new Error("Browser random byte generator is not available.");
        const Y = new Uint8Array(z);
        for (let ne = 0; ne < Y.length; ne += QUOTA)
            this._crypto.getRandomValues(Y.subarray(ne, ne + Math.min(Y.length - ne, QUOTA)));
        return Y
    }
}
browser.BrowserRandomSource = BrowserRandomSource;
var node = {};
const __viteBrowserExternal = {}
  , __viteBrowserExternal$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$3 = getAugmentedNamespace(__viteBrowserExternal$1);
Object.defineProperty(node, "__esModule", {
    value: !0
}),
node.NodeRandomSource = void 0;
const wipe_1 = wipe$1;
class NodeRandomSource {
    constructor() {
        if (this.isAvailable = !1,
        this.isInstantiated = !1,
        commonjsRequire !== void 0) {
            const z = require$$3;
            z && z.randomBytes && (this._crypto = z,
            this.isAvailable = !0,
            this.isInstantiated = !0)
        }
    }
    randomBytes(z) {
        if (!this.isAvailable || !this._crypto)
            throw new Error("Node.js random byte generator is not available.");
        let Y = this._crypto.randomBytes(z);
        if (Y.length !== z)
            throw new Error("NodeRandomSource: got fewer bytes than requested");
        const ne = new Uint8Array(z);
        for (let le = 0; le < ne.length; le++)
            ne[le] = Y[le];
        return (0,
        wipe_1.wipe)(Y),
        ne
    }
}
node.NodeRandomSource = NodeRandomSource,
Object.defineProperty(system, "__esModule", {
    value: !0
}),
system.SystemRandomSource = void 0;
const browser_1 = browser
  , node_1 = node;
class SystemRandomSource {
    constructor() {
        return this.isAvailable = !1,
        this.name = "",
        this._source = new browser_1.BrowserRandomSource,
        this._source.isAvailable ? (this.isAvailable = !0,
        void (this.name = "Browser")) : (this._source = new node_1.NodeRandomSource,
        this._source.isAvailable ? (this.isAvailable = !0,
        void (this.name = "Node")) : void 0)
    }
    randomBytes(z) {
        if (!this.isAvailable)
            throw new Error("System random byte generator is not available.");
        return this._source.randomBytes(z)
    }
}
system.SystemRandomSource = SystemRandomSource,
function(W) {
    Object.defineProperty(W, "__esModule", {
        value: !0
    }),
    W.randomStringForEntropy = W.randomString = W.randomUint32 = W.randomBytes = W.defaultRandomSource = void 0;
    const z = system
      , Y = binary
      , ne = wipe$1;
    function le(he, fe=W.defaultRandomSource) {
        return fe.randomBytes(he)
    }
    W.defaultRandomSource = new z.SystemRandomSource,
    W.randomBytes = le,
    W.randomUint32 = function(he=W.defaultRandomSource) {
        const fe = le(4, he)
          , ge = (0,
        Y.readUint32LE)(fe);
        return (0,
        ne.wipe)(fe),
        ge
    }
    ;
    const ue = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    function de(he, fe=ue, ge=W.defaultRandomSource) {
        if (fe.length < 2)
            throw new Error("randomString charset is too short");
        if (fe.length > 256)
            throw new Error("randomString charset is too long");
        let xe = "";
        const $e = fe.length
          , Ee = 256 - 256 % $e;
        for (; he > 0; ) {
            const Se = le(Math.ceil(256 * he / Ee), ge);
            for (let Ne = 0; Ne < Se.length && he > 0; Ne++) {
                const tt = Se[Ne];
                tt < Ee && (xe += fe.charAt(tt % $e),
                he--)
            }
            (0,
            ne.wipe)(Se)
        }
        return xe
    }
    W.randomString = de,
    W.randomStringForEntropy = function(he, fe=ue, ge=W.defaultRandomSource) {
        return de(Math.ceil(he / (Math.log(fe.length) / Math.LN2)), fe, ge)
    }
}(random);
var sha256 = {};
(function(W) {
    Object.defineProperty(W, "__esModule", {
        value: !0
    });
    var z = binary
      , Y = wipe$1;
    W.DIGEST_LENGTH = 32,
    W.BLOCK_SIZE = 64;
    var ne = function() {
        function de() {
            this.digestLength = W.DIGEST_LENGTH,
            this.blockSize = W.BLOCK_SIZE,
            this._state = new Int32Array(8),
            this._temp = new Int32Array(64),
            this._buffer = new Uint8Array(128),
            this._bufferLength = 0,
            this._bytesHashed = 0,
            this._finished = !1,
            this.reset()
        }
        return de.prototype._initState = function() {
            this._state[0] = 1779033703,
            this._state[1] = 3144134277,
            this._state[2] = 1013904242,
            this._state[3] = 2773480762,
            this._state[4] = 1359893119,
            this._state[5] = 2600822924,
            this._state[6] = 528734635,
            this._state[7] = 1541459225
        }
        ,
        de.prototype.reset = function() {
            return this._initState(),
            this._bufferLength = 0,
            this._bytesHashed = 0,
            this._finished = !1,
            this
        }
        ,
        de.prototype.clean = function() {
            Y.wipe(this._buffer),
            Y.wipe(this._temp),
            this.reset()
        }
        ,
        de.prototype.update = function(he, fe) {
            if (fe === void 0 && (fe = he.length),
            this._finished)
                throw new Error("SHA256: can't update because hash was finished.");
            var ge = 0;
            if (this._bytesHashed += fe,
            this._bufferLength > 0) {
                for (; this._bufferLength < this.blockSize && fe > 0; )
                    this._buffer[this._bufferLength++] = he[ge++],
                    fe--;
                this._bufferLength === this.blockSize && (ue(this._temp, this._state, this._buffer, 0, this.blockSize),
                this._bufferLength = 0)
            }
            for (fe >= this.blockSize && (ge = ue(this._temp, this._state, he, ge, fe),
            fe %= this.blockSize); fe > 0; )
                this._buffer[this._bufferLength++] = he[ge++],
                fe--;
            return this
        }
        ,
        de.prototype.finish = function(he) {
            if (!this._finished) {
                var fe = this._bytesHashed
                  , ge = this._bufferLength
                  , xe = fe / 536870912 | 0
                  , $e = fe << 3
                  , Ee = fe % 64 < 56 ? 64 : 128;
                this._buffer[ge] = 128;
                for (var Se = ge + 1; Se < Ee - 8; Se++)
                    this._buffer[Se] = 0;
                z.writeUint32BE(xe, this._buffer, Ee - 8),
                z.writeUint32BE($e, this._buffer, Ee - 4),
                ue(this._temp, this._state, this._buffer, 0, Ee),
                this._finished = !0
            }
            for (Se = 0; Se < this.digestLength / 4; Se++)
                z.writeUint32BE(this._state[Se], he, 4 * Se);
            return this
        }
        ,
        de.prototype.digest = function() {
            var he = new Uint8Array(this.digestLength);
            return this.finish(he),
            he
        }
        ,
        de.prototype.saveState = function() {
            if (this._finished)
                throw new Error("SHA256: cannot save finished state");
            return {
                state: new Int32Array(this._state),
                buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
                bufferLength: this._bufferLength,
                bytesHashed: this._bytesHashed
            }
        }
        ,
        de.prototype.restoreState = function(he) {
            return this._state.set(he.state),
            this._bufferLength = he.bufferLength,
            he.buffer && this._buffer.set(he.buffer),
            this._bytesHashed = he.bytesHashed,
            this._finished = !1,
            this
        }
        ,
        de.prototype.cleanSavedState = function(he) {
            Y.wipe(he.state),
            he.buffer && Y.wipe(he.buffer),
            he.bufferLength = 0,
            he.bytesHashed = 0
        }
        ,
        de
    }();
    W.SHA256 = ne;
    var le = new Int32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
    function ue(de, he, fe, ge, xe) {
        for (; xe >= 64; ) {
            for (var $e = he[0], Ee = he[1], Se = he[2], Ne = he[3], tt = he[4], rr = he[5], tr = he[6], we = he[7], Ut = 0; Ut < 16; Ut++) {
                var lr = ge + 4 * Ut;
                de[Ut] = z.readUint32BE(fe, lr)
            }
            for (Ut = 16; Ut < 64; Ut++) {
                var cr = de[Ut - 2]
                  , be = (cr >>> 17 | cr << 15) ^ (cr >>> 19 | cr << 13) ^ cr >>> 10
                  , mr = ((cr = de[Ut - 15]) >>> 7 | cr << 25) ^ (cr >>> 18 | cr << 14) ^ cr >>> 3;
                de[Ut] = (be + de[Ut - 7] | 0) + (mr + de[Ut - 16] | 0)
            }
            for (Ut = 0; Ut < 64; Ut++)
                be = (((tt >>> 6 | tt << 26) ^ (tt >>> 11 | tt << 21) ^ (tt >>> 25 | tt << 7)) + (tt & rr ^ ~tt & tr) | 0) + (we + (le[Ut] + de[Ut] | 0) | 0) | 0,
                mr = (($e >>> 2 | $e << 30) ^ ($e >>> 13 | $e << 19) ^ ($e >>> 22 | $e << 10)) + ($e & Ee ^ $e & Se ^ Ee & Se) | 0,
                we = tr,
                tr = rr,
                rr = tt,
                tt = Ne + be | 0,
                Ne = Se,
                Se = Ee,
                Ee = $e,
                $e = be + mr | 0;
            he[0] += $e,
            he[1] += Ee,
            he[2] += Se,
            he[3] += Ne,
            he[4] += tt,
            he[5] += rr,
            he[6] += tr,
            he[7] += we,
            ge += 64,
            xe -= 64
        }
        return ge
    }
    W.hash = function(de) {
        var he = new ne;
        he.update(de);
        var fe = he.digest();
        return he.clean(),
        fe
    }
}
)(sha256);
var x25519 = {};
function asUint8Array(W) {
    return globalThis.Buffer != null ? new Uint8Array(W.buffer,W.byteOffset,W.byteLength) : W
}
function allocUnsafe(W=0) {
    return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? asUint8Array(globalThis.Buffer.allocUnsafe(W)) : new Uint8Array(W)
}
function concat(W, z) {
    z || (z = W.reduce((le,ue)=>le + ue.length, 0));
    const Y = allocUnsafe(z);
    let ne = 0;
    for (const le of W)
        Y.set(le, ne),
        ne += le.length;
    return asUint8Array(Y)
}
function base(W, z) {
    if (W.length >= 255)
        throw new TypeError("Alphabet too long");
    for (var Y = new Uint8Array(256), ne = 0; ne < Y.length; ne++)
        Y[ne] = 255;
    for (var le = 0; le < W.length; le++) {
        var ue = W.charAt(le)
          , de = ue.charCodeAt(0);
        if (Y[de] !== 255)
            throw new TypeError(ue + " is ambiguous");
        Y[de] = le
    }
    var he = W.length
      , fe = W.charAt(0)
      , ge = Math.log(he) / Math.log(256)
      , xe = Math.log(256) / Math.log(he);
    function $e(Ee) {
        if (typeof Ee != "string")
            throw new TypeError("Expected String");
        if (Ee.length === 0)
            return new Uint8Array;
        var Se = 0;
        if (Ee[Se] !== " ") {
            for (var Ne = 0, tt = 0; Ee[Se] === fe; )
                Ne++,
                Se++;
            for (var rr = (Ee.length - Se) * ge + 1 >>> 0, tr = new Uint8Array(rr); Ee[Se]; ) {
                var we = Y[Ee.charCodeAt(Se)];
                if (we === 255)
                    return;
                for (var Ut = 0, lr = rr - 1; (we !== 0 || Ut < tt) && lr !== -1; lr--,
                Ut++)
                    we += he * tr[lr] >>> 0,
                    tr[lr] = we % 256 >>> 0,
                    we = we / 256 >>> 0;
                if (we !== 0)
                    throw new Error("Non-zero carry");
                tt = Ut,
                Se++
            }
            if (Ee[Se] !== " ") {
                for (var cr = rr - tt; cr !== rr && tr[cr] === 0; )
                    cr++;
                for (var be = new Uint8Array(Ne + (rr - cr)), mr = Ne; cr !== rr; )
                    be[mr++] = tr[cr++];
                return be
            }
        }
    }
    return {
        encode: function(Ee) {
            if (Ee instanceof Uint8Array || (ArrayBuffer.isView(Ee) ? Ee = new Uint8Array(Ee.buffer,Ee.byteOffset,Ee.byteLength) : Array.isArray(Ee) && (Ee = Uint8Array.from(Ee))),
            !(Ee instanceof Uint8Array))
                throw new TypeError("Expected Uint8Array");
            if (Ee.length === 0)
                return "";
            for (var Se = 0, Ne = 0, tt = 0, rr = Ee.length; tt !== rr && Ee[tt] === 0; )
                tt++,
                Se++;
            for (var tr = (rr - tt) * xe + 1 >>> 0, we = new Uint8Array(tr); tt !== rr; ) {
                for (var Ut = Ee[tt], lr = 0, cr = tr - 1; (Ut !== 0 || lr < Ne) && cr !== -1; cr--,
                lr++)
                    Ut += 256 * we[cr] >>> 0,
                    we[cr] = Ut % he >>> 0,
                    Ut = Ut / he >>> 0;
                if (Ut !== 0)
                    throw new Error("Non-zero carry");
                Ne = lr,
                tt++
            }
            for (var be = tr - Ne; be !== tr && we[be] === 0; )
                be++;
            for (var mr = fe.repeat(Se); be < tr; ++be)
                mr += W.charAt(we[be]);
            return mr
        },
        decodeUnsafe: $e,
        decode: function(Ee) {
            var Se = $e(Ee);
            if (Se)
                return Se;
            throw new Error(`Non-${z} character`)
        }
    }
}
(function(W) {
    Object.defineProperty(W, "__esModule", {
        value: !0
    }),
    W.sharedKey = W.generateKeyPair = W.generateKeyPairFromSeed = W.scalarMultBase = W.scalarMult = W.SHARED_KEY_LENGTH = W.SECRET_KEY_LENGTH = W.PUBLIC_KEY_LENGTH = void 0;
    const z = random
      , Y = wipe$1;
    function ne(tt) {
        const rr = new Float64Array(16);
        if (tt)
            for (let tr = 0; tr < tt.length; tr++)
                rr[tr] = tt[tr];
        return rr
    }
    W.PUBLIC_KEY_LENGTH = 32,
    W.SECRET_KEY_LENGTH = 32,
    W.SHARED_KEY_LENGTH = 32;
    const le = new Uint8Array(32);
    le[0] = 9;
    const ue = ne([56129, 1]);
    function de(tt) {
        let rr = 1;
        for (let tr = 0; tr < 16; tr++) {
            let we = tt[tr] + rr + 65535;
            rr = Math.floor(we / 65536),
            tt[tr] = we - 65536 * rr
        }
        tt[0] += rr - 1 + 37 * (rr - 1)
    }
    function he(tt, rr, tr) {
        const we = ~(tr - 1);
        for (let Ut = 0; Ut < 16; Ut++) {
            const lr = we & (tt[Ut] ^ rr[Ut]);
            tt[Ut] ^= lr,
            rr[Ut] ^= lr
        }
    }
    function fe(tt, rr, tr) {
        for (let we = 0; we < 16; we++)
            tt[we] = rr[we] + tr[we]
    }
    function ge(tt, rr, tr) {
        for (let we = 0; we < 16; we++)
            tt[we] = rr[we] - tr[we]
    }
    function xe(tt, rr, tr) {
        let we, Ut, lr = 0, cr = 0, be = 0, mr = 0, fr = 0, Rr = 0, Pr = 0, Fr = 0, br = 0, xr = 0, _r = 0, Ir = 0, Nr = 0, gn = 0, Zr = 0, Tn = 0, Zn = 0, Cn = 0, Gn = 0, ni = 0, xi = 0, oi = 0, $i = 0, Ci = 0, Yn = 0, pi = 0, yi = 0, dr = 0, Sr = 0, Gr = 0, Qr = 0, vn = tr[0], Oe = tr[1], ot = tr[2], ir = tr[3], vr = tr[4], Er = tr[5], Ar = tr[6], kr = tr[7], _n = tr[8], Qn = tr[9], gi = tr[10], ei = tr[11], si = tr[12], Ki = tr[13], Ni = tr[14], Hi = tr[15];
        we = rr[0],
        lr += we * vn,
        cr += we * Oe,
        be += we * ot,
        mr += we * ir,
        fr += we * vr,
        Rr += we * Er,
        Pr += we * Ar,
        Fr += we * kr,
        br += we * _n,
        xr += we * Qn,
        _r += we * gi,
        Ir += we * ei,
        Nr += we * si,
        gn += we * Ki,
        Zr += we * Ni,
        Tn += we * Hi,
        we = rr[1],
        cr += we * vn,
        be += we * Oe,
        mr += we * ot,
        fr += we * ir,
        Rr += we * vr,
        Pr += we * Er,
        Fr += we * Ar,
        br += we * kr,
        xr += we * _n,
        _r += we * Qn,
        Ir += we * gi,
        Nr += we * ei,
        gn += we * si,
        Zr += we * Ki,
        Tn += we * Ni,
        Zn += we * Hi,
        we = rr[2],
        be += we * vn,
        mr += we * Oe,
        fr += we * ot,
        Rr += we * ir,
        Pr += we * vr,
        Fr += we * Er,
        br += we * Ar,
        xr += we * kr,
        _r += we * _n,
        Ir += we * Qn,
        Nr += we * gi,
        gn += we * ei,
        Zr += we * si,
        Tn += we * Ki,
        Zn += we * Ni,
        Cn += we * Hi,
        we = rr[3],
        mr += we * vn,
        fr += we * Oe,
        Rr += we * ot,
        Pr += we * ir,
        Fr += we * vr,
        br += we * Er,
        xr += we * Ar,
        _r += we * kr,
        Ir += we * _n,
        Nr += we * Qn,
        gn += we * gi,
        Zr += we * ei,
        Tn += we * si,
        Zn += we * Ki,
        Cn += we * Ni,
        Gn += we * Hi,
        we = rr[4],
        fr += we * vn,
        Rr += we * Oe,
        Pr += we * ot,
        Fr += we * ir,
        br += we * vr,
        xr += we * Er,
        _r += we * Ar,
        Ir += we * kr,
        Nr += we * _n,
        gn += we * Qn,
        Zr += we * gi,
        Tn += we * ei,
        Zn += we * si,
        Cn += we * Ki,
        Gn += we * Ni,
        ni += we * Hi,
        we = rr[5],
        Rr += we * vn,
        Pr += we * Oe,
        Fr += we * ot,
        br += we * ir,
        xr += we * vr,
        _r += we * Er,
        Ir += we * Ar,
        Nr += we * kr,
        gn += we * _n,
        Zr += we * Qn,
        Tn += we * gi,
        Zn += we * ei,
        Cn += we * si,
        Gn += we * Ki,
        ni += we * Ni,
        xi += we * Hi,
        we = rr[6],
        Pr += we * vn,
        Fr += we * Oe,
        br += we * ot,
        xr += we * ir,
        _r += we * vr,
        Ir += we * Er,
        Nr += we * Ar,
        gn += we * kr,
        Zr += we * _n,
        Tn += we * Qn,
        Zn += we * gi,
        Cn += we * ei,
        Gn += we * si,
        ni += we * Ki,
        xi += we * Ni,
        oi += we * Hi,
        we = rr[7],
        Fr += we * vn,
        br += we * Oe,
        xr += we * ot,
        _r += we * ir,
        Ir += we * vr,
        Nr += we * Er,
        gn += we * Ar,
        Zr += we * kr,
        Tn += we * _n,
        Zn += we * Qn,
        Cn += we * gi,
        Gn += we * ei,
        ni += we * si,
        xi += we * Ki,
        oi += we * Ni,
        $i += we * Hi,
        we = rr[8],
        br += we * vn,
        xr += we * Oe,
        _r += we * ot,
        Ir += we * ir,
        Nr += we * vr,
        gn += we * Er,
        Zr += we * Ar,
        Tn += we * kr,
        Zn += we * _n,
        Cn += we * Qn,
        Gn += we * gi,
        ni += we * ei,
        xi += we * si,
        oi += we * Ki,
        $i += we * Ni,
        Ci += we * Hi,
        we = rr[9],
        xr += we * vn,
        _r += we * Oe,
        Ir += we * ot,
        Nr += we * ir,
        gn += we * vr,
        Zr += we * Er,
        Tn += we * Ar,
        Zn += we * kr,
        Cn += we * _n,
        Gn += we * Qn,
        ni += we * gi,
        xi += we * ei,
        oi += we * si,
        $i += we * Ki,
        Ci += we * Ni,
        Yn += we * Hi,
        we = rr[10],
        _r += we * vn,
        Ir += we * Oe,
        Nr += we * ot,
        gn += we * ir,
        Zr += we * vr,
        Tn += we * Er,
        Zn += we * Ar,
        Cn += we * kr,
        Gn += we * _n,
        ni += we * Qn,
        xi += we * gi,
        oi += we * ei,
        $i += we * si,
        Ci += we * Ki,
        Yn += we * Ni,
        pi += we * Hi,
        we = rr[11],
        Ir += we * vn,
        Nr += we * Oe,
        gn += we * ot,
        Zr += we * ir,
        Tn += we * vr,
        Zn += we * Er,
        Cn += we * Ar,
        Gn += we * kr,
        ni += we * _n,
        xi += we * Qn,
        oi += we * gi,
        $i += we * ei,
        Ci += we * si,
        Yn += we * Ki,
        pi += we * Ni,
        yi += we * Hi,
        we = rr[12],
        Nr += we * vn,
        gn += we * Oe,
        Zr += we * ot,
        Tn += we * ir,
        Zn += we * vr,
        Cn += we * Er,
        Gn += we * Ar,
        ni += we * kr,
        xi += we * _n,
        oi += we * Qn,
        $i += we * gi,
        Ci += we * ei,
        Yn += we * si,
        pi += we * Ki,
        yi += we * Ni,
        dr += we * Hi,
        we = rr[13],
        gn += we * vn,
        Zr += we * Oe,
        Tn += we * ot,
        Zn += we * ir,
        Cn += we * vr,
        Gn += we * Er,
        ni += we * Ar,
        xi += we * kr,
        oi += we * _n,
        $i += we * Qn,
        Ci += we * gi,
        Yn += we * ei,
        pi += we * si,
        yi += we * Ki,
        dr += we * Ni,
        Sr += we * Hi,
        we = rr[14],
        Zr += we * vn,
        Tn += we * Oe,
        Zn += we * ot,
        Cn += we * ir,
        Gn += we * vr,
        ni += we * Er,
        xi += we * Ar,
        oi += we * kr,
        $i += we * _n,
        Ci += we * Qn,
        Yn += we * gi,
        pi += we * ei,
        yi += we * si,
        dr += we * Ki,
        Sr += we * Ni,
        Gr += we * Hi,
        we = rr[15],
        Tn += we * vn,
        Zn += we * Oe,
        Cn += we * ot,
        Gn += we * ir,
        ni += we * vr,
        xi += we * Er,
        oi += we * Ar,
        $i += we * kr,
        Ci += we * _n,
        Yn += we * Qn,
        pi += we * gi,
        yi += we * ei,
        dr += we * si,
        Sr += we * Ki,
        Gr += we * Ni,
        Qr += we * Hi,
        lr += 38 * Zn,
        cr += 38 * Cn,
        be += 38 * Gn,
        mr += 38 * ni,
        fr += 38 * xi,
        Rr += 38 * oi,
        Pr += 38 * $i,
        Fr += 38 * Ci,
        br += 38 * Yn,
        xr += 38 * pi,
        _r += 38 * yi,
        Ir += 38 * dr,
        Nr += 38 * Sr,
        gn += 38 * Gr,
        Zr += 38 * Qr,
        Ut = 1,
        we = lr + Ut + 65535,
        Ut = Math.floor(we / 65536),
        lr = we - 65536 * Ut,
        we = cr + Ut + 65535,
        Ut = Math.floor(we / 65536),
        cr = we - 65536 * Ut,
        we = be + Ut + 65535,
        Ut = Math.floor(we / 65536),
        be = we - 65536 * Ut,
        we = mr + Ut + 65535,
        Ut = Math.floor(we / 65536),
        mr = we - 65536 * Ut,
        we = fr + Ut + 65535,
        Ut = Math.floor(we / 65536),
        fr = we - 65536 * Ut,
        we = Rr + Ut + 65535,
        Ut = Math.floor(we / 65536),
        Rr = we - 65536 * Ut,
        we = Pr + Ut + 65535,
        Ut = Math.floor(we / 65536),
        Pr = we - 65536 * Ut,
        we = Fr + Ut + 65535,
        Ut = Math.floor(we / 65536),
        Fr = we - 65536 * Ut,
        we = br + Ut + 65535,
        Ut = Math.floor(we / 65536),
        br = we - 65536 * Ut,
        we = xr + Ut + 65535,
        Ut = Math.floor(we / 65536),
        xr = we - 65536 * Ut,
        we = _r + Ut + 65535,
        Ut = Math.floor(we / 65536),
        _r = we - 65536 * Ut,
        we = Ir + Ut + 65535,
        Ut = Math.floor(we / 65536),
        Ir = we - 65536 * Ut,
        we = Nr + Ut + 65535,
        Ut = Math.floor(we / 65536),
        Nr = we - 65536 * Ut,
        we = gn + Ut + 65535,
        Ut = Math.floor(we / 65536),
        gn = we - 65536 * Ut,
        we = Zr + Ut + 65535,
        Ut = Math.floor(we / 65536),
        Zr = we - 65536 * Ut,
        we = Tn + Ut + 65535,
        Ut = Math.floor(we / 65536),
        Tn = we - 65536 * Ut,
        lr += Ut - 1 + 37 * (Ut - 1),
        Ut = 1,
        we = lr + Ut + 65535,
        Ut = Math.floor(we / 65536),
        lr = we - 65536 * Ut,
        we = cr + Ut + 65535,
        Ut = Math.floor(we / 65536),
        cr = we - 65536 * Ut,
        we = be + Ut + 65535,
        Ut = Math.floor(we / 65536),
        be = we - 65536 * Ut,
        we = mr + Ut + 65535,
        Ut = Math.floor(we / 65536),
        mr = we - 65536 * Ut,
        we = fr + Ut + 65535,
        Ut = Math.floor(we / 65536),
        fr = we - 65536 * Ut,
        we = Rr + Ut + 65535,
        Ut = Math.floor(we / 65536),
        Rr = we - 65536 * Ut,
        we = Pr + Ut + 65535,
        Ut = Math.floor(we / 65536),
        Pr = we - 65536 * Ut,
        we = Fr + Ut + 65535,
        Ut = Math.floor(we / 65536),
        Fr = we - 65536 * Ut,
        we = br + Ut + 65535,
        Ut = Math.floor(we / 65536),
        br = we - 65536 * Ut,
        we = xr + Ut + 65535,
        Ut = Math.floor(we / 65536),
        xr = we - 65536 * Ut,
        we = _r + Ut + 65535,
        Ut = Math.floor(we / 65536),
        _r = we - 65536 * Ut,
        we = Ir + Ut + 65535,
        Ut = Math.floor(we / 65536),
        Ir = we - 65536 * Ut,
        we = Nr + Ut + 65535,
        Ut = Math.floor(we / 65536),
        Nr = we - 65536 * Ut,
        we = gn + Ut + 65535,
        Ut = Math.floor(we / 65536),
        gn = we - 65536 * Ut,
        we = Zr + Ut + 65535,
        Ut = Math.floor(we / 65536),
        Zr = we - 65536 * Ut,
        we = Tn + Ut + 65535,
        Ut = Math.floor(we / 65536),
        Tn = we - 65536 * Ut,
        lr += Ut - 1 + 37 * (Ut - 1),
        tt[0] = lr,
        tt[1] = cr,
        tt[2] = be,
        tt[3] = mr,
        tt[4] = fr,
        tt[5] = Rr,
        tt[6] = Pr,
        tt[7] = Fr,
        tt[8] = br,
        tt[9] = xr,
        tt[10] = _r,
        tt[11] = Ir,
        tt[12] = Nr,
        tt[13] = gn,
        tt[14] = Zr,
        tt[15] = Tn
    }
    function $e(tt, rr) {
        xe(tt, rr, rr)
    }
    function Ee(tt, rr) {
        const tr = new Uint8Array(32)
          , we = new Float64Array(80)
          , Ut = ne()
          , lr = ne()
          , cr = ne()
          , be = ne()
          , mr = ne()
          , fr = ne();
        for (let br = 0; br < 31; br++)
            tr[br] = tt[br];
        tr[31] = 127 & tt[31] | 64,
        tr[0] &= 248,
        function(br, xr) {
            for (let _r = 0; _r < 16; _r++)
                br[_r] = xr[2 * _r] + (xr[2 * _r + 1] << 8);
            br[15] &= 32767
        }(we, rr);
        for (let br = 0; br < 16; br++)
            lr[br] = we[br];
        Ut[0] = be[0] = 1;
        for (let br = 254; br >= 0; --br) {
            const xr = tr[br >>> 3] >>> (7 & br) & 1;
            he(Ut, lr, xr),
            he(cr, be, xr),
            fe(mr, Ut, cr),
            ge(Ut, Ut, cr),
            fe(cr, lr, be),
            ge(lr, lr, be),
            $e(be, mr),
            $e(fr, Ut),
            xe(Ut, cr, Ut),
            xe(cr, lr, mr),
            fe(mr, Ut, cr),
            ge(Ut, Ut, cr),
            $e(lr, Ut),
            ge(cr, be, fr),
            xe(Ut, cr, ue),
            fe(Ut, Ut, be),
            xe(cr, cr, Ut),
            xe(Ut, be, fr),
            xe(be, lr, we),
            $e(lr, mr),
            he(Ut, lr, xr),
            he(cr, be, xr)
        }
        for (let br = 0; br < 16; br++)
            we[br + 16] = Ut[br],
            we[br + 32] = cr[br],
            we[br + 48] = lr[br],
            we[br + 64] = be[br];
        const Rr = we.subarray(32)
          , Pr = we.subarray(16);
        (function(br, xr) {
            const _r = ne();
            for (let Ir = 0; Ir < 16; Ir++)
                _r[Ir] = xr[Ir];
            for (let Ir = 253; Ir >= 0; Ir--)
                $e(_r, _r),
                Ir !== 2 && Ir !== 4 && xe(_r, _r, xr);
            for (let Ir = 0; Ir < 16; Ir++)
                br[Ir] = _r[Ir]
        }
        )(Rr, Rr),
        xe(Pr, Pr, Rr);
        const Fr = new Uint8Array(32);
        return function(br, xr) {
            const _r = ne()
              , Ir = ne();
            for (let Nr = 0; Nr < 16; Nr++)
                Ir[Nr] = xr[Nr];
            de(Ir),
            de(Ir),
            de(Ir);
            for (let Nr = 0; Nr < 2; Nr++) {
                _r[0] = Ir[0] - 65517;
                for (let Zr = 1; Zr < 15; Zr++)
                    _r[Zr] = Ir[Zr] - 65535 - (_r[Zr - 1] >> 16 & 1),
                    _r[Zr - 1] &= 65535;
                _r[15] = Ir[15] - 32767 - (_r[14] >> 16 & 1);
                const gn = _r[15] >> 16 & 1;
                _r[14] &= 65535,
                he(Ir, _r, 1 - gn)
            }
            for (let Nr = 0; Nr < 16; Nr++)
                br[2 * Nr] = 255 & Ir[Nr],
                br[2 * Nr + 1] = Ir[Nr] >> 8
        }(Fr, Pr),
        Fr
    }
    function Se(tt) {
        return Ee(tt, le)
    }
    function Ne(tt) {
        if (tt.length !== W.SECRET_KEY_LENGTH)
            throw new Error(`x25519: seed must be ${W.SECRET_KEY_LENGTH} bytes`);
        const rr = new Uint8Array(tt);
        return {
            publicKey: Se(rr),
            secretKey: rr
        }
    }
    W.scalarMult = Ee,
    W.scalarMultBase = Se,
    W.generateKeyPairFromSeed = Ne,
    W.generateKeyPair = function(tt) {
        const rr = (0,
        z.randomBytes)(32, tt)
          , tr = Ne(rr);
        return (0,
        Y.wipe)(rr),
        tr
    }
    ,
    W.sharedKey = function(tt, rr, tr=!1) {
        if (tt.length !== W.PUBLIC_KEY_LENGTH)
            throw new Error("X25519: incorrect secret key length");
        if (rr.length !== W.PUBLIC_KEY_LENGTH)
            throw new Error("X25519: incorrect public key length");
        const we = Ee(tt, rr);
        if (tr) {
            let Ut = 0;
            for (let lr = 0; lr < we.length; lr++)
                Ut |= we[lr];
            if (Ut === 0)
                throw new Error("X25519: invalid shared key")
        }
        return we
    }
}
)(x25519);
var src = base
  , _brrp__multiformats_scope_baseX = src;
const coerce = W=>{
    if (W instanceof Uint8Array && W.constructor.name === "Uint8Array")
        return W;
    if (W instanceof ArrayBuffer)
        return new Uint8Array(W);
    if (ArrayBuffer.isView(W))
        return new Uint8Array(W.buffer,W.byteOffset,W.byteLength);
    throw new Error("Unknown type, must be binary type")
}
  , fromString$1 = W=>new TextEncoder().encode(W)
  , toString$1 = W=>new TextDecoder().decode(W);
class Encoder {
    constructor(z, Y, ne) {
        this.name = z,
        this.prefix = Y,
        this.baseEncode = ne
    }
    encode(z) {
        if (z instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(z)}`;
        throw Error("Unknown type, must be binary type")
    }
}
class Decoder {
    constructor(z, Y, ne) {
        if (this.name = z,
        this.prefix = Y,
        Y.codePointAt(0) === void 0)
            throw new Error("Invalid prefix character");
        this.prefixCodePoint = Y.codePointAt(0),
        this.baseDecode = ne
    }
    decode(z) {
        if (typeof z == "string") {
            if (z.codePointAt(0) !== this.prefixCodePoint)
                throw Error(`Unable to decode multibase string ${JSON.stringify(z)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            return this.baseDecode(z.slice(this.prefix.length))
        }
        throw Error("Can only multibase decode strings")
    }
    or(z) {
        return or(this, z)
    }
}
class ComposedDecoder {
    constructor(z) {
        this.decoders = z
    }
    or(z) {
        return or(this, z)
    }
    decode(z) {
        const Y = z[0]
          , ne = this.decoders[Y];
        if (ne)
            return ne.decode(z);
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(z)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
    }
}
const or = (W,z)=>new ComposedDecoder({
    ...W.decoders || {
        [W.prefix]: W
    },
    ...z.decoders || {
        [z.prefix]: z
    }
});
class Codec {
    constructor(z, Y, ne, le) {
        this.name = z,
        this.prefix = Y,
        this.baseEncode = ne,
        this.baseDecode = le,
        this.encoder = new Encoder(z,Y,ne),
        this.decoder = new Decoder(z,Y,le)
    }
    encode(z) {
        return this.encoder.encode(z)
    }
    decode(z) {
        return this.decoder.decode(z)
    }
}
const from = ({name: W, prefix: z, encode: Y, decode: ne})=>new Codec(W,z,Y,ne)
  , baseX = ({prefix: W, name: z, alphabet: Y})=>{
    const {encode: ne, decode: le} = _brrp__multiformats_scope_baseX(Y, z);
    return from({
        prefix: W,
        name: z,
        encode: ne,
        decode: ue=>coerce(le(ue))
    })
}
  , decode$2 = (W,z,Y,ne)=>{
    const le = {};
    for (let xe = 0; xe < z.length; ++xe)
        le[z[xe]] = xe;
    let ue = W.length;
    for (; W[ue - 1] === "="; )
        --ue;
    const de = new Uint8Array(ue * Y / 8 | 0);
    let he = 0
      , fe = 0
      , ge = 0;
    for (let xe = 0; xe < ue; ++xe) {
        const $e = le[W[xe]];
        if ($e === void 0)
            throw new SyntaxError(`Non-${ne} character`);
        fe = fe << Y | $e,
        he += Y,
        he >= 8 && (he -= 8,
        de[ge++] = 255 & fe >> he)
    }
    if (he >= Y || 255 & fe << 8 - he)
        throw new SyntaxError("Unexpected end of data");
    return de
}
  , encode$1 = (W,z,Y)=>{
    const ne = z[z.length - 1] === "="
      , le = (1 << Y) - 1;
    let ue = ""
      , de = 0
      , he = 0;
    for (let fe = 0; fe < W.length; ++fe)
        for (he = he << 8 | W[fe],
        de += 8; de > Y; )
            de -= Y,
            ue += z[le & he >> de];
    if (de && (ue += z[le & he << Y - de]),
    ne)
        for (; ue.length * Y & 7; )
            ue += "=";
    return ue
}
  , rfc4648 = ({name: W, prefix: z, bitsPerChar: Y, alphabet: ne})=>from({
    prefix: z,
    name: W,
    encode: le=>encode$1(le, ne, Y),
    decode: le=>decode$2(le, ne, Y, W)
})
  , identity = from({
    prefix: "\0",
    name: "identity",
    encode: W=>toString$1(W),
    decode: W=>fromString$1(W)
})
  , identityBase = Object.freeze(Object.defineProperty({
    __proto__: null,
    identity
}, Symbol.toStringTag, {
    value: "Module"
}))
  , base2 = rfc4648({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
})
  , base2$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    base2
}, Symbol.toStringTag, {
    value: "Module"
}))
  , base8 = rfc4648({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
})
  , base8$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    base8
}, Symbol.toStringTag, {
    value: "Module"
}))
  , base10 = baseX({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
})
  , base10$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    base10
}, Symbol.toStringTag, {
    value: "Module"
}))
  , base16 = rfc4648({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
})
  , base16upper = rfc4648({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
})
  , base16$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    base16,
    base16upper
}, Symbol.toStringTag, {
    value: "Module"
}))
  , base32 = rfc4648({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
})
  , base32upper = rfc4648({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
})
  , base32pad = rfc4648({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
})
  , base32padupper = rfc4648({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
})
  , base32hex = rfc4648({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
})
  , base32hexupper = rfc4648({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
})
  , base32hexpad = rfc4648({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
})
  , base32hexpadupper = rfc4648({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
})
  , base32z = rfc4648({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
})
  , base32$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    base32,
    base32hex,
    base32hexpad,
    base32hexpadupper,
    base32hexupper,
    base32pad,
    base32padupper,
    base32upper,
    base32z
}, Symbol.toStringTag, {
    value: "Module"
}))
  , base36 = baseX({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
})
  , base36upper = baseX({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
})
  , base36$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    base36,
    base36upper
}, Symbol.toStringTag, {
    value: "Module"
}))
  , base58btc = baseX({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
})
  , base58flickr = baseX({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
})
  , base58 = Object.freeze(Object.defineProperty({
    __proto__: null,
    base58btc,
    base58flickr
}, Symbol.toStringTag, {
    value: "Module"
}))
  , base64 = rfc4648({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
})
  , base64pad = rfc4648({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
})
  , base64url = rfc4648({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
})
  , base64urlpad = rfc4648({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
})
  , base64$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    base64,
    base64pad,
    base64url,
    base64urlpad
}, Symbol.toStringTag, {
    value: "Module"
}))
  , alphabet = Array.from("ððªâð°ðððððððððððððâð»ð¥ð¾ð¿ðâ¤ðð¤£ðððð­ðððððð¥ð¥°ðððð¢ð¤ðððªðâºðð¤ððððð¹ð¤¦ððââ¨ð¤·ð±ðð¸ððððððððð¤©ððð¤ðð¯ððð¶ðð¤­â£ððððªðð¥ððð©ð¡ð¤ªðð¥³ð¥ð¤¤ððð³âððð´ðð¬ððð·ð»ðâ­âð¥ºððð¤ð¦âð£ððâ¹ððð âððºðð»ððððð¹ð£ð«ðððµð¤ðð´ð¤ð¼ð«â½ð¤âðð¤«ðð®ðð»ðð¶ðð²ð¿ð§¡ðâ¡ððââðð°ð¤¨ð¶ð¤ð¶ð°ðð¢ð¤ðð¨ð¨ð¤¬âððºð¤ððð±ðð¶ð¥´â¶â¡âðð¸â¬ð¨ðð¦ð·ðºâ ðððµðð¤²ð¤ ð¤§ððµðð§ð¾ððð¤ðð¤¯ð·âð§ð¯ððð¤ððâð´ð£ð¸ððð¥ð¤¢ðð¡ð©ðð¸ð»ð¤ð¤®ð¼ð¥µð©ððð¼ðð£ð¥")
  , alphabetBytesToChars = alphabet.reduce((W,z,Y)=>(W[Y] = z,
W), [])
  , alphabetCharsToBytes = alphabet.reduce((W,z,Y)=>(W[z.codePointAt(0)] = Y,
W), []);
function encode(W) {
    return W.reduce((z,Y)=>z += alphabetBytesToChars[Y], "")
}
function decode$1(W) {
    const z = [];
    for (const Y of W) {
        const ne = alphabetCharsToBytes[Y.codePointAt(0)];
        if (ne === void 0)
            throw new Error(`Non-base256emoji character: ${Y}`);
        z.push(ne)
    }
    return new Uint8Array(z)
}
const base256emoji = from({
    prefix: "ð",
    name: "base256emoji",
    encode,
    decode: decode$1
})
  , base256emoji$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    base256emoji
}, Symbol.toStringTag, {
    value: "Module"
}));
new TextEncoder,
new TextDecoder;
const bases = {
    ...identityBase,
    ...base2$1,
    ...base8$1,
    ...base10$1,
    ...base16$1,
    ...base32$1,
    ...base36$1,
    ...base58,
    ...base64$1,
    ...base256emoji$1
};
function createCodec(W, z, Y, ne) {
    return {
        name: W,
        prefix: z,
        encoder: {
            name: W,
            prefix: z,
            encode: Y
        },
        decoder: {
            decode: ne
        }
    }
}
const string = createCodec("utf8", "u", W=>"u" + new TextDecoder("utf8").decode(W), W=>new TextEncoder().encode(W.substring(1)))
  , ascii = createCodec("ascii", "a", W=>{
    let z = "a";
    for (let Y = 0; Y < W.length; Y++)
        z += String.fromCharCode(W[Y]);
    return z
}
, W=>{
    const z = allocUnsafe((W = W.substring(1)).length);
    for (let Y = 0; Y < W.length; Y++)
        z[Y] = W.charCodeAt(Y);
    return z
}
)
  , BASES = {
    utf8: string,
    "utf-8": string,
    hex: bases.base16,
    latin1: ascii,
    ascii,
    binary: ascii,
    ...bases
};
function fromString(W, z="utf8") {
    const Y = BASES[z];
    if (!Y)
        throw new Error(`Unsupported encoding "${z}"`);
    return z !== "utf8" && z !== "utf-8" || globalThis.Buffer == null || globalThis.Buffer.from == null ? Y.decoder.decode(`${Y.prefix}${W}`) : asUint8Array(globalThis.Buffer.from(W, "utf-8"))
}
function toString(W, z="utf8") {
    const Y = BASES[z];
    if (!Y)
        throw new Error(`Unsupported encoding "${z}"`);
    return z !== "utf8" && z !== "utf-8" || globalThis.Buffer == null || globalThis.Buffer.from == null ? Y.encoder.encode(W).substring(1) : globalThis.Buffer.from(W.buffer, W.byteOffset, W.byteLength).toString("utf8")
}
var __spreadArray = globalThis && globalThis.__spreadArray || function(W, z, Y) {
    if (Y || arguments.length === 2)
        for (var ne, le = 0, ue = z.length; le < ue; le++)
            !ne && le in z || (ne || (ne = Array.prototype.slice.call(z, 0, le)),
            ne[le] = z[le]);
    return W.concat(ne || Array.prototype.slice.call(z))
}
  , BrowserInfo = function(W, z, Y) {
    this.name = W,
    this.version = z,
    this.os = Y,
    this.type = "browser"
}
  , NodeInfo = function(W) {
    this.version = W,
    this.type = "node",
    this.name = "node",
    this.os = process.platform
}
  , SearchBotDeviceInfo = function(W, z, Y, ne) {
    this.name = W,
    this.version = z,
    this.os = Y,
    this.bot = ne,
    this.type = "bot-device"
}
  , BotInfo = function() {
    this.type = "bot",
    this.bot = !0,
    this.name = "bot",
    this.version = null,
    this.os = null
}
  , ReactNativeInfo = function() {
    this.type = "react-native",
    this.name = "react-native",
    this.version = null,
    this.os = null
}
  , SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/
  , SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/
  , REQUIRED_VERSION_PARTS = 3
  , userAgentRules = [["aol", /AOLShield\/([0-9\._]+)/], ["edge", /Edge\/([0-9\._]+)/], ["edge-ios", /EdgiOS\/([0-9\._]+)/], ["yandexbrowser", /YaBrowser\/([0-9\._]+)/], ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/], ["samsung", /SamsungBrowser\/([0-9\.]+)/], ["silk", /\bSilk\/([0-9._-]+)\b/], ["miui", /MiuiBrowser\/([0-9\.]+)$/], ["beaker", /BeakerBrowser\/([0-9\.]+)/], ["edge-chromium", /EdgA?\/([0-9\.]+)/], ["chromium-webview", /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/], ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/], ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/], ["fxios", /FxiOS\/([0-9\.]+)/], ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/], ["opera", /Opera\/([0-9\.]+)(?:\s|$)/], ["opera", /OPR\/([0-9\.]+)(:?\s|$)/], ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/], ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/], ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/], ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/], ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/], ["ie", /MSIE\s(7\.0)/], ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/], ["android", /Android\s([0-9\.]+)/], ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/], ["safari", /Version\/([0-9\._]+).*Safari/], ["facebook", /FB[AS]V\/([0-9\.]+)/], ["instagram", /Instagram\s([0-9\.]+)/], ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/], ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/], ["curl", /^curl\/([0-9\.]+)$/], ["searchbot", SEARCHBOX_UA_REGEX]]
  , operatingSystemRules = [["iOS", /iP(hone|od|ad)/], ["Android OS", /Android/], ["BlackBerry OS", /BlackBerry|BB10/], ["Windows Mobile", /IEMobile/], ["Amazon OS", /Kindle/], ["Windows 3.11", /Win16/], ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/], ["Windows 98", /(Windows 98)|(Win98)/], ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/], ["Windows XP", /(Windows NT 5.1)|(Windows XP)/], ["Windows Server 2003", /(Windows NT 5.2)/], ["Windows Vista", /(Windows NT 6.0)/], ["Windows 7", /(Windows NT 6.1)/], ["Windows 8", /(Windows NT 6.2)/], ["Windows 8.1", /(Windows NT 6.3)/], ["Windows 10", /(Windows NT 10.0)/], ["Windows ME", /Windows ME/], ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/], ["Open BSD", /OpenBSD/], ["Sun OS", /SunOS/], ["Chrome OS", /CrOS/], ["Linux", /(Linux)|(X11)/], ["Mac OS", /(Mac_PowerPC)|(Macintosh)/], ["QNX", /QNX/], ["BeOS", /BeOS/], ["OS/2", /OS\/2/]];
function detect(W) {
    return W ? parseUserAgent(W) : typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new ReactNativeInfo : typeof navigator < "u" ? parseUserAgent(navigator.userAgent) : getNodeVersion()
}
function matchUserAgent(W) {
    return W !== "" && userAgentRules.reduce(function(z, Y) {
        var ne = Y[0]
          , le = Y[1];
        if (z)
            return z;
        var ue = le.exec(W);
        return !!ue && [ne, ue]
    }, !1)
}
function parseUserAgent(W) {
    var z = matchUserAgent(W);
    if (!z)
        return null;
    var Y = z[0]
      , ne = z[1];
    if (Y === "searchbot")
        return new BotInfo;
    var le = ne[1] && ne[1].split(".").join("_").split("_").slice(0, 3);
    le ? le.length < REQUIRED_VERSION_PARTS && (le = __spreadArray(__spreadArray([], le, !0), createVersionParts(REQUIRED_VERSION_PARTS - le.length), !0)) : le = [];
    var ue = le.join(".")
      , de = detectOS(W)
      , he = SEARCHBOT_OS_REGEX.exec(W);
    return he && he[1] ? new SearchBotDeviceInfo(Y,ue,de,he[1]) : new BrowserInfo(Y,ue,de)
}
function detectOS(W) {
    for (var z = 0, Y = operatingSystemRules.length; z < Y; z++) {
        var ne = operatingSystemRules[z]
          , le = ne[0];
        if (ne[1].exec(W))
            return le
    }
    return null
}
function getNodeVersion() {
    return typeof process < "u" && process.version ? new NodeInfo(process.version.slice(1)) : null
}
function createVersionParts(W) {
    for (var z = [], Y = 0; Y < W; Y++)
        z.push("0");
    return z
}
var cjs$2 = {}
  , extendStatics = function(W, z) {
    return extendStatics = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(Y, ne) {
        Y.__proto__ = ne
    }
    || function(Y, ne) {
        for (var le in ne)
            ne.hasOwnProperty(le) && (Y[le] = ne[le])
    }
    ,
    extendStatics(W, z)
};
function __extends(W, z) {
    function Y() {
        this.constructor = W
    }
    extendStatics(W, z),
    W.prototype = z === null ? Object.create(z) : (Y.prototype = z.prototype,
    new Y)
}
var __assign = function() {
    return __assign = Object.assign || function(W) {
        for (var z, Y = 1, ne = arguments.length; Y < ne; Y++)
            for (var le in z = arguments[Y])
                Object.prototype.hasOwnProperty.call(z, le) && (W[le] = z[le]);
        return W
    }
    ,
    __assign.apply(this, arguments)
};
function __rest(W, z) {
    var Y = {};
    for (var ne in W)
        Object.prototype.hasOwnProperty.call(W, ne) && z.indexOf(ne) < 0 && (Y[ne] = W[ne]);
    if (W != null && typeof Object.getOwnPropertySymbols == "function") {
        var le = 0;
        for (ne = Object.getOwnPropertySymbols(W); le < ne.length; le++)
            z.indexOf(ne[le]) < 0 && Object.prototype.propertyIsEnumerable.call(W, ne[le]) && (Y[ne[le]] = W[ne[le]])
    }
    return Y
}
function __decorate(W, z, Y, ne) {
    var le, ue = arguments.length, de = ue < 3 ? z : ne === null ? ne = Object.getOwnPropertyDescriptor(z, Y) : ne;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        de = Reflect.decorate(W, z, Y, ne);
    else
        for (var he = W.length - 1; he >= 0; he--)
            (le = W[he]) && (de = (ue < 3 ? le(de) : ue > 3 ? le(z, Y, de) : le(z, Y)) || de);
    return ue > 3 && de && Object.defineProperty(z, Y, de),
    de
}
function __param(W, z) {
    return function(Y, ne) {
        z(Y, ne, W)
    }
}
function __metadata(W, z) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(W, z)
}
function __awaiter(W, z, Y, ne) {
    return new (Y || (Y = Promise))(function(le, ue) {
        function de(ge) {
            try {
                fe(ne.next(ge))
            } catch (xe) {
                ue(xe)
            }
        }
        function he(ge) {
            try {
                fe(ne.throw(ge))
            } catch (xe) {
                ue(xe)
            }
        }
        function fe(ge) {
            var xe;
            ge.done ? le(ge.value) : (xe = ge.value,
            xe instanceof Y ? xe : new Y(function($e) {
                $e(xe)
            }
            )).then(de, he)
        }
        fe((ne = ne.apply(W, z || [])).next())
    }
    )
}
function __generator(W, z) {
    var Y, ne, le, ue, de = {
        label: 0,
        sent: function() {
            if (1 & le[0])
                throw le[1];
            return le[1]
        },
        trys: [],
        ops: []
    };
    return ue = {
        next: he(0),
        throw: he(1),
        return: he(2)
    },
    typeof Symbol == "function" && (ue[Symbol.iterator] = function() {
        return this
    }
    ),
    ue;
    function he(fe) {
        return function(ge) {
            return function(xe) {
                if (Y)
                    throw new TypeError("Generator is already executing.");
                for (; de; )
                    try {
                        if (Y = 1,
                        ne && (le = 2 & xe[0] ? ne.return : xe[0] ? ne.throw || ((le = ne.return) && le.call(ne),
                        0) : ne.next) && !(le = le.call(ne, xe[1])).done)
                            return le;
                        switch (ne = 0,
                        le && (xe = [2 & xe[0], le.value]),
                        xe[0]) {
                        case 0:
                        case 1:
                            le = xe;
                            break;
                        case 4:
                            return de.label++,
                            {
                                value: xe[1],
                                done: !1
                            };
                        case 5:
                            de.label++,
                            ne = xe[1],
                            xe = [0];
                            continue;
                        case 7:
                            xe = de.ops.pop(),
                            de.trys.pop();
                            continue;
                        default:
                            if (le = de.trys,
                            !((le = le.length > 0 && le[le.length - 1]) || xe[0] !== 6 && xe[0] !== 2)) {
                                de = 0;
                                continue
                            }
                            if (xe[0] === 3 && (!le || xe[1] > le[0] && xe[1] < le[3])) {
                                de.label = xe[1];
                                break
                            }
                            if (xe[0] === 6 && de.label < le[1]) {
                                de.label = le[1],
                                le = xe;
                                break
                            }
                            if (le && de.label < le[2]) {
                                de.label = le[2],
                                de.ops.push(xe);
                                break
                            }
                            le[2] && de.ops.pop(),
                            de.trys.pop();
                            continue
                        }
                        xe = z.call(W, de)
                    } catch ($e) {
                        xe = [6, $e],
                        ne = 0
                    } finally {
                        Y = le = 0
                    }
                if (5 & xe[0])
                    throw xe[1];
                return {
                    value: xe[0] ? xe[1] : void 0,
                    done: !0
                }
            }([fe, ge])
        }
    }
}
function __createBinding(W, z, Y, ne) {
    ne === void 0 && (ne = Y),
    W[ne] = z[Y]
}
function __exportStar(W, z) {
    for (var Y in W)
        Y === "default" || z.hasOwnProperty(Y) || (z[Y] = W[Y])
}
function __values(W) {
    var z = typeof Symbol == "function" && Symbol.iterator
      , Y = z && W[z]
      , ne = 0;
    if (Y)
        return Y.call(W);
    if (W && typeof W.length == "number")
        return {
            next: function() {
                return W && ne >= W.length && (W = void 0),
                {
                    value: W && W[ne++],
                    done: !W
                }
            }
        };
    throw new TypeError(z ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function __read(W, z) {
    var Y = typeof Symbol == "function" && W[Symbol.iterator];
    if (!Y)
        return W;
    var ne, le, ue = Y.call(W), de = [];
    try {
        for (; (z === void 0 || z-- > 0) && !(ne = ue.next()).done; )
            de.push(ne.value)
    } catch (he) {
        le = {
            error: he
        }
    } finally {
        try {
            ne && !ne.done && (Y = ue.return) && Y.call(ue)
        } finally {
            if (le)
                throw le.error
        }
    }
    return de
}
function __spread() {
    for (var W = [], z = 0; z < arguments.length; z++)
        W = W.concat(__read(arguments[z]));
    return W
}
function __spreadArrays() {
    for (var W = 0, z = 0, Y = arguments.length; z < Y; z++)
        W += arguments[z].length;
    var ne = Array(W)
      , le = 0;
    for (z = 0; z < Y; z++)
        for (var ue = arguments[z], de = 0, he = ue.length; de < he; de++,
        le++)
            ne[le] = ue[de];
    return ne
}
function __await(W) {
    return this instanceof __await ? (this.v = W,
    this) : new __await(W)
}
function __asyncGenerator(W, z, Y) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var ne, le = Y.apply(W, z || []), ue = [];
    return ne = {},
    de("next"),
    de("throw"),
    de("return"),
    ne[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    ne;
    function de($e) {
        le[$e] && (ne[$e] = function(Ee) {
            return new Promise(function(Se, Ne) {
                ue.push([$e, Ee, Se, Ne]) > 1 || he($e, Ee)
            }
            )
        }
        )
    }
    function he($e, Ee) {
        try {
            (function(Se) {
                Se.value instanceof __await ? Promise.resolve(Se.value.v).then(fe, ge) : xe(ue[0][2], Se)
            }
            )(le[$e](Ee))
        } catch (Se) {
            xe(ue[0][3], Se)
        }
    }
    function fe($e) {
        he("next", $e)
    }
    function ge($e) {
        he("throw", $e)
    }
    function xe($e, Ee) {
        $e(Ee),
        ue.shift(),
        ue.length && he(ue[0][0], ue[0][1])
    }
}
function __asyncDelegator(W) {
    var z, Y;
    return z = {},
    ne("next"),
    ne("throw", function(le) {
        throw le
    }),
    ne("return"),
    z[Symbol.iterator] = function() {
        return this
    }
    ,
    z;
    function ne(le, ue) {
        z[le] = W[le] ? function(de) {
            return (Y = !Y) ? {
                value: __await(W[le](de)),
                done: le === "return"
            } : ue ? ue(de) : de
        }
        : ue
    }
}
function __asyncValues(W) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var z, Y = W[Symbol.asyncIterator];
    return Y ? Y.call(W) : (W = typeof __values == "function" ? __values(W) : W[Symbol.iterator](),
    z = {},
    ne("next"),
    ne("throw"),
    ne("return"),
    z[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    z);
    function ne(le) {
        z[le] = W[le] && function(ue) {
            return new Promise(function(de, he) {
                (function(fe, ge, xe, $e) {
                    Promise.resolve($e).then(function(Ee) {
                        fe({
                            value: Ee,
                            done: xe
                        })
                    }, ge)
                }
                )(de, he, (ue = W[le](ue)).done, ue.value)
            }
            )
        }
    }
}
function __makeTemplateObject(W, z) {
    return Object.defineProperty ? Object.defineProperty(W, "raw", {
        value: z
    }) : W.raw = z,
    W
}
function __importStar(W) {
    if (W && W.__esModule)
        return W;
    var z = {};
    if (W != null)
        for (var Y in W)
            Object.hasOwnProperty.call(W, Y) && (z[Y] = W[Y]);
    return z.default = W,
    z
}
function __importDefault(W) {
    return W && W.__esModule ? W : {
        default: W
    }
}
function __classPrivateFieldGet(W, z) {
    if (!z.has(W))
        throw new TypeError("attempted to get private field on non-instance");
    return z.get(W)
}
function __classPrivateFieldSet(W, z, Y) {
    if (!z.has(W))
        throw new TypeError("attempted to set private field on non-instance");
    return z.set(W, Y),
    Y
}
const tslib_es6 = Object.freeze(Object.defineProperty({
    __proto__: null,
    get __assign() {
        return __assign
    },
    __asyncDelegator,
    __asyncGenerator,
    __asyncValues,
    __await,
    __awaiter,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __createBinding,
    __decorate,
    __exportStar,
    __extends,
    __generator,
    __importDefault,
    __importStar,
    __makeTemplateObject,
    __metadata,
    __param,
    __read,
    __rest,
    __spread,
    __spreadArrays,
    __values
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$0 = getAugmentedNamespace(tslib_es6);
var utils = {}, delay = {}, hasRequiredDelay;
function requireDelay() {
    return hasRequiredDelay || (hasRequiredDelay = 1,
    Object.defineProperty(delay, "__esModule", {
        value: !0
    }),
    delay.delay = void 0,
    delay.delay = function(W) {
        return new Promise(z=>{
            setTimeout(()=>{
                z(!0)
            }
            , W)
        }
        )
    }
    ),
    delay
}
var convert = {}, constants = {}, misc = {}, hasRequiredMisc;
function requireMisc() {
    return hasRequiredMisc || (hasRequiredMisc = 1,
    Object.defineProperty(misc, "__esModule", {
        value: !0
    }),
    misc.ONE_THOUSAND = misc.ONE_HUNDRED = void 0,
    misc.ONE_HUNDRED = 100,
    misc.ONE_THOUSAND = 1e3),
    misc
}
var time = {}, hasRequiredTime, hasRequiredConstants, hasRequiredConvert, hasRequiredUtils;
function requireTime() {
    return hasRequiredTime || (hasRequiredTime = 1,
    function(W) {
        Object.defineProperty(W, "__esModule", {
            value: !0
        }),
        W.ONE_YEAR = W.FOUR_WEEKS = W.THREE_WEEKS = W.TWO_WEEKS = W.ONE_WEEK = W.THIRTY_DAYS = W.SEVEN_DAYS = W.FIVE_DAYS = W.THREE_DAYS = W.ONE_DAY = W.TWENTY_FOUR_HOURS = W.TWELVE_HOURS = W.SIX_HOURS = W.THREE_HOURS = W.ONE_HOUR = W.SIXTY_MINUTES = W.THIRTY_MINUTES = W.TEN_MINUTES = W.FIVE_MINUTES = W.ONE_MINUTE = W.SIXTY_SECONDS = W.THIRTY_SECONDS = W.TEN_SECONDS = W.FIVE_SECONDS = W.ONE_SECOND = void 0,
        W.ONE_SECOND = 1,
        W.FIVE_SECONDS = 5,
        W.TEN_SECONDS = 10,
        W.THIRTY_SECONDS = 30,
        W.SIXTY_SECONDS = 60,
        W.ONE_MINUTE = W.SIXTY_SECONDS,
        W.FIVE_MINUTES = 5 * W.ONE_MINUTE,
        W.TEN_MINUTES = 10 * W.ONE_MINUTE,
        W.THIRTY_MINUTES = 30 * W.ONE_MINUTE,
        W.SIXTY_MINUTES = 60 * W.ONE_MINUTE,
        W.ONE_HOUR = W.SIXTY_MINUTES,
        W.THREE_HOURS = 3 * W.ONE_HOUR,
        W.SIX_HOURS = 6 * W.ONE_HOUR,
        W.TWELVE_HOURS = 12 * W.ONE_HOUR,
        W.TWENTY_FOUR_HOURS = 24 * W.ONE_HOUR,
        W.ONE_DAY = W.TWENTY_FOUR_HOURS,
        W.THREE_DAYS = 3 * W.ONE_DAY,
        W.FIVE_DAYS = 5 * W.ONE_DAY,
        W.SEVEN_DAYS = 7 * W.ONE_DAY,
        W.THIRTY_DAYS = 30 * W.ONE_DAY,
        W.ONE_WEEK = W.SEVEN_DAYS,
        W.TWO_WEEKS = 2 * W.ONE_WEEK,
        W.THREE_WEEKS = 3 * W.ONE_WEEK,
        W.FOUR_WEEKS = 4 * W.ONE_WEEK,
        W.ONE_YEAR = 365 * W.ONE_DAY
    }(time)),
    time
}
function requireConstants() {
    return hasRequiredConstants || (hasRequiredConstants = 1,
    function(W) {
        Object.defineProperty(W, "__esModule", {
            value: !0
        });
        const z = require$$0;
        z.__exportStar(requireMisc(), W),
        z.__exportStar(requireTime(), W)
    }(constants)),
    constants
}
function requireConvert() {
    if (hasRequiredConvert)
        return convert;
    hasRequiredConvert = 1,
    Object.defineProperty(convert, "__esModule", {
        value: !0
    }),
    convert.fromMiliseconds = convert.toMiliseconds = void 0;
    const W = requireConstants();
    return convert.toMiliseconds = function(z) {
        return z * W.ONE_THOUSAND
    }
    ,
    convert.fromMiliseconds = function(z) {
        return Math.floor(z / W.ONE_THOUSAND)
    }
    ,
    convert
}
function requireUtils() {
    return hasRequiredUtils || (hasRequiredUtils = 1,
    function(W) {
        Object.defineProperty(W, "__esModule", {
            value: !0
        });
        const z = require$$0;
        z.__exportStar(requireDelay(), W),
        z.__exportStar(requireConvert(), W)
    }(utils)),
    utils
}
var watch$1 = {}, hasRequiredWatch$1;
function requireWatch$1() {
    if (hasRequiredWatch$1)
        return watch$1;
    hasRequiredWatch$1 = 1,
    Object.defineProperty(watch$1, "__esModule", {
        value: !0
    }),
    watch$1.Watch = void 0;
    class W {
        constructor() {
            this.timestamps = new Map
        }
        start(Y) {
            if (this.timestamps.has(Y))
                throw new Error(`Watch already started for label: ${Y}`);
            this.timestamps.set(Y, {
                started: Date.now()
            })
        }
        stop(Y) {
            const ne = this.get(Y);
            if (ne.elapsed !== void 0)
                throw new Error(`Watch already stopped for label: ${Y}`);
            const le = Date.now() - ne.started;
            this.timestamps.set(Y, {
                started: ne.started,
                elapsed: le
            })
        }
        get(Y) {
            const ne = this.timestamps.get(Y);
            if (ne === void 0)
                throw new Error(`No timestamp found for label: ${Y}`);
            return ne
        }
        elapsed(Y) {
            const ne = this.get(Y);
            return ne.elapsed || Date.now() - ne.started
        }
    }
    return watch$1.Watch = W,
    watch$1.default = W,
    watch$1
}
var types = {}, watch = {}, hasRequiredWatch, hasRequiredTypes;
function requireWatch() {
    return hasRequiredWatch ? watch : (hasRequiredWatch = 1,
    Object.defineProperty(watch, "__esModule", {
        value: !0
    }),
    watch.IWatch = void 0,
    watch.IWatch = class {
    }
    ,
    watch)
}
function requireTypes() {
    return hasRequiredTypes || (hasRequiredTypes = 1,
    function(W) {
        Object.defineProperty(W, "__esModule", {
            value: !0
        }),
        require$$0.__exportStar(requireWatch(), W)
    }(types)),
    types
}
(function(W) {
    Object.defineProperty(W, "__esModule", {
        value: !0
    });
    const z = require$$0;
    z.__exportStar(requireUtils(), W),
    z.__exportStar(requireWatch$1(), W),
    z.__exportStar(requireTypes(), W),
    z.__exportStar(requireConstants(), W)
}
)(cjs$2);
var cjs$1 = {};
function getFromWindow(W) {
    let z;
    return typeof window < "u" && window[W] !== void 0 && (z = window[W]),
    z
}
function getFromWindowOrThrow(W) {
    const z = getFromWindow(W);
    if (!z)
        throw new Error(`${W} is not defined in Window`);
    return z
}
function getDocumentOrThrow() {
    return getFromWindowOrThrow("document")
}
function getDocument() {
    return getFromWindow("document")
}
Object.defineProperty(cjs$1, "__esModule", {
    value: !0
}),
cjs$1.getLocalStorage = cjs$1.getLocalStorageOrThrow = cjs$1.getCrypto = cjs$1.getCryptoOrThrow = getLocation_1 = cjs$1.getLocation = cjs$1.getLocationOrThrow = getNavigator_1 = cjs$1.getNavigator = cjs$1.getNavigatorOrThrow = getDocument_1 = cjs$1.getDocument = cjs$1.getDocumentOrThrow = cjs$1.getFromWindowOrThrow = cjs$1.getFromWindow = void 0,
cjs$1.getFromWindow = getFromWindow,
cjs$1.getFromWindowOrThrow = getFromWindowOrThrow,
cjs$1.getDocumentOrThrow = getDocumentOrThrow;
var getDocument_1 = cjs$1.getDocument = getDocument;
function getNavigatorOrThrow() {
    return getFromWindowOrThrow("navigator")
}
function getNavigator() {
    return getFromWindow("navigator")
}
cjs$1.getNavigatorOrThrow = getNavigatorOrThrow;
var getNavigator_1 = cjs$1.getNavigator = getNavigator;
function getLocationOrThrow() {
    return getFromWindowOrThrow("location")
}
function getLocation() {
    return getFromWindow("location")
}
cjs$1.getLocationOrThrow = getLocationOrThrow;
var getLocation_1 = cjs$1.getLocation = getLocation;
function getCryptoOrThrow() {
    return getFromWindowOrThrow("crypto")
}
function getCrypto() {
    return getFromWindow("crypto")
}
function getLocalStorageOrThrow() {
    return getFromWindowOrThrow("localStorage")
}
function getLocalStorage() {
    return getFromWindow("localStorage")
}
cjs$1.getCryptoOrThrow = getCryptoOrThrow,
cjs$1.getCrypto = getCrypto,
cjs$1.getLocalStorageOrThrow = getLocalStorageOrThrow,
cjs$1.getLocalStorage = getLocalStorage;
var cjs = {};
Object.defineProperty(cjs, "__esModule", {
    value: !0
});
var getWindowMetadata_1 = cjs.getWindowMetadata = void 0;
const window_getters_1 = cjs$1;
function getWindowMetadata() {
    let W, z;
    try {
        W = window_getters_1.getDocumentOrThrow(),
        z = window_getters_1.getLocationOrThrow()
    } catch {
        return null
    }
    function Y(...he) {
        const fe = W.getElementsByTagName("meta");
        for (let ge = 0; ge < fe.length; ge++) {
            const xe = fe[ge]
              , $e = ["itemprop", "property", "name"].map(Ee=>xe.getAttribute(Ee)).filter(Ee=>!!Ee && he.includes(Ee));
            if ($e.length && $e) {
                const Ee = xe.getAttribute("content");
                if (Ee)
                    return Ee
            }
        }
        return ""
    }
    const ne = function() {
        let he = Y("name", "og:site_name", "og:title", "twitter:title");
        return he || (he = W.title),
        he
    }()
      , le = Y("description", "og:description", "twitter:description", "keywords")
      , ue = z.origin
      , de = function() {
        const he = W.getElementsByTagName("link")
          , fe = [];
        for (let ge = 0; ge < he.length; ge++) {
            const xe = he[ge]
              , $e = xe.getAttribute("rel");
            if ($e && $e.toLowerCase().indexOf("icon") > -1) {
                const Ee = xe.getAttribute("href");
                if (Ee)
                    if (Ee.toLowerCase().indexOf("https:") === -1 && Ee.toLowerCase().indexOf("http:") === -1 && Ee.indexOf("//") !== 0) {
                        let Se = z.protocol + "//" + z.host;
                        if (Ee.indexOf("/") === 0)
                            Se += Ee;
                        else {
                            const Ne = z.pathname.split("/");
                            Ne.pop(),
                            Se += Ne.join("/") + "/" + Ee
                        }
                        fe.push(Se)
                    } else if (Ee.indexOf("//") === 0) {
                        const Se = z.protocol + Ee;
                        fe.push(Se)
                    } else
                        fe.push(Ee)
            }
        }
        return fe
    }();
    return {
        description: le,
        url: ue,
        icons: de,
        name: ne
    }
}
getWindowMetadata_1 = cjs.getWindowMetadata = getWindowMetadata;
var queryString = {}
  , strictUriEncode = W=>encodeURIComponent(W).replace(/[!'()*]/g, z=>`%${z.charCodeAt(0).toString(16).toUpperCase()}`)
  , token = "%[a-f0-9]{2}"
  , singleMatcher = new RegExp("(" + token + ")|([^%]+?)","gi")
  , multiMatcher = new RegExp("(" + token + ")+","gi");
function decodeComponents(W, z) {
    try {
        return [decodeURIComponent(W.join(""))]
    } catch {}
    if (W.length === 1)
        return W;
    z = z || 1;
    var Y = W.slice(0, z)
      , ne = W.slice(z);
    return Array.prototype.concat.call([], decodeComponents(Y), decodeComponents(ne))
}
function decode(W) {
    try {
        return decodeURIComponent(W)
    } catch {
        for (var z = W.match(singleMatcher) || [], Y = 1; Y < z.length; Y++)
            z = (W = decodeComponents(z, Y).join("")).match(singleMatcher) || [];
        return W
    }
}
function customDecodeURIComponent(W) {
    for (var z = {
        "%FE%FF": "ï¿½ï¿½",
        "%FF%FE": "ï¿½ï¿½"
    }, Y = multiMatcher.exec(W); Y; ) {
        try {
            z[Y[0]] = decodeURIComponent(Y[0])
        } catch {
            var ne = decode(Y[0]);
            ne !== Y[0] && (z[Y[0]] = ne)
        }
        Y = multiMatcher.exec(W)
    }
    z["%C2"] = "ï¿½";
    for (var le = Object.keys(z), ue = 0; ue < le.length; ue++) {
        var de = le[ue];
        W = W.replace(new RegExp(de,"g"), z[de])
    }
    return W
}
var decodeUriComponent = function(W) {
    if (typeof W != "string")
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof W + "`");
    try {
        return W = W.replace(/\+/g, " "),
        decodeURIComponent(W)
    } catch {
        return customDecodeURIComponent(W)
    }
}
  , splitOnFirst = (W,z)=>{
    if (typeof W != "string" || typeof z != "string")
        throw new TypeError("Expected the arguments to be of type `string`");
    if (z === "")
        return [W];
    const Y = W.indexOf(z);
    return Y === -1 ? [W] : [W.slice(0, Y), W.slice(Y + z.length)]
}
  , filterObj = function(W, z) {
    for (var Y = {}, ne = Object.keys(W), le = Array.isArray(z), ue = 0; ue < ne.length; ue++) {
        var de = ne[ue]
          , he = W[de];
        (le ? z.indexOf(de) !== -1 : z(de, he, W)) && (Y[de] = he)
    }
    return Y
};
(function(W) {
    const z = strictUriEncode
      , Y = decodeUriComponent
      , ne = splitOnFirst
      , le = filterObj
      , ue = Symbol("encodeFragmentIdentifier");
    function de(Ne) {
        if (typeof Ne != "string" || Ne.length !== 1)
            throw new TypeError("arrayFormatSeparator must be single character string")
    }
    function he(Ne, tt) {
        return tt.encode ? tt.strict ? z(Ne) : encodeURIComponent(Ne) : Ne
    }
    function fe(Ne, tt) {
        return tt.decode ? Y(Ne) : Ne
    }
    function ge(Ne) {
        return Array.isArray(Ne) ? Ne.sort() : typeof Ne == "object" ? ge(Object.keys(Ne)).sort((tt,rr)=>Number(tt) - Number(rr)).map(tt=>Ne[tt]) : Ne
    }
    function xe(Ne) {
        const tt = Ne.indexOf("#");
        return tt !== -1 && (Ne = Ne.slice(0, tt)),
        Ne
    }
    function $e(Ne) {
        const tt = (Ne = xe(Ne)).indexOf("?");
        return tt === -1 ? "" : Ne.slice(tt + 1)
    }
    function Ee(Ne, tt) {
        return tt.parseNumbers && !Number.isNaN(Number(Ne)) && typeof Ne == "string" && Ne.trim() !== "" ? Ne = Number(Ne) : !tt.parseBooleans || Ne === null || Ne.toLowerCase() !== "true" && Ne.toLowerCase() !== "false" || (Ne = Ne.toLowerCase() === "true"),
        Ne
    }
    function Se(Ne, tt) {
        de((tt = Object.assign({
            decode: !0,
            sort: !0,
            arrayFormat: "none",
            arrayFormatSeparator: ",",
            parseNumbers: !1,
            parseBooleans: !1
        }, tt)).arrayFormatSeparator);
        const rr = function(we) {
            let Ut;
            switch (we.arrayFormat) {
            case "index":
                return (lr,cr,be)=>{
                    Ut = /\[(\d*)\]$/.exec(lr),
                    lr = lr.replace(/\[\d*\]$/, ""),
                    Ut ? (be[lr] === void 0 && (be[lr] = {}),
                    be[lr][Ut[1]] = cr) : be[lr] = cr
                }
                ;
            case "bracket":
                return (lr,cr,be)=>{
                    Ut = /(\[\])$/.exec(lr),
                    lr = lr.replace(/\[\]$/, ""),
                    Ut ? be[lr] !== void 0 ? be[lr] = [].concat(be[lr], cr) : be[lr] = [cr] : be[lr] = cr
                }
                ;
            case "colon-list-separator":
                return (lr,cr,be)=>{
                    Ut = /(:list)$/.exec(lr),
                    lr = lr.replace(/:list$/, ""),
                    Ut ? be[lr] !== void 0 ? be[lr] = [].concat(be[lr], cr) : be[lr] = [cr] : be[lr] = cr
                }
                ;
            case "comma":
            case "separator":
                return (lr,cr,be)=>{
                    const mr = typeof cr == "string" && cr.includes(we.arrayFormatSeparator)
                      , fr = typeof cr == "string" && !mr && fe(cr, we).includes(we.arrayFormatSeparator);
                    cr = fr ? fe(cr, we) : cr;
                    const Rr = mr || fr ? cr.split(we.arrayFormatSeparator).map(Pr=>fe(Pr, we)) : cr === null ? cr : fe(cr, we);
                    be[lr] = Rr
                }
                ;
            case "bracket-separator":
                return (lr,cr,be)=>{
                    const mr = /(\[\])$/.test(lr);
                    if (lr = lr.replace(/\[\]$/, ""),
                    !mr)
                        return void (be[lr] = cr && fe(cr, we));
                    const fr = cr === null ? [] : cr.split(we.arrayFormatSeparator).map(Rr=>fe(Rr, we));
                    be[lr] !== void 0 ? be[lr] = [].concat(be[lr], fr) : be[lr] = fr
                }
                ;
            default:
                return (lr,cr,be)=>{
                    be[lr] !== void 0 ? be[lr] = [].concat(be[lr], cr) : be[lr] = cr
                }
            }
        }(tt)
          , tr = Object.create(null);
        if (typeof Ne != "string" || !(Ne = Ne.trim().replace(/^[?#&]/, "")))
            return tr;
        for (const we of Ne.split("&")) {
            if (we === "")
                continue;
            let[Ut,lr] = ne(tt.decode ? we.replace(/\+/g, " ") : we, "=");
            lr = lr === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(tt.arrayFormat) ? lr : fe(lr, tt),
            rr(fe(Ut, tt), lr, tr)
        }
        for (const we of Object.keys(tr)) {
            const Ut = tr[we];
            if (typeof Ut == "object" && Ut !== null)
                for (const lr of Object.keys(Ut))
                    Ut[lr] = Ee(Ut[lr], tt);
            else
                tr[we] = Ee(Ut, tt)
        }
        return tt.sort === !1 ? tr : (tt.sort === !0 ? Object.keys(tr).sort() : Object.keys(tr).sort(tt.sort)).reduce((we,Ut)=>{
            const lr = tr[Ut];
            return lr && typeof lr == "object" && !Array.isArray(lr) ? we[Ut] = ge(lr) : we[Ut] = lr,
            we
        }
        , Object.create(null))
    }
    W.extract = $e,
    W.parse = Se,
    W.stringify = (Ne,tt)=>{
        if (!Ne)
            return "";
        de((tt = Object.assign({
            encode: !0,
            strict: !0,
            arrayFormat: "none",
            arrayFormatSeparator: ","
        }, tt)).arrayFormatSeparator);
        const rr = lr=>tt.skipNull && Ne[lr] == null || tt.skipEmptyString && Ne[lr] === ""
          , tr = function(lr) {
            switch (lr.arrayFormat) {
            case "index":
                return cr=>(be,mr)=>{
                    const fr = be.length;
                    return mr === void 0 || lr.skipNull && mr === null || lr.skipEmptyString && mr === "" ? be : mr === null ? [...be, [he(cr, lr), "[", fr, "]"].join("")] : [...be, [he(cr, lr), "[", he(fr, lr), "]=", he(mr, lr)].join("")]
                }
                ;
            case "bracket":
                return cr=>(be,mr)=>mr === void 0 || lr.skipNull && mr === null || lr.skipEmptyString && mr === "" ? be : mr === null ? [...be, [he(cr, lr), "[]"].join("")] : [...be, [he(cr, lr), "[]=", he(mr, lr)].join("")];
            case "colon-list-separator":
                return cr=>(be,mr)=>mr === void 0 || lr.skipNull && mr === null || lr.skipEmptyString && mr === "" ? be : mr === null ? [...be, [he(cr, lr), ":list="].join("")] : [...be, [he(cr, lr), ":list=", he(mr, lr)].join("")];
            case "comma":
            case "separator":
            case "bracket-separator":
                {
                    const cr = lr.arrayFormat === "bracket-separator" ? "[]=" : "=";
                    return be=>(mr,fr)=>fr === void 0 || lr.skipNull && fr === null || lr.skipEmptyString && fr === "" ? mr : (fr = fr === null ? "" : fr,
                    mr.length === 0 ? [[he(be, lr), cr, he(fr, lr)].join("")] : [[mr, he(fr, lr)].join(lr.arrayFormatSeparator)])
                }
            default:
                return cr=>(be,mr)=>mr === void 0 || lr.skipNull && mr === null || lr.skipEmptyString && mr === "" ? be : mr === null ? [...be, he(cr, lr)] : [...be, [he(cr, lr), "=", he(mr, lr)].join("")]
            }
        }(tt)
          , we = {};
        for (const lr of Object.keys(Ne))
            rr(lr) || (we[lr] = Ne[lr]);
        const Ut = Object.keys(we);
        return tt.sort !== !1 && Ut.sort(tt.sort),
        Ut.map(lr=>{
            const cr = Ne[lr];
            return cr === void 0 ? "" : cr === null ? he(lr, tt) : Array.isArray(cr) ? cr.length === 0 && tt.arrayFormat === "bracket-separator" ? he(lr, tt) + "[]" : cr.reduce(tr(lr), []).join("&") : he(lr, tt) + "=" + he(cr, tt)
        }
        ).filter(lr=>lr.length > 0).join("&")
    }
    ,
    W.parseUrl = (Ne,tt)=>{
        tt = Object.assign({
            decode: !0
        }, tt);
        const [rr,tr] = ne(Ne, "#");
        return Object.assign({
            url: rr.split("?")[0] || "",
            query: Se($e(Ne), tt)
        }, tt && tt.parseFragmentIdentifier && tr ? {
            fragmentIdentifier: fe(tr, tt)
        } : {})
    }
    ,
    W.stringifyUrl = (Ne,tt)=>{
        tt = Object.assign({
            encode: !0,
            strict: !0,
            [ue]: !0
        }, tt);
        const rr = xe(Ne.url).split("?")[0] || ""
          , tr = W.extract(Ne.url)
          , we = W.parse(tr, {
            sort: !1
        })
          , Ut = Object.assign(we, Ne.query);
        let lr = W.stringify(Ut, tt);
        lr && (lr = `?${lr}`);
        let cr = function(be) {
            let mr = "";
            const fr = be.indexOf("#");
            return fr !== -1 && (mr = be.slice(fr)),
            mr
        }(Ne.url);
        return Ne.fragmentIdentifier && (cr = `#${tt[ue] ? he(Ne.fragmentIdentifier, tt) : Ne.fragmentIdentifier}`),
        `${rr}${lr}${cr}`
    }
    ,
    W.pick = (Ne,tt,rr)=>{
        rr = Object.assign({
            parseFragmentIdentifier: !0,
            [ue]: !1
        }, rr);
        const {url: tr, query: we, fragmentIdentifier: Ut} = W.parseUrl(Ne, rr);
        return W.stringifyUrl({
            url: tr,
            query: le(we, tt),
            fragmentIdentifier: Ut
        }, rr)
    }
    ,
    W.exclude = (Ne,tt,rr)=>{
        const tr = Array.isArray(tt) ? we=>!tt.includes(we) : (we,Ut)=>!tt(we, Ut);
        return W.pick(Ne, tr, rr)
    }
}
)(queryString);
const RELAY_JSONRPC = {
    waku: {
        publish: "waku_publish",
        batchPublish: "waku_batchPublish",
        subscribe: "waku_subscribe",
        batchSubscribe: "waku_batchSubscribe",
        subscription: "waku_subscription",
        unsubscribe: "waku_unsubscribe",
        batchUnsubscribe: "waku_batchUnsubscribe"
    },
    irn: {
        publish: "irn_publish",
        batchPublish: "irn_batchPublish",
        subscribe: "irn_subscribe",
        batchSubscribe: "irn_batchSubscribe",
        subscription: "irn_subscription",
        unsubscribe: "irn_unsubscribe",
        batchUnsubscribe: "irn_batchUnsubscribe"
    },
    iridium: {
        publish: "iridium_publish",
        batchPublish: "iridium_batchPublish",
        subscribe: "iridium_subscribe",
        batchSubscribe: "iridium_batchSubscribe",
        subscription: "iridium_subscription",
        unsubscribe: "iridium_unsubscribe",
        batchUnsubscribe: "iridium_batchUnsubscribe"
    }
}
  , M = ":";
function ve(W) {
    const [z,Y] = W.split(M);
    return {
        namespace: z,
        reference: Y
    }
}
function Rn(W, z=[]) {
    const Y = [];
    return Object.keys(W).forEach(ne=>{
        if (z.length && !z.includes(ne))
            return;
        const le = W[ne];
        Y.push(...le.accounts)
    }
    ),
    Y
}
function K(W, z) {
    return W.includes(":") ? [W] : z.chains || []
}
const J = "base10"
  , p = "base16"
  , x = "base64pad"
  , F = "utf8"
  , Q = 0
  , _ = 1
  , $n = 0
  , Ie = 1
  , Z = 12
  , X = 32;
function jn() {
    const W = x25519.generateKeyPair();
    return {
        privateKey: toString(W.secretKey, p),
        publicKey: toString(W.publicKey, p)
    }
}
function Dn() {
    return toString(random.randomBytes(X), p)
}
function kn(W, z) {
    const Y = x25519.sharedKey(fromString(W, p), fromString(z, p), !0);
    return toString(new HKDF_1(sha256.SHA256,Y).expand(X), p)
}
function Vn(W) {
    return toString(sha256.hash(fromString(W, p)), p)
}
function Mn(W) {
    return toString(sha256.hash(fromString(W, F)), p)
}
function Pe(W) {
    return fromString(`${W}`, J)
}
function $(W) {
    return Number(toString(W, J))
}
function Kn(W) {
    const z = Pe(typeof W.type < "u" ? W.type : Q);
    if ($(z) === _ && typeof W.senderPublicKey > "u")
        throw new Error("Missing sender public key for type 1 envelope");
    const Y = typeof W.senderPublicKey < "u" ? fromString(W.senderPublicKey, p) : void 0
      , ne = typeof W.iv < "u" ? fromString(W.iv, p) : random.randomBytes(Z);
    return Te({
        type: z,
        sealed: new chacha20poly1305.ChaCha20Poly1305(fromString(W.symKey, p)).seal(ne, fromString(W.message, F)),
        iv: ne,
        senderPublicKey: Y
    })
}
function Ln(W) {
    const z = new chacha20poly1305.ChaCha20Poly1305(fromString(W.symKey, p))
      , {sealed: Y, iv: ne} = ee(W.encoded)
      , le = z.open(ne, Y);
    if (le === null)
        throw new Error("Failed to decrypt");
    return toString(le, F)
}
function Te(W) {
    if ($(W.type) === _) {
        if (typeof W.senderPublicKey > "u")
            throw new Error("Missing sender public key for type 1 envelope");
        return toString(concat([W.type, W.senderPublicKey, W.iv, W.sealed]), x)
    }
    return toString(concat([W.type, W.iv, W.sealed]), x)
}
function ee(W) {
    const z = fromString(W, x)
      , Y = z.slice($n, Ie)
      , ne = Ie;
    if ($(Y) === _) {
        const de = ne + X
          , he = de + Z
          , fe = z.slice(ne, de)
          , ge = z.slice(de, he);
        return {
            type: Y,
            sealed: z.slice(he),
            iv: ge,
            senderPublicKey: fe
        }
    }
    const le = ne + Z
      , ue = z.slice(ne, le);
    return {
        type: Y,
        sealed: z.slice(le),
        iv: ue
    }
}
function xn(W, z) {
    const Y = ee(W);
    return Re({
        type: $(Y.type),
        senderPublicKey: typeof Y.senderPublicKey < "u" ? toString(Y.senderPublicKey, p) : void 0,
        receiverPublicKey: z?.receiverPublicKey
    })
}
function Re(W) {
    const z = W?.type || Q;
    if (z === _) {
        if (typeof W?.senderPublicKey > "u")
            throw new Error("missing sender public key");
        if (typeof W?.receiverPublicKey > "u")
            throw new Error("missing receiver public key")
    }
    return {
        type: z,
        senderPublicKey: W?.senderPublicKey,
        receiverPublicKey: W?.receiverPublicKey
    }
}
function Fn(W) {
    return W.type === _ && typeof W.senderPublicKey == "string" && typeof W.receiverPublicKey == "string"
}
var Hn = Object.defineProperty
  , Ae = Object.getOwnPropertySymbols
  , qn = Object.prototype.hasOwnProperty
  , Bn = Object.prototype.propertyIsEnumerable
  , Ue = (W,z,Y)=>z in W ? Hn(W, z, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: Y
}) : W[z] = Y
  , _e = (W,z)=>{
    for (var Y in z || (z = {}))
        qn.call(z, Y) && Ue(W, Y, z[Y]);
    if (Ae)
        for (var Y of Ae(z))
            Bn.call(z, Y) && Ue(W, Y, z[Y]);
    return W
}
;
const Ce = "ReactNative"
  , m = {
    reactNative: "react-native",
    node: "node",
    browser: "browser",
    unknown: "unknown"
}
  , je = "js";
function te() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u"
}
function j() {
    return !getDocument_1() && !!getNavigator_1() && navigator.product === Ce
}
function q() {
    return !te() && !!getNavigator_1()
}
function R() {
    return j() ? m.reactNative : te() ? m.node : q() ? m.browser : m.unknown
}
function De(W, z) {
    let Y = queryString.parse(W);
    return Y = _e(_e({}, Y), z),
    W = queryString.stringify(Y)
}
function zn() {
    return getWindowMetadata_1() || {
        name: "",
        description: "",
        url: "",
        icons: [""]
    }
}
function ke() {
    if (R() === m.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
        const {OS: Y, Version: ne} = global.Platform;
        return [Y, ne].join("-")
    }
    const W = detect();
    if (W === null)
        return "unknown";
    const z = W.os ? W.os.replace(" ", "").toLowerCase() : "unknown";
    return W.type === "browser" ? [z, W.name, W.version].join("-") : [z, W.version].join("-")
}
function Ve() {
    var W;
    const z = R();
    return z === m.browser ? [z, ((W = getLocation_1()) == null ? void 0 : W.host) || "unknown"].join(":") : z
}
function Me(W, z, Y) {
    const ne = ke()
      , le = Ve();
    return [[W, z].join("-"), [je, Y].join("-"), ne, le].join("/")
}
function Jn({protocol: W, version: z, relayUrl: Y, sdkVersion: ne, auth: le, projectId: ue, useOnCloseEvent: de}) {
    const he = Y.split("?")
      , fe = {
        auth: le,
        ua: Me(W, z, ne),
        projectId: ue,
        useOnCloseEvent: de || void 0
    }
      , ge = De(he[1] || "", fe);
    return he[0] + "?" + ge
}
function O(W, z) {
    return W.filter(Y=>z.includes(Y)).length === W.length
}
function et(W) {
    return Object.fromEntries(W.entries())
}
function nt(W) {
    return new Map(Object.entries(W))
}
function st(W=cjs$2.FIVE_MINUTES, z) {
    const Y = cjs$2.toMiliseconds(W || cjs$2.FIVE_MINUTES);
    let ne, le, ue;
    return {
        resolve: de=>{
            ue && ne && (clearTimeout(ue),
            ne(de))
        }
        ,
        reject: de=>{
            ue && le && (clearTimeout(ue),
            le(de))
        }
        ,
        done: ()=>new Promise((de,he)=>{
            ue = setTimeout(()=>{
                he(new Error(z))
            }
            , Y),
            ne = de,
            le = he
        }
        )
    }
}
function it(W, z, Y) {
    return new Promise(async(ne,le)=>{
        const ue = setTimeout(()=>le(new Error(Y)), z);
        try {
            ne(await W)
        } catch (de) {
            le(de)
        }
        clearTimeout(ue)
    }
    )
}
function re(W, z) {
    if (typeof z == "string" && z.startsWith(`${W}:`))
        return z;
    if (W.toLowerCase() === "topic") {
        if (typeof z != "string")
            throw new Error('Value must be "string" for expirer target type: topic');
        return `topic:${z}`
    }
    if (W.toLowerCase() === "id") {
        if (typeof z != "number")
            throw new Error('Value must be "number" for expirer target type: id');
        return `id:${z}`
    }
    throw new Error(`Unknown expirer target type: ${W}`)
}
function ct(W) {
    return re("topic", W)
}
function at(W) {
    return re("id", W)
}
function ut(W) {
    const [z,Y] = W.split(":")
      , ne = {
        id: void 0,
        topic: void 0
    };
    if (z === "topic" && typeof Y == "string")
        ne.topic = Y;
    else {
        if (z !== "id" || !Number.isInteger(Number(Y)))
            throw new Error(`Invalid target, expected id:number or topic:string, got ${z}:${Y}`);
        ne.id = Number(Y)
    }
    return ne
}
function lt(W, z) {
    return cjs$2.fromMiliseconds((z || Date.now()) + cjs$2.toMiliseconds(W))
}
function dt(W) {
    return Date.now() >= cjs$2.toMiliseconds(W)
}
function ft(W, z) {
    return `${W}${z ? `:${z}` : ""}`
}
function S(W=[], z=[]) {
    return [...new Set([...W, ...z])]
}
async function pt({id: W, topic: z, wcDeepLink: Y}) {
    try {
        if (!Y)
            return;
        let le = (typeof Y == "string" ? JSON.parse(Y) : Y)?.href;
        if (typeof le != "string")
            return;
        le.endsWith("/") && (le = le.slice(0, -1));
        const ue = `${le}/wc?requestId=${W}&sessionTopic=${z}`
          , de = R();
        de === m.browser ? ue.startsWith("https://") ? window.open(ue, "_blank", "noreferrer noopener") : window.open(ue, "_self", "noreferrer noopener") : de === m.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(ue)
    } catch (ne) {
        console.error(ne)
    }
}
const Fe = "irn";
function mt(W) {
    return W?.relay || {
        protocol: Fe
    }
}
function yt(W) {
    const z = RELAY_JSONRPC[W];
    if (typeof z > "u")
        throw new Error(`Relay Protocol not supported: ${W}`);
    return z
}
var ht = Object.defineProperty
  , He = Object.getOwnPropertySymbols
  , vt = Object.prototype.hasOwnProperty
  , gt = Object.prototype.propertyIsEnumerable
  , qe = (W,z,Y)=>z in W ? ht(W, z, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: Y
}) : W[z] = Y
  , Et = (W,z)=>{
    for (var Y in z || (z = {}))
        vt.call(z, Y) && qe(W, Y, z[Y]);
    if (He)
        for (var Y of He(z))
            gt.call(z, Y) && qe(W, Y, z[Y]);
    return W
}
;
function Be(W, z="-") {
    const Y = {}
      , ne = "relay" + z;
    return Object.keys(W).forEach(le=>{
        if (le.startsWith(ne)) {
            const ue = le.replace(ne, "")
              , de = W[le];
            Y[ue] = de
        }
    }
    ),
    Y
}
function bt(W) {
    const z = W.indexOf(":")
      , Y = W.indexOf("?") !== -1 ? W.indexOf("?") : void 0
      , ne = W.substring(0, z)
      , le = W.substring(z + 1, Y).split("@")
      , ue = typeof Y < "u" ? W.substring(Y) : ""
      , de = queryString.parse(ue);
    return {
        protocol: ne,
        topic: Ge(le[0]),
        version: parseInt(le[1], 10),
        symKey: de.symKey,
        relay: Be(de)
    }
}
function Ge(W) {
    return W.startsWith("//") ? W.substring(2) : W
}
function We(W, z="-") {
    const Y = {};
    return Object.keys(W).forEach(ne=>{
        const le = "relay" + z + ne;
        W[ne] && (Y[le] = W[ne])
    }
    ),
    Y
}
function Nt(W) {
    return `${W.protocol}:${W.topic}@${W.version}?` + queryString.stringify(Et({
        symKey: W.symKey
    }, We(W.relay)))
}
var Ot = Object.defineProperty
  , St = Object.defineProperties
  , wt = Object.getOwnPropertyDescriptors
  , ze = Object.getOwnPropertySymbols
  , It = Object.prototype.hasOwnProperty
  , Pt = Object.prototype.propertyIsEnumerable
  , Ye = (W,z,Y)=>z in W ? Ot(W, z, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: Y
}) : W[z] = Y
  , Tt = (W,z)=>{
    for (var Y in z || (z = {}))
        It.call(z, Y) && Ye(W, Y, z[Y]);
    if (ze)
        for (var Y of ze(z))
            Pt.call(z, Y) && Ye(W, Y, z[Y]);
    return W
}
  , Rt = (W,z)=>St(W, wt(z));
function A(W) {
    const z = [];
    return W.forEach(Y=>{
        const [ne,le] = Y.split(":");
        z.push(`${ne}:${le}`)
    }
    ),
    z
}
function Je(W) {
    const z = [];
    return Object.values(W).forEach(Y=>{
        z.push(...A(Y.accounts))
    }
    ),
    z
}
function Qe(W, z) {
    const Y = [];
    return Object.values(W).forEach(ne=>{
        A(ne.accounts).includes(z) && Y.push(...ne.methods)
    }
    ),
    Y
}
function Ze(W, z) {
    const Y = [];
    return Object.values(W).forEach(ne=>{
        A(ne.accounts).includes(z) && Y.push(...ne.events)
    }
    ),
    Y
}
function At(W, z) {
    const Y = cn(W, z);
    if (Y)
        throw new Error(Y.message);
    const ne = {};
    for (const [le,ue] of Object.entries(W))
        ne[le] = {
            methods: ue.methods,
            events: ue.events,
            chains: ue.accounts.map(de=>`${de.split(":")[0]}:${de.split(":")[1]}`)
        };
    return ne
}
function oe(W) {
    return W.includes(":")
}
function Xe(W) {
    return oe(W) ? W.split(":")[0] : W
}
function se(W) {
    var z, Y, ne;
    const le = {};
    if (!B(W))
        return le;
    for (const [ue,de] of Object.entries(W)) {
        const he = oe(ue) ? [ue] : de.chains
          , fe = de.methods || []
          , ge = de.events || []
          , xe = Xe(ue);
        le[xe] = Rt(Tt({}, le[xe]), {
            chains: S(he, (z = le[xe]) == null ? void 0 : z.chains),
            methods: S(fe, (Y = le[xe]) == null ? void 0 : Y.methods),
            events: S(ge, (ne = le[xe]) == null ? void 0 : ne.events)
        })
    }
    return le
}
const _t = {
    INVALID_METHOD: {
        message: "Invalid method.",
        code: 1001
    },
    INVALID_EVENT: {
        message: "Invalid event.",
        code: 1002
    },
    INVALID_UPDATE_REQUEST: {
        message: "Invalid update request.",
        code: 1003
    },
    INVALID_EXTEND_REQUEST: {
        message: "Invalid extend request.",
        code: 1004
    },
    INVALID_SESSION_SETTLE_REQUEST: {
        message: "Invalid session settle request.",
        code: 1005
    },
    UNAUTHORIZED_METHOD: {
        message: "Unauthorized method.",
        code: 3001
    },
    UNAUTHORIZED_EVENT: {
        message: "Unauthorized event.",
        code: 3002
    },
    UNAUTHORIZED_UPDATE_REQUEST: {
        message: "Unauthorized update request.",
        code: 3003
    },
    UNAUTHORIZED_EXTEND_REQUEST: {
        message: "Unauthorized extend request.",
        code: 3004
    },
    USER_REJECTED: {
        message: "User rejected.",
        code: 5e3
    },
    USER_REJECTED_CHAINS: {
        message: "User rejected chains.",
        code: 5001
    },
    USER_REJECTED_METHODS: {
        message: "User rejected methods.",
        code: 5002
    },
    USER_REJECTED_EVENTS: {
        message: "User rejected events.",
        code: 5003
    },
    UNSUPPORTED_CHAINS: {
        message: "Unsupported chains.",
        code: 5100
    },
    UNSUPPORTED_METHODS: {
        message: "Unsupported methods.",
        code: 5101
    },
    UNSUPPORTED_EVENTS: {
        message: "Unsupported events.",
        code: 5102
    },
    UNSUPPORTED_ACCOUNTS: {
        message: "Unsupported accounts.",
        code: 5103
    },
    UNSUPPORTED_NAMESPACE_KEY: {
        message: "Unsupported namespace key.",
        code: 5104
    },
    USER_DISCONNECTED: {
        message: "User disconnected.",
        code: 6e3
    },
    SESSION_SETTLEMENT_FAILED: {
        message: "Session settlement failed.",
        code: 7e3
    },
    WC_METHOD_UNSUPPORTED: {
        message: "Unsupported wc_ method.",
        code: 10001
    }
}
  , Ct = {
    NOT_INITIALIZED: {
        message: "Not initialized.",
        code: 1
    },
    NO_MATCHING_KEY: {
        message: "No matching key.",
        code: 2
    },
    RESTORE_WILL_OVERRIDE: {
        message: "Restore will override.",
        code: 3
    },
    RESUBSCRIBED: {
        message: "Resubscribed.",
        code: 4
    },
    MISSING_OR_INVALID: {
        message: "Missing or invalid.",
        code: 5
    },
    EXPIRED: {
        message: "Expired.",
        code: 6
    },
    UNKNOWN_TYPE: {
        message: "Unknown type.",
        code: 7
    },
    MISMATCHED_TOPIC: {
        message: "Mismatched topic.",
        code: 8
    },
    NON_CONFORMING_NAMESPACES: {
        message: "Non conforming namespaces.",
        code: 9
    }
};
function N(W, z) {
    const {message: Y, code: ne} = Ct[W];
    return {
        message: z ? `${Y} ${z}` : Y,
        code: ne
    }
}
function U(W, z) {
    const {message: Y, code: ne} = _t[W];
    return {
        message: z ? `${Y} ${z}` : Y,
        code: ne
    }
}
function D(W, z) {
    return !!Array.isArray(W) && (!(typeof z < "u" && W.length) || W.every(z))
}
function B(W) {
    return Object.getPrototypeOf(W) === Object.prototype && Object.keys(W).length
}
function w(W) {
    return typeof W > "u"
}
function h(W, z) {
    return !(!z || !w(W)) || typeof W == "string" && !!W.trim().length
}
function G(W, z) {
    return !(!z || !w(W)) || typeof W == "number" && !isNaN(W)
}
function $t(W, z) {
    const {requiredNamespaces: Y} = z
      , ne = Object.keys(W.namespaces)
      , le = Object.keys(Y);
    let ue = !0;
    return !!O(le, ne) && (ne.forEach(de=>{
        const {accounts: he, methods: fe, events: ge} = W.namespaces[de]
          , xe = A(he)
          , $e = Y[de];
        O(K(de, $e), xe) && O($e.methods, fe) && O($e.events, ge) || (ue = !1)
    }
    ),
    ue)
}
function k(W) {
    return !(!h(W, !1) || !W.includes(":")) && W.split(":").length === 2
}
function en(W) {
    if (h(W, !1) && W.includes(":")) {
        const z = W.split(":");
        if (z.length === 3) {
            const Y = z[0] + ":" + z[1];
            return !!z[2] && k(Y)
        }
    }
    return !1
}
function jt(W) {
    if (h(W, !1))
        try {
            return typeof new URL(W) < "u"
        } catch {
            return !1
        }
    return !1
}
function Dt(W) {
    var z;
    return (z = W?.proposer) == null ? void 0 : z.publicKey
}
function kt(W) {
    return W?.topic
}
function Vt(W, z) {
    let Y = null;
    return h(W?.publicKey, !1) || (Y = N("MISSING_OR_INVALID", `${z} controller public key should be a string`)),
    Y
}
function ie(W) {
    let z = !0;
    return D(W) ? W.length && (z = W.every(Y=>h(Y, !1))) : z = !1,
    z
}
function nn(W, z, Y) {
    let ne = null;
    return D(z) && z.length ? z.forEach(le=>{
        ne || k(le) || (ne = U("UNSUPPORTED_CHAINS", `${Y}, chain ${le} should be a string and conform to "namespace:chainId" format`))
    }
    ) : k(W) || (ne = U("UNSUPPORTED_CHAINS", `${Y}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)),
    ne
}
function tn(W, z, Y) {
    let ne = null;
    return Object.entries(W).forEach(([le,ue])=>{
        if (ne)
            return;
        const de = nn(le, K(le, ue), `${z} ${Y}`);
        de && (ne = de)
    }
    ),
    ne
}
function rn(W, z) {
    let Y = null;
    return D(W) ? W.forEach(ne=>{
        Y || en(ne) || (Y = U("UNSUPPORTED_ACCOUNTS", `${z}, account ${ne} should be a string and conform to "namespace:chainId:address" format`))
    }
    ) : Y = U("UNSUPPORTED_ACCOUNTS", `${z}, accounts should be an array of strings conforming to "namespace:chainId:address" format`),
    Y
}
function on(W, z) {
    let Y = null;
    return Object.values(W).forEach(ne=>{
        if (Y)
            return;
        const le = rn(ne?.accounts, `${z} namespace`);
        le && (Y = le)
    }
    ),
    Y
}
function sn(W, z) {
    let Y = null;
    return ie(W?.methods) ? ie(W?.events) || (Y = U("UNSUPPORTED_EVENTS", `${z}, events should be an array of strings or empty array for no events`)) : Y = U("UNSUPPORTED_METHODS", `${z}, methods should be an array of strings or empty array for no methods`),
    Y
}
function ce(W, z) {
    let Y = null;
    return Object.values(W).forEach(ne=>{
        if (Y)
            return;
        const le = sn(ne, `${z}, namespace`);
        le && (Y = le)
    }
    ),
    Y
}
function Mt(W, z, Y) {
    let ne = null;
    if (W && B(W)) {
        const le = ce(W, z);
        le && (ne = le);
        const ue = tn(W, z, Y);
        ue && (ne = ue)
    } else
        ne = N("MISSING_OR_INVALID", `${z}, ${Y} should be an object with data`);
    return ne
}
function cn(W, z) {
    let Y = null;
    if (W && B(W)) {
        const ne = ce(W, z);
        ne && (Y = ne);
        const le = on(W, z);
        le && (Y = le)
    } else
        Y = N("MISSING_OR_INVALID", `${z}, namespaces should be an object with data`);
    return Y
}
function an(W) {
    return h(W.protocol, !0)
}
function Kt(W, z) {
    let Y = !1;
    return z && !W ? Y = !0 : W && D(W) && W.length && W.forEach(ne=>{
        Y = an(ne)
    }
    ),
    Y
}
function Lt(W) {
    return typeof W == "number"
}
function xt(W) {
    return typeof W < "u" && typeof W !== null
}
function Ft(W) {
    return !!(W && typeof W == "object" && W.code && G(W.code, !1) && W.message && h(W.message, !1))
}
function Ht(W) {
    return !(w(W) || !h(W.method, !1))
}
function qt(W) {
    return !(w(W) || w(W.result) && w(W.error) || !G(W.id, !1) || !h(W.jsonrpc, !1))
}
function Bt(W) {
    return !(w(W) || !h(W.name, !1))
}
function Gt(W, z) {
    return !(!k(z) || !Je(W).includes(z))
}
function Wt(W, z, Y) {
    return !!h(Y, !1) && Qe(W, z).includes(Y)
}
function zt(W, z, Y) {
    return !!h(Y, !1) && Ze(W, z).includes(Y)
}
function un(W, z, Y) {
    let ne = null;
    const le = Yt(W)
      , ue = Jt(z)
      , de = Object.keys(le)
      , he = Object.keys(ue)
      , fe = ln(Object.keys(W))
      , ge = ln(Object.keys(z))
      , xe = fe.filter($e=>!ge.includes($e));
    return xe.length && (ne = N("NON_CONFORMING_NAMESPACES", `${Y} namespaces keys don't satisfy requiredNamespaces.
      Required: ${xe.toString()}
      Received: ${Object.keys(z).toString()}`)),
    O(de, he) || (ne = N("NON_CONFORMING_NAMESPACES", `${Y} namespaces chains don't satisfy required namespaces.
      Required: ${de.toString()}
      Approved: ${he.toString()}`)),
    Object.keys(z).forEach($e=>{
        if (!$e.includes(":") || ne)
            return;
        const Ee = A(z[$e].accounts);
        Ee.includes($e) || (ne = N("NON_CONFORMING_NAMESPACES", `${Y} namespaces accounts don't satisfy namespace accounts for ${$e}
        Required: ${$e}
        Approved: ${Ee.toString()}`))
    }
    ),
    de.forEach($e=>{
        ne || (O(le[$e].methods, ue[$e].methods) ? O(le[$e].events, ue[$e].events) || (ne = N("NON_CONFORMING_NAMESPACES", `${Y} namespaces events don't satisfy namespace events for ${$e}`)) : ne = N("NON_CONFORMING_NAMESPACES", `${Y} namespaces methods don't satisfy namespace methods for ${$e}`))
    }
    ),
    ne
}
function Yt(W) {
    const z = {};
    return Object.keys(W).forEach(Y=>{
        var ne;
        Y.includes(":") ? z[Y] = W[Y] : (ne = W[Y].chains) == null || ne.forEach(le=>{
            z[le] = {
                methods: W[Y].methods,
                events: W[Y].events
            }
        }
        )
    }
    ),
    z
}
function ln(W) {
    return [...new Set(W.map(z=>z.includes(":") ? z.split(":")[0] : z))]
}
function Jt(W) {
    const z = {};
    return Object.keys(W).forEach(Y=>{
        Y.includes(":") ? z[Y] = W[Y] : A(W[Y].accounts)?.forEach(le=>{
            z[le] = {
                accounts: W[Y].accounts.filter(ue=>ue.includes(`${le}:`)),
                methods: W[Y].methods,
                events: W[Y].events
            }
        }
        )
    }
    ),
    z
}
function Qt(W, z) {
    return G(W, !1) && W <= z.max && W >= z.min
}
function Zt() {
    const W = R();
    return new Promise(z=>{
        switch (W) {
        case m.browser:
            z(dn());
            break;
        case m.reactNative:
            z(fn());
            break;
        case m.node:
            z(pn());
            break;
        default:
            z(!0)
        }
    }
    )
}
function dn() {
    return q() && navigator?.onLine
}
async function fn() {
    return j() && typeof global < "u" && global != null && global.NetInfo ? (await (global == null ? void 0 : global.NetInfo.fetch()))?.isConnected : !0
}
function pn() {
    return !0
}
function Xt(W) {
    switch (R()) {
    case m.browser:
        mn(W);
        break;
    case m.reactNative:
        yn(W)
    }
}
function mn(W) {
    !j() && q() && (window.addEventListener("online", ()=>W(!0)),
    window.addEventListener("offline", ()=>W(!1)))
}
function yn(W) {
    j() && typeof global < "u" && global != null && global.NetInfo && global?.NetInfo.addEventListener(z=>W(z?.isConnected))
}
const ae = {};
class er {
    static get(z) {
        return ae[z]
    }
    static set(z, Y) {
        ae[z] = Y
    }
    static delete(z) {
        delete ae[z]
    }
}
var NAMESPACE = "eip155", STORE_KEY = "store", REQUESTED_CHAINS_KEY = "requestedChains", ADD_ETH_CHAIN_METHOD = "wallet_addEthereumChain", _provider, _initProviderPromise, _createProvider, createProvider_fn, _initProvider, initProvider_fn, _isChainsStale, isChainsStale_fn, _setupListeners, setupListeners_fn, _removeListeners, removeListeners_fn, _setRequestedChainsIds, setRequestedChainsIds_fn, _getRequestedChainsIds, getRequestedChainsIds_fn, _getNamespaceChainsIds, getNamespaceChainsIds_fn, _getNamespaceMethods, getNamespaceMethods_fn, WalletConnectConnector = class extends Connector {
    constructor(W) {
        super({
            ...W,
            options: {
                isNewChainsStale: !0,
                ...W.options
            }
        }),
        __privateAdd$1(this, _createProvider),
        __privateAdd$1(this, _initProvider),
        __privateAdd$1(this, _isChainsStale),
        __privateAdd$1(this, _setupListeners),
        __privateAdd$1(this, _removeListeners),
        __privateAdd$1(this, _setRequestedChainsIds),
        __privateAdd$1(this, _getRequestedChainsIds),
        __privateAdd$1(this, _getNamespaceChainsIds),
        __privateAdd$1(this, _getNamespaceMethods),
        this.id = "walletConnect",
        this.name = "WalletConnect",
        this.ready = !0,
        __privateAdd$1(this, _provider, void 0),
        __privateAdd$1(this, _initProviderPromise, void 0),
        this.onAccountsChanged = z=>{
            z.length === 0 ? this.emit("disconnect") : this.emit("change", {
                account: getAddress(z[0])
            })
        }
        ,
        this.onChainChanged = z=>{
            const Y = Number(z)
              , ne = this.isChainUnsupported(Y);
            this.emit("change", {
                chain: {
                    id: Y,
                    unsupported: ne
                }
            })
        }
        ,
        this.onDisconnect = ()=>{
            __privateMethod$1(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, []),
            this.emit("disconnect")
        }
        ,
        this.onDisplayUri = z=>{
            this.emit("message", {
                type: "display_uri",
                data: z
            })
        }
        ,
        this.onConnect = ()=>{
            this.emit("connect", {})
        }
        ,
        __privateMethod$1(this, _createProvider, createProvider_fn).call(this)
    }
    async connect({chainId: W, pairingTopic: z}={}) {
        try {
            let Y = W;
            if (!Y) {
                const he = this.storage?.getItem(STORE_KEY)
                  , fe = he?.state?.data?.chain?.id;
                Y = fe && !this.isChainUnsupported(fe) ? fe : this.chains[0]?.id
            }
            if (!Y)
                throw new Error("No chains found on connector.");
            const ne = await this.getProvider();
            __privateMethod$1(this, _setupListeners, setupListeners_fn).call(this);
            const le = __privateMethod$1(this, _isChainsStale, isChainsStale_fn).call(this);
            if (ne.session && le && await ne.disconnect(),
            !ne.session || le) {
                const he = this.chains.filter(fe=>fe.id !== Y).map(fe=>fe.id);
                this.emit("message", {
                    type: "connecting"
                }),
                await ne.connect({
                    pairingTopic: z,
                    chains: [Y],
                    optionalChains: he.length ? he : void 0
                }),
                __privateMethod$1(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, this.chains.map(({id: fe})=>fe))
            }
            const ue = getAddress((await ne.enable())[0])
              , de = await this.getChainId();
            return {
                account: ue,
                chain: {
                    id: de,
                    unsupported: this.isChainUnsupported(de)
                }
            }
        } catch (Y) {
            throw /user rejected/i.test(Y?.message) ? new UserRejectedRequestError(Y) : Y
        }
    }
    async disconnect() {
        const W = await this.getProvider();
        try {
            await W.disconnect()
        } catch (z) {
            if (!/No matching key/i.test(z.message))
                throw z
        } finally {
            __privateMethod$1(this, _removeListeners, removeListeners_fn).call(this),
            __privateMethod$1(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, [])
        }
    }
    async getAccount() {
        const {accounts: W} = await this.getProvider();
        return getAddress(W[0])
    }
    async getChainId() {
        const {chainId: W} = await this.getProvider();
        return W
    }
    async getProvider({chainId: W}={}) {
        return __privateGet$1(this, _provider) || await __privateMethod$1(this, _createProvider, createProvider_fn).call(this),
        W && await this.switchChain(W),
        __privateGet$1(this, _provider)
    }
    async getWalletClient({chainId: W}={}) {
        const [z,Y] = await Promise.all([this.getProvider({
            chainId: W
        }), this.getAccount()])
          , ne = this.chains.find(le=>le.id === W);
        if (!z)
            throw new Error("provider is required.");
        return createWalletClient({
            account: Y,
            chain: ne,
            transport: custom(z)
        })
    }
    async isAuthorized() {
        try {
            const [W,z] = await Promise.all([this.getAccount(), this.getProvider()])
              , Y = __privateMethod$1(this, _isChainsStale, isChainsStale_fn).call(this);
            if (!W)
                return !1;
            if (Y && z.session) {
                try {
                    await z.disconnect()
                } catch {}
                return !1
            }
            return !0
        } catch {
            return !1
        }
    }
    async switchChain(W) {
        const z = this.chains.find(Y=>Y.id === W);
        if (!z)
            throw new SwitchChainError(new Error("chain not found on connector."));
        try {
            const Y = await this.getProvider()
              , ne = __privateMethod$1(this, _getNamespaceChainsIds, getNamespaceChainsIds_fn).call(this)
              , le = __privateMethod$1(this, _getNamespaceMethods, getNamespaceMethods_fn).call(this);
            if (!ne.includes(W) && le.includes(ADD_ETH_CHAIN_METHOD)) {
                await Y.request({
                    method: ADD_ETH_CHAIN_METHOD,
                    params: [{
                        chainId: numberToHex(z.id),
                        blockExplorerUrls: [z.blockExplorers?.default?.url],
                        chainName: z.name,
                        nativeCurrency: z.nativeCurrency,
                        rpcUrls: [...z.rpcUrls.default.http]
                    }]
                });
                const ue = __privateMethod$1(this, _getRequestedChainsIds, getRequestedChainsIds_fn).call(this);
                ue.push(W),
                __privateMethod$1(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, ue)
            }
            return await Y.request({
                method: "wallet_switchEthereumChain",
                params: [{
                    chainId: numberToHex(W)
                }]
            }),
            z
        } catch (Y) {
            throw /user rejected request/i.test(typeof Y == "string" ? Y : Y?.message) ? new UserRejectedRequestError(Y) : new SwitchChainError(Y)
        }
    }
}
;
function publicProvider() {
    return function(W) {
        return W.rpcUrls.public.http[0] ? {
            chain: W,
            rpcUrls: W.rpcUrls.public
        } : null
    }
}
_provider = new WeakMap,
_initProviderPromise = new WeakMap,
_createProvider = new WeakSet,
createProvider_fn = async function() {
    return __privateGet$1(this, _initProviderPromise) || typeof window > "u" || __privateSet$1(this, _initProviderPromise, __privateMethod$1(this, _initProvider, initProvider_fn).call(this)),
    __privateGet$1(this, _initProviderPromise)
}
,
_initProvider = new WeakSet,
initProvider_fn = async function() {
   /* const {EthereumProvider: W, OPTIONAL_EVENTS: z, OPTIONAL_METHODS: Y} = await __vitePreload(()=>import("https://evergem.io/_astro/index.es.bab90ec7.js"), ["_astro/index.es.bab90ec7.js", "_astro/events.86a01509.js"])
      , [ne,...le] = this.chains.map(({id: ue})=>ue);
    if (ne) {
        const {projectId: ue, showQrModal: de=!0, qrModalOptions: he, metadata: fe, relayUrl: ge} = this.options;
        __privateSet$1(this, _provider, await W.init({
            showQrModal: de,
            qrModalOptions: he,
            projectId: ue,
            optionalMethods: Y,
            optionalEvents: z,
            chains: [ne],
            optionalChains: le.length ? le : void 0,
            rpcMap: Object.fromEntries(this.chains.map(xe=>[xe.id, xe.rpcUrls.default.http[0]])),
            metadata: fe,
            relayUrl: ge
        }))
    }*/
}
,
_isChainsStale = new WeakSet,
isChainsStale_fn = function() {
    if (__privateMethod$1(this, _getNamespaceMethods, getNamespaceMethods_fn).call(this).includes(ADD_ETH_CHAIN_METHOD) || !this.options.isNewChainsStale)
        return !1;
    const W = __privateMethod$1(this, _getRequestedChainsIds, getRequestedChainsIds_fn).call(this)
      , z = this.chains.map(({id: ne})=>ne)
      , Y = __privateMethod$1(this, _getNamespaceChainsIds, getNamespaceChainsIds_fn).call(this);
    return !(Y.length && !Y.some(ne=>z.includes(ne))) && !z.every(ne=>W.includes(ne))
}
,
_setupListeners = new WeakSet,
setupListeners_fn = function() {
    __privateGet$1(this, _provider) && (__privateMethod$1(this, _removeListeners, removeListeners_fn).call(this),
    __privateGet$1(this, _provider).on("accountsChanged", this.onAccountsChanged),
    __privateGet$1(this, _provider).on("chainChanged", this.onChainChanged),
    __privateGet$1(this, _provider).on("disconnect", this.onDisconnect),
    __privateGet$1(this, _provider).on("session_delete", this.onDisconnect),
    __privateGet$1(this, _provider).on("display_uri", this.onDisplayUri),
    __privateGet$1(this, _provider).on("connect", this.onConnect))
}
,
_removeListeners = new WeakSet,
removeListeners_fn = function() {
    __privateGet$1(this, _provider) && (__privateGet$1(this, _provider).removeListener("accountsChanged", this.onAccountsChanged),
    __privateGet$1(this, _provider).removeListener("chainChanged", this.onChainChanged),
    __privateGet$1(this, _provider).removeListener("disconnect", this.onDisconnect),
    __privateGet$1(this, _provider).removeListener("session_delete", this.onDisconnect),
    __privateGet$1(this, _provider).removeListener("display_uri", this.onDisplayUri),
    __privateGet$1(this, _provider).removeListener("connect", this.onConnect))
}
,
_setRequestedChainsIds = new WeakSet,
setRequestedChainsIds_fn = function(W) {
    this.storage?.setItem(REQUESTED_CHAINS_KEY, W)
}
,
_getRequestedChainsIds = new WeakSet,
getRequestedChainsIds_fn = function() {
    return this.storage?.getItem(REQUESTED_CHAINS_KEY) ?? []
}
,
_getNamespaceChainsIds = new WeakSet,
getNamespaceChainsIds_fn = function() {
    if (!__privateGet$1(this, _provider))
        return [];
    const W = __privateGet$1(this, _provider).session?.namespaces;
    return W ? se(W)[NAMESPACE]?.chains?.map(ne=>parseInt(ne.split(":")[1] || "")) ?? [] : []
}
,
_getNamespaceMethods = new WeakSet,
getNamespaceMethods_fn = function() {
    if (!__privateGet$1(this, _provider))
        return [];
    const W = __privateGet$1(this, _provider).session?.namespaces;
    return W ? se(W)[NAMESPACE]?.methods ?? [] : []
}
;
const RPC_URL = CoreHelperUtil.getBlockchainApiUrl();
function walletConnectProvider({projectId: W}) {
    return function(z) {
        if (![1, 5, 11155111, 10, 420, 42161, 421613, 137, 80001, 42220, 1313161554, 1313161555, 56, 97, 43114, 43113, 100, 8453, 84531, 7777777, 999, 324, 280].includes(z.id))
            return null;
        const Y = `${RPC_URL}/v1/?chainId=${ConstantsUtil.EIP155}:${z.id}&projectId=${W}`;
        return {
            chain: {
                ...z,
                rpcUrls: {
                    ...z.rpcUrls,
                    default: {
                        http: [Y]
                    }
                }
            },
            rpcUrls: {
                http: [Y]
            }
        }
    }
}
function defaultWagmiConfig({projectId: W, chains: z, metadata: Y}) {
    const {publicClient: ne} = configureChains(z, [walletConnectProvider({
        projectId: W
    }), publicProvider()]);
    return createConfig({
        autoConnect: !0,
        connectors: [new WalletConnectConnector({
            chains: z,
            options: {
                projectId: W,
                showQrModal: !1,
                metadata: Y
            }
        }), new EIP6963Connector({
            chains: z
        }), new InjectedConnector({
            chains: z,
            options: {
                shimDisconnect: !0
            }
        }), new CoinbaseWalletConnector({
            chains: z,
            options: {
                appName: Y?.name ?? "Unknown"
            }
        })],
        publicClient: ne
    })
}
function createWeb3Modal(W) {
    return new Web3Modal({
        ...W,
        _sdkVersion: `html-wagmi-${ConstantsUtil.VERSION}`
    })
}
window.jQuery = window.$ = $$3,
dayjs.extend(duration),
castleExports.configure({
    pk: "pk_hyEiWzedVz8rrfqzBk8o8rNjQEgYxext"
});
const TOKEN_ADDRESS = "0x672A11C200a88d4250C5561158560C17aAAA011B"
  , DEPOSIT_ADDRESS = "0x93A5EDdA3E87bf53BB74628d90b2555B402047AE"
  , waitForConnection = ()=>new Promise((W,z)=>{
    const Y = ()=>{
        const ne = getAccount();
        ne.isDisconnected && z("account is disconnected"),
        ne.isConnecting ? setTimeout(Y, 250) : W(ne)
    }
    ;
    Y()
}
)
  , percent = (W,z)=>W >= z ? "100" : (W / z * 100).toFixed(0);
let prevVideo = null;
const loadVideo = function(W=1) {
    if (W != prevVideo) {
        prevVideo = W;
        var z = $$3(".bg");
        z.empty(),
        z.trigger("load"),
        z.trigger("play");
        var Y = $$3(window).width();
        Y <= 480 ? z.append(`<source src="/public/bg/480/${W + 1}.mp4" type="video/mp4">`) : Y <= 768 ? z.append(`<source src="/public/bg/768/${W + 1}.mp4" type="video/mp4">`) : Y <= 1440 ? z.append(`<source src="/public/bg/1440/${W + 1}.mp4" type="video/mp4">`) : z.append(`<source src="/public/bg/1920/${W + 1}.mp4" type="video/mp4">`),
        $$3(".js-audio-pickaxe")[0].currentTime = 0
    }
}
  , deposit = async(W="0")=>{
    try {
        (await getNetwork()).chain.id != chains[0].id && await switchNetwork({
            chainId: chains[0].id
        })
    } catch (ne) {
        console.log(ne)
    }
    const z = await readContract({
        address: TOKEN_ADDRESS,
        abi: erc20ABI,
        functionName: "decimals",
        chainId: chains[0].id
    });
    if (!z)
        throw new Error("Please try again later");
    const Y = parseUnits(W.toString(), +z);
    try {
        const ne = await prepareWriteContract({
            address: TOKEN_ADDRESS,
            abi: erc20ABI,
            functionName: "transfer",
            args: [DEPOSIT_ADDRESS, Y],
            chainId: chains[0].id
        })
          , {hash: le} = await writeContract(ne);
        return {
            hash: le
        }
    } catch (ne) {
        return console.error(ne),
        {
            error: ne.shortMessage || ne.toString()
        }
    }
}
  , t = W=>{
    let z = 6;
    return W > 1e3 && (z = 2),
    new Intl.NumberFormat("en-US",{
        maximumFractionDigits: z,
        minimumFractionDigits: 0
    }).format(W)
}
;
new Intl.NumberFormat("en-US",{
    maximumFractionDigits: 2,
    minimumFractionDigits: 2
}).format;
const days = [60, 58, 56, 54, 52, 50, 48, 46, 44, 42, 40, 38]
  , price = [100, 1e3, 1e4, 25e3, 5e4, 75e3, 1e5];
let {now, active, items, ...variables} = window.variables || {};
const user = {
    address: variables.address
};
user.address && castleExports.page({
    user: {
        id: variables.user_id,
        onchain_address: variables.address
    }
});
const levels = [{
    perMinute: .018,
    days: 0,
    price: 0,
    stack: 5
}, ...[...Array(7)].map((W,z)=>({
    price: price[z],
    days: days[z],
    stack: 0,
    perMinute: 3 * price[z] / (1440 * days[z])
}))]
  , toClaim = ({usedAt: W, perMinute: z, stack: Y},ne=dayjs())=>{
    let le = ne.diff(W, "milliseconds");
    return Y && le > 60 * Y * 1e3 && (le = 60 * Y * 1e3),
    z / 60 / 1e3 * Math.abs(le)
}
  , addToMined = (W,z)=>{
    let Y;
    z == "green" && (Y = "/public/img/ic-pickaxe.svg"),
    z == "yellow" && (Y = "/public/img/ic-alarm.svg"),
    z == "red" && (Y = "/public/img/ic-stop.svg");
    const ne = `
        <div class="item ${z}">
          <img src="${Y}">
          <p class="fz16 fw500">${W}</p>
        </div>
    `;
    $minedItem.find(".item").length >= 4 && $minedItem.find(".item:first-child").remove(),
    $minedItem.append(ne),
    $minedItem.removeClass("active"),
    setTimeout(()=>{
        $minedItem.addClass("active")
    }
    , 25)
}
;
function showAlert(W, z) {
    const Y = $$3("<div>").addClass("popup-alert").addClass(W).html(`
        <span>â</span>
        <div>
            <h3 class="fz16">SUCCESS</h3>
            <h4 class="fz14">${z}</h4>
        </div>
        <button class="popup-alert-close">
            <svg width="25" height="24" viewBox="0 0 25 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M18.9502 6L6.9502 18" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M6.95019 6L18.9502 18" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </button>`);
    $$3(".popup-alert-container").append(Y),
    setTimeout(()=>Y.remove(), 5e3)
}
window.showAlert = showAlert;
const showNotify = W=>{
    $$3(".popup-notify-container").append(W),
    setTimeout(()=>{
        W.remove()
    }
    , 5e3)
}
  , createError = (W,z)=>{
    const Y = $$3("<div>").addClass("popup-notify")
      , ne = `
      <button class="close">
        <svg viewBox="0 0 24 24" width="24rem">
          <use xlink:href="./img/sprite.svg#ic-close"></use>
        </svg>
      </button>
      <div class="ic">
      <picture>
        <source srcset="/_astro/notify-error.avif" type="image/avif">
        <source srcset="/_astro/notify-error.webp" type="image/webp">
        <img src="/_astro/notify-error.png" alt="Error" width="144"
            height="144" loading="lazy" decoding="async">
        </picture>

        </div>
      <div class="text-wrap">
        <p class="fz16 ttu c-red">${W}</p>
        <p class="fz14 c-red">${z}</p>
      </div>
    `;
    return Y.append(ne),
    Y.find(".close").click(function() {
        Y.remove()
    }),
    Y
}
  , createNotify = (W,z,Y,ne)=>{
    const le = $$3("<div>").addClass("popup-notify");
    let ue, de = "c-green";
    ne && (de = "c-red"),
    ne && (ue = "c-red");
    const he = `
      <button class="close">
        <svg viewBox="0 0 24 24" width="24rem">
          <use xlink:href="./img/sprite.svg#ic-close"></use>
        </svg>
      </button>
      <div class="ic"><img src="${W}" alt=""></div>
      <div class="text-wrap">
        <p class="fz16 ttu ${ue}">${z}</p>
        <p class="fz14 ${de}">${Y}</p>
      </div>
    `;
    return le.append(he),
    le.find(".close").click(function() {
        le.remove()
    }),
    le
}
  , metadata = {
    name: "Evergem",
    description: "Will you emerge as the hero who restores freedom?",
    icons: [""],
    url: "https://evergem.io"
}
  , projectId = "cf0bf17238b4dc76ee09d8741ee13b49"
  , chains = [bsc]
  , wagmiConfig = defaultWagmiConfig({
    chains,
    projectId,
    metadata
})
  , modal = createWeb3Modal({
    wagmiConfig,
    projectId,
    chains
})
  , $form = $$3("#login")
  , $address = $form.find("[name=address]")
  , initWeb3 = async W=>{
    try {
        modal.subscribeState(async Y=>{
            Y.open == 0 && setTimeout(()=>W(getAccount()), 500)
        }
        );
        const z = await waitForConnection();
        return W(z),
        watchAccount(W),
        z
    } catch (z) {
        return z.toString() == "account is disconnected" ? void W({
            address: void 0
        }) : (console.error(z),
        {
            error: z
        })
    }
}
  , $body = $$3("body")
  , $game = $body.find("#game")
  , $claim = $game.find("[name=item_id]")
  , $toClaim = $game.find("#toClaim")
  , $total = $game.find("#total")
  , $all = $game.find("#all")
  , $verification = $$3("#verification")
  , $minedItem = $$3(".js-mined")
  , $free = $$3(".js-free");
let stoped = !1;
const recalculate = ()=>{
    let W = $toClaim.html();
    const z = t(toClaim(active, now))
      , Y = z.replaceAll(",", "") - W.replaceAll(",", "");
    $toClaim.html(z),
    $total.html(t(parseFloat(z) + parseFloat(active.total_earned)));
    const ne = levels[active.level]
      , le = parseInt(active.level, 10) ? 3 * ne.price : active.perMinute * active.stack
      , ue = percent((active.level ? parseFloat(active.total_earned) : 0) + parseFloat(toClaim(active, now)), le);
    return $$3("#percent").css({
        width: `${ue}%`
    }),
    Y
}
;
if ($game?.length && active) {
    $$3("#verification").on("submit", function(z) {
        return castleExports.custom({
            user: {
                id: variables.user_id,
                onchain_address: variables.address
            },
            name: "claim"
        }),
        castleExports.injectTokenOnSubmit(z),
        !0
    });
    const W = $$3(".js-change-pickaxe");
    now = dayjs(window.now),
    loadVideo(active.level),
    setInterval(()=>{
        if (now = now.add(1, "second"),
        W.each((z,Y)=>{
            const ne = dayjs.duration(dayjs.unix($$3(Y).data("end")).diff(now)).format("M [month] DD[d]:HH[h]:mm[m]:ss[s]");
            $$3(Y).find(".expire").text(ne)
        }
        ),
        $free.length) {
            const z = items.find(le=>le.level == 0)
              , Y = z.perMinute * z.stack
              , ne = percent(parseFloat(toClaim(z, now)), Y);
            $free.find(".line.green").css({
                width: `${ne}%`
            })
        }
        if (now.unix() % 2 == 0) {
            const z = recalculate();
            z ? addToMined(`+${t(z)} HPE`, "green") : stoped || (stoped = !0,
            $$3(".bg").trigger("pause"),
            addToMined("Production stoped", "red"))
        }
    }
    , 1e3)
}
function debounce(W, z) {
    let Y;
    return function(...ne) {
        clearTimeout(Y),
        Y = setTimeout(()=>{
            W.apply(this, ne)
        }
        , z)
    }
}
const login = debounce(async W=>{
    if (W?.toLowerCase() != user?.address?.toLowerCase())
        return $address.val(W),
        $form.submit();
    W && (balance = await fetchBalance({
        address: W,
        token: TOKEN_ADDRESS
    }))
}
, 1e3);
let balance, address = initWeb3(W=>{
    address = W?.address,
    login(address)
}
);
$body.delegate("#connect", "click", async W=>{
    W.preventDefault(),
    modal.open()
}
);
const $ajax = $body.find("#ajax")
  , $ajax_content = $ajax.find(".content-wrap.active")
  , $add = $body.find(".add a");
$add.on("click", ()=>{
    $$3(".js-toggle-table.active").index() == 1 && $$3(".js-toggle-table").eq(0).click()
}
),
$ajax.delegate(".js-toggle-table", "click", async function() {
    if ($$3(this).hasClass("active"))
        return;
    $$3(".js-toggle-table").removeClass("active"),
    $$3(this).addClass("active");
    const W = $$3(this).index()
      , z = $$3(".section-tabs .header-wrap .text-wrap .txt-wrap");
    z.removeClass("active"),
    z.eq(W).addClass("active")
}),
$ajax.delegate("a", "click", async function(W) {
    if ($$3(this).attr("href").includes("component")) {
        W.preventDefault();
        const z = $ajax.find(".loading");
        try {
            z.fadeIn(300);
            const Y = $$3(this).attr("href");
            $ajax_content.html(await $$3.ajax(Y))
        } finally {
            z.fadeOut(300)
        }
    }
}),
$$3(".js-change-pickaxe").click(function() {
    if ($$3(this).hasClass("active"))
        return;
    const W = $$3(this).data("id");
    active.item_id != W && (active = items?.find(ue=>ue.item_id == W),
    loadVideo(active.level),
    recalculate());
    const {level: z} = active
      , Y = levels[z]
      , ne = $$3(".game-welcome .level-wrap .level")
      , le = $$3(".game-welcome .level-wrap .id");
    $$3(".js-change-pickaxe").removeClass("active"),
    $$3(this).addClass("active"),
    stoped = !1,
    z ? ($all.text("/ " + 3 * Y.price),
    $game.find(".js-noverification").show(),
    $game.find(".js-verification").hide(),
    $game.find(".js-upgrade").hide(),
    $game.find(".js-claim-all").show()) : ($all.text(""),
    $verification.find("[name=item_id]").attr("value", W),
    $game.find(".js-noverification").hide(),
    $game.find(".js-verification").show(),
    $game.find(".js-upgrade").show(),
    $game.find(".js-claim-all").hide()),
    ne.text("level " + (z + 1)),
    le.text("#" + W),
    $claim.attr("value", W)
}),
new Swiper(".js-account-banner",{
    modules: [Pagination, Autoplay],
    lazy: !0,
    loop: !0,
    autoplay: {
        delay: 5e3
    },
    pagination: {
        el: ".swiper-pagination"
    }
}),
new Swiper(".js-game-banner",{
    modules: [Pagination, Autoplay],
    lazy: !0,
    loop: !0,
    autoplay: {
        delay: 5e3
    },
    pagination: {
        el: ".swiper-pagination"
    }
});
const $parallax = $$3(".js-parallax");
$parallax.length && new Parallax($parallax[0]);
const verifyWait = async W=>{
    const z = W.find(".step--waiting");
    z.length && setTimeout(async()=>{
        const Y = await $$3.ajax("/components/airdrop")
          , ne = $$3(Y);
        let le = !1;
        z.each((ue,de)=>{
            const he = $$3(de).index();
            ne.find(".step").eq(he).hasClass("step--waiting") ? le = !0 : (window.location = "/airdrop#airdrop",
            window.location.reload())
        }
        ),
        le && verifyWait(W)
    }
    , 1e3)
}
  , $popup = $$3(".js-popup");
$popup.length && $popup.magnificPopup({
    callbacks: {
        open: function() {
            $$3(this.content).attr("id", "airdrop") && verifyWait($$3(this.content))
        }
    },
    removalDelay: 250,
    showCloseBtn: !1
});
const $ajaxPopup = $$3(".js-ajax-popup");
$ajaxPopup.length && $ajaxPopup.magnificPopup({
    removalDelay: 250,
    showCloseBtn: !1,
    ajax: !0,
    type: "ajax"
}),
$body.delegate(".js-close-popup", "click", W=>{
    W.preventDefault(),
    $$3.magnificPopup.close()
}
);
let tokenomicsTemp = 0;
$$3("[data-percent]").each(function() {
    const W = +$$3(this).data("percent");
    $$3(this).css({
        width: W + "%",
        left: tokenomicsTemp + "%"
    }),
    tokenomicsTemp += W
}),
$$3(".home-tokenomics").length && setTimeout(function() {
    new Waypoint({
        offset: 90,
        element: $$3(".home-tokenomics")[0],
        handler: function(W) {
            $$3("[data-percent]").each(function(z) {
                setTimeout(()=>{
                    $$3(this).addClass("active")
                }
                , 250 * z)
            }),
            this.destroy()
        }
    })
}, 100),
$$3(".referral-program-work").length && new Waypoint({
    element: $$3(".referral-program-work")[0],
    handler: function(W) {
        $$3(".referral-program-work img.arrow").each(function(z) {
            setTimeout(()=>{
                $$3(this).addClass("active")
            }
            , 250 * z)
        }),
        $$3(".referral-program-work .level-imgs img.arr").each(function(z) {
            setTimeout(()=>{
                $$3(this).addClass("active")
            }
            , 250 * z)
        }),
        this.destroy()
    }
}),
$$3(".js-scroll-up").click(()=>{
    $$3("html, body").stop().animate({
        scrollTop: 0
    }, 1e3)
}
),
$$3(".js-scroll").click(function(W) {
    if ($$3(this).attr("href").startsWith("/") && window.location.pathname !== "/")
        return;
    W.preventDefault();
    const z = $$3(this).attr("href").replace("/", "");
    $$3("html, body").stop().animate({
        scrollTop: $$3(z).offset().top
    }, 500)
}),
$$3(window).scroll(()=>{
    $$3(window).scrollTop() >= 200 ? $$3(".js-scroll-up").addClass("active") : $$3(".js-scroll-up").removeClass("active")
}
),
$$3(".js-accordione").click(function() {
    var W = $$3(this).parents(".item");
    W.find(".text-wrap").stop().slideToggle(300),
    W.toggleClass("active")
}),
$$3(".js-toggle-refferal").click(function() {
    const W = $$3(this).parents(".item").eq(0);
    $$3(this).toggleClass("open"),
    W.toggleClass("open")
}),
$$3(".js-trx-tab").click(function() {
    $$3(".js-trx-tab").removeClass("active"),
    $$3(this).addClass("active");
    const W = $$3(this).index()
      , z = $$3(".section-tabs .content-wrap .tab-wrap");
    z.removeClass("active"),
    z.eq(W).addClass("active")
}),
$$3(".js-tab-balance").click(function() {
    $$3(".js-tab-balance").removeClass("active"),
    $$3(this).addClass("active");
    const W = $$3(this).index()
      , z = $$3("header.header-main .block-balance-wrap .content-wrap");
    z.removeClass("active"),
    z.eq(W).addClass("active")
}),
$$3(".js-toggle-inner").click(function() {
    $$3(".js-toggle-inner.active").not(this).removeClass("active"),
    $$3(this).toggleClass("active")
}),
$$3(".js-close-parent-popup").click(function() {
    $$3(this).parents(".popup").parent().find(".js-toggle-inner").removeClass("active")
}),
$$3(window).scroll(function() {
    $$3(".js-toggle-inner").removeClass("active")
}),
$$3(".js-input-max").click(function() {
    const W = $$3(this).parents(".block-input").find("input")
      , z = +$$3(this).data("max");
    W.val(z)
}),
$$3(".js-balance-max").click(function() {
    $$3(this).parents(".block-input").find("input").val(balance.formatted)
}),
$$3(".js-tooltip").each(function() {
    new jBox("Tooltip",{
        attach: $$3(this),
        content: $$3(this).data("content")
    })
}),
$$3(".js-show-alert").click(function() {
    showAlert($$3(this).data("alert-type"), $$3(this).data("alert-msg"))
}),
$$3(".js-notify-1").click(()=>{
    const W = createNotify("./img/notify-withdraw.webp", "Withdraw", "You've successfully withdrawn HPE", !1);
    showNotify(W)
}
),
$$3(".js-notify-2").click(()=>{
    const W = createNotify("./img/notify-deposit.webp", "Deposit", "You've successfully deposited HPE", !1);
    showNotify(W)
}
),
$$3(".js-notify-3").click(()=>{
    const W = createNotify("./img/notify-harvest.webp", "Harvest", "You've successfully claimed rewards", !1);
    showNotify(W)
}
),
$$3(".js-notify-4").click(()=>{
    const W = createNotify("./img/notify-error.webp", "Error:(", "Oops, there's an issue. Contact Support", !0);
    showNotify(W)
}
),
$$3("[data-copy]").click(function() {
    var W = $$3(this).attr("data-copy")
      , z = $$3("<textarea/>");
    z.css({
        position: "fixed",
        top: "-999px",
        left: "-999px"
    }),
    z.val(W),
    $$3(".mfp-wrap").attr("tabindex", ""),
    $$3("body").prepend(z),
    z.select(),
    document.execCommand("copy"),
    z.remove(),
    showAlert("good", "Copied â¨")
}),
$$3(".js-copy-input").click(function() {
    $$3(this)[0].select(),
    document.execCommand("copy"),
    showAlert("good", "Copied â¨")
}),
$$3(".js-toggle-video-sound").click(function(W) {
    W.preventDefault(),
    $$3(this).toggleClass("off"),
    $$3(".js-toggle-video-sound").hasClass("off") ? $$3(".js-audio-bg, .js-audio-pickaxe").trigger("pause") : ($$3(".js-audio-bg, .js-audio-pickaxe").trigger("play"),
    $$3(".js-audio-pickaxe").trigger("play"),
    $$3(".bg")[0].currentTime = 0)
}),
$$3(".js-toggle-video-play").click(function() {
    $$3(this).toggleClass("pause")
}),
$$3(window).scroll(()=>{
    $$3(window).scrollTop() >= 10 ? $$3("header.header-main").addClass("fixed") : $$3("header.header-main").removeClass("fixed")
}
),
$$3(".js-toggle-menu").click(()=>{
    $$3(".js-toggle-menu, .mobile-popup-menu").toggleClass("active")
}
),
$$3(window).scroll(()=>{
    $$3(".js-toggle-menu, .mobile-popup-menu").removeClass("active")
}
),
$$3("[data-scroll-from]").click(function(W) {
    W.preventDefault();
    const z = $$3(this).attr("data-scroll-from");
    $$3("html, body").animate({
        scrollTop: $$3("[data-scroll-to=" + z + "]").offset().top - $$3(".header-main").outerHeight()
    }, 1e3)
}),
$$3(window).on("load resize", ()=>{
    let W = .01 * window.innerHeight;
    document.documentElement.style.setProperty("--vh", `${W}px`)
}
),
$$3(".button.exit").on("click", ()=>{
    disconnect()
}
);
const $deposit = $$3("#deposit");
$deposit.on("submit", async W=>{
    W.preventDefault();
    const z = $deposit.find("input").val()
      , Y = $deposit.find(".loading");
    try {
        Y.show(100),
        $$3.magnificPopup.open({
            items: {
                src: "#status-wait"
            }
        });
        const {error: ne, hash: le} = await deposit(z);
        ne ? ($$3.magnificPopup.close(),
        showNotify(createError("Error", ne))) : ($$3.magnificPopup.close(),
        $$3(".block-balance-wrap .js-toggle-inner").removeClass("active"),
        $$3("#status-done a").attr("href", `https://bscscan.com/tx/${le}`),
        $$3.magnificPopup.open({
            items: {
                src: "#status-done"
            }
        }))
    } finally {
        Y.hide(100)
    }
}
);
const $congratulations1 = $$3("#congratulations-1");
$congratulations1.length && $$3.magnificPopup.open({
    items: {
        src: "#congratulations-1"
    }
});
const $congratulations2 = $$3("#congratulations-2");
$congratulations2.length && $$3.magnificPopup.open({
    items: {
        src: "#congratulations-2"
    }
});
const $congratulations3 = $$3("#congratulations-3");
$congratulations3.length && $$3.magnificPopup.open({
    items: {
        src: "#congratulations-3"
    }
});
const $shop = $$3(".shop");
if ($shop.length) {
    const W = $$3("#confirm");
    $shop.delegate("button", "click", function(z) {
        const Y = $$3(this);
        z.preventDefault(),
        $$3.magnificPopup.open({
            items: {
                src: "#confirm"
            }
        }),
        W.find(".price").text(levels[Y.val()].price),
        W.find(".level").text(parseInt(Y.val(), 10) + 1),
        W.find(".confirm").on("click", ()=>{
            $shop.find("[type=hidden]").val(Y.val()),
            $shop.submit()
        }
        )
    })
}
if (window.location.hash) {
    var targetId = window.location.hash;
    if (targetId != "#airdrop") {
        var target = $$3(targetId);
        target.length && $$3("html, body").animate({
            scrollTop: target.offset().top
        }, 800)
    } else {
        const W = $$3("#airdrop");
        W.length && ($$3.magnificPopup.open({
            items: {
                src: "#airdrop"
            }
        }),
        verifyWait(W))
    }
    history.replaceState({}, document.title, window.location.pathname)
}
const $alerts = $$3(".popup-alert");
$alerts.each(function(W, z) {
    setTimeout(()=>{
        $$3(z).fadeOut(300).remove()
    }
    , 4e3)
}),
$$3("body").delegate(".popup-alert-close", "click", function(W) {
    W.preventDefault(),
    $$3(this).parents(".popup-alert").fadeOut(300).remove()
}),
$$3("#add-to-metamask").on("click", async W=>{
    W.preventDefault();
    try {
        await (await getWalletClient()).watchAsset({
            type: "ERC20",
            options: {
                address: TOKEN_ADDRESS,
                decimals: 18,
                symbol: "HPE"
            }
        }) && showAlert("good", "Added â¨")
    } catch (z) {
        createError("Add to metamask", z.toString())
    }
}
),
$$3(".ref-copy").on("click", ()=>{
    $$3(".js-copy-input")[0].select(),
    document.execCommand("copy"),
    showAlert("good", "Copied â¨")
}
),
$$3(".js-changeto-verify").on("click", function() {
    const W = $$3(this);
    W.hide(),
    W.next("button").show()
});
const $welcome = $$3("#welcome");
$welcome.length && $$3.magnificPopup.open({
    items: {
        src: "#welcome"
    }
});
export {getEnsAvatar as $, WuiInputText as A, WuiLink as B, WuiListItem as C, WuiTransactionListItem as D, WuiTransactionListItemLoader as E, WuiListWallet as F, WuiLogoSelect as G, WuiLogo as H, WuiNetworkButton as I, WuiNetworkImage as J, WuiOtp as K, WuiQrCode as L, WuiSearchBar as M, WuiSnackbar as N, WuiTabs as O, WuiTag as P, WuiTooltip as Q, WuiTransactionVisual as R, WuiVisualThumbnail as S, TransactionUtil as T, UiHelperUtil as U, WuiWalletImage as V, WuiCard as W, WuiFlex as X, WuiGrid as Y, WuiSeparator as Z, getEnsAddress as _, setThemeVariables as a, ut as a$, getEnsName as a0, getEnsResolver as a1, getEnsText as a2, labelhash as a3, namehash as a4, getDefaultExportFromCjs as a5, proxy$1 as a6, subscribe as a7, snapshot as a8, __vitePreload as a9, jn as aA, Dn as aB, kn as aC, Vn as aD, Re as aE, Fn as aF, Kn as aG, xn as aH, Ln as aI, ee as aJ, $ as aK, p as aL, it as aM, Zt as aN, Jn as aO, Xt as aP, _ as aQ, lt as aR, Nt as aS, bt as aT, st as aU, ft as aV, U as aW, dt as aX, xt as aY, jt as aZ, h as a_, BaseError as aa, getUrl as ab, stringify as ac, isAddress as ad, InvalidAddressError as ae, decodeErrorResult as af, call as ag, concat$1 as ah, encodeAbiParameters as ai, HttpRequestError as aj, isHex as ak, browser$1 as al, getAugmentedNamespace as am, require$$0 as an, cjs$2 as ao, binary as ap, wipe$1 as aq, random as ar, fromString as as, toString as at, concat as au, commonjsGlobal as av, w as aw, Dt as ax, kt as ay, N as az, WuiIcon as b, ct as b0, at as b1, j as b2, q as b3, te as b4, et as b5, nt as b6, Mn as b7, mt as b8, yt as b9, Rn as bA, require$$3 as bB, buffer as bC, __extends as bD, D as ba, zn as bb, B as bc, At as bd, pt as be, $t as bf, er as bg, Kt as bh, Mt as bi, cn as bj, un as bk, Ft as bl, an as bm, Vt as bn, Gt as bo, Ht as bp, Wt as bq, Qt as br, qt as bs, Bt as bt, zt as bu, Lt as bv, Xe as bw, oe as bx, S as by, ve as bz, customElement as c, WuiImage as d, WuiLoadingHexagon as e, WuiLoadingSpinner as f, WuiLoadingThumbnail as g, WuiShimmer as h, initializeTheming as i, WuiText as j, WuiVisual as k, WuiAccountButton as l, WuiAllWalletsImage as m, WuiAvatar as n, WuiButton as o, WuiCardSelectLoader as p, WuiCardSelect as q, WuiChip as r, setColorTheme as s, WuiConnectButton as t, WuiCtaButton as u, WuiEmailInput as v, WuiIconBox as w, WuiIconLink as x, WuiInputElement as y, WuiInputNumeric as z};
